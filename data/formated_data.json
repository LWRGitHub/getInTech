[
    {
        "name": "3Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-3sum",
        "video": {
            "has_video": true,
            "scripts": [
                "https://www.youtube.com/embed/qmntcyBt-5s?si=nUJQ3Unrd6RDdKzG"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge is about finding all unique triplets in an array that add up to zero. The solution provided follows a two-step approach: sorting the array and then using a two-pointer technique to find the triplets. Here's a step-by-step explanation along with the corresponding pseudo code:"
            },
            {
                "tag": "h2",
                "content": "1. Sort the Array"
            },
            {
                "tag": "p",
                "content": "First, the array is sorted. This makes it easier to avoid duplicates and to efficiently find the triplets."
            },
            {
                "tag": "code",
                "content": "\nSORT nums"
            },
            {
                "tag": "h2",
                "content": "2. Iterate through the Array"
            },
            {
                "tag": "p",
                "content": "Next, we iterate through the array, using each element as a potential first element of a triplet. The loop is stopped if the current element is greater than 0 because, given the array is sorted, no three elements can sum to 0 beyond this point."
            },
            {
                "tag": "code",
                "content": "\nFOR i FROM 0 TO length of nums\n    IF nums[i] > 0 THEN\n        BREAK\n    END IF\n    IF i == 0 OR nums[i-1] != nums[i] THEN\n        findTriplets(nums, i, result)\n    END IF\nEND FOR"
            },
            {
                "tag": "h2",
                "content": "3. Finding Triplets (Two-Pointer Technique)"
            },
            {
                "tag": "p",
                "content": "For each element nums[i], we use two additional pointers to find pairs that sum up to -nums[i], thus ensuring the total sum is zero. The sm (small) pointer starts just after i, and the lg (large) pointer starts at the end of the array. We move these pointers towards each other until they meet, adjusting them based on the sum of nums[i], nums[sm], and nums[lg]."
            },
            {
                "tag": "code",
                "content": "\nFUNCTION findTriplets(nums, i, result)\n    sm = i + 1\n    lg = length of nums - 1\n    WHILE sm < lg DO\n        sum = nums[i] + nums[sm] + nums[lg]\n        IF sum < 0 THEN\n            sm = sm + 1\n        ELSE IF sum > 0 THEN\n            lg = lg - 1\n        ELSE\n            ADD [nums[i], nums[sm], nums[lg]] TO result\n            sm = sm + 1\n            lg = lg - 1\n            WHILE sm < lg AND nums[sm] == nums[sm-1] DO\n                sm = sm + 1\n            END WHILE\n        END IF\n    END WHILE\nEND FUNCTION"
            },
            {
                "tag": "h2",
                "content": "4. Avoiding Duplicates"
            },
            {
                "tag": "p",
                "content": "To avoid adding duplicate triplets to the result, we skip over any subsequent elements that are equal to the current one. This check is done both at the top-level iteration through nums and after finding a valid triplet, for the sm pointer."
            },
            {
                "tag": "h2",
                "content": "Summary"
            },
            {
                "tag": "p",
                "content": "The algorithm efficiently finds all unique triplets in the array that sum up to zero by first sorting the array, then iterating through it with a fixed first element, and using a two-pointer approach to find complementary pairs for the current element. The careful management of pointers and the conditions for incrementing them ensure that duplicates are avoided."
            }
        ],
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "py",
                "code": "\ndef threeSum(nums):\n\n    nums.sort()\n    res = []\n\n    for i in range(len(nums)):\n\n        if nums[i] > 0:\n            break\n        elif i == 0 or nums[i-1] != nums[i]:\n            sum0(nums, i, res)\n\n    return res\n\ndef sum0(nums, i, res):\n\n    sm = i + 1\n    lg = len(nums) - 1\n\n    while sm < lg:\n        sum = nums[i] + nums[sm] + nums[lg]\n\n        if sum < 0:\n            sm+= 1\n        elif sum > 0:\n            lg-= 1\n        else:\n            res.append([nums[i], nums[sm], nums[lg]])\n            sm+= 1\n            lg-= 1\n            while(sm < len(nums) and nums[sm] == nums[sm-1]):\n                sm+= 1"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst threeSum = function(nums, res=[]) {\n    nums.sort((a,b) => a - b);\n    for(let i = 0; i < nums.length; i++){\n        if(nums[i] > 0){\n            break;\n        } else if(i === 0 || nums[i-1] !== nums[i]){\n            sum0(nums, i, res);\n        }\n    }\n    return res;\n};\n\nconst sum0 = (nums, i, res, sm=i+1, lg=nums.length-1) => {\n    while(sm < lg){\n        const sum = nums[i] + nums[sm] + nums[lg];\n        if(sum < 0){\n            sm++;\n        } else if(sum > 0) {\n            lg--;\n        } else {\n            res.push([nums[i], nums[sm], nums[lg]]);\n            sm++;\n            lg--;\n            while(nums[sm] === nums[sm-1]){\n                sm++;\n            }\n        }\n    }\n};"
            },
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> result;\n        if(nums.size() < 3) {\n            return result;\n        }\n        \n        sort(nums.begin(), nums.end());\n        \n        for(int i = 0; i < nums.size() - 2; i++) {\n            if(i > 0 && nums[i] == nums[i-1]) {\n                continue;\n            }\n            \n            int target = -nums[i];\n            int left = i + 1;\n            int right = nums.size() - 1;\n            \n            while(left < right) {\n                int sum = nums[left] + nums[right];\n                if(sum == target) {\n                    result.push_back({nums[i], nums[left], nums[right]});\n                    while(left < right && nums[left] == nums[left+1]) {\n                        left++;\n                    }\n                    while(left < right && nums[right] == nums[right-1]) {\n                        right--;\n                    }\n                    left++;\n                    right--;\n                } else if(sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        \n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                int left = i + 1, right = nums.length - 1, target = -nums[i];\n                while (left < right) {\n                    if (nums[left] + nums[right] == target) {\n                        result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        left++;\n                        right--;\n                    } else if (nums[left] + nums[right] < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> ThreeSum(int[] nums) {\n        Array.Sort(nums);\n        IList<IList<int>> result = new List<IList<int>>();\n        \n        for(int i = 0; i < nums.Length - 2; i++){\n            if(i == 0 || (i > 0 && nums[i] != nums[i-1])){\n                int low = i + 1, high = nums.Length - 1, sum = 0 - nums[i];\n                \n                while(low < high){\n                    if(nums[low] + nums[high] == sum){\n                        result.Add(new List<int>{nums[i], nums[low], nums[high]});\n                        while(low < high && nums[low] == nums[low+1]) low++;\n                        while(low < high && nums[high] == nums[high-1]) high--;\n                        low++;\n                        high--;\n                    } else if(nums[low] + nums[high] < sum){\n                        low++;\n                    } else {\n                        high--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function threeSum(nums: number[]): number[][] {\n    const result: number[][] = [];\n    \n    nums.sort((a, b) => a - b);\n    \n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {\n            let lo = i + 1;\n            let hi = nums.length - 1;\n            const sum = 0 - nums[i];\n            \n            while (lo < hi) {\n                if (nums[lo] + nums[hi] === sum) {\n                    result.push([nums[i], nums[lo], nums[hi]]);\n                    while (lo < hi && nums[lo] === nums[lo + 1]) lo++;\n                    while (lo < hi && nums[hi] === nums[hi - 1]) hi--;\n                    lo++;\n                    hi--;\n                } else if (nums[lo] + nums[hi] < sum) {\n                    lo++;\n                } else {\n                    hi--;\n                }\n            }\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function threeSum($nums) {\n        $result = [];\n        sort($nums);\n        $n = count($nums);\n        \n        for ($i = 0; $i < $n - 2; $i++) {\n            if ($i == 0 || ($i > 0 && $nums[$i] != $nums[$i - 1])) {\n                $lo = $i + 1;\n                $hi = $n - 1;\n                $sum = 0 - $nums[$i];\n                \n                while ($lo < $hi) {\n                    if ($nums[$lo] + $nums[$hi] == $sum) {\n                        $result[] = [$nums[$i], $nums[$lo], $nums[$hi]];\n                        while ($lo < $hi && $nums[$lo] == $nums[$lo + 1]) $lo++;\n                        while ($lo < $hi && $nums[$hi] == $nums[$hi - 1]) $hi--;\n                        $lo++;\n                        $hi--;\n                    } elseif ($nums[$lo] + $nums[$hi] < $sum) {\n                        $lo++;\n                    } else {\n                        $hi--;\n                    }\n                }\n            }\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func threeSum(_ nums: [Int]) -> [[Int]] {\n        var result = [[Int]]()\n        let nums = nums.sorted()\n        \n        for i in 0..<nums.count {\n            if i > 0 && nums[i] == nums[i - 1] {\n                continue\n            }\n            var left = i + 1\n            var right = nums.count - 1\n            \n            while left < right {\n                let sum = nums[i] + nums[left] + nums[right]\n                if sum == 0 {\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right && nums[left] == nums[left + 1] {\n                        left += 1\n                    }\n                    while left < right && nums[right] == nums[right - 1] {\n                        right -= 1\n                    }\n                    left += 1\n                    right -= 1\n                } else if sum < 0 {\n                    left += 1\n                } else {\n                    right -= 1\n                }\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun threeSum(nums: IntArray): List<List<Int>> {\n        nums.sort()\n        val result = mutableListOf<List<Int>>()\n\n        for (i in 0 until nums.size - 2) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                var left = i + 1\n                var right = nums.size - 1\n                val target = 0 - nums[i]\n\n                while (left < right) {\n                    when {\n                        nums[left] + nums[right] == target -> {\n                            result.add(listOf(nums[i], nums[left], nums[right]))\n                            while (left < right && nums[left] == nums[left + 1]) left++\n                            while (left < right && nums[right] == nums[right - 1]) right--\n                            left++\n                            right--\n                        }\n                        nums[left] + nums[right] < target -> left++\n                        else -> right--\n                    }\n                }\n            }\n        }\n\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> threeSum(List<int> nums) {\n      List<List<int>> result = [];\n      nums.sort();\n      for (int i = 0; i < nums.length - 2; i++) {\n          if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n              int lo = i + 1;\n              int hi = nums.length - 1;\n              int sum = 0 - nums[i];\n              while (lo < hi) {\n                  if (nums[lo] + nums[hi] == sum) {\n                      result.add([nums[i], nums[lo], nums[hi]]);\n                      while (lo < hi && nums[lo] == nums[lo + 1]) lo++;\n                      while (lo < hi && nums[hi] == nums[hi - 1]) hi--;\n                      lo++;\n                      hi--;\n                  } else if (nums[lo] + nums[hi] < sum) {\n                      lo++;\n                  } else {\n                      hi--;\n                  }\n              }\n          }\n      }\n      return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func threeSum(nums []int) [][]int {\n    res := [][]int{}\n    \n    for i := 0; i < len(nums)-2; i++ {\n        for j := i + 1; j < len(nums)-1; j++ {\n            for k := j + 1; k < len(nums); k++ {\n                if nums[i]+nums[j]+nums[k] == 0 {\n                    triplet := []int{nums[i], nums[j], nums[k]}\n                    sort.Ints(triplet)\n                    found := false\n                    for _, v := range res {\n                        if reflect.DeepEqual(v, triplet) {\n                            found = true\n                            break\n                        }\n                    }\n                    if !found {\n                        res = append(res, triplet)\n                    }\n                }\n            }\n        }\n    }\n    \n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef three_sum(nums)\n    nums.sort!\n    res = []\n    (0..nums.length-2).each do |i|\n        next if i > 0 && nums[i] == nums[i-1]\n        left, right = i+1, nums.length-1\n        while left < right\n            sum = nums[i] + nums[left] + nums[right]\n            if sum < 0\n                left += 1\n            elsif sum > 0\n                right -= 1\n            else\n                res << [nums[i], nums[left], nums[right]]\n                left += 1 while nums[left] == nums[left+1]\n                right -= 1 while nums[right] == nums[right-1]\n                left += 1\n                right -= 1\n            end\n        end\n    end\n    return res\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut res = Vec::new();\n        \n        if nums.len() < 3 {\n            return res;\n        }\n        \n        let mut nums = nums;\n        nums.sort();\n\n        for i in 0..nums.len() - 2 {\n            if i > 0 && nums[i] == nums[i - 1] {\n                continue;\n            }\n            let mut left = i + 1;\n            let mut right = nums.len() - 1;\n            while left < right {\n                let sum = nums[i] + nums[left] + nums[right];\n                if sum == 0 {\n                    res.push(vec![nums[i], nums[left], nums[right]]);\n                    while left < right && nums[left] == nums[left + 1] {\n                        left += 1;\n                    }\n                    while left < right && nums[right] == nums[right - 1] {\n                        right -= 1;\n                    }\n                    left += 1;\n                    right -= 1;\n                } else if sum < 0 {\n                    left += 1;\n                } else {\n                    right -= 1;\n                }\n            }\n        }\n        \n        res\n    }\n}\n"
            }
        ],
        "search_res": {
            "video": {
                "has_video": true,
                "src": [
                    "https://www.youtube.com/embed/jzZsG8n2R9A?si=uwDfaIS98YU3Xb0T",
                    "https://www.youtube.com/embed/cRBSOz49fQk?si=jTOTlZh0rFbZnmPF",
                    "https://www.youtube.com/embed/qJSPYnS35SE?si=uLOE-LePO8NRJa8Q"
                ]
            },
            "languages": [
                {
                    "name": "Python",
                    "solutions": [
                        {
                            "site_name": "Coding Broz",
                            "href": "https://www.codingbroz.com/3sum-leetcode-solution/"
                        },
                        {
                            "site_name": "Medium @Norman Aranez",
                            "href": "https://medium.com/@araneznorman/15-3sum-leetcode-31ab6df7969e"
                        }
                    ]
                },
                {
                    "name": "JavaScript",
                    "solutions": [
                        {
                            "site_name": "Medium @Norman Aranez",
                            "href": "https://medium.com/@araneznorman/15-3sum-leetcode-31ab6df7969e"
                        }
                    ]
                },
                {
                    "name": "TypeScript",
                    "solutions": [
                        {
                            "site_name": "Medium @Norman Aranez",
                            "href": "https://medium.com/@araneznorman/15-3sum-leetcode-31ab6df7969e"
                        }
                    ]
                },
                {
                    "name": "PHP",
                    "solutions": [
                        {
                            "site_name": "Medium @Norman Aranez",
                            "href": "https://medium.com/@araneznorman/15-3sum-leetcode-31ab6df7969e"
                        }
                    ]
                },
                {
                    "name": "C-Sharp",
                    "solutions": [
                        {
                            "site_name": "Medium @Norman Aranez",
                            "href": "https://medium.com/@araneznorman/15-3sum-leetcode-31ab6df7969e"
                        }
                    ]
                },
                {
                    "name": "C-Plus-Plus",
                    "solutions": [
                        {
                            "site_name": "Coding Broz",
                            "href": "https://www.codingbroz.com/3sum-leetcode-solution/"
                        },
                        {
                            "site_name": "Tutorial Cup",
                            "href": "https://tutorialcup.com/leetcode-solutions/3sum-leetcode-solution.htm"
                        }
                    ]
                },
                {
                    "name": "Java",
                    "solutions": [
                        {
                            "site_name": "Coding Broz",
                            "href": "https://www.codingbroz.com/3sum-leetcode-solution/"
                        },
                        {
                            "site_name": "Tutorial Cup",
                            "href": "https://tutorialcup.com/leetcode-solutions/3sum-leetcode-solution.htm"
                        },
                        {
                            "site_name": "Medium @Norman Aranez",
                            "href": "https://medium.com/@araneznorman/15-3sum-leetcode-31ab6df7969e"
                        }
                    ]
                }
            ]
        },
        "markdown_how_to_solve": "To solve this coding challenge, we need to find all unique triplets in the array that sum up to zero. \n\n# Explanation\n\n1. **Sort the Array**: Sorting the array helps in efficiently finding the triplets using the two-pointer technique.\n2. **Iterate through the Array**: For each element, use the two-pointer approach to find pairs that form a valid triplet with the current element.\n3. **Avoid Duplicates**: Ensure that we skip over duplicate elements to prevent duplicate triplets.\n4. **Two-pointer Technique**: For each element, use two pointers (one starting just after the current element and one at the end of the array) to find pairs that sum up to the negative of the current element.\n\n# Pseudocode\n\n```\nfunction threeSum(nums):\n    sort(nums)\n    result = []\n\n    for i from 0 to len(nums) - 1:\n        if nums[i] > 0:\n            break   // Since the array is sorted, no three positive numbers can sum to zero.\n\n        if i == 0 or nums[i-1] != nums[i]:   // Skip duplicates\n            twoSumZero(nums, i, result)\n\n    return result\n\nfunction twoSumZero(nums, i, result):\n    left = i + 1\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[i] + nums[left] + nums[right]\n\n        if sum < 0:\n            left += 1\n        elif sum > 0:\n            right -= 1\n        else:\n            result.append([nums[i], nums[left], nums[right]])\n            left += 1\n            right -= 1\n\n            while left < right and nums[left] == nums[left - 1]:\n                left += 1\n```\n\nThis approach ensures that the solution is efficient and handles duplicate triplets appropriately by leveraging sorting and the two-pointer technique.",
        "_id": "LeetCode-3sum"
    },
    {
        "name": "Two Sum",
        "site": "LeetCode",
        "_id": "LeetCode-Two-Sum",
        "href": "/solution/LeetCode-Two-Sum",
        "video": {
            "has_video": true,
            "scripts": [
                "https://www.youtube.com/embed/S_Nic1VxgPg?si=nThhdnGjD1_aUDJg"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves finding two numbers in an array whose sum equals a given target. The solution uses a hash map (or dictionary in Python) to efficiently find the pair. Here's how the solution works along with pseudo code:"
            },
            {
                "tag": "h2",
                "content": "1. Initialize a Hash Map"
            },
            {
                "tag": "p",
                "content": "First, initialize an empty hash map (or dictionary). This will store the array elements as keys and their indices as values."
            },
            {
                "tag": "code",
                "content": "\nInitialize memo as an empty hash map"
            },
            {
                "tag": "h2",
                "content": "2. Iterate through the Array"
            },
            {
                "tag": "p",
                "content": "Loop through each element in the array. For each element, calculate the complementary value needed to reach the target sum by subtracting the current element's value from the target."
            },
            {
                "tag": "code",
                "content": "\nFOR i FROM 0 TO length of nums - 1\n    Set need to target - nums[i]"
            },
            {
                "tag": "h2",
                "content": "3. Check for Complement in Hash Map"
            },
            {
                "tag": "p",
                "content": "For each element, check if its complement (the 'need' value) already exists in the hash map. If it does, the current element and the element at the index stored in the hash map are the solution."
            },
            {
                "tag": "code",
                "content": "\nCopy code\n    IF need EXISTS IN memo\n        RETURN [i, memo[need]]"
            },
            {
                "tag": "h2",
                "content": "4. Store the Current Element in the Hash Map"
            },
            {
                "tag": "p",
                "content": "If the complement isn't found, add the current element and its index to the hash map and proceed. This step is crucial because it records the indices of the elements we've already seen, allowing us to find the complement in constant time."
            },
            {
                "tag": "code",
                "content": "\n    memo[nums[i]] = i\nEND FOR"
            },
            {
                "tag": "h2",
                "content": "Pseudo Code Summary"
            },
            {
                "tag": "p",
                "content": "Combining all the steps, we get the following pseudo code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION twoSum(nums, target)\n    Initialize memo as an empty hash map\n\n    FOR i FROM 0 TO length of nums - 1\n        Set need to target - nums[i]\n\n        IF need EXISTS IN memo\n            RETURN [i, memo[need]]\n\n        memo[nums[i]] = i\n    END FOR\nEND FUNCTION"
            },
            {
                "tag": "h2",
                "content": "Explanation"
            },
            {
                "tag": "p",
                "content": "The key idea of this solution is to use a hash map to keep track of the indices of the elements we've encountered so far. For each element, we check if the complement (the number that, when added to the current element, equals the target) has already been seen. If it has, we immediately return the current index and the index of the complement from the hash map. This approach ensures that the solution runs in linear time, making it efficient even for large arrays."
            }
        ],
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (hash.find(complement) != hash.end()) {\n                return {hash[complement], i};\n            }\n            hash[nums[i]] = i;\n        }\n        return {};\n    }\n};\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "py",
                "code": "\ndef twoSum(nums, target):\n    memo = {}\n    for i in range(len(nums)):\n\n        need = target - nums[i]\n        if need in memo:\n            return [i, memo[need]]\n\n        memo[nums[i]] = i "
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst twoSum = function(nums, t, m={}) {\n    for(let i = 0; i < nums.length; i++){\n        const need = t - nums[i];\n        if(need in m ) return [i, m[need]];\n        m[nums[i]] = i;\n    }\n};"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "\nfunc twoSum(nums []int, target int) []int {\n\tmemo := make(map[int]int)\n\tfor i, num := range nums {\n\t\tif val, is := memo[target-num]; is {\n\t\t\treturn []int{i, val}\n\t\t}\n\t\tmemo[num] = i\n\t}\n\treturn []int{}\n}"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "\nstatic class Solution \n{\n    public int[] twoSum(int[] nums, int target) \n    {\n        Map<Integer, Integer> memo = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) \n        {\n            int need = target - nums[i];\n            if (memo.containsKey(need)) \n            {\n                return new int[] { memo.get(need), i };\n            }\n            memo.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "\nclass Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n        var dict = [Int: Int]()\n        for (i, num) in nums.enumerated() {\n            if let j = dict[target - num] {\n                return [j, i]\n            }\n            dict[num] = i\n        }\n        return []\n    }\n}"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    *returnSize = 2;\n    int* result = (int*) malloc(2 * sizeof(int));\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n        }\n    }\n    return result; // control never reaches here since there is always exactly one solution\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        Dictionary<int, int> seenNumbers = new Dictionary<int, int>();\n        for (int i = 0; i < nums.Length; i++) {\n            int complement = target - nums[i];\n            if (seenNumbers.ContainsKey(complement)) {\n                return new [] { seenNumbers[complement], i };\n            }\n            if (!seenNumbers.ContainsKey(nums[i])) {\n                seenNumbers.Add(nums[i], i);\n            }\n        }\n        return new int[0]; // Should never be reached as there is exactly one solution\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function twoSum(nums: number[], target: number): number[] {\n    const map: {[key: number]: number} = {};\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map[complement] !== undefined) {\n            return [map[complement], i];\n        }\n        map[nums[i]] = i;\n    }\n    return [];\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function twoSum($nums, $target) {\n        $map = [];\n\n        for ($i = 0; $i < count($nums); $i++) {\n            $complement = $target - $nums[$i];\n            if (array_key_exists($complement, $map)) {\n                return [$map[$complement], $i];\n            }\n            $map[$nums[$i]] = $i;\n        }\n\n        return [];\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n        val map = mutableMapOf<Int, Int>()\n        for ((index, value) in nums.withIndex()) {\n            val complement = target - value\n            if (map.containsKey(complement)) {\n                return intArrayOf(map[complement]!!, index)\n            }\n            map[value] = index\n        }\n        return intArrayOf()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> twoSum(List<int> nums, int target) {\n    Map<int, int> numMap = {};\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (numMap.containsKey(complement)) {\n        return [numMap[complement]!, i];\n      }\n      numMap[nums[i]] = i;\n    }\n    return [];\n  }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def two_sum(nums, target)\n    hash = {}\n    nums.each_with_index do |num, i|\n        diff = target - num\n        return [hash[diff], i] if hash.has_key?(diff)\n        hash[num] = i\n    end\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        use std::collections::HashMap;\n        let mut map = HashMap::new();\n        for (index, &num) in nums.iter().enumerate() {\n            if let Some(&i) = map.get(&(target - num)) {\n                return vec![i as i32, index as i32];\n            }\n            map.insert(num, index);\n        }\n        vec![]\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define (two-sum nums target)\n  (define (find-indices hmap index)\n    (if (= index (length nums))\n        '()\n        (let* ((current-num (list-ref nums index))\n               (complement (- target current-num)))\n          (if (hash-has-key? hmap complement)\n              (list (hash-ref hmap complement) index)\n              (find-indices (hash-set hmap current-num index) (+ index 1))))))\n  (find-indices (make-immutable-hash) 0))\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "two_sum(Nums, Target) ->\n    two_sum(Nums, Target, dict:new(), 0).\n\ntwo_sum([H|T], Target, Dict, Index) ->\n    case dict:find(Target - H, Dict) of\n        {ok, Idx} -> [Idx, Index];\n        error -> two_sum(T, Target, dict:store(H, Index, Dict), Index + 1)\n    end.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can utilize a hash table (dictionary in Python) to keep track of the numbers we have seen so far and their corresponding indices. This approach ensures that we can check for the existence of the required complement in constant time, leading to an overall linear time complexity.\n\nHere\u2019s the breakdown:\n\n# Explanation:\n1. Iterate through the list of numbers.\n2. For each number, calculate the complement (the number that, when added to the current number, equals the target).\n3. Check if the complement is already in the hash table.\n4. If it is, return the indices of the current number and the complement.\n5. If it is not, add the current number and its index to the hash table.\n6. Since the problem guarantees that there is exactly one solution, we can be assured that this approach will find the solution.\n\n# Pseudocode:\n```\nfunction twoSum(nums, target):\n    # Create an empty hash table to store numbers and their indices\n    memo = {}\n\n    # Iterate through each number in the list\n    for i from 0 to length of nums - 1:\n        # Calculate the complement\n        need = target - nums[i]\n\n        # Check if the complement is already in the hash table\n        if need in memo:\n            # If found, return the indices of the current number and the complement\n            return [i, memo[need]]\n\n        # If not found, add the current number and its index to the hash table\n        memo[nums[i]] = i\n```\n\nThis approach ensures that we only pass through the list once, achieving a time complexity of O(n). The space complexity is also O(n) due to the storage required for the hash table."
    },
    {
        "name": "Add Two Numbers",
        "site": "LeetCode",
        "_id": "LeetCode-Add-Two-Numbers",
        "href": "/solution/LeetCode-Add-Two-Numbers",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves adding two non-negative integers represented by two non-empty linked lists, where each node contains a single digit. The digits are stored in reverse order. The goal is to return the sum as a linked list, also in reverse order."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Initialize:"
            },
            {
                "tag": "p",
                "content": "Create a dummy head for the result linked list to simplify adding new nodes. Also, keep a variable for carrying over the value when the sum of two digits is 10 or more."
            },
            {
                "tag": "h5",
                "content": "2. Traverse Both Lists:"
            },
            {
                "tag": "p",
                "content": "Iterate through both linked lists simultaneously, adding corresponding digits and the carry value from the previous addition. If one list is longer than the other, consider the missing digits as 0."
            },
            {
                "tag": "h5",
                "content": "3. Handle Carry Over:"
            },
            {
                "tag": "p",
                "content": "After each sum, if the result is 10 or more, set carry to 1 (to be added in the next node's value), and reduce the sum by 10 (since we only store a single digit per node)."
            },
            {
                "tag": "h5",
                "content": "4. Move to Next Nodes:"
            },
            {
                "tag": "p",
                "content": "Move to the next node in both input linked lists (if available) and the result linked list."
            },
            {
                "tag": "h5",
                "content": "5. Check for Remaining Carry:"
            },
            {
                "tag": "p",
                "content": "After finishing iterating through both lists, if there's still a carry value (meaning the last addition resulted in a value of 10 or more), add a new node with the carry value."
            },
            {
                "tag": "h5",
                "content": "6. Return the Result:"
            },
            {
                "tag": "p",
                "content": "Since the dummy head was used as a starting point, return dummy.next, which points to the head of the resultant linked list."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION addTwoNumbers(l1, l2)\n    INITIALIZE dummyNode to a new ListNode()\n    INITIALIZE current to dummyNode\n    INITIALIZE carry to 0\n\n    WHILE l1 OR l2 OR carry IS NOT 0\n        INITIALIZE sum to carry\n        IF l1 IS NOT NULL\n            ADD l1's value to sum\n            MOVE l1 to its next node\n        END IF\n        IF l2 IS NOT NULL\n            ADD l2's value to sum\n            MOVE l2 to its next node\n        END IF\n        \n        COMPUTE carry and sum (sum divmod 10)\n        current.next = new ListNode with value sum\n        MOVE current to its next node\n\n    END WHILE\n\n    RETURN dummyNode.next\nEND FUNCTION"
            },
            {
                "tag": "p",
                "content": "This pseudo code outlines the process of iteratively traversing both input linked lists, adding corresponding digits along with any carry from the previous addition, and forming a new linked list to represent the sum. The use of a dummy head node simplifies the process of adding new nodes to the result list."
            }
        ],
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "py",
                "code": "\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \n\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode()\n    curr, carry = dummy, 0\n\n    while l1 or l2 or carry:\n        val = carry\n        if l1:\n            val += l1.val\n            l1 = l1.next\n        if l2:\n            val += l2.val\n            l2 = l2.next\n        carry, val = divmod(val, 10)\n        curr.next = ListNode(val)\n        curr = curr.next\n        \n    return dummy.next"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nclass ListNode{\n    constructor(val, next = null){\n        this.val = val;\n        this.next = next;\n    }\n}\n  \n\nconst addTwoNumbers = (l1, l2) =>{\n    const addLists = (num1, num2, carry = 0) => {\n        if (!num1 && !num2 && !carry) return null;\n        const newVal = (num1?.val || 0) + (num2?.val || 0) + carry;\n        const nextNode = addLists(num1?.next, num2?.next, Math.floor(newVal / 10));\n        return new ListNode(newVal % 10, nextNode);\n    }\n    return addLists(l1, l2);\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode curr = dummy;\n        int carry = 0;\n        while(l1!=null || l2!=null || carry==1){\n            int num = carry;\n            if(l1!=null){\n                num+=l1.val;\n                l1 = l1.next;\n            }\n            if(l2!=null){\n                num+=l2.val;\n                l2 = l2.next;\n            }\n            carry = num / 10;\n            curr.next = new ListNode(num % 10);;\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n\tcarry, dummy := 0, new(ListNode)\n\tfor node := dummy; l1 != nil || l2 != nil || carry > 0; node = node.Next {\n\t\tif l1 != nil {\n\t\t\tcarry += l1.Val\n\t\t\tl1 = l1.Next\n\t\t}\n\t\tif l2 != nil {\n\t\t\tcarry += l2.Val\n\t\t\tl2 = l2.Next\n\t\t}\n\t\tnode.Next = &ListNode{carry % 10, nil}\n\t\tcarry /= 10\n\t}\n\treturn dummy.Next\n}"
            },
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode(0);\n        ListNode* current = dummy;\n        int carry = 0;\n        \n        while (l1 != nullptr || l2 != nullptr || carry) {\n            int sum = carry;\n            if (l1 != nullptr) {\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if (l2 != nullptr) {\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            carry = sum / 10;\n            current->next = new ListNode(sum % 10);\n            current = current->next;\n        }\n        \n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode *dummy = (struct ListNode*) malloc(sizeof(struct ListNode));\n    struct ListNode *current = dummy;\n    int carry = 0;\n    \n    while (l1 != NULL || l2 != NULL || carry != 0) {\n        int sum = carry;\n        if (l1 != NULL) {\n            sum += l1->val;\n            l1 = l1->next;\n        }\n        if (l2 != NULL) {\n            sum += l2->val;\n            l2 = l2->next;\n        }\n        carry = sum / 10;\n        current->next = (struct ListNode*) malloc(sizeof(struct ListNode));\n        current->next->val = sum % 10;\n        current->next->next = NULL;\n        current = current->next;\n    }\n    \n    struct ListNode *result = dummy->next;\n    free(dummy);\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = l1, q = l2, curr = dummyHead;\n        int carry = 0;\n        while (p != null || q != null) {\n            int x = (p != null) ? p.val : 0;\n            int y = (q != null) ? q.val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n            if (p != null) p = p.next;\n            if (q != null) q = q.next;\n        }\n        if (carry > 0) {\n            curr.next = new ListNode(carry);\n        }\n        return dummyHead.next;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    function addTwoNumbers($l1, $l2) {\n        $dummyHead = new ListNode(0);\n        $current = $dummyHead;\n        $carry = 0;\n\n        while ($l1 !== null || $l2 !== null || $carry !== 0) {\n            $sum = $carry;\n            if ($l1 !== null) {\n                $sum += $l1->val;\n                $l1 = $l1->next;\n            }\n            if ($l2 !== null) {\n                $sum += $l2->val;\n                $l2 = $l2->next;\n            }\n            \n            $carry = intdiv($sum, 10);\n            $current->next = new ListNode($sum % 10);\n            $current = $current->next;\n        }\n\n        return $dummyHead->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        let dummyHead = ListNode(0)\n        var current = dummyHead\n        var p = l1, q = l2\n        var carry = 0\n        \n        while p != nil || q != nil {\n            let x = p?.val ?? 0\n            let y = q?.val ?? 0\n            let sum = carry + x + y\n            carry = sum / 10\n            current.next = ListNode(sum % 10)\n            current = current.next!\n            if p != nil { p = p!.next }\n            if q != nil { q = q!.next }\n        }\n        \n        if carry > 0 {\n            current.next = ListNode(carry)\n        }\n        \n        return dummyHead.next\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n    dummy_head = ListNode.new(0)\n    current = dummy_head\n    carry = 0\n    \n    while l1 || l2 || carry > 0\n        val1 = l1 ? l1.val : 0\n        val2 = l2 ? l2.val : 0\n        sum = val1 + val2 + carry\n        carry = sum / 10\n        current.next = ListNode.new(sum % 10)\n        current = current.next\n        \n        l1 = l1.next if l1\n        l2 = l2.next if l2\n    end\n    \n    dummy_head.next\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n  def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {\n    var carry = 0\n    val head = new ListNode(0)\n    var current = head\n    var p1 = l1\n    var p2 = l2\n\n    while (p1 != null || p2 != null || carry != 0) {\n      val sum = (if (p1 != null) p1.x else 0) + (if (p2 != null) p2.x else 0) + carry\n      carry = sum / 10\n      current.next = new ListNode(sum % 10)\n      current = current.next\n      if (p1 != null) p1 = p1.next\n      if (p2 != null) p2 = p2.next\n    }\n\n    head.next\n  }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule ListNode do\n  @type t :: %__MODULE__{\n          val: integer,\n          next: t() | nil\n        }\n  defstruct val: 0, next: nil\nend\n\ndefmodule Solution do\n  def add_two_numbers(l1, l2) do\n    add_lists(l1, l2, 0)\n  end\n\n  defp add_lists(%ListNode{val: v1, next: n1} = l1, %ListNode{val: v2, next: n2} = l2, carry) do\n    sum = v1 + v2 + carry\n    new_val = rem(sum, 10)\n    carry = div(sum, 10)\n\n    %ListNode{val: new_val, next: add_next(n1, n2, carry)}\n  end\n\n  defp add_lists(nil, nil, 0), do: nil\n  defp add_lists(nil, nil, carry), do: %ListNode{val: carry}\n\n  defp add_lists(nil, %ListNode{} = l2, carry), do: add_lists(%ListNode{val: 0}, l2, carry)\n  defp add_lists(%ListNode{} = l1, nil, carry), do: add_lists(l1, %ListNode{val: 0}, carry)\n\n  defp add_next(n1, n2, carry) do\n    case {n1, n2, carry} do\n      {nil, nil, 0} -> nil\n      {_n1, _n2, _} -> add_lists(n1, n2, carry)\n    end\n  end\nend\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    if (!l1 && !l2) return null;\n\n    let dummy = new ListNode();\n    let current = dummy;\n    let carry = 0;\n\n    while (l1 || l2 || carry > 0) {\n        let sum = carry;\n        if (l1) {\n            sum += l1.val;\n            l1 = l1.next;\n        }\n        if (l2) {\n            sum += l2.val;\n            l2 = l2.next;\n        }\n        carry = Math.floor(sum / 10);\n        sum = sum % 10;\n        current.next = new ListNode(sum);\n        current = current.next;\n    }\n\n    return dummy.next;\n};\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut dummy = Some(Box::new(ListNode { val: 0, next: None }));\n        let (mut p, mut q, mut current) = (l1, l2, dummy.as_mut());\n\n        let mut carry = 0;\n\n        while p.is_some() || q.is_some() {\n            let sum = carry +\n                p.as_ref().map_or(0, |node| node.val) +\n                q.as_ref().map_or(0, |node| node.val);\n\n            carry = sum / 10;\n\n            current.as_mut().unwrap().next = Some(Box::new(ListNode { val: sum % 10, next: None }));\n            current = current.and_then(|node| node.next.as_mut());\n\n            if let Some(node) = p.as_mut() {\n                p = node.next.take();\n            }\n            if let Some(node) = q.as_mut() {\n                q = node.next.take();\n            }\n        }\n\n        if carry > 0 {\n            current.as_mut().unwrap().next = Some(Box::new(ListNode { val: carry, next: None }));\n        }\n\n        dummy.unwrap().next\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "add_two_numbers(null, L2) -> L2;\nadd_two_numbers(L1, null) -> L1;\nadd_two_numbers(#list_node{val = V1, next = N1}, #list_node{val = V2, next = N2}) ->\n    Sum = V1 + V2,\n    {NewVal, Carry} = case Sum >= 10 of\n        true -> {Sum rem 10, 1};\n        false -> {Sum, 0}\n    end,\n    NewNode = #list_node{val = NewVal},\n    NextL1 = if N1 =:= null -> null; true -> N1 end,\n    NextL2 = if N2 =:= null -> null; true -> N2 end,\n    NextNode = add_two_numbers(NextL1, NextL2),\n    if\n        Carry =:= 1 ->\n            #list_node{val = NewVal, next = add_two_numbers(NextNode, #list_node{val = Carry, next = null})}\n        ;\n        true -> #list_node{val = NewVal, next = NextNode}\n    end.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to add two non-empty linked lists representing two non-negative integers. The digits in the linked lists are stored in reverse order, and each node contains a single digit.\n\n## Explanation\n\n1. **Initialize a dummy node**: This dummy node helps to simplify the edge cases handling and provides an easy starting point for our result list.\n   \n2. **Initialize pointers and variables**: We use a `current` pointer starting from the dummy node and a `carry` variable initialized to zero to handle the sum carry-over.\n\n3. **Iterate through the lists**: Continue iterating as long as there is a node in `l1` or `l2`, or there is a carry to process.\n   - Add the values from the current nodes of `l1` and `l2` to the `carry`.\n   - Move to the next nodes in `l1` and `l2`.\n   - Calculate the new carry and the current digit using `divmod`.\n   - Create a new node with the current digit and link it to the `current` node.\n   - Move the `current` node to the new node.\n\n4. **Return the result**: The resultant linked list starts from the node next to the dummy node.\n\n## Pseudocode\n\n``` \n// Class definition for ListNode\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n// Function to add two numbers represented by linked lists\nfunction addTwoNumbers(l1, l2):\n    // Initialize dummy node\n    dummy = ListNode()\n\n    // Initialize current pointer and carry variable\n    current = dummy\n    carry = 0\n\n    // Iterate through l1, l2, and while there is a carry\n    while l1 is not null or l2 is not null or carry is not 0:\n        // Initialize sum with carry\n        sum = carry\n       \n        // Add value of l1 node to sum if l1 is not null\n        if l1 is not null:\n            sum += l1.val\n            l1 = l1.next\n       \n        // Add value of l2 node to sum if l2 is not null\n        if l2 is not null:\n            sum += l2.val\n            l2 = l2.next\n\n        // Update carry and the current digit using divmod function\n        carry, val = divmod(sum, 10)\n\n        // Create a new node with the current digit and link it to current pointer's next\n        current.next = ListNode(val)\n        \n        // Move current pointer to the next node\n        current = current.next\n\n    // Return the resultant linked list starting from dummy.next\n    return dummy.next\n```\n\nThis pseudocode outlines the logical steps to creating an algorithm that can add two numbers represented by linked lists in reverse order, handling each node from the least significant digit to the most significant digit, and managing the carry-over appropriately."
    },
    {
        "name": "Add Two Promises",
        "site": "LeetCode",
        "_id": "LeetCode-Add-Two-Promises",
        "href": "/solution/LeetCode-Add-Two-Promises",
        "video": {
            "has_video": false
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves working with JavaScript promises. You're given two promises, promise1 and promise2, both of which resolve to a number. The task is to return a new promise that resolves with the sum of the numbers from promise1 and promise2."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Wait for Promises to Resolve:"
            },
            {
                "tag": "p",
                "content": "Use the await keyword to wait for each of the two promises to resolve. This allows you to get the resolved value of each promise."
            },
            {
                "tag": "h5",
                "content": "2. Add the Resolved Values:"
            },
            {
                "tag": "p",
                "content": "Once you have both resolved values, add them together."
            },
            {
                "tag": "h5",
                "content": "3. Return a Promise:"
            },
            {
                "tag": "p",
                "content": "Since the function is asynchronous (because of the await keyword), it automatically returns a promise. This promise will resolve with the sum of the two resolved values from promise1 and promise2."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nASYNC FUNCTION addTwoPromises(promise1, promise2)\n    // Wait for the first promise to resolve and store its value\n    value1 = AWAIT promise1\n    \n    // Wait for the second promise to resolve and store its value\n    value2 = AWAIT promise2\n    \n    // Return the sum of the two values\n    RETURN value1 + value2\nEND FUNCTION"
            },
            {
                "tag": "h2",
                "content": "Explanation:"
            },
            {
                "tag": "h5",
                "content": "Async Function:"
            },
            {
                "tag": "p",
                "content": "The function is declared with async to allow the use of the await keyword inside it. This also means the function returns a promise."
            },
            {
                "tag": "h5",
                "content": "Awaiting Promises:"
            },
            {
                "tag": "p",
                "content": "The await keyword is used to pause the execution of the function until the promise resolves. This makes the asynchronous promise handling appear more synchronous."
            },
            {
                "tag": "h5",
                "content": "Summing Values:"
            },
            {
                "tag": "p",
                "content": "After both promises have resolved, their values are added together. The sum is then automatically wrapped in a promise and returned by the async function."
            },
            {
                "tag": "p",
                "content": "This approach simplifies handling asynchronous operations by making the code appear more like synchronous code, improving readability and maintainability."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst addTwoPromises = async (promise1, promise2) => await promise1 + await promise2;"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to write a function that takes two promises as input and returns a new promise that resolves with the sum of the values resolved by the input promises.\n\n# Explanation:\n1. **Input**: Two promises `promise1` and `promise2`.\n2. **Promise Resolution**: Both promises will resolve to a number after a certain amount of time.\n3. **Output**: A new promise that should resolve to the sum of the two numbers resolved by the input promises.\n\n# Pseudocode:\n1. Create an asynchronous function `addTwoPromises` that accepts two promises as arguments.\n2. Inside the function, use the `await` keyword to wait for both promises to resolve and get their values.\n3. Return a new promise that resolves to the sum of these two values.\n\n```plaintext\n# Pseudocode\nasync function addTwoPromises(promise1, promise2):\n    # Await for promise1 and promise2 to resolve and get their values\n    value1 = await promise1\n    value2 = await promise2\n    \n    # Return a new promise that resolves to the sum of value1 and value2\n    return value1 + value2\n```\n\nBy using the `await` keyword in an asynchronous function, we ensure that the function pauses execution until the promises are resolved. Once both promises are resolved, we add their resolved values and return the result."
    },
    {
        "name": "All Paths From Source to Target",
        "site": "LeetCode",
        "_id": "LeetCode-All-Paths-From-Source-to-Target",
        "href": "/solution/LeetCode-All-Paths-From-Source-to-Target",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves finding all paths from the start node (node 0) to the end node (node n-1) in a Directed Acyclic Graph (DAG). The approach to solve this problem involves using Depth-First Search (DFS) with backtracking."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Initialization:"
            },
            {
                "tag": "p",
                "content": "Define a variable to hold the final result (list of paths). Also, define the target node, which is the last node (n-1)."
            },
            {
                "tag": "h5",
                "content": "2. Depth-First Search (DFS) Function:"
            },
            {
                "tag": "p",
                "content": "This function, let's call it DFS, will take the current node and the current path as arguments. If the current node is the target node, add the current path to the result and return. If the current node is the target node, add the current path to the result and return. Iterate over all adjacent nodes of the current node. For each adjacent node. Add the adjacent node to the current path. Recursively call DFS with the adjacent node and the updated path. Backtrack by removing the last node added to the path (to explore other paths)."
            },
            {
                "tag": "h5",
                "content": "3. Backtracking:"
            },
            {
                "tag": "p",
                "content": "This is implicitly done by the DFS function by adding and then removing nodes from the current path as it explores different paths."
            },
            {
                "tag": "h5",
                "content": "4. Start DFS: "
            },
            {
                "tag": "p",
                "content": "Begin the DFS from node 0 with an initial path containing just the start node."
            },
            {
                "tag": "h5",
                "content": "5. Return Result:"
            },
            {
                "tag": "p",
                "content": "Convert the result set to an array or list and return it."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION allPathsSourceTarget(graph)\n    target = LENGTH(graph) - 1\n    result = NEW LIST\n\n    FUNCTION DFS(currentNode, path)\n        IF currentNode IS target\n            ADD path TO result\n            RETURN\n        END IF\n\n        FOR each nextNode IN graph[currentNode]\n            ADD nextNode TO path\n            DFS(nextNode, path)\n            REMOVE last element from path (BACKTRACK)\n        END FOR\n    END FUNCTION\n\n    INITIAL_PATH = [0]\n    DFS(0, INITIAL_PATH)\n\n    RETURN result\nEND FUNCTION"
            },
            {
                "tag": "p",
                "content": "In this solution, the DFS function is defined within the allPathsSourceTarget function and recursively explores all paths from the start node to the target node. By adding and removing nodes from the path within the loop, the function effectively backtracks after exploring all paths from a given node, allowing it to explore all possible paths without revisiting the same path."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst allPathsSourceTarget = (graph) =>{\n    \n    const target = graph.length - 1;\n    let ans = new Set;\n    \n    const backtrack = (currentNode, path) =>{\n        \n        if(currentNode === target){\n            ans.add(path.slice(0));\n            return;\n        }\n        \n        for(let i=0; i<graph[currentNode].length; i++){\n            \n            const nextNode = graph[currentNode][i];\n            path.push(nextNode);\n            backtrack(nextNode, path);\n            path.pop();\n        }\n    };\n    backtrack(0, [0]);\n    \n    return Array.from(ans); \n};"
            }
        ]
    },
    {
        "name": "Array Wrapper",
        "site": "LeetCode",
        "_id": "LeetCode-Array-Wrapper",
        "href": "/solution/LeetCode-Array-Wrapper",
        "video": {
            "has_video": false
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you need to create a class ArrayWrapper that encapsulates an array of integers and defines custom behavior for addition and string representation operations. Here's a step-by-step explanation along with pseudo code:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Class Definition"
            },
            {
                "tag": "p",
                "content": "Begin by defining a class named ArrayWrapper. The constructor of the class should accept an array of integers, nums, and store it as an instance variable."
            },
            {
                "tag": "h2",
                "content": "Step 2: Addition Operation"
            },
            {
                "tag": "p",
                "content": "To enable the addition of two ArrayWrapper instances using the + operator, you need to override a method that JavaScript uses internally when addition is performed. In JavaScript, this is typically achieved by defining or overriding the valueOf() method. The valueOf() method should iterate through the array stored in the instance and calculate the sum of its elements. This sum will then be used when the + operator is involved."
            },
            {
                "tag": "h2",
                "content": "Step 3: String Representation"
            },
            {
                "tag": "p",
                "content": "To define how an ArrayWrapper instance is converted to a string, you should override the toString() method. The toString() method should return a string representation of the array, formatted as a comma-separated list of elements enclosed in square brackets [ and ]."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nClass ArrayWrapper\n    Constructor(nums)\n        this.nums = nums\n\n    Method valueOf()\n        sum = 0\n        For each num in this.nums\n            sum = sum + num\n        EndFor\n        Return sum\n\n    Method toString()\n        Return \"[\" + this.nums.join(\",\") + \"]\"\nEndClass"
            },
            {
                "tag": "h2",
                "content": "Usage Examples"
            },
            {
                "tag": "p",
                "content": "Creating instances:"
            },
            {
                "tag": "code",
                "content": "\nobj1 = new ArrayWrapper([1, 2])\nobj2 = new ArrayWrapper([3, 4])"
            },
            {
                "tag": "p",
                "content": "Adding instances:"
            },
            {
                "tag": "code",
                "content": "\nresult = obj1 + obj2  // result would be 10"
            },
            {
                "tag": "h2",
                "content": "Converting to string:"
            },
            {
                "tag": "code",
                "content": "\nstrRepresentation = String(obj1)  // strRepresentation would be \"[1,2]\" "
            },
            {
                "tag": "p",
                "content": "This pseudo code outlines the structure and logic needed to meet the requirements of the coding challenge. The actual JavaScript implementation provided does this by defining the ArrayWrapper function as a constructor and adding the valueOf and toString methods to its prototype, allowing all instances to share these methods."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst ArrayWrapper = function(nums) {\n    this.nums = nums;\n};\n\nArrayWrapper.prototype.valueOf = function() {\n    return this.nums.reduce((a, b) => a + b, 0);;\n}\n\nArrayWrapper.prototype.toString = function() {\n    return `[${this.nums}]`;\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create a class `ArrayWrapper` that will encapsulate an array of integers, providing specific functionality: \n\n1. Adding two instances of this class using the `+` operator should result in the sum of all elements in both arrays.\n2. Converting an instance to a string using the `String()` function should return a comma-separated string representation of the array surrounded by brackets.\n\nLet's break down the solution into clear steps:\n\n# Explanation\n\n1. **Constructor**: The class will have a constructor that accepts an array of integers and assigns it to an instance variable.\n2. **Addition (`+` operator)**: To make two instances of the class addable using the `+` operator, we\u2019ll need to define a method that the interpreter will call during such operations. In JavaScript, this is done using the `valueOf` method.\n3. **String representation**: To control the string conversion of an instance, we can define the `toString` method, which will be called when `String()` or template literals are used.\n\n# Pseudocode\n\nHere's the pseudocode that summarizes the solution:\n\n```\nclass ArrayWrapper:\n    # Constructor to initialize the array\n    def __init__(self, nums):\n        this.nums = nums\n\n    # Method to handle the addition of two instances\n    def __add__(self, other):\n        if isinstance(other, ArrayWrapper):\n            return sum(self.nums) + sum(other.nums)\n        return NotImplemented\n\n    # Method to convert the instance to a string\n    def __str__(self):\n        return '[' + ','.join(map(str, self.nums)) + ']'\n```\n\n1. **Constructor**: Initialize the array attribute with the given input array.\n2. **Addition (`__add__` method)**: Check if the other object is an instance of `ArrayWrapper`. If so, return the sum of elements in both arrays.\n3. **String conversion (`__str__` method)**: Convert the list of numbers to a comma-separated string and surround it with brackets.\n\nThis pseudocode outlines how the required functionality can be implemented. Adjustments may be needed to fit the syntax and idioms of the actual programming language used, but the overall logic will remain the same."
    },
    {
        "name": "Binary Search Tree to Greater Sum Tree",
        "site": "LeetCode",
        "_id": "LeetCode-Binary-Search-Tree-to-Greater-Sum-Tree",
        "href": "/solution/LeetCode-Binary-Search-Tree-to-Greater-Sum-Tree",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you need to convert a given Binary Search Tree (BST) into a Greater Tree where each node's value is updated to be itself plus the sum of all values greater than it in the BST. The solution involves a depth-first search (DFS) traversal, specifically a reverse in-order traversal (right node, current node, left node), to accumulate the sum of nodes' values in a descending order. Here's how you can solve it along with the pseudo code:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Initialize a Variable"
            },
            {
                "tag": "p",
                "content": "Initialize a variable, say lastSum, to store the cumulative sum of node values encountered during the traversal. Start with lastSum set to 0."
            },
            {
                "tag": "h2",
                "content": "Step 2: Define a Recursive DFS Function"
            },
            {
                "tag": "p",
                "content": "Define a recursive function, say convertToGreaterTree(node), which will perform the reverse in-order traversal and update each node's value."
            },
            {
                "tag": "h2",
                "content": "Step 3: Reverse In-Order Traversal"
            },
            {
                "tag": "p",
                "content": "If the current node (node) is null, return immediately, as there's nothing to process. Recursively call convertToGreaterTree(node.right) to start traversal from the rightmost node (the largest value in a BST). Add lastSum to the current node's value (node.val) and update lastSum to be the new value of node.val. This step ensures that each node's value is updated to include the sum of all greater values in the tree. Recursively call convertToGreaterTree(node.left) to process the left subtree, which contains smaller values."
            },
            {
                "tag": "h2",
                "content": "Step 4: Initiate the Traversal"
            },
            {
                "tag": "p",
                "content": "Call convertToGreaterTree(root) with the root of the BST to start the conversion process."
            },
            {
                "tag": "h2",
                "content": "Step 5: Return the Modified Tree"
            },
            {
                "tag": "p",
                "content": "After the recursive function has updated all nodes, return the root of the modified tree."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFunction bstToGst(root)\n    Initialize lastSum to 0\n\n    Function convertToGreaterTree(node)\n        If node is null, return\n\n        // Traverse the right subtree\n        convertToGreaterTree(node.right)\n\n        // Update the current node's value and lastSum\n        node.val = node.val + lastSum\n        lastSum = node.val\n\n        // Traverse the left subtree\n        convertToGreaterTree(node.left)\n    EndFunction\n\n    // Start the conversion from the root\n    convertToGreaterTree(root)\n\n    Return root\nEndFunction"
            },
            {
                "tag": "h2",
                "content": "Explanation"
            },
            {
                "tag": "p",
                "content": "This algorithm leverages the properties of a BST to ensure that when we traverse the tree in reverse in-order order (right subtree, current node, left subtree), we visit nodes in descending order. By maintaining a running sum of all previously visited node values (lastSum), we can update each node to be the sum of its original value and all greater values in the BST. This results in the BST being transformed into a Greater Tree as required by the problem statement."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst bstToGst = (root) =>{\n    let lastN = 0;\n    const dfs = (n) =>{\n        if(!n) return;\n        dfs(n.right);\n        n.val += lastN;\n        lastN = n.val;\n        dfs(n.left);\n    };\n    dfs(root);\n    return root;\n};"
            }
        ]
    },
    {
        "name": "Best Time to Buy and Sell Stock",
        "site": "LeetCode",
        "_id": "LeetCode-Best-Time-to-Buy-and-Sell-Stock",
        "href": "/solution/LeetCode-Best-Time-to-Buy-and-Sell-Stock",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves finding the maximum profit from a single buy-sell transaction given a list of stock prices over consecutive days. The key idea is to keep track of the minimum purchase price (buy) seen so far and the maximum profit that can be achieved with each new price encountered."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Initialize Variables:"
            },
            {
                "tag": "p",
                "content": "Initialize two variables: profit to track the maximum profit and buy to keep track of the minimum purchase price so far. Set profit to 0 and buy to a very high value (Infinity) to ensure any price will be lower."
            },
            {
                "tag": "h5",
                "content": "2. Iterate Through Prices:"
            },
            {
                "tag": "p",
                "content": "For each price p in the prices array, perform the following checks and updates:"
            },
            {
                "tag": "h5",
                "content": "3. Buying Condition:"
            },
            {
                "tag": "p",
                "content": "If p is less than buy, update buy to p. Also, reset sell to a very low value (-Infinity) to ensure the next sell price is higher than the new buy price."
            },
            {
                "tag": "h5",
                "content": "4. Selling Condition: "
            },
            {
                "tag": "p",
                "content": "If p is greater than sell, update sell to p. Update profit to the maximum of the current profit and the difference between sell and buy."
            },
            {
                "tag": "h5",
                "content": "5. Return Profit:"
            },
            {
                "tag": "p",
                "content": "After iterating through all prices, return the maximum profit achieved."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction maxProfit(prices)\n    Initialize profit to 0\n    Initialize buy to Infinity\n    Initialize sell to -Infinity\n\n    For each price p in prices\n        If p < buy\n            Update buy to p\n            Reset sell to -Infinity\n        Else if p > sell\n            Update sell to p\n            Update profit to max(profit, sell - buy)\n\n    Return profit\nEndFunction"
            },
            {
                "tag": "h2",
                "content": "Explanation of Solution"
            },
            {
                "tag": "p",
                "content": "The solution effectively scans through the list of prices once (O(n) complexity), updating the buy price whenever a lower price is found. This guarantees buying at the lowest price up to that point. When a higher sell price is encountered, the potential profit (sell - buy) is calculated. If this profit is greater than the current maximum profit, the maximum profit is updated. This approach ensures that the maximum profit possible with a single buy-sell transaction is found, adhering to the constraint that the buy must occur before the sell."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst maxProfit = (prices, prf=0, buy=Infinity, sell=-Infinity) =>{\n    for(let p of prices){\n        if(p<buy){\n            buy = p;\n            sell = -Infinity;\n        }else if(p>sell){\n            sell = p;\n            prf = Math.max(sell - buy, prf);\n        }\n    }\n    return prf;\n};"
            }
        ]
    },
    {
        "name": "Coin Change",
        "site": "LeetCode",
        "_id": "LeetCode-Coin-Change",
        "href": "/solution/LeetCode-Coin-Change",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you can use dynamic programming, specifically the bottom-up approach. The problem asks for the fewest number of coins needed to make up a given amount using coins of different denominations. Here's how to approach it:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Initialize"
            },
            {
                "tag": "p",
                "content": "Create an array, let's call it dp, with a length of amount + 1 to store the minimum number of coins needed for each amount from 0 to amount. Initialize this array with a value that indicates an impossible situation, such as -1. Set dp[0] = 0 because the minimum number of coins needed to make up an amount of 0 is 0."
            },
            {
                "tag": "h2",
                "content": "Step 2: Sort Coins"
            },
            {
                "tag": "p",
                "content": "Although not always necessary, sorting the coins can sometimes improve efficiency. This ensures you're always starting with the smallest denomination."
            },
            {
                "tag": "h2",
                "content": "Step 3: Dynamic Programming"
            },
            {
                "tag": "p",
                "content": "Loop through each coin denomination. For each coin, iterate through the dp array starting from the coin's value up to the target amount. For each amount i that is at least as large as the current coin's value, calculate the minimum number of coins needed as follows: Find the previous amount i - coin in the dp array and add 1 to it (since you're using one more coin). Compare this number with the current value in dp[i] (if it's not -1, which means it's been updated before) and take the minimum. Update dp[i] with this minimum number."
            },
            {
                "tag": "h2",
                "content": "Step 4: Return the Result"
            },
            {
                "tag": "p",
                "content": "After filling the dp array, the value at dp[amount] will represent the fewest number of coins needed to make up the amount. If dp[amount] is still -1, it means it's impossible to make up the amount with the given coins, so return -1."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction coinChange(coins, amount)\n    Initialize dp array of length amount + 1 with -1\n    dp[0] = 0\n    \n    Sort coins array\n    \n    For each coin in coins\n        For i from coin to amount\n            If i >= coin\n                If dp[i - coin] is not -1\n                    If dp[i] is -1\n                        dp[i] = dp[i - coin] + 1\n                    Else\n                        dp[i] = Min(dp[i], dp[i - coin] + 1)\n    \n    Return dp[amount]\nEnd Function"
            },
            {
                "tag": "p",
                "content": "This pseudo code outlines the dynamic programming approach to solving the problem by iteratively building up the solution for all amounts from 1 to amount using the given coin denominations."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nvar coinChange = function(coins, amount) {\n    const arr = Array.from({length: amount+1}, ()=> -1)\n    arr[0] = 0;\n    coins.sort((a,b)=>a-b)\n  \n    for(const coin of coins){\n        for(let i=0; i<amount+1; i++){\n            if(i >= coin){\n                const i2 = i - coin\n                let pos = arr[i2] + 1 > 0? arr[i2] + 1 : -1\n                if(pos > -1 && arr[i] > -1){\n                    arr[i] = Math.min(arr[i], pos)\n                }else{\n                    arr[i] = arr[i]>-1 ? arr[i] : pos\n                }\n              \n            }\n        }\n    }\n  \n    return arr[amount];\n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the objective is to find the minimum number of coins needed to make up a given amount using a provided list of coin denominations. Here's how to tackle this using dynamic programming.\n\n# Explanation\n\n1. **Initialization**: Create an array `dp` of size `amount + 1` initialized with a value that represents infinity (or a very large number), except for `dp[0]` which should be `0`. This is because zero coins are needed to make the amount `0`.\n\n2. **Dynamic Programming Update**: Iterate over each coin in the coin list. For each coin, update the `dp` array for all values from `coin` to `amount`. The update rule is:\n   \\[\n   dp[i] = \\min(dp[i], dp[i - coin] + 1)\n   \\]\n   This rule checks if using the current coin results in a lesser number of coins than previously recorded for that amount.\n\n3. **Result**: After processing all coins, the value at `dp[amount]` will have the minimum number of coins needed to make up the amount. If `dp[amount]` is still infinity, it means the amount cannot be formed with the given coins, and the function should return `-1`.\n\n# Pseudocode\n\n``` \nFUNCTION coinChange(coins, amount):\n    INITIALIZE dp as an array with size amount + 1, filled with infinity\n    SET dp[0] to 0\n\n    FOR each coin in coins:\n        FOR i from coin to amount:\n            dp[i] = MIN(dp[i], dp[i - coin] + 1)\n\n    IF dp[amount] is infinity:\n        RETURN -1\n    ELSE:\n        RETURN dp[amount]\n\n# Example\ncoins = [1, 2, 5]\namount = 11\n# The result will be 3 since we can form 11 with [5, 5, 1]\n```\n\nThis approach ensures that we explore all possible combinations in a systematic manner and find the optimal solution efficiently using dynamic programming."
    },
    {
        "name": "Compare Version Numbers",
        "site": "LeetCode",
        "_id": "LeetCode-Compare-Version-Numbers",
        "href": "/solution/LeetCode-Compare-Version-Numbers",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "The provided solution does not match the problem statement. The solution seems to be for adding two promises, which is unrelated to comparing version numbers. For the problem of comparing two version numbers, the correct approach involves parsing and comparing the numbers part by part. Here's how to approach it:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Split the Version Numbers"
            },
            {
                "tag": "p",
                "content": "Split both version1 and version2 by the dot '.' to separate the revisions into arrays."
            },
            {
                "tag": "h2",
                "content": "Step 2: Compare Revisions"
            },
            {
                "tag": "p",
                "content": "Iterate over the revisions, comparing the integer values of the corresponding elements from each version. Since one version might have more revisions than the other, continue comparing with 0 if one version runs out of revisions."
            },
            {
                "tag": "h2",
                "content": "Step 3: Determine the Result"
            },
            {
                "tag": "p",
                "content": "During each comparison, if a difference is found, return -1 if version1 is less than version2, or 1 if version1 is greater than version2. If the loop completes without finding any differences, it means the versions are equal, so return 0."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction compareVersion(version1, version2)\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    maxLen = Max(length of v1, length of v2)\n    \n    For i from 0 to maxLen-1\n        rev1 = i < length of v1 ? Integer(v1[i]) : 0\n        rev2 = i < length of v2 ? Integer(v2[i]) : 0\n        \n        If rev1 < rev2\n            Return -1\n        Else if rev1 > rev2\n            Return 1\n    \n    Return 0\nEnd Function"
            },
            {
                "tag": "p",
                "content": "This pseudo code provides a clear outline of the steps needed to compare the version numbers according to the rules specified in the problem statement."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst addTwoPromises = async (promise1, promise2) => await promise1 + await promise2;"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to compare version numbers that are represented as strings, where each version number consists of revisions separated by dots. The solution should determine whether the first version is less than, greater than, or equal to the second version. Let's break down the methodology and provide pseudocode.\n\n# Explanation\n\n1. **Split the Strings:** Convert the version strings into lists of integers by splitting the strings by the dot character (`.`).\n2. **Equalize Lengths:** If the two lists are of different lengths, pad the shorter list with zeros to make them the same length.\n3. **Compare Revisions:** Iterate through the lists and compare each corresponding pair of revisions (integers). \n    - If a revision from `version1` is greater than the corresponding revision from `version2`, return `1`.\n    - If a revision from `version1` is less than the corresponding revision from `version2`, return `-1`.\n4. **Return 0 if Equal:** If all corresponding revisions are equal, return `0`.\n\n# Pseudocode\n\n```\nfunction compareVersion(version1, version2):\n    # Split the version strings into lists of integers\n    revisions1 = split(version1, '.')\n    revisions2 = split(version2, '.')\n\n    # Convert each revision to an integer (ignoring leading zeros)\n    revisions1 = map to int(revisions1)\n    revisions2 = map to int(revisions2)\n    \n    len1 = length(revisions1)\n    len2 = length(revisions2)\n    \n    # Pad the shorter list with zeros\n    while len1 < len2:\n        append 0 to revisions1\n        len1 += 1\n    \n    while len2 < len1:\n        append 0 to revisions2\n        len2 += 1\n\n    # Compare the revisions\n    for i from 0 to len1 - 1:\n        if revisions1[i] > revisions2[i]:\n            return 1\n        else if revisions1[i] < revisions2[i]:\n            return -1\n\n    # If all revisions are equal\n    return 0\n```\n\nThis pseudocode provides a structured approach to solving the problem by breaking it down into manageable steps. Adjustments may be needed if the specifics of the language used vary, but the core logic remains consistent."
    },
    {
        "name": "Concatenation of Array",
        "site": "LeetCode",
        "_id": "LeetCode-Concatenation-of-Array",
        "href": "/solution/LeetCode-Concatenation-of-Array",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you need to create a new array that consists of the original array nums followed by a duplicate of itself. This is straightforward and involves concatenating the original array with a copy of itself. Here's a step-by-step guide and the corresponding pseudo code:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Concatenation"
            },
            {
                "tag": "p",
                "content": "You need to concatenate the original array nums with another instance of itself. There are various ways to do this depending on the programming language being used. In some languages, there might be a built-in function or method for array concatenation."
            },
            {
                "tag": "h2",
                "content": "Step 2: Return the New Array"
            },
            {
                "tag": "p",
                "content": "After concatenating, you will have a new array of length 2n, where n is the length of the original array. This new array is what the problem statement refers to as ans."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFunction getConcatenation(nums)\n    // Create a new array 'ans' by concatenating 'nums' with itself\n    ans = nums + nums\n\n    // Return the new array\n    Return ans\nEnd Function"
            },
            {
                "tag": "p",
                "content": "This pseudo code uses a simple operation + to represent the concatenation process, assuming the programming environment supports such an operation for arrays. The actual implementation might use a different method or function for concatenation, such as concat() in JavaScript, as shown in the provided solution."
            },
            {
                "tag": "p",
                "content": "The provided solution in JavaScript uses the .concat() method, which joins two or more arrays by returning a new array. In this case, nums.concat(nums) creates a new array by concatenating nums with itself, effectively doubling the array while preserving the order of elements."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst getConcatenation = (nums) => nums.concat(nums);"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "py",
                "code": "\nclass Solution(object):\n    def getConcatenation(self, nums):\n        return nums + nums"
            }
        ]
    },
    {
        "name": "Convert The Temperature",
        "site": "LeetCode",
        "_id": "LeetCode-Convert-The-Temperature",
        "href": "/solution/LeetCode-Convert-The-Temperature",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you'll need to perform two straightforward calculations to convert a temperature from Celsius to Kelvin and Fahrenheit. The given formulas are:"
            },
            {
                "tag": "h5",
                "content": "Kelvin = Celsius + 273.15"
            },
            {
                "tag": "h5",
                "content": "Fahrenheit = Celsius * 1.80 + 32.00"
            },
            {
                "tag": "p",
                "content": "Using these formulas, you can easily write a function that takes celsius as its input and returns an array containing the converted temperatures in Kelvin and Fahrenheit."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction convertTemperature(celsius)\n    // Initialize an empty array 'ans'\n    Initialize ans = []\n\n    // Convert Celsius to Kelvin and add to 'ans'\n    kelvin = celsius + 273.15\n    Add kelvin to ans\n\n    // Convert Celsius to Fahrenheit and add to 'ans'\n    fahrenheit = celsius * 1.80 + 32.00\n    Add fahrenheit to ans\n\n    // Return the 'ans' array\n    Return ans\nEnd Function"
            },
            {
                "tag": "h2",
                "content": "Explanation"
            },
            {
                "tag": "h5",
                "content": "Kelvin Conversion:"
            },
            {
                "tag": "p",
                "content": "You add 273.15 to the Celsius value to convert it to Kelvin and store this value in the first element of the answer array."
            },
            {
                "tag": "h5",
                "content": "Fahrenheit Conversion:"
            },
            {
                "tag": "p",
                "content": "You multiply the Celsius value by 1.80 and add 32.00 to convert it to Fahrenheit, then store this value as the second element of the answer array."
            },
            {
                "tag": "p",
                "content": "Finally, you return the array containing both converted temperatures."
            },
            {
                "tag": "p",
                "content": "This approach ensures the conversion is accurate to two decimal places as specified, assuming the arithmetic operations in the programming environment adhere to the typical rules of floating-point arithmetic."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst convertTemperature = (celsius) => [celsius+273.15, celsius*9/5+32];"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "py",
                "code": "\nclass Solution(object):\n    def convertTemperature(self, celsius):\n        return [celsius+273.15, celsius*9/5+32]"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a given temperature in Celsius to both Kelvin and Fahrenheit and return the results as an array.\n\n# Explanation\n1. **Input:** A non-negative floating point number in Celsius.\n2. **Output:** An array with two floating point numbers: the temperature converted to Kelvin and the temperature converted to Fahrenheit.\n3. **Formulas:**\n   - Kelvin = Celsius + 273.15\n   - Fahrenheit = Celsius * 1.80 + 32.00\n4. **Approach:**\n   - Read the temperature in Celsius.\n   - Convert the temperature to Kelvin using the provided formula.\n   - Convert the temperature to Fahrenheit using the provided formula.\n   - Store both converted temperatures in an array and return the array.\n\n# Pseudocode\n```\n# Define the function to convert temperature\nFUNCTION convertTemperature(celsius)\n    # Convert Celsius to Kelvin\n    kelvin = celsius + 273.15\n    \n    # Convert Celsius to Fahrenheit\n    fahrenheit = celsius * 1.80 + 32.00\n    \n    # Return the result as an array [kelvin, fahrenheit]\n    RETURN [kelvin, fahrenheit]\n```\nThis pseudocode outlines the step-by-step approach to solving the problem by using the given conversion formulas and ensuring the output meets the required format."
    },
    {
        "name": "Count Complete Tree Nodes",
        "site": "LeetCode",
        "_id": "LeetCode-Count-Complete-Tree-Nodes",
        "href": "/solution/LeetCode-Count-Complete-Tree-Nodes",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge efficiently, especially with the constraint to run in less than O(n) time complexity, you need to leverage the properties of a complete binary tree. The straightforward depth-first search (DFS) solution provided in the example counts all nodes one by one, which leads to O(n) time complexity. However, for a complete binary tree, you can do better by checking the depth of the leftmost and rightmost paths."
            },
            {
                "tag": "h2",
                "content": "Properties of a Complete Binary Tree"
            },
            {
                "tag": "ul",
                "content": [
                    "All levels are fully filled except possibly the last one.",
                    "All nodes in the last level are as far left as possible."
                ]
            },
            {
                "tag": "h2",
                "content": "These properties allow us to use the following approach:"
            },
            {
                "tag": "ol",
                "content": [
                    "Calculate the depth of the leftmost path (let's call it leftDepth).",
                    "Calculate the depth of the rightmost path (let's call it rightDepth).",
                    "If leftDepth equals rightDepth, it means the tree is a perfect binary tree, and the total number of nodes can be found by the formula 2^depth - 1, where depth is the depth of the tree.",
                    "If leftDepth does not equal rightDepth, the tree is not perfect, and you need to recursively apply the same procedure to the left and right subtrees and add 1 for the root node."
                ]
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction countNodes(root)\n    If root is NULL\n        Return 0\n\n    Initialize leftDepth = 0\n    Node temp = root\n    While temp is not NULL\n        Increment leftDepth\n        Move temp to temp's left child\n\n    Initialize rightDepth = 0\n    temp = root\n    While temp is not NULL\n        Increment rightDepth\n        Move temp to temp's right child\n\n    If leftDepth equals rightDepth\n        Return 2^leftDepth - 1\n\n    Else\n        Return 1 + countNodes(root.left) + countNodes(root.right)\nEnd Function"
            },
            {
                "tag": "h2",
                "content": "Explanation"
            },
            {
                "tag": "h5",
                "content": "Base Case:"
            },
            {
                "tag": "p",
                "content": "If the root is NULL, return 0."
            },
            {
                "tag": "h5",
                "content": "Perfect Binary Tree Check:"
            },
            {
                "tag": "p",
                "content": "Calculate the depth of the leftmost and rightmost paths from the root. If they are equal, the tree is perfect, and you can directly return the total node count using the formula 2^depth - 1."
            },
            {
                "tag": "h5",
                "content": "Recursive Case:"
            },
            {
                "tag": "p",
                "content": "If the tree is not perfect, recursively count the nodes in the left and right subtrees and add 1 for the root node."
            },
            {
                "tag": "p",
                "content": "This approach ensures that the algorithm runs faster than O(n) in cases where the tree leverages the properties of a complete binary tree, especially when the tree is nearly perfect, thus reducing the number of recursive calls significantly."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nvar countNodes = function(root) {\n    let count = 0;\n\n    const dfs = (n) => {\n        if(!n) return;\n        dfs(n.left);\n        dfs(n.right);\n        count++;\n    }\n    dfs(root);\n      \n    return count;\n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to design an algorithm that counts the nodes in a complete binary tree in less than O(n) time complexity. The provided JavaScript solution uses Depth-First Search (DFS), which operates in O(n) time complexity. However, to meet the requirement of less than O(n) complexity, a more efficient approach is needed.\n\nA complete binary tree has a special property where every level except possibly the last is completely filled, and all nodes in the last level are as far left as possible. This can be exploited to count nodes more efficiently by leveraging the height of the tree and the properties of complete binary trees.\n\n# Explanation\n\n1. **Calculate the height of the tree**: The height is determined by traversing the left-most path from the root.\n2. **Check if the tree is perfect**: If the right and left sub-trees have the same height, the tree is perfect and hence all nodes can be counted using the formula \\(2^{\\text{height} + 1} - 1\\).\n3. **Recursively count nodes in subtrees**: If the tree is not perfect, recursively count nodes in the left and right sub-trees, ensuring that the subtree with the same height is perfect and the other is a recursively smaller complete binary tree.\n\n# Pseudocode\n\n```python\nfunction countNodes(root):\n    # Helper function to calculate the height of the tree\n    function height(node):\n        if node is None:\n            return -1  # height of empty tree is -1\n        return 1 + height(node.left)\n    \n    if root is None:\n        return 0  # empty tree has 0 nodes\n\n    left_height = height(root.left)\n    right_height = height(root.right)\n    \n    # If the heights are equal, left subtree is perfect\n    if left_height == right_height:\n        return (2 ** (left_height + 1)) - 1  # Perfect tree formula\n    \n    # If the heights are not equal, recursively count nodes\n    return 1 + countNodes(root.left) + countNodes(root.right)\n```\n\nThis approach ensures that the counting leverages the structure of the tree to achieve a time complexity closer to O(log n * log n) in the average case, which is significantly more efficient than O(n)."
    },
    {
        "name": "Course Schedule",
        "site": "LeetCode",
        "_id": "LeetCode-Course-Schedule",
        "href": "/solution/LeetCode-Course-Schedule",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "The provided solution does not directly address the stated problem of counting nodes in a complete binary tree with optimized time complexity. Instead, it seems to be focused on detecting cycles in a graph, which is unrelated to the original task."
            },
            {
                "tag": "p",
                "content": "To solve the original problem of counting the number of nodes in a complete binary tree in less than O(n) time complexity, you can leverage the properties of a complete binary tree. Here's how to approach it:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Calculate Tree Height"
            },
            {
                "tag": "p",
                "content": "Compute the height of the leftmost path (left height) and the rightmost path (right height) from the root. In a complete binary tree, if these heights are equal, it means the tree is a perfect binary tree and you can directly calculate the number of nodes using the formula 2^height - 1."
            },
            {
                "tag": "h2",
                "content": "Step 2: Recursive Split"
            },
            {
                "tag": "p",
                "content": "If the heights are not equal, recursively apply the same process to the left and right subtrees. The idea is that at least one of the subtrees will be a perfect binary tree, allowing you to avoid traversing all nodes."
            },
            {
                "tag": "h2",
                "content": "Step 3: Combine Counts"
            },
            {
                "tag": "p",
                "content": "Add the counts from the left and right subtrees and include the root node to get the total count for the subtree."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction countNodes(root)\n    If root is null\n        Return 0\n\n    Initialize leftHeight = 0, rightHeight = 0\n    Initialize leftNode = root, rightNode = root\n\n    // Calculate the height of the leftmost and rightmost paths\n    While leftNode is not null\n        Increment leftHeight\n        leftNode = leftNode.left\n\n    While rightNode is not null\n        Increment rightHeight\n        rightNode = rightNode.right\n\n    // If the heights are equal, it's a perfect binary tree\n    If leftHeight == rightHeight\n        Return 2^leftHeight - 1\n\n    // If not, recursively count nodes in left and right subtrees\n    Return 1 + countNodes(root.left) + countNodes(root.right)\nEnd Function"
            },
            {
                "tag": "h2",
                "content": "Explanation"
            },
            {
                "tag": "h5",
                "content": "Perfect Binary Tree Check:"
            },
            {
                "tag": "p",
                "content": "If the left and right heights are equal, the tree is perfect, and you can calculate the number of nodes directly."
            },
            {
                "tag": "h5",
                "content": "Recursive Count:"
            },
            {
                "tag": "p",
                "content": "If the tree is not perfect, recursively count the nodes in the left and right subtrees and add them together, along with the root node."
            },
            {
                "tag": "p",
                "content": "This approach significantly reduces the time complexity in many cases because it avoids traversing every node in the tree, especially when dealing with perfect binary tree sections."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\n// create the adjacency list\nconst buildAdjacencyList = (totalNodes, graph) =>{\n    // makes >>> obj = {key: [], ...}\n    const adjacencyList = Array.from({length: totalNodes}, () => []);\n\n    // Loop through the graph grabbing the node in the adjacent node\n    for(let [node, adjacentNode] of graph){\n        // push the node and it's adjacent node into the adjacency list\n        adjacencyList[node].push(adjacentNode);\n    };\n\n    // return adjacency list\n    return adjacencyList;\n};\n\n// check for a cycle\nconst hasCycle = (node, adjacencyList, visited, departedCount) =>{\n    // Mark the nude as visited\n    visited[node] = true;\n\n    // loop through the node adjacent nodes\n    for(const adjacent of adjacencyList[node]){\n        if(!visited[adjacent]){ // if not visited\n            visited[adjacent] = true; // mark as visited\n            // if has cycle return true\n            if(hasCycle(adjacent, adjacencyList, visited, departedCount)) return true;\n        }else{\n            // Else if departed count equals zero return true\n            if(departedCount[adjacent] === 0) return true;\n        }\n    }\n\n    // if you get here we're departing and we can return false as there is no cycle\n    departedCount[node]++;\n    return false;\n};\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nconst canFinish = (numCourses, prerequisites) =>{\n    // adjacencyList = {node: [<adjacentNode>, ...], ...}\n    const adjacencyList = buildAdjacencyList(numCourses, prerequisites);\n    const visited = {};\n    // departedCount = {node: 0, ...}\n    const departedCount = Array.from({length: numCourses}, () => 0);\n\n    // loop through nodes in adjacency list\n    for(let node in adjacencyList){\n        if(!visited[node]){ // if not visited and has cycle return false\n            if(hasCycle(node, adjacencyList, visited, departedCount)) return false; \n        };     \n    }; \n\n    return true;      \n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if it is possible to take all given courses without having any cyclic dependencies among them. This problem can be mapped to detecting a cycle in a directed graph, where each course is a node and each prerequisite is a directed edge.\n\n# Explanation\nWe can use Depth-First Search (DFS) to detect cycles in the graph. Here's a step-by-step explanation:\n\n1. **Build the Adjacency List**: Create an adjacency list to represent the graph. Each course is a node, and each requisite pair `[ai, bi]` indicates a directed edge from `bi` to `ai`.\n   \n2. **Detect Cycles with DFS**:\n    - Use a DFS-based approach to traverse the graph.\n    - Maintain a `visited` array where:\n        - `visited[node] == 0` indicates the node hasn't been visited.\n        - `visited[node] == 1` indicates the node is in the current DFS path (and hence a cycle if revisited).\n        - `visited[node] == 2` indicates the node has been fully processed and does not form a cycle.\n    - During the DFS traversal, if you encounter a node that is already in the current DFS path (`visited[node] == 1`), a cycle is detected, making it impossible to complete all courses.\n\n# Pseudocode\n```plaintext\n# Function to build the adjacency list\nfunction buildAdjacencyList(numCourses, prerequisites):\n    adjacencyList = [ ]  # initialize with empty lists for each course\n    for course in range(numCourses):\n        adjacencyList.append([])\n    \n    for (course, prerequisite) in prerequisites:\n        adjacencyList[prerequisite].append(course)\n    \n    return adjacencyList\n\n# Function for DFS to detect cycles\nfunction hasCycle(node, adjacencyList, visited):\n    if visited[node] == 1:  # node is in the current path, cycle detected\n        return true\n    if visited[node] == 2:  # node has been fully processed, no cycle from this node\n        return false\n    \n    # Mark the node as visiting\n    visited[node] = 1\n    \n    # Visit all the adjacent nodes\n    for adjacent in adjacencyList[node]:\n        if hasCycle(adjacent, adjacencyList, visited):\n            return true\n    \n    # Mark the node as visited\n    visited[node] = 2\n    return false\n\n# Main function to check if all courses can be finished\nfunction canFinish(numCourses, prerequisites):\n    # Step 1: Build the adjacency list\n    adjacencyList = buildAdjacencyList(numCourses, prerequisites)\n    \n    # Step 2: Initialize visited array\n    visited = [0] * numCourses\n    \n    # Step 3: Check for cycles in the graph\n    for course in range(numCourses):\n        if visited[course] == 0:  # not visited yet\n            if hasCycle(course, adjacencyList, visited):\n                return false  # cycle detected\n    \n    return true  # no cycle detected, all courses can be finished\n```\n\nBy following this methodology and pseudocode, we can systematically determine whether all courses can be completed given their prerequisites."
    },
    {
        "name": "Course Schedule II",
        "site": "LeetCode",
        "_id": "LeetCode-Course-Schedule-II",
        "href": "/solution/LeetCode-Course-Schedule-II",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves finding a possible order to take all courses given the prerequisites for each course. This problem can be solved using the concept of Topological Sorting in a Directed Graph, where courses are represented as nodes, and prerequisites are represented as directed edges from one node to another. Here's a step-by-step guide and pseudo code for solving this problem:"
            },
            {
                "tag": "h2",
                "content": "Step 1: Graph Representation"
            },
            {
                "tag": "p",
                "content": "Create an adjacency list to represent the directed graph, where the key is a course, and the value is a list of courses that depend on this course (i.e., the courses that can be taken after completing the key course). Create an array to store the in-degree of each node (course). In-degree is the number of incoming edges to a node."
            },
            {
                "tag": "h2",
                "content": "Step 2: Populate Graph and In-Degree Array"
            },
            {
                "tag": "p",
                "content": "Iterate through the prerequisites array. For each pair [a, b] in prerequisites, add a to the adjacency list of b, and increment the in-degree of a by 1."
            },
            {
                "tag": "h2",
                "content": "Step 3: Find Courses with No Prerequisites"
            },
            {
                "tag": "p",
                "content": "Initialize a queue and an array to store the course order. Enqueue all courses with an in-degree of 0 (i.e., courses with no prerequisites)."
            },
            {
                "tag": "h2",
                "content": "Step 4: Process the Queue"
            },
            {
                "tag": "h5",
                "content": "While the queue is not empty:"
            },
            {
                "tag": "ul",
                "content": [
                    "Dequeue a course and add it to the course order array.",
                    "Iterate over its adjacent courses (i.e., courses that can be taken after completing the dequeued course). For each adjacent course, reduce its in-degree by 1. If the in-degree of an adjacent course becomes 0, enqueue it."
                ]
            },
            {
                "tag": "h2",
                "content": "Step 5: Check if All Courses are Processed"
            },
            {
                "tag": "p",
                "content": "After processing the queue, if the course order array contains all the courses (i.e., its length equals numCourses), return the course order array. If not all courses are processed, return an empty array, indicating that it's impossible to complete all courses due to cyclic dependencies or other issues."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code"
            },
            {
                "tag": "code",
                "content": "\nFunction findOrder(numCourses, prerequisites)\n    Initialize adjacency list and in-degree array\n    For each pair [course, prerequisite] in prerequisites\n        Add course to adjacency list of prerequisite\n        Increment in-degree of course\n\n    Initialize queue and course order array\n    For each course\n        If in-degree of course is 0\n            Enqueue course\n\n    While queue is not empty\n        Dequeue a course\n        Add it to course order array\n        For each adjacent course of dequeued course\n            Decrement in-degree of adjacent course\n            If in-degree of adjacent course is 0\n                Enqueue adjacent course\n\n    If length of course order array equals numCourses\n        Return course order array\n    Else\n        Return empty array\nEnd Function"
            },
            {
                "tag": "p",
                "content": "This pseudo code outlines the steps to find the order of courses to take, ensuring that prerequisites are met. The algorithm uses a topological sorting approach to process courses in a valid order, respecting all prerequisites."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst findOrder = (numC, prerequ, adj=Array.from({length:numC},()=>[]), idg=Array.from({length:numC},()=>0),q=[],ans=[]) =>{\n    console.log(adj);\n    console.log(idg);\n\n    for(const [c,pre] of prerequ){\n       adj[pre].push(c);\n       idg[c]++;\n    }\n    for(let i=0; i<idg.length; i++){\n        if(idg[i] === 0) q.push(i);\n    }\n    while(q.length){\n        const n = q.shift();\n        ans.push(n);\n        for(const v of adj[n]){\n            idg[v]--;\n            if(idg[v] === 0) q.push(v);\n        }\n    }\n    if(ans.length === numC) return ans;\n    return [];\n};"
            }
        ]
    },
    {
        "name": "Course Schedule III",
        "site": "LeetCode",
        "_id": "LeetCode-Course-Schedule-III",
        "href": "/solution/LeetCode-Course-Schedule-III",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you can use a greedy algorithm approach combined with the use of a max heap (priority queue). The goal is to maximize the number of courses one can take given the constraints of course duration and latest finish day. Here's how the solution works and the corresponding pseudo code:"
            },
            {
                "tag": "h2",
                "content": "Solution Explanation:"
            },
            {
                "tag": "h5",
                "content": "1. Sort Courses:"
            },
            {
                "tag": "p",
                "content": "First, the courses are sorted based on their lastDay. This is done so that courses with earlier end dates are considered first, aligning with the strategy of minimizing the risk of exceeding course deadlines."
            },
            {
                "tag": "h5",
                "content": "2. Use Max Heap (Priority Queue):"
            },
            {
                "tag": "p",
                "content": "A max heap is used to keep track of the courses taken. In this context, the heap stores the durations of the courses. The max heap is helpful because it allows easy access to the course with the longest duration taken so far, which is the first candidate to be dropped if necessary."
            },
            {
                "tag": "h5",
                "content": "3. Iterate and Decide: "
            },
            {
                "tag": "p",
                "content": "Iterate through each course. For each course, there are two main decisions:"
            },
            {
                "tag": "ul",
                "content": [
                    "If the course can be taken within its deadline considering the total duration of courses taken so far (maxTime), add it to the heap and update maxTime.",
                    "If the course cannot be taken by its deadline, check if there's a course that has been taken with a longer duration than the current one (the top of the max heap). If so, replace that course with the current one by removing the longest course from the heap and adding the current course. This is done because replacing a longer course with a shorter one may allow for more courses to be taken."
                ]
            },
            {
                "tag": "h5",
                "content": "4. Return Result: "
            },
            {
                "tag": "p",
                "content": "The size of the heap at the end of the iteration represents the maximum number of courses that can be taken, as it contains all the courses that have been successfully scheduled."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nfunction scheduleCourse(courses):\n    # Sort courses by their end time\n    sort courses by lastDay\n\n    # Initialize a max heap and a variable for tracking total time\n    maxHeap = new MaxHeap()\n    maxTime = 0\n\n    # Iterate through each course\n    for each course in courses:\n        time, endTime = course\n\n        # If course can be taken within its deadline\n        if time + maxTime <= endTime:\n            add time to maxHeap\n            maxTime += time\n        # If not within deadline, but a longer course exists in the heap\n        else if maxHeap is not empty and maxHeap.top() > time:\n            maxTime += time - maxHeap.pop()\n            add time to maxHeap\n\n    # Return the number of courses in the heap\n    return size of maxHeap"
            },
            {
                "tag": "p",
                "content": "This approach ensures that you always prioritize taking courses that have the earliest deadlines, while also being flexible enough to replace longer-duration courses with shorter ones if it allows for a more optimal schedule."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst scheduleCourse = (courses) =>{\n\n    courses.sort((a,b)=>a[1]-b[1])\n    const maxHeap = new MaxPriorityQueue(); \n    let maxTime = 0;\n\n    for(const [time, endTime] of courses){\n        if(time + maxTime <= endTime){\n            maxHeap.enqueue(time);\n            maxTime += time;\n        }else if(maxHeap.front() && maxHeap.front().element > time){\n            maxTime += time - maxHeap.dequeue().element\n            maxHeap.enqueue(time);\n        }\n    }\n\n    return maxHeap.size(); \n};"
            }
        ]
    },
    {
        "name": "Deepest Leaves Sum",
        "site": "LeetCode",
        "_id": "LeetCode-Deepest-Leaves-Sum",
        "href": "/solution/LeetCode-Deepest-Leaves-Sum",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this challenge, you need to find the sum of the values of the deepest leaves in a binary tree. This involves two main tasks: identifying the deepest leaves and calculating their sum. A depth-first search (DFS) can be used to traverse the tree, track the depth of each leaf, and sum the values of the deepest leaves."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Initialize Depth and Sum Tracking:"
            },
            {
                "tag": "p",
                "content": "Create a structure or object to keep track of the current maximum depth found and the sum of the values of the leaves at that depth."
            },
            {
                "tag": "h5",
                "content": "2. Depth-First Search (DFS) Function:"
            },
            {
                "tag": "p",
                "content": "Implement a DFS function that traverses the tree. This function should take the current node and its depth as parameters."
            },
            {
                "tag": "h5",
                "content": "3. Traverse the Tree:"
            },
            {
                "tag": "p",
                "content": "If the current node is null, return immediately (base case for recursion). Increment the depth as you go deeper into the tree. If the current node is a leaf (no left or right child), compare its depth with the maximum depth found so far:"
            },
            {
                "tag": "ul",
                "content": [
                    "If the depth is greater, update the maximum depth and reset the sum to the current node's value.",
                    "If the depth is equal to the maximum depth, add the current node's value to the sum."
                ]
            },
            {
                "tag": "p",
                "content": "Recursively call the DFS function for the left and right children of the current node."
            },
            {
                "tag": "h5",
                "content": "4. Start DFS:"
            },
            {
                "tag": "p",
                "content": "Begin the DFS from the root node, starting at depth 0."
            },
            {
                "tag": "h5",
                "content": "5. Return the Sum:"
            },
            {
                "tag": "p",
                "content": "After completing the DFS traversal, return the sum of the deepest leaves."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION deepestLeavesSum(root)\n    deepestDepth = 0\n    sumOfDeepestLeaves = 0\n\n    FUNCTION DFS(node, depth)\n        IF node IS NULL\n            RETURN\n        END IF\n\n        IF node IS A LEAF\n            IF depth > deepestDepth\n                deepestDepth = depth\n                sumOfDeepestLeaves = node.value\n            ELSE IF depth == deepestDepth\n                sumOfDeepestLeaves += node.value\n            END IF\n        END IF\n\n        DFS(node.left, depth + 1)\n        DFS(node.right, depth + 1)\n    END FUNCTION\n\n    DFS(root, 0)\n    RETURN sumOfDeepestLeaves\nEND FUNCTION"
            },
            {
                "tag": "p",
                "content": "This pseudo code outlines the steps to find the sum of the values of the deepest leaves in a binary tree using a depth-first search (DFS) approach. This approach ensures that you only keep track of the leaves at the maximum depth and sum their values, fulfilling the challenge's requirements."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst deepestLeavesSum = (root) =>{\n    \n    deepthObj = {\n        deepest: 0,\n        nums: []\n    }\n    \n    const dfs = (n, depth)=>{\n        if(!root) return;\n        depth++;\n        if(n.left !== null) dfs(n.left, depth);\n        if(n.right !== null) dfs(n.right, depth);\n        if(deepthObj.deepest < depth){\n            deepthObj.deepest = depth\n            deepthObj.nums = [n.val]\n        }else if(deepthObj.deepest === depth){\n            deepthObj.nums.push(n.val)\n        }\n    }\n   \n    dfs(root, 0);\n    \n    return deepthObj.nums.reduce((a, b) => a + b, 0);\n    \n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to calculate the sum of the values of the deepest leaves in a binary tree. Here's how to approach it:\n\n# Explanation\n\n1. **Traversal Method**: Using Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse through the binary tree.\n2. **Tracking Depth**: Keep track of the maximum depth encountered and the sum of nodes at that depth.\n3. **Updating Values**: If a new depth is found deeper than the current maximum, update the sum. If a node at the current maximum depth is found, add its value to the sum.\n4. **Return the Sum**: Once the traversal is complete, return the sum of the deepest leaves.\n\n# Pseudocode\n\nHere\u2019s how to structure the solution in pseudocode:\n\n1. Initialize variables to track the maximum depth and the sum of the deepest leaves.\n2. Define a helper function `dfs` to perform the DFS.\n3. Within the `dfs` function:\n   - Update the current depth.\n   - Recursively call `dfs` for the left and right children.\n   - Check if the current node\u2019s depth is greater than the maximum depth recorded:\n     - If it is, update the maximum depth and reset the sum.\n     - If it matches the maximum depth, add the current node\u2019s value to the sum.\n4. Start the DFS from the root node.\n5. Return the sum after the DFS completes.\n\nHere's the pseudocode:\n\n# Pseudocode\n\n```\nfunction deepestLeavesSum(root):\n    # Initialize tracking variables\n    max_depth = 0\n    sum_at_max_depth = 0\n\n    # Helper function for DFS traversal\n    function dfs(node, depth):\n        if node is null:\n            return\n        # Update depth\n        depth += 1\n        # Check left and right children\n        dfs(node.left, depth)\n        dfs(node.right, depth)\n        # Check if new maximum depth is found\n        if depth > max_depth:\n            max_depth = depth\n            sum_at_max_depth = node.val\n        elif depth == max_depth:\n            sum_at_max_depth += node.val\n\n    # Start DFS from the root\n    dfs(root, 0)\n    \n    return sum_at_max_depth\n```\n\nBy following this methodology, we can ensure that we correctly sum up the values of the deepest leaves of the binary tree."
    },
    {
        "name": "Defanging an IP Address",
        "site": "LeetCode",
        "_id": "LeetCode-Defanging-an-IP-Address",
        "href": "/solution/LeetCode-Defanging-an-IP-Address",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, the goal is to transform a given valid IPv4 address into a 'defanged' version, where every period (.) is replaced with '[.]'. This can be easily achieved by splitting the input string at each period and then joining the resulting array of strings with the defanged period '[.]'."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Split the IP Address:"
            },
            {
                "tag": "p",
                "content": "Split the input IP address string at each period (.), which will create an array of strings, each representing an octet of the IP address."
            },
            {
                "tag": "h5",
                "content": "2. Join with Defanged Period:"
            },
            {
                "tag": "p",
                "content": "Join the array of octet strings using the defanged period '[.]' as the separator."
            },
            {
                "tag": "h5",
                "content": "3. Return the Result:"
            },
            {
                "tag": "p",
                "content": "The result of the join operation is the defanged IP address."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION defangIPaddr(address)\n    // Split the address at each period and join with \"[.]\"\n    RETURN address.SPLIT('.').JOIN(\"[.]\")\nEND FUNCTION"
            },
            {
                "tag": "h2",
                "content": "Explanation:"
            },
            {
                "tag": "h5",
                "content": "Split:"
            },
            {
                "tag": "p",
                "content": "The SPLIT('.') method divides the IP address into its constituent octets by using the period as a delimiter, resulting in an array of strings."
            },
            {
                "tag": "h5",
                "content": "Join:"
            },
            {
                "tag": "p",
                "content": "The JOIN('[.]') method then assembles these strings back into a single string, inserting '[.]' between each octet, effectively replacing each period in the original IP address."
            },
            {
                "tag": "p",
                "content": "This approach provides a simple and efficient way to create a defanged version of an IPv4 address."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst defangIPaddr = (address) => address.split('.').join(\"[.]\")"
            }
        ]
    },
    {
        "name": "Design Parking System",
        "site": "LeetCode",
        "_id": "LeetCode-Design-Parking-System",
        "href": "/solution/LeetCode-Design-Parking-System",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, we need to design a ParkingSystem class that manages parking spaces of different sizes. The class should have two main components:"
            },
            {
                "tag": "h5",
                "content": "1. Constructor (ParkingSystem):"
            },
            {
                "tag": "p",
                "content": "Initializes the parking system with a fixed number of slots for each size: big, medium, and small."
            },
            {
                "tag": "h5",
                "content": "2. Method (addCar):"
            },
            {
                "tag": "p",
                "content": "Attempts to park a car of a given type into a slot of its corresponding size. If successful (a slot is available), it decrements the available slot count for that size and returns true. If no slot is available, it returns false."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code for the Solution:"
            },
            {
                "tag": "code",
                "content": "\nCLASS ParkingSystem\n    FUNCTION Constructor(big, medium, small)\n        // Initialize the available slots for each car type in a map or object\n        this.availableParking = {\n            '1': big,    // Big car slots\n            '2': medium, // Medium car slots\n            '3': small   // Small car slots\n        }\n    END FUNCTION\n\n    FUNCTION addCar(carType)\n        // Check if there's an available slot for the given car type\n        IF this.availableParking[carType] > 0 THEN\n            // Decrement the slot count for that car type and return true\n            this.availableParking[carType] = this.availableParking[carType] - 1\n            RETURN true\n        ELSE\n            // Return false if no slot is available\n            RETURN false\n        END IF\n    END FUNCTION\nEND CLASS"
            },
            {
                "tag": "h2",
                "content": "Explanation:"
            },
            {
                "tag": "h5",
                "content": "Initialization: "
            },
            {
                "tag": "p",
                "content": "In the Constructor, the ParkingSystem is initialized with the given number of slots for each car type. This information is stored in a key-value pair structure (this.availableParking), where keys are car types (1, 2, and 3 for big, medium, and small, respectively) and values are the counts of available slots."
            },
            {
                "tag": "h5",
                "content": "Adding a Car: "
            },
            {
                "tag": "p",
                "content": "The addCar method checks if there's at least one slot available for the specified car type. If so, it decrements the count of available slots for that car type in this.availableParking and returns true to indicate the car was successfully parked. If there are no available slots for the car type, it returns false."
            },
            {
                "tag": "p",
                "content": "This design allows the ParkingSystem to efficiently manage parking slots and handle parking requests, adhering to the constraints provided in the challenge."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\n/* ---------------------- *\n *  Brute force solution: *\n * ---------------------- */\nvar ParkingSystem = function(big, medium, small){\n    this.availableParking = {'1':big,'2':medium,'3':small};\n};\n\nParkingSystem.prototype.addCar = function(carType){\n    if(this.availableParking[carType] !== 0){\n        this.availableParking[carType]--;\n        return true;\n    }else{\n        return false;\n    }\n};\n\n/* ------------------- *\n * Optimized solution: *\n * ------------------- */\nvar ParkingSystem = function(big, medium, small){\n    this.availableParking = {'1':big,'2':medium,'3':small};\n};\n\nParkingSystem.prototype.addCar = function(carType){\n    return this.availableParking[carType]-- > 0;\n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to design a system that simulates a parking lot with different sizes of parking spaces. The main tasks involve initializing the number of parking spaces of each type and handling requests to park cars based on their types.\n\n### # Explanation\n1. **Initialization**: We will create a class `ParkingSystem` that initializes with a given number of slots for each size: big, medium, and small.\n2. **Adding Cars**: The class will have a method `addCar` that takes the car type as an input and checks if space is available. If space is available, it parks the car (by decrementing the count for that type) and returns `true`. If no space is available, it returns `false`.\n\n### # Pseudocode\n```python\n# Define the ParkingSystem class\nclass ParkingSystem:\n\n    # Initialize the object with parking slots for each type\n    def __init__(self, big, medium, small):\n        # Dictionary to store the remaining slots for each car type\n        self.slots = {\n            1: big,    # Big car slots\n            2: medium, # Medium car slots\n            3: small   # Small car slots\n        }\n\n    # Method to attempt to add a car of a specific type\n    def addCar(self, carType):\n        # Check if slots are available for the given car type\n        if self.slots[carType] > 0:\n            # If available, decrement the slot count and return True\n            self.slots[carType] -= 1\n            return True\n        else:\n            # If not available, return False\n            return False\n```\n\nThis pseudocode outlines the class structure and the logic for handling parking operations. Here, the `ParkingSystem` class uses a dictionary to track available slots for each car type, and the `addCar` method modifies this count based on availability."
    },
    {
        "name": "Edit Distance",
        "site": "LeetCode",
        "_id": "LeetCode-Edit-Distance",
        "href": "/solution/LeetCode-Edit-Distance",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves finding the minimum number of operations required to convert one string (word1) into another (word2). The allowed operations are inserting, deleting, or replacing a character. The problem is a classic example of dynamic programming, specifically the Edit Distance problem (also known as the Levenshtein distance problem)."
            },
            {
                "tag": "h2",
                "content": "Dynamic Programming Approach:"
            },
            {
                "tag": "h5",
                "content": "1. Initialization:"
            },
            {
                "tag": "p",
                "content": "Create a 2D array dp where dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2."
            },
            {
                "tag": "h5",
                "content": "2. Base Cases:"
            },
            {
                "tag": "p",
                "content": "If word1 is empty (i = 0), dp[0][j] is j because it takes j insertions to convert an empty string to the first j characters of word2. If word2 is empty (j = 0), dp[i][0] is i because it takes i deletions to convert the first i characters of word1 to an empty string."
            },
            {
                "tag": "h5",
                "content": "3. Filling the DP Table:"
            },
            {
                "tag": "p",
                "content": "For each pair of indices i and j, compute dp[i][j] as follows:"
            },
            {
                "tag": "p",
                "content": "If the characters word1[i - 1] and word2[j - 1] are the same, no operation is needed for the i-th and j-th characters, so dp[i][j] = dp[i-1][j-1]. If the characters are different, consider the minimum of the following three operations:"
            },
            {
                "tag": "ul",
                "content": [
                    "Inserting (dp[i][j-1] + 1)",
                    "Deleting (dp[i-1][j] + 1)",
                    "Replacing (dp[i-1][j-1] + 1)"
                ]
            },
            {
                "tag": "p",
                "content": "Take the minimum of these three values as dp[i][j]."
            },
            {
                "tag": "h5",
                "content": "4. Return the Result:"
            },
            {
                "tag": "p",
                "content": "The value at dp[word1.length][word2.length] gives the minimum number of operations required."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION minDistance(word1, word2)\n    INITIALIZE dp with dimensions [word1.length+1][word2.length+1]\n\n    // Base cases\n    FOR i FROM 0 TO word1.length\n        dp[i][0] = i\n    END FOR\n    FOR j FROM 0 TO word2.length\n        dp[0][j] = j\n    END FOR\n\n    // Fill dp table\n    FOR i FROM 1 TO word1.length\n        FOR j FROM 1 TO word2.length\n            IF word1[i-1] EQUALS word2[j-1]\n                dp[i][j] = dp[i-1][j-1]\n            ELSE\n                dp[i][j] = 1 + MIN(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])\n            END IF\n        END FOR\n    END FOR\n\n    RETURN dp[word1.length][word2.length]\nEND FUNCTION"
            },
            {
                "tag": "p",
                "content": "This approach efficiently computes the minimum number of operations by building up solutions from smaller subproblems, a hallmark of dynamic programming."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst minDistance = (word1, word2)=>{\n    const dp = Array(word1.length+1).fill(0).map(()=>Array(word2.length+1).fill(0));\n    for(let i = 0; i <= word1.length; i++){\n        dp[i][0] = i;\n    };\n    for(let j = 0; j <= word2.length; j++){\n        dp[0][j] = j;\n    };\n    for(let i = 1; i <= word1.length; i++){\n        for(let j = 1; j <= word2.length; j++){\n            if(word1[i-1] === word2[j-1]){\n                dp[i][j] = dp[i-1][j-1];\n            }else{\n                dp[i][j] = 1 + Math.min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]);\n            };\n        };\n    };\n    return dp[word1.length][word2.length];\n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the minimum number of operations required to convert one string into another. The allowed operations are insert, delete, or replace a character. The problem can be approached using dynamic programming.\n\n# Explanation\n\nThe idea is to use dynamic programming to solve the problem efficiently. We will create a 2D table where `dp[i][j]` represents the minimum number of operations required to convert the first `i` characters of `word1` to the first `j` characters of `word2`.\n\n1. **Initialization**:\n    - If either string is empty, the edit distance is equal to the length of the other string (because we would need to insert all characters).\n    - `dp[0][j] = j` where `0 <= j <= len(word2)` (converting empty string to `word2`).\n    - `dp[i][0] = i` where `0 <= i <= len(word1)` (converting `word1` to empty string).\n\n2. **Filling the DP table**:\n    - We iterate through both strings and fill the table based on the following conditions:\n        - If the current characters (`word1[i-1]` and `word2[j-1]`) match, the value is the same as `dp[i-1][j-1]`, because no new operation is needed.\n        - If they do not match, we take the minimum value obtained by inserting, deleting, or replacing a character:\n            - Insert: `dp[i][j-1] + 1`\n            - Delete: `dp[i-1][j] + 1`\n            - Replace: `dp[i-1][j-1] + 1`\n \n3. **Return the result**:\n    - The value `dp[len(word1)][len(word2)]` will have the answer to the minimum edit distance.\n\n# Pseudocode\n\n```\nfunction minDistance(word1, word2):\n    # Initialize the DP table\n    dp = 2D array of size (len(word1) + 1) x (len(word2) + 1)\n    \n    # Base cases: converting to/from an empty string\n    for i from 0 to len(word1):\n        dp[i][0] = i\n    for j from 0 to len(word2):\n        dp[0][j] = j\n    \n    # Fill the DP table\n    for i from 1 to len(word1):\n        for j from 1 to len(word2):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]  # Characters match, take diagonal value\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])  # Min of replace, insert, delete\n\n    # The result is in the bottom-right cell of the table\n    return dp[len(word1)][len(word2)]\n```\n\nThis pseudocode outlines the steps necessary to solve the edit distance problem using dynamic programming. It initializes a table, fills it based on conditions derived from the problem constraints, and finally extracts the result."
    },
    {
        "name": "Final Value of Variable After Performing Operations",
        "site": "LeetCode",
        "_id": "LeetCode-Final-Value-of-Variable-After-Performing-Operations",
        "href": "/solution/LeetCode-Final-Value-of-Variable-After-Performing-Operations",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "This coding challenge involves simulating the effect of a series of operations on a variable X. The operations can be of four types: ++X, X++, --X, and X--. The goal is to determine the final value of X after applying all the operations in the given array."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Initialize Variable X:"
            },
            {
                "tag": "p",
                "content": "Start with X set to 0."
            },
            {
                "tag": "h5",
                "content": "2. Iterate Through Operations:"
            },
            {
                "tag": "p",
                "content": "Go through each operation in the operations array."
            },
            {
                "tag": "h5",
                "content": "3. Determine Operation Type:"
            },
            {
                "tag": "ul",
                "content": [
                    "If the operation is ++X or X++, increment X by 1.",
                    " If the operation is --X or X--, decrement X by 1."
                ]
            },
            {
                "tag": "h5",
                "content": "4. Return Final Value:"
            },
            {
                "tag": "p",
                "content": "After all operations are performed, return the final value of X."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION finalValueAfterOperations(operations)\n    INITIALIZE X to 0\n\n    FOR EACH operation IN operations\n        IF operation EQUALS \"++X\" OR operation EQUALS \"X++\" THEN\n            INCREMENT X by 1\n        ELSE\n            DECREMENT X by 1\n        END IF\n    END FOR\n\n    RETURN X\nEND FUNCTION"
            },
            {
                "tag": "h2",
                "content": "Explanation:"
            },
            {
                "tag": "ul",
                "content": [
                    "The for loop iterates through each operation in the given array.",
                    " Inside the loop, a simple if-else conditional checks whether the current operation is an increment operation (++X or X++) or a decrement operation (--X or X--). The value of X is adjusted accordingly.",
                    " After all operations have been applied, the function returns the final value of X. This solution is straightforward and efficient, directly translating the problem statement into code logic."
                ]
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst finalValueAfterOperations = (operations) => {\n    let x = 0;\n    for(i in operations){\n        const o = operations[i]\n        if(o === \"++X\" || o === \"X++\"){\n            x++;\n        }else{\n            x--;\n        } \n    }\n    return x;\n};"
            }
        ]
    },
    {
        "name": "Find Center of Star Graph",
        "site": "LeetCode",
        "_id": "LeetCode-Find-Center-of-Star-Graph",
        "href": "/solution/LeetCode-Find-Center-of-Star-Graph",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, you need to identify the center of a star graph. A star graph has one central node that is connected to all other nodes. Given that the input is a set of edges in a 2D array, where each edge connects two nodes, the central node will be the one that appears in every edge."
            },
            {
                "tag": "p",
                "content": "Since the graph is a star graph, examining any two edges is sufficient to determine the center. The center node will be the common node in the first two edges."
            },
            {
                "tag": "h2",
                "content": "Steps to Solve:"
            },
            {
                "tag": "h5",
                "content": "1. Examine the First Two Edges:"
            },
            {
                "tag": "p",
                "content": "Look at the first two edges in the array."
            },
            {
                "tag": "h5",
                "content": "2. Identify the Common Node:"
            },
            {
                "tag": "p",
                "content": "The center node will be the one that appears in both edges. There are only three nodes involved in the first two edges, and two of them will be the same. That repeated node is the center."
            },
            {
                "tag": "h5",
                "content": "3. Return the Center Node:"
            },
            {
                "tag": "p",
                "content": "Once identified, return the center node."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION findCenter(edges)\n    // e[0] and e[1] are the first two edges in the edges array\n    IF edges[0][0] EQUALS edges[1][0] OR edges[0][0] EQUALS edges[1][1] THEN\n        RETURN edges[0][0]\n    ELSE\n        RETURN edges[0][1]\n    END IF\nEND FUNCTION"
            },
            {
                "tag": "h2",
                "content": "Explanation:"
            },
            {
                "tag": "ul",
                "content": [
                    "The function findCenter checks if the first node in the first edge (edges[0][0]) is also present in the second edge (edges[1]). It does this by comparing edges[0][0] with both nodes in the second edge (edges[1][0] and edges[1][1]).",
                    "If edges[0][0] is found in the second edge, it is the center node, and the function returns edges[0][0].",
                    "If edges[0][0] is not found in the second edge, then the second node in the first edge (edges[0][1]) must be the center, and the function returns edges[0][1]."
                ]
            },
            {
                "tag": "p",
                "content": "This approach efficiently identifies the center of a star graph by leveraging the graph's structural properties, requiring only a constant number of comparisons."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst findCenter = (e) => e[0][0] === e[1][0] || e[0][0] === e[1][1] ? e[0][0] : e[0][1];"
            }
        ]
    },
    {
        "name": "Find Median from Data Stream",
        "site": "LeetCode",
        "_id": "LeetCode-Find-Median-from-Data-Stream",
        "href": "/solution/LeetCode-Find-Median-from-Data-Stream",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this challenge, the key idea is to maintain two priority queues (or heaps): a max heap for the lower half of the numbers and a min heap for the upper half. This way, the max heap always contains the smaller half of the numbers, with its maximum value at the top, while the min heap contains the larger half of the numbers, with its minimum value at the top. By doing this, the median will always be among the top elements of these two heaps."
            },
            {
                "tag": "h2",
                "content": "Here's a step-by-step explanation of the solution, followed by the pseudo code:"
            },
            {
                "tag": "h5",
                "content": "1. Initialization:"
            },
            {
                "tag": "ul",
                "content": [
                    "Initialize two heaps - a max heap (maxHeap) for the lower half of the numbers and a min heap (minHeap) for the upper half."
                ]
            },
            {
                "tag": "h5",
                "content": "2. Adding a Number (addNum):"
            },
            {
                "tag": "ul",
                "content": [
                    "First, decide which heap to add the new number (num) to. If the maxHeap is empty or the new number is less than the maximum of the lower half (maxHeap's top), add it to the maxHeap. Otherwise, add it to the minHeap.",
                    "After adding the new number, check the size difference between the two heaps. The heaps should either have the same size or one heap should have one more element than the other. If the size difference exceeds 1, rebalance the heaps by moving the top element from the larger heap to the smaller heap."
                ]
            },
            {
                "tag": "h5",
                "content": "3. Finding the Median (findMedian):"
            },
            {
                "tag": "ul",
                "content": [
                    "If one heap has more elements than the other, the median is the top element of the heap with more elements.",
                    "If both heaps have the same number of elements, the median is the average of the tops of both heaps."
                ]
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nClass MedianFinder\n    Initialize:\n        maxHeap = new MaxHeap() // Lower half\n        minHeap = new MinHeap() // Upper half\n\n    Function addNum(num):\n        If maxHeap.isEmpty() OR num < maxHeap.peek():\n            maxHeap.add(num)\n        Else:\n            minHeap.add(num)\n        \n        // Rebalance heaps if necessary\n        If maxHeap.size() - minHeap.size() > 1:\n            minHeap.add(maxHeap.poll())\n        Else If minHeap.size() - maxHeap.size() > 1:\n            maxHeap.add(minHeap.poll())\n\n    Function findMedian():\n        If maxHeap.size() > minHeap.size():\n            Return maxHeap.peek()\n        Else If minHeap.size() > maxHeap.size():\n            Return minHeap.peek()\n        Else:\n            Return (maxHeap.peek() + minHeap.peek()) / 2"
            },
            {
                "tag": "h2",
                "content": "Optimization for Range-Based Data"
            },
            {
                "tag": "p",
                "content": "For the follow-up questions, if all integer numbers are in a specific range, you can optimize the solution by using an array or a hashmap to count the occurrences of each number. This would allow for a more efficient way to find the median without maintaining two heaps, especially when the range of numbers is small. For numbers mostly in a certain range with some outliers, a hybrid approach can be used where the array or hashmap is used for numbers within the range, and heaps or another data structure for numbers outside of the range."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst {\n    PriorityQueue,\n    MinPriorityQueue,\n    MaxPriorityQueue,\n} = require('@datastructures-js/priority-queue');\n\n\nvar MedianFinder = function() {\n\n    this.maxHeap = new MaxPriorityQueue();\n    this.minHeap = new MinPriorityQueue();\n    \n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nMedianFinder.prototype.addNum = function(num) {\n    if(this.maxHeap.size() === 0 || num < this.maxHeap.front().element){\n        this.maxHeap.enqueue(num);\n    }else{\n        this.minHeap.enqueue(num);\n    };\n\n    if(this.maxHeap.size() - this.minHeap.size() > 1){\n        this.minHeap.enqueue(this.maxHeap.dequeue().element);\n    }else if(this.minHeap.size() - this.maxHeap.size()> 1){\n        this.maxHeap.enqueue(this.minHeap.dequeue().element);\n    }\n   \n};\n\n/**\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function() {\n    if(this.maxHeap.size() > this.minHeap.size()){\n        return this.maxHeap.front().element;\n    }else if(this.minHeap.size() > this.maxHeap.size()){\n        return this.minHeap.front().element;\n    }else{\n        return (this.minHeap.front().element + this.maxHeap.front().element) / 2;\n    }\n};\n\n/** \n * Your MedianFinder object will be instantiated and called as such:\n * var obj = new MedianFinder()\n * obj.addNum(num)\n * var param_2 = obj.findMedian()\n */"
            }
        ]
    },
    {
        "name": "Find Mode in Binary Search Tree",
        "site": "LeetCode",
        "_id": "LeetCode-Find-Mode-in-Binary-Search-Tree",
        "href": "/solution/LeetCode-Find-Mode-in-Binary-Search-Tree",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "The provided solution finds the mode(s) in a Binary Search Tree (BST) using a depth-first search (DFS) traversal and a hashmap (or object in JavaScript) to keep track of the frequency of each value encountered in the tree. Here's a step-by-step explanation followed by pseudo code:"
            },
            {
                "tag": "h2",
                "content": "Explanation:"
            },
            {
                "tag": "h5",
                "content": "1. Define a hashmap (memo):"
            },
            {},
            {
                "tag": "p",
                "content": "This hashmap is used to store the frequency of each value encountered in the tree. The keys are the node values, and the values are their respective counts."
            },
            {
                "tag": "h5",
                "content": "2. Depth-First Search (DFS) function:"
            },
            {
                "tag": "p",
                "content": "The dfs function is defined to traverse the tree. It's a recursive function that visits every node in the tree, starting from the root."
            },
            {
                "tag": "h5",
                "content": "3. Recursive DFS traversal:"
            },
            {
                "tag": "p",
                "content": "For each node visited, the function recursively calls itself on the left and right children of the node (if they exist), ensuring that all nodes in the tree are visited."
            },
            {
                "tag": "h5",
                "content": "4. Update hashmap:"
            },
            {
                "tag": "p",
                "content": "After visiting a node's children, the function updates the hashmap with the current node's value. If the value is already in the hashmap, its count is incremented. Otherwise, it's added to the hashmap with a count of 1."
            },
            {
                "tag": "h5",
                "content": "5. Sorting and finding modes:"
            },
            {
                "tag": "p",
                "content": "After the DFS traversal is complete, the entries in the hashmap are sorted in descending order by their frequency. The highest frequency (or frequencies, in case of a tie) determines the mode(s) of the tree."
            },
            {
                "tag": "h5",
                "content": "6. Constructing the result:"
            },
            {
                "tag": "p",
                "content": "The function then iterates through the sorted array of frequencies. It adds the values with the highest frequency to the result array. The iteration stops as soon as a value with a lower frequency is encountered, as the array is sorted."
            },
            {
                "tag": "h5",
                "content": "7. Return result:"
            },
            {
                "tag": "p",
                "content": "Finally, the function returns the result array, which contains the mode(s) of the BST."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nfunction findMode(root):\n    Initialize a hashmap (memo) to store value frequencies\n    Define a DFS function (dfs) that takes a node (n) as its argument\n\n    DFS function (n):\n        if n is null, return\n        Call DFS on n.left (left child)\n        Call DFS on n.right (right child)\n        Update memo with n.val (increment if exists, set to 1 if not)\n\n    Call DFS with root node\n    Convert memo to an array of [value, frequency] pairs and sort it in descending order by frequency\n    Initialize an empty array (ans) for storing modes\n    Iterate through the sorted array:\n        if current frequency equals the highest frequency, add the value to ans\n        else, break the loop\n    Return ans"
            },
            {
                "tag": "h2",
                "content": "Note on Space Complexity:"
            },
            {
                "tag": "p",
                "content": "The follow-up question asks if it's possible to solve this without using any extra space. The provided solution does use extra space for the hashmap and the sorted array. An in-order traversal could be used to leverage the properties of the BST to find modes without extra space, but this would require a more complex approach to keep track of the current count, maximum count, and modes as you traverse."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nvar findMode = function(root) {\n  const memo = {}\n\n  const dfs = (n) =>{\n    if(!n) return;\n      \n    dfs(n.left);\n    dfs(n.right);\n    if(n.val in memo){\n      memo[n.val]++;\n    }else{\n      memo[n.val] = 1;\n    }\n    \n  }\n    dfs(root)\n  const arr = Object.entries(memo).sort((a,b)=> b[1] - a[1]);\n  let ans = [];\n  \n  for(let i=0; i<arr.length; i++){\n    if(arr[i][1] === arr[0][1]){\n      ans.push(arr[i][0])\n    }else{\n      break; \n    }\n  }\n  return ans;\n};"
            }
        ]
    },
    {
        "name": "Find the Index of the First Occurrence in a String",
        "site": "LeetCode",
        "_id": "LeetCode-Find-the-Index-of-the-First-Occurrence-in-a-String",
        "href": "/solution/LeetCode-Find-the-Index-of-the-First-Occurrence-in-a-String",
        "video": {
            "has_video": false,
            "scripts": [
                "Video Script Goes Here",
                "Video2 Script Goes Here"
            ]
        },
        "how_to": [
            {
                "tag": "p",
                "content": "To solve this coding challenge, the task is to find the first occurrence of a substring (needle) within another string (haystack). The solution provided uses a built-in JavaScript function indexOf, which directly solves the problem by returning the index of the first occurrence of the needle in the haystack. If the needle is not found, indexOf returns -1."
            },
            {
                "tag": "p",
                "content": "Let's break down the steps to solve this without relying on the built-in indexOf function, for a deeper understanding:"
            },
            {
                "tag": "h5",
                "content": "1. Check for Edge Cases:"
            },
            {
                "tag": "p",
                "content": "First, we need to handle some edge cases. If the needle is an empty string, we can consider the index of the first occurrence to be 0, since an empty string technically occurs at every index. If the haystack is empty, or if the needle is longer than the haystack, the needle cannot be found, so we return -1."
            },
            {
                "tag": "h5",
                "content": "2. Iterate Over the Haystack:"
            },
            {
                "tag": "p",
                "content": "Loop through the haystack string, up to the point where the remaining characters are at least as many as the length of the needle. This is because if there are fewer characters left in the haystack than the length of the needle, the needle cannot possibly fit."
            },
            {
                "tag": "h5",
                "content": "3. Match the Needle:"
            },
            {
                "tag": "p",
                "content": "For each character in the haystack that could potentially be the start of an occurrence of the needle, check if the substring of the haystack starting from that character, of the same length as the needle, matches the needle."
            },
            {
                "tag": "h5",
                "content": "4. Return the Index:"
            },
            {
                "tag": "p",
                "content": "If a match is found, return the current index. This is the first occurrence of the needle in the haystack."
            },
            {
                "tag": "h5",
                "content": "5. Return -1 if Not Found:"
            },
            {
                "tag": "p",
                "content": "If the loop completes and no match is found, return -1."
            },
            {
                "tag": "h2",
                "content": "Pseudo Code:"
            },
            {
                "tag": "code",
                "content": "\nFUNCTION findFirstOccurrence(haystack, needle)\n    IF needle IS EMPTY\n        RETURN 0  // An empty needle is found at the beginning\n\n    FOR each startingPosition IN haystack FROM 0 TO LENGTH(haystack) - LENGTH(needle)\n        matchFound = TRUE\n\n        FOR each characterPosition IN needle FROM 0 TO LENGTH(needle) - 1\n            IF haystack[startingPosition + characterPosition] != needle[characterPosition]\n                matchFound = FALSE\n                BREAK  // Exit the inner loop as soon as a mismatch is found\n\n        IF matchFound\n            RETURN startingPosition  // Return the index of the first match\n\n    RETURN -1  // Return -1 if no match is found\nEND FUNCTION"
            },
            {
                "tag": "p",
                "content": "This pseudo code provides a step-by-step approach to find the first occurrence of needle in haystack without using any built-in string search functions, demonstrating the underlying algorithmic logic."
            }
        ],
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "js",
                "code": "\nconst strStr = (haystack, needle) => haystack.indexOf(needle);"
            }
        ]
    },
    {
        "name": "Minimum Height Trees",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-height-trees",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) return {0};\n        \n        vector<unordered_set<int>> adj(n);\n        for (auto& edge : edges) {\n            adj[edge[0]].insert(edge[1]);\n            adj[edge[1]].insert(edge[0]);\n        }\n        \n        vector<int> leaves;\n        for (int i = 0; i < n; ++i) {\n            if (adj[i].size() == 1) leaves.push_back(i);\n        }\n        \n        while (n > 2) {\n            n -= leaves.size();\n            vector<int> newLeaves;\n            for (int i : leaves) {\n                int j = *adj[i].begin();\n                adj[j].erase(i);\n                if (adj[j].size() == 1) newLeaves.push_back(j);\n            }\n            leaves = newLeaves;\n        }\n        \n        return leaves;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        if (n == 1) return List.of(0);\n        ArrayList<Integer>[] adj = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            adj[edge[0]].add(edge[1]);\n            adj[edge[1]].add(edge[0]);\n        }\n        // Leaves are nodes with only one connection.\n        ArrayList<Integer> leaves = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (adj[i].size() == 1) leaves.add(i);\n        }\n        int remainingNodes = n;\n        while (remainingNodes > 2) {\n            remainingNodes -= leaves.size();\n            ArrayList<Integer> newLeaves = new ArrayList<>();\n            for (int leaf : leaves) {\n                int neighbor = adj[leaf].get(0); // the only neighbor\n                adj[neighbor].remove(Integer.valueOf(leaf));\n                if (adj[neighbor].size() == 1) {\n                    newLeaves.add(neighbor);\n                }\n            }\n            leaves = newLeaves;\n        }\n        return leaves;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findMinHeightTrees(self, n, edges):\n        if n <= 2:\n            return [i for i in range(n)]\n\n        # Build the graph from the edge list\n        from collections import defaultdict, deque\n        neighbors = defaultdict(set)\n        for u, v in edges:\n            neighbors[u].add(v)\n            neighbors[v].add(u)\n\n        # Create a queue to hold leaves\n        leaves = deque()\n        for node in range(n):\n            if len(neighbors[node]) == 1:\n                leaves.append(node)\n\n        remaining_nodes = n\n        while remaining_nodes > 2:\n            leaves_count = len(leaves)\n            remaining_nodes -= leaves_count\n            for _ in range(leaves_count):\n                leaf = leaves.popleft()\n                neighbor = neighbors[leaf].pop()\n                neighbors[neighbor].remove(leaf)\n                if len(neighbors[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n        return list(leaves)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "#include <stdlib.h>\n\ntypedef struct {\n    int* list;\n    int size;\n    int capacity;\n} ArrayList;\n\nvoid initArrayList(ArrayList* alist, int initCapacity) {\n    alist->list = (int*)malloc(initCapacity * sizeof(int));\n    alist->size = 0;\n    alist->capacity = initCapacity;\n}\n\nvoid addToArrayList(ArrayList* alist, int value) {\n    if (alist->size == alist->capacity) {\n        alist->capacity *= 2;\n        alist->list = (int*)realloc(alist->list, alist->capacity * sizeof(int));\n    }\n    alist->list[alist->size++] = value;\n}\n\nvoid freeArrayList(ArrayList* alist) {\n    free(alist->list);\n    alist->list = NULL;\n    alist->size = 0;\n    alist->capacity = 0;\n}\n\nint* findMinHeightTrees(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    if (n == 1) {\n        int* result = (int*)malloc(sizeof(int));\n        result[0] = 0;\n        *returnSize = 1;\n        return result;\n    }\n\n    int* degree = (int*)calloc(n, sizeof(int));\n    ArrayList* graph = (ArrayList*)malloc(n * sizeof(ArrayList));\n    for (int i = 0; i < n; ++i) {\n        initArrayList(&graph[i], 5);\n    }\n\n    for (int i = 0; i < edgesSize; ++i) {\n        int u = edges[i][0];\n        int v = edges[i][1];\n        addToArrayList(&graph[u], v);\n        addToArrayList(&graph[v], u);\n        degree[u]++;\n        degree[v]++;\n    }\n\n    int* leaves = (int*)malloc(n * sizeof(int));\n    int leavesSize = 0;\n    for (int i = 0; i < n; ++i) {\n        if (degree[i] == 1) {\n            leaves[leavesSize++] = i;\n        }\n    }\n\n    while (n > 2) {\n        int newLeavesSize = 0;\n        int* newLeaves = (int*)malloc(n * sizeof(int));\n        for (int i = 0; i < leavesSize; ++i) {\n            int leaf = leaves[i];\n            n--;\n            for (int j = 0; j < graph[leaf].size; ++j) {\n                int neighbor = graph[leaf].list[j];\n                if (--degree[neighbor] == 1) {\n                    newLeaves[newLeavesSize++] = neighbor;\n                }\n            }\n        }\n        free(leaves);\n        leaves = newLeaves;\n        leavesSize = newLeavesSize;\n    }\n\n    *returnSize = leavesSize;\n    for (int i = 0; i < n; ++i) {\n        freeArrayList(&graph[i]);\n    }\n    free(graph);\n    free(degree);\n    return leaves;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> FindMinHeightTrees(int n, int[][] edges) {\n        if (n == 1) return new List<int> { 0 };\n        List<int>[] graph = new List<int>[n];\n        for (int i = 0; i < n; i++)\n            graph[i] = new List<int>();\n        foreach (int[] edge in edges) {\n            graph[edge[0]].Add(edge[1]);\n            graph[edge[1]].Add(edge[0]);\n        }\n        List<int> leaves = new List<int>();\n        for (int i = 0; i < n; i++)\n            if (graph[i].Count == 1)\n                leaves.Add(i);\n\n        while (n > 2) {\n            n -= leaves.Count;\n            List<int> newLeaves = new List<int>();\n            foreach (int leaf in leaves) {\n                int j = graph[leaf][0];\n                graph[j].Remove(leaf);\n                if (graph[j].Count == 1) newLeaves.Add(j);\n            }\n            leaves = newLeaves;\n        }\n        return leaves;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var findMinHeightTrees = function(n, edges) {\n    if (n === 1) return [0];\n    let adjacencyList = new Array(n);\n    for (let i = 0; i < n; ++i) {\n        adjacencyList[i] = [];\n    }\n    for (let [u, v] of edges) {\n        adjacencyList[u].push(v);\n        adjacencyList[v].push(u);\n    }\n\n    let leaves = [];\n    for (let i = 0; i < n; ++i) {\n        if (adjacencyList[i].length === 1) {\n            leaves.push(i);\n        }\n    }\n\n    let remainingNodes = n;\n    while (remainingNodes > 2) {\n        remainingNodes -= leaves.length;\n        let newLeaves = [];\n        for (let leaf of leaves) {\n            let neighbor = adjacencyList[leaf].pop();\n            let index = adjacencyList[neighbor].indexOf(leaf);\n            adjacencyList[neighbor].splice(index, 1);\n            if (adjacencyList[neighbor].length === 1) {\n                newLeaves.push(neighbor);\n            }\n        }\n        leaves = newLeaves;\n    }\n    return leaves;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findMinHeightTrees(n: number, edges: number[][]): number[] {\n    if (n <= 2) {\n        return Array.from({ length: n }, (_, index) => index);\n    }\n\n    const adj: Map<number, Set<number>> = new Map();\n    for (const [u, v] of edges) {\n        if (!adj.has(u)) adj.set(u, new Set());\n        if (!adj.has(v)) adj.set(v, new Set());\n        adj.get(u)!.add(v);\n        adj.get(v)!.add(u);\n    }\n\n    let leaves: number[] = [];\n    for (const [key, neighbours] of adj) {\n        if (neighbours.size === 1) {\n            leaves.push(key);\n        }\n    }\n\n    let remainingNodes = n;\n    while (remainingNodes > 2) {\n        remainingNodes -= leaves.length;\n        const newLeaves: number[] = [];\n        for (const leaf of leaves) {\n            const neighbour = Array.from(adj.get(leaf)!)[0];\n            adj.get(neighbour)!.delete(leaf);\n            if (adj.get(neighbour)!.size === 1) {\n                newLeaves.push(neighbour);\n            }\n        }\n        leaves = newLeaves;\n    }\n    return leaves;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findMinHeightTrees($n, $edges) {\n        if ($n == 1) return [0];\n        \n        $adj = array_fill(0, $n, []);\n        foreach ($edges as $pair) {\n            $adj[$pair[0]][] = $pair[1];\n            $adj[$pair[1]][] = $pair[0];\n        }\n        \n        $leaves = [];\n        for ($i = 0; $i < $n; $i++) {\n            if (count($adj[$i]) == 1) $leaves[] = $i;\n        }\n        \n        $remainingNodes = $n;\n        while ($remainingNodes > 2) {\n            $newLeaves = [];\n            $remainingNodes -= count($leaves);\n            foreach ($leaves as $leaf) {\n                foreach ($adj[$leaf] as $neighbor) {\n                    unset($adj[$neighbor][array_search($leaf, $adj[$neighbor])]);\n                    if (count($adj[$neighbor]) == 1) $newLeaves[] = $neighbor;\n                }\n            }\n            $leaves = $newLeaves;\n        }\n        \n        return $leaves;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findMinHeightTrees(_ n: Int, _ edges: [[Int]]) -> [Int] {\n        if n == 1 { return [0] }\n        \n        var adjacencyList = Array(repeating: Set<Int>(), count: n)\n        for edge in edges {\n            adjacencyList[edge[0]].insert(edge[1])\n            adjacencyList[edge[1]].insert(edge[0])\n        }\n        \n        var leaves = [Int]()\n        for i in 0..<n {\n            if adjacencyList[i].count == 1 {\n                leaves.append(i)\n            }\n        }\n        \n        var remainingNodes = n\n        while remainingNodes > 2 {\n            remainingNodes -= leaves.count\n            var newLeaves = [Int]()\n            \n            for leaf in leaves {\n                guard let neighbor = adjacencyList[leaf].popFirst() else { continue }\n                adjacencyList[neighbor].remove(leaf)\n                if adjacencyList[neighbor].count == 1 {\n                    newLeaves.append(neighbor)\n                }\n            }\n            \n            leaves = newLeaves\n        }\n        \n        return leaves\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findMinHeightTrees(n: Int, edges: Array<IntArray>): List<Int> {\n        if (n == 1) return listOf(0)\n        \n        val adjacencyList = Array<MutableList<Int>>(n) { mutableListOf() }\n        val degree = IntArray(n)\n        \n        for (edge in edges) {\n            adjacencyList[edge[0]].add(edge[1])\n            adjacencyList[edge[1]].add(edge[0])\n            degree[edge[0]]++\n            degree[edge[1]]++\n        }\n        \n        val leaves = ArrayDeque<Int>()\n        for (i in 0 until n) {\n            if (degree[i] == 1) leaves.add(i)\n        }\n        \n        var remainingNodes = n\n        while (remainingNodes > 2) {\n            val size = leaves.size\n            remainingNodes -= size\n            for (i in 0 until size) {\n                val leaf = leaves.removeFirst()\n                for (neighbor in adjacencyList[leaf]) {\n                    degree[neighbor]--\n                    if (degree[neighbor] == 1) {\n                        leaves.add(neighbor)\n                    }\n                }\n            }\n        }\n        \n        return leaves.toList()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> findMinHeightTrees(int n, List<List<int>> edges) {\n    if (n == 1) return [0];\n\n    List<Set<int>> graph = List.generate(n, (_) => <int>{});\n    for (List<int> edge in edges) {\n      graph[edge[0]].add(edge[1]);\n      graph[edge[1]].add(edge[0]);\n    }\n\n    List<int> leaves = [];\n    for (int i = 0; i < n; i++) {\n      if (graph[i].length == 1) {\n        leaves.add(i);\n      }\n    }\n\n    int remainingNodes = n;\n    while (remainingNodes > 2) {\n      remainingNodes -= leaves.length;\n      List<int> newLeaves = [];\n\n      for (int leaf in leaves) {\n        int neighbor = graph[leaf].first;\n        graph[neighbor].remove(leaf);\n        if (graph[neighbor].length == 1) {\n          newLeaves.add(neighbor);\n        }\n      }\n\n      leaves = newLeaves;\n    }\n\n    return leaves;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findMinHeightTrees(n int, edges [][]int) []int {\n    if n == 1 {\n        return []int{0}\n    }\n    adj := make([][]int, n)\n    for _, edge := range edges {\n        u, v := edge[0], edge[1]\n        adj[u] = append(adj[u], v)\n        adj[v] = append(adj[v], u)\n    }\n\n    leaves := make([]int, 0)\n    for i := 0; i < n; i++ {\n        if len(adj[i]) == 1 {\n            leaves = append(leaves, i)\n        }\n    }\n\n    remainingNodes := n\n    for remainingNodes > 2 {\n        newLeaves := make([]int, 0)\n        remainingNodes -= len(leaves)\n        for _, leaf := range leaves {\n            for _, neighbor := range adj[leaf] {\n                adj[neighbor] = remove(adj[neighbor], leaf)\n                if len(adj[neighbor]) == 1 {\n                    newLeaves = append(newLeaves, neighbor)\n                }\n            }\n        }\n        leaves = newLeaves\n    }\n\n    return leaves\n}\n\nfunc remove(slice []int, val int) []int {\n    newSlice := make([]int, 0, len(slice)-1)\n    for _, x := range slice {\n        if x != val {\n            newSlice = append(newSlice, x)\n        }\n    }\n    return newSlice\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n  def findMinHeightTrees(n: Int, edges: Array[Array[Int]]): List[Int] = {\n    if (n == 1) return List(0)\n    val adj = Array.fill(n)(collection.mutable.Set[Int]())\n    for (e <- edges) {\n      adj(e(0)).add(e(1))\n      adj(e(1)).add(e(0))\n    }\n\n    var leaves = collection.mutable.Queue[Int]()\n    for (i <- 0 until n if adj(i).size == 1) {\n      leaves.enqueue(i)\n    }\n\n    var remainingNodes = n\n    while (remainingNodes > 2) {\n      val leavesCount = leaves.size\n      remainingNodes -= leavesCount\n      for (_ <- 1 to leavesCount) {\n        val leaf = leaves.dequeue()\n        adj(leaf).foreach { neighbor =>\n          adj(neighbor) -= leaf\n          if (adj(neighbor).size == 1) leaves.enqueue(neighbor)\n        }\n      }\n    }\n\n    leaves.toList\n  }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        if n == 1 {\n            return vec![0];\n        }\n\n        let mut graph = vec![vec![]; n as usize];\n        let mut degree = vec![0; n as usize];\n\n        for edge in edges {\n            let (a, b) = (edge[0] as usize, edge[1] as usize);\n            graph[a].push(b);\n            graph[b].push(a);\n            degree[a] += 1;\n            degree[b] += 1;\n        }\n\n        let mut leaves = Vec::new();\n        for i in 0..n as usize {\n            if degree[i] == 1 {\n                leaves.push(i);\n            }\n        }\n\n        let mut remaining_nodes = n;\n        while remaining_nodes > 2 {\n            remaining_nodes -= leaves.len() as i32;\n            let mut new_leaves = Vec::new();\n            for &leaf in &leaves {\n                for &neighbor in &graph[leaf] {\n                    degree[neighbor] -= 1;\n                    if degree[neighbor] == 1 {\n                        new_leaves.push(neighbor);\n                    }\n                }\n            }\n            leaves = new_leaves;\n        }\n\n        leaves.iter().map(|&x| x as i32).collect()\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define (find-min-height-trees n edges)\n  (define (create-graph n edges)\n    (let ([graph (make-hash)])\n      (for ([i (in-range n)]) (hash-set! graph i '()))\n      (for ([edge edges])\n        (let ([a (first edge)]\n              [b (second edge)])\n          (hash-set! graph a (cons b (hash-ref graph a)))\n          (hash-set! graph b (cons a (hash-ref graph b)))))\n      graph))\n\n  (define (find-leaves graph)\n    (filter-map (\u03bb (node) (and (= (length (hash-ref graph node)) 1) node))\n                (hash-keys graph)))\n\n  (define (bfs-cut-leaves graph)\n    (let loop ([current-graph graph]\n               [leaves (find-leaves graph)])\n      (for ([leaf leaves])\n        (for ([neighbor (hash-ref current-graph leaf)])\n          (hash-set! current-graph neighbor (remove leaf (hash-ref current-graph neighbor)))))\n      (for ([leaf leaves]) (hash-remove! current-graph leaf))\n      \n      (if (or (<= (hash-count current-graph) 2)\n              (null? leaves))\n          (hash-keys current-graph)\n          (loop current-graph (find-leaves current-graph)))))\n\n  (if (= n 1)\n      '(0)\n      (bfs-cut-leaves (create-graph n edges))))\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def find_min_height_trees(n, edges)\n    return (0...n).to_a if n <= 2\n    \n    adj = Array.new(n) { [] }\n    edges.each do |a, b|\n        adj[a] << b\n        adj[b] << a\n    end\n    \n    leaves = []\n    adj.each_with_index do |nodes, i|\n        leaves << i if nodes.length == 1\n    end\n    \n    remaining_nodes = n\n    while remaining_nodes > 2\n        remaining_nodes -= leaves.length\n        new_leaves = []\n        leaves.each do |leaf|\n            neighbor = adj[leaf].pop\n            adj[neighbor].delete(leaf)\n            new_leaves << neighbor if adj[neighbor].length == 1\n        end\n        leaves = new_leaves\n    end\n    \n    leaves\nend\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec find_min_height_trees(non_neg_integer(), [[non_neg_integer()]]) -> [non_neg_integer()].\nfind_min_height_trees(N, Edges) when N =:= 1 -> [0];\nfind_min_height_trees(N, Edges) ->\n    Adj = lists:foldl(\n        fun([A, B], Acc) ->\n            maps:update_with(A, fun(L) -> [B | L] end, [B], maps:update_with(B, fun(K) -> [A | K] end, [A], Acc))\n        end,\n        #{},\n        Edges\n    ),\n\n    Leaves = maps:fold(\n        fun(K, V, Acc) ->\n            if length(V) == 1 -> [K | Acc];\n               true -> Acc\n            end\n        end,\n        [],\n        Adj\n    ),\n\n    RemainingNodes = N,\n\n    find_roots(Adj, Leaves, RemainingNodes).\n\n-spec find_roots(map(), [integer()], integer()) -> [integer()].\nfind_roots(Adj, Leaves, RemainingNodes) when RemainingNodes =< 2 -> Leaves;\nfind_roots(Adj, Leaves, RemainingNodes) ->\n    {NewAdj, NewLeaves} = lists:foldl(\n        fun(Leaf, {AccAdj, AccLeaves}) ->\n            Neighbors = maps:get(Leaf, AccAdj),\n            UpdatedAdj = lists:foldl(\n                fun(Neighbor, AccMap) ->\n                    NList = lists:delete(Leaf, maps:get(Neighbor, AccMap)),\n                    maps:put(Neighbor, NList, AccMap)\n                end,\n                AccAdj,\n                Neighbors\n            ),\n            NewLeavesAcc = lists:foldl(\n                fun(N, L) ->\n                    case maps:find(N, UpdatedAdj) of\n                        {ok, NAdj} when length(NAdj) == 1 -> [N | L];\n                        _ -> L\n                    end\n                end,\n                AccLeaves,\n                Neighbors\n            ),\n            {UpdatedAdj, NewLeavesAcc}\n        end,\n        {Adj, []},\n        Leaves\n    ),\n    find_roots(NewAdj, NewLeaves, RemainingNodes - length(Leaves)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to find the root nodes that result in the Minimum Height Trees (MHTs) from a given tree. Here's the methodology and the pseudocode to achieve this:\n\n### # Explanation\n\n1. **Initial Check:** If the number of nodes `n` is less than or equal to 2, the nodes themselves are the MHTs because they inherently have the minimum height possible.\n2. **Building the Graph:** Create an adjacency list to represent the graph using a dictionary where each node points to a set of its neighbors.\n3. **Identifying Leaves:** The leaves are nodes with only one connection. Initialize a deque with all these leaf nodes.\n4. **Trimming Leaves Iteratively:** Continue removing leaves level by level and updating the graph. Since we are working a tree, each removed leaf simplifies the problem until fewer than 3 nodes remain. The remaining nodes will be the roots of the Minimum Height Trees.\n5. **Return the Remaining Nodes:** These nodes are the result, as they represent the centers of the tree with minimum height.\n\n### # Pseudocode\n\n```pseudo\nFunction findMinHeightTrees(n, edges):\n    If n <= 2:\n        Return list of nodes from 0 to n-1\n\n    # Initialize the graph\n    neighbors = defaultdict(set)\n    For each edge in edges:\n        u, v = edge\n        neighbors[u].add(v)\n        neighbors[v].add(u)\n\n    # Initialize the first set of leaves\n    leaves = Deque()\n    For each node in range(n):\n        If len(neighbors[node]) == 1:\n            leaves.append(node)\n\n    # Trim the leaves until reaching the core of the graph\n    remaining_nodes = n\n    While remaining_nodes > 2:\n        leaves_count = len(leaves)\n        remaining_nodes -= leaves_count\n\n        For i in range(leaves_count):\n            leaf = leaves.popleft()\n            neighbor = neighbors[leaf].pop()\n            neighbors[neighbor].remove(leaf)\n\n            if len(neighbors[neighbor]) == 1:\n                leaves.append(neighbor)\n\n    Return list(leaves)\n```\n\nThis approach ensures that we efficiently find the minimum height trees using a BFS-like approach by systematically trimming the leaves. This process is repeated until the core of the graph is reached, ensuring that the remaining nodes are the roots of the minimum height trees.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-height-trees"
    },
    {
        "name": "Longest Palindromic Substring",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-palindromic-substring",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        if (s.empty()) return \"\";\n        int n = s.length();\n        if (n == 1) return s;\n\n        int start = 0, len = 1; // variables to track the start and max length of the palindrome found\n\n        vector<vector<bool>> dp(n, vector<bool>(n, false)); // DP table\n        for (int i = 0; i < n; i++)\n            dp[i][i] = true; // All single characters are palindromes\n\n        // Check for sub-string of length 2\n        for (int i = 0; i < n - 1; i++) {\n            if (s[i] == s[i + 1]) {\n                dp[i][i + 1] = true;\n                start = i;\n                len = 2;\n            }\n        }\n\n        // Check for lengths greater than 2\n        for (int k = 3; k <= n; k++) { // sub-string length\n            for (int i = 0; i < n - k + 1; i++) { // start index\n                int j = i + k - 1; // end index\n                if (s[i] == s[j] && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    start = i;\n                    len = k;\n                }\n            }\n        }\n\n        return s.substr(start, len);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() < 1) return \"\";\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = expandAroundCenter(s, i, i);\n            int len2 = expandAroundCenter(s, i, i + 1);\n            int len = Math.max(len1, len2);\n            if (len > (end - start)) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n    \n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if len(s) == 0:\n            return \"\"\n        max_len = 0\n        start = 0\n        \n        for i in range(len(s)):\n            len1 = self.expandAroundCenter(s, i, i)\n            len2 = self.expandAroundCenter(s, i, i + 1)\n            max_len_here = max(len1, len2)\n            if max_len_here > max_len:\n                max_len = max_len_here\n                start = i - (max_len_here - 1) // 2\n                \n        return s[start:start + max_len]\n\n    def expandAroundCenter(self, s, left, right):\n        L, R = left, right\n        while L >= 0 and R < len(s) and s[L] == s[R]:\n            L -= 1\n            R += 1\n        return R - L - 1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* longestPalindrome(char* s) {\n    int start = 0, end = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = len1 > len2 ? len1 : len2;\n        if (len > end - start) {\n            start = i - (len - 1) / 2;\n            end = i + len / 2;\n        }\n    }\n    int size = end - start + 1;\n    char* result = (char*)malloc(sizeof(char) * (size + 1));\n    strncpy(result, s + start, size);\n    result[size] = '\\0';\n    return result;\n}\n\nint expandAroundCenter(char* s, int left, int right) {\n    while (left >= 0 && s[right] != '\\0' && s[left] == s[right]) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string LongestPalindrome(string s) {\n        if (s == null || s.Length < 1) return \"\";\n        int start = 0, end = 0;\n        for (int i = 0; i < s.Length; i++) {\n            int len1 = ExpandAroundCenter(s, i, i);\n            int len2 = ExpandAroundCenter(s, i, i + 1);\n            int len = Math.Max(len1, len2);\n            if (len > end - start) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.Substring(start, end - start + 1);\n    }\n\n    private int ExpandAroundCenter(string s, int left, int right) {\n        while (left >= 0 && right < s.Length && s[left] == s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var longestPalindrome = function(s) {\n    if (!s || s.length <= 1) {\n        return s;\n    }\n\n    let longest = '';\n\n    function expandAroundCenter(left, right) {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            if (right - left + 1 > longest.length) {\n                longest = s.substring(left, right + 1);\n            }\n            left--;\n            right++;\n        }\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        expandAroundCenter(i, i);       // Odd length palindromes\n        expandAroundCenter(i, i + 1);   // Even length palindromes\n    }\n\n    return longest;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function longestPalindrome(s: string): string {\n    if (s.length < 1) return \"\";\n\n    let start = 0, end = 0;\n\n    const expandAroundCenter = (left: number, right: number) => {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    };\n\n    for (let i = 0; i < s.length; i++) {\n        const len1 = expandAroundCenter(i, i);\n        const len2 = expandAroundCenter(i, i + 1);\n        const len = Math.max(len1, len2);\n        if (len > end - start) {\n            start = i - Math.floor((len - 1) / 2);\n            end = i + Math.floor(len / 2);\n        }\n    }\n\n    return s.substring(start, end + 1);\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    function longestPalindrome($s) {\n        $n = strlen($s);\n        if ($n < 2) return $s;\n        \n        $start = 0;\n        $maxLen = 1;\n        \n        for ($i = 0; $i < $n; $i++) {\n            if ($n - $i <= $maxLen / 2) break;\n            \n            $left = $right = $i;\n            while ($right < $n - 1 && $s[$right] == $s[$right + 1]) $right++;\n            $i = $right++;\n            \n            while ($left > 0 && $right < $n && $s[$left - 1] == $s[$right]) {\n                $left--;\n                $right++;\n            }\n            \n            $newLength = $right - $left;\n            if ($newLength > $maxLen) {\n                $start = $left;\n                $maxLen = $newLength;\n            }\n        }\n        \n        return substr($s, $start, $maxLen);\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun longestPalindrome(s: String): String {\n        if (s.isEmpty() || s.length < 2) {\n            return s\n        }\n        \n        var start = 0\n        var end = 0\n        \n        for (i in 0 until s.length) {\n            val len1 = expandAroundCenter(s, i, i)\n            val len2 = expandAroundCenter(s, i, i + 1)\n            val len = maxOf(len1, len2)\n            if (len > end - start) {\n                start = i - (len - 1) / 2\n                end = i + len / 2\n            }\n        }\n        \n        return s.substring(start, end + 1)\n    }\n    \n    private fun expandAroundCenter(s: String, left: Int, right: Int): Int {\n        var l = left\n        var r = right\n        while (l >= 0 && r < s.length && s[l] == s[r]) {\n            l--\n            r++\n        }\n        return r - l - 1\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String longestPalindrome(String s) {\n    if (s.isEmpty) {\n      return '';\n    }\n    \n    String result = '';\n    \n    for (int i = 0; i < s.length; i++) {\n      String palindrome1 = expandAroundCenter(s, i, i);\n      String palindrome2 = expandAroundCenter(s, i, i + 1);\n      \n      if (palindrome1.length > result.length) {\n        result = palindrome1;\n      }\n      \n      if (palindrome2.length > result.length) {\n        result = palindrome2;\n      }\n    }\n    \n    return result;\n  }\n  \n  String expandAroundCenter(String s, int left, int right) {\n    while (left >= 0 && right < s.length && s[left] == s[right]) {\n      left--;\n      right++;\n    }\n    \n    return s.substring(left + 1, right);\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func longestPalindrome(s string) string {\n    if len(s) < 2 {\n        return s\n    }\n    \n    var start, end int\n    for i := 0; i < len(s); i++ {\n        len1 := expandAroundCenter(s, i, i)\n        len2 := expandAroundCenter(s, i, i+1)\n        maxLen := max(len1, len2)\n        if maxLen > end-start {\n            start = i - (maxLen-1)/2\n            end = i + maxLen/2\n        }\n    }\n    \n    return s[start : end+1]\n}\n\nfunc expandAroundCenter(s string, left, right int) int {\n    for left >= 0 && right < len(s) && s[left] == s[right] {\n        left--\n        right++\n    }\n    return right - left - 1\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def longest_palindrome(s)\n    return s if s.length <= 1\n    \n    longest = \"\"\n    \n    (0...s.length).each do |i|\n        # For odd length palindromes\n        len1 = expand_around_center(s, i, i)\n        if len1.length > longest.length\n            longest = len1\n        end\n        \n        # For even length palindromes\n        len2 = expand_around_center(s, i, i + 1)\n        if len2.length > longest.length\n            longest = len2\n        end\n    end\n    \n    return longest\nend\n\ndef expand_around_center(s, left, right)\n    while left >= 0 && right < s.length && s[left] == s[right]\n        left -= 1\n        right += 1\n    end\n    \n    return s[left + 1..right - 1]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def longestPalindrome(s: String): String = {\n        if (s == null || s.length < 1) return \"\"\n\n        var start = 0\n        var end = 0\n\n        for (i <- 0 until s.length) {\n            val len1 = expandAroundCenter(s, i, i)\n            val len2 = expandAroundCenter(s, i, i + 1)\n            val len = math.max(len1, len2)\n\n            if (len > end - start) {\n                start = i - (len - 1) / 2\n                end = i + len / 2\n            }\n        }\n\n        s.substring(start, end + 1)\n    }\n\n    def expandAroundCenter(s: String, left: Int, right: Int): Int = {\n        var L = left\n        var R = right\n\n        while (L >= 0 && R < s.length && s.charAt(L) == s.charAt(R)) {\n            L -= 1\n            R += 1\n        }\n\n        R - L - 1\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn longest_palindrome(s: String) -> String {\n        let mut start = 0;\n        let mut end = 0;\n        \n        for i in 0..s.len() {\n            let len1 = Self::expand_around_center(&s, i, i);\n            let len2 = Self::expand_around_center(&s, i, i + 1);\n            let max_len = std::cmp::max(len1, len2);\n            \n            if max_len > end - start {\n                start = i - (max_len - 1) / 2;\n                end = i + max_len / 2;\n            }\n        }\n        \n        s[start..=end].to_string()\n    }\n    \n    fn expand_around_center(s: &String, left: usize, right: usize) -> usize {\n        let mut l = left as i32;\n        let mut r = right as i32;\n        \n        while l >= 0 && r < s.len() as i32 && s.as_bytes()[l as usize] == s.as_bytes()[r as usize] {\n            l -= 1;\n            r += 1;\n        }\n        \n        (r - l - 1) as usize\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify and return the longest palindromic substring within a given string `s`.\n\n# Explanation\n\nA palindrome reads the same forwards and backwards. Hence, the goal is to find the longest substring of `s` which maintains this property. A common technique for solving this problem is to use the \"expand around center\" method. \n\nThe idea is to consider each character (and each pair of adjacent characters) in the string as the center of a potential palindrome and then expand outwards as long as the characters on both sides are the same. This approach works efficiently with a time complexity of \\(O(n^2)\\), where \\(n\\) is the length of the string.\n\nHere's the step-by-step methodology:\n\n1. **Check for edge cases**: If the string is empty, return an empty string.\n2. **Initialize variables**: Track the starting index and the maximum length of the longest palindrome found.\n3. **Iterate** over the string, considering each character and each pair of adjacent characters as possible centers of palindromes.\n4. **Expand around the center**: For each center, expand outward as long as the characters on both sides are equal.\n5. **Update the maximum palindrome**: If the length of the palindrome found by expanding around the current center is greater than the previously recorded maximum length, update the maximum length and the starting index of the palindrome.\n6. **Return the longest palindromic substring**: Use the starting index and the maximum length to slice the longest palindrome out of the original string.\n\n# Pseudocode\n\nHere's the pseudocode based on the outlined methodology:\n\n```\nfunction longestPalindrome(s):\n    if length of s is 0:\n        return \"\"\n    \n    max_len <- 0\n    start <- 0\n    \n    for i from 0 to length of s - 1:\n        len1 <- expandAroundCenter(s, i, i)      # Odd-length palindromes\n        len2 <- expandAroundCenter(s, i, i + 1)  # Even-length palindromes\n        max_len_here <- max(len1, len2)\n        \n        if max_len_here > max_len:\n            max_len <- max_len_here\n            start <- i - (max_len_here - 1) // 2\n    \n    return substring of s from start to start + max_len\n\nfunction expandAroundCenter(s, left, right):\n    while left >= 0 and right < length of s and s[left] == s[right]:\n        left <- left - 1\n        right <- right + 1\n    \n    return right - left - 1\n```\n\nThis approach ensures that each possible center is explored, and the longest palindromic substring is identified efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-palindromic-substring"
    },
    {
        "name": "Longest Substring Without Repeating Characters",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-substring-without-repeating-characters",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        vector<int> dict(256, -1);\n        int maxLen = 0, start = -1;\n        for (int i = 0; i < s.size(); i++) {\n            if (dict[s[i]] > start)\n                start = dict[s[i]];\n            dict[s[i]] = i;\n            maxLen = max(maxLen, i - start);\n        }\n        return maxLen;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s.length() == 0) return 0;\n        HashMap<Character, Integer> map = new HashMap<>();\n        int max = 0;\n        for (int i = 0, j = 0; i < s.length(); ++i) {\n            if (map.containsKey(s.charAt(i))) {\n                j = Math.max(j, map.get(s.charAt(i)) + 1);\n            }\n            map.put(s.charAt(i), i);\n            max = Math.max(max, i - j + 1);\n        }\n        return max;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        chars = {}\n        left = 0\n        right = 0\n        max_len = 0\n        while right < len(s):\n            if s[right] in chars and chars[s[right]] >= left:\n                left = chars[s[right]] + 1\n            max_len = max(max_len, right - left + 1)\n            chars[s[right]] = right\n            right += 1\n        return max_len\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int lengthOfLongestSubstring(char* s) {\n    int max_length = 0, start = 0;\n    int char_index[256];   // ASCII table size\n    for (int i = 0; i < 256; i++) {\n        char_index[i] = -1;\n    }\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (char_index[(unsigned char)s[i]] >= start) {\n            start = char_index[(unsigned char)s[i]] + 1;\n        }\n        char_index[(unsigned char)s[i]] = i;\n        max_length = max_length > (i - start + 1) ? max_length : (i - start + 1);\n    }\n\n    return max_length;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LengthOfLongestSubstring(string s) {\n        int n = s.Length;\n        int i = 0, j = 0, maxLength = 0;\n        HashSet<char> set = new HashSet<char>();\n\n        while (j < n) {\n            if (!set.Contains(s[j])) {\n                set.Add(s[j++]);\n                maxLength = Math.Max(maxLength, set.Count);\n            } else {\n                set.Remove(s[i++]);\n            }\n        }\n        return maxLength;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var lengthOfLongestSubstring = function(s) {\n    let map = {};\n    let start = 0;\n    let maxLength = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        let char = s[i];\n        if (map[char] >= start) {\n            start = map[char] + 1;\n        }\n        map[char] = i;\n        maxLength = Math.max(maxLength, i - start + 1);\n    }\n    \n    return maxLength;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function lengthOfLongestSubstring(s: string): number {\n    let map = new Map<string, number>();\n    let left = 0;\n    let maxLen = 0;\n\n    for (let right = 0; right < s.length; right++) {\n        const char = s[right];\n        if (map.has(char)) {\n            left = Math.max(map.get(char)! + 1, left);\n        }\n        map.set(char, right);\n        maxLen = Math.max(maxLen, right - left + 1);\n    }\n\n    return maxLen;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLongestSubstring($s) {\n        $n = strlen($s);\n        $maxLen = 0;\n        $map = [];\n        $left = 0;\n\n        for ($right = 0; $right < $n; $right++) {\n            $char = $s[$right];\n            if (array_key_exists($char, $map)) {\n                $left = max($map[$char] + 1, $left);\n            }\n            $map[$char] = $right;\n            $maxLen = max($maxLen, $right - $left + 1);\n        }\n\n        return $maxLen;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func lengthOfLongestSubstring(_ s: String) -> Int {\n        var charSet = Set<Character>()\n        var left = 0\n        var maxLength = 0\n        \n        let chars = Array(s)\n        \n        for (i, char) in chars.enumerated() {\n            while charSet.contains(char) {\n                charSet.remove(chars[left])\n                left += 1\n            }\n            charSet.insert(char)\n            maxLength = max(maxLength, i - left + 1)\n        }\n        \n        return maxLength\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun lengthOfLongestSubstring(s: String): Int {\n        val n = s.length\n        var longest = 0\n        var start = 0\n        val map = mutableMapOf<Char, Int>()\n\n        for (end in 0 until n) {\n            if (s[end] in map) {\n                start = maxOf(map[s[end]]!! + 1, start)\n            }\n            map[s[end]] = end\n            longest = maxOf(longest, end - start + 1)\n        }\n        return longest\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int lengthOfLongestSubstring(String s) {\n    Map<String, int> map = {};\n    int start = 0, maxLength = 0;\n\n    for (int i = 0; i < s.length; i++) {\n      String c = s[i];\n      if (map.containsKey(c)) {\n        start = max(start, map[c]! + 1);\n      }\n      map[c] = i;\n      maxLength = max(maxLength, i - start + 1);\n    }\n    return maxLength;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func lengthOfLongestSubstring(s string) int {\n    charMap := make(map[byte]int)\n    maxLength := 0\n    l := 0\n    \n    for r := 0; r < len(s); r++ {\n        if index, found := charMap[s[r]]; found && index >= l {\n            l = index + 1\n        }\n        charMap[s[r]] = r\n        if maxLength < r-l+1 {\n            maxLength = r-l+1\n        }\n    }\n    \n    return maxLength\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def length_of_longest_substring(s)\n  chars = {}\n  max_length = 0\n  left = 0\n\n  s.chars.each_with_index do |char, right|\n    if chars.include?(char) && chars[char] >= left\n      left = chars[char] + 1\n    end\n\n    chars[char] = right\n    max_length = [max_length, right - left + 1].max\n  end\n\n  max_length\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def lengthOfLongestSubstring(s: String): Int = {\n        var maxLen = 0\n        var start = 0\n        val map = scala.collection.mutable.Map[Char, Int]()\n\n        for (end <- 0 until s.length) {\n            val ch = s(end)\n            if (map.contains(ch)) {\n                start = math.max(start, map(ch) + 1)\n            }\n            map(ch) = end\n            maxLen = math.max(maxLen, end - start + 1)\n        }\n        maxLen\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        use std::collections::HashMap;\n        let (mut max_len, mut start) = (0, 0);\n        let mut last_seen = HashMap::new();\n\n        for (i, c) in s.chars().enumerate() {\n            if let Some(prev) = last_seen.get(&c) {\n                start = start.max(prev + 1);\n            }\n            max_len = max_len.max(i + 1 - start);\n            last_seen.insert(c, i);\n        }\n\n        max_len as i32\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec length_of_longest_substring(S :: unicode:unicode_binary()) -> integer().\nlength_of_longest_substring(S) ->\n    length_of_longest_substring(S, maps:new(), 0, 0, 0).\n\nlength_of_longest_substring(<<>>, _CharMap, MaxLen, _, _) ->\n    MaxLen;\nlength_of_longest_substring(<<H, Rest/binary>>, CharMap, MaxLen, L, R) ->\n    {NewL, UpdatedCharMap} =\n        case maps:find(H, CharMap) of\n            {ok, PrevIndex} when PrevIndex >= L ->\n                {PrevIndex + 1, maps:put(H, R, CharMap)};\n            _ ->\n                {L, maps:put(H, R, CharMap)}\n        end,\n    NewMaxLen = max(MaxLen, R - NewL + 1),\n    length_of_longest_substring(Rest, UpdatedCharMap, NewMaxLen, NewL, R + 1).\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  def length_of_longest_substring(s) do\n    longest_substring(s, %{}, 0, 0, 0)\n  end\n\n  defp longest_substring(\"\", _seen, max_len, _start, _idx),\n    do: max_len\n\n  defp longest_substring(<<h::utf8, rest::binary>>, seen, max_len, start, idx) do\n    ch = <<h::utf8>>\n    case Map.get(seen, ch) do\n      nil ->\n        longest_substring(rest, Map.put(seen, ch, idx), max(max_len, idx - start + 1), start, idx + 1)\n\n      pos when pos >= start ->\n        longest_substring(rest, Map.put(seen, ch, idx), max_len, pos + 1, idx + 1)\n\n      _ ->\n        longest_substring(rest, Map.put(seen, ch, idx), max(max_len, idx - start + 1), start, idx + 1)\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can utilize the sliding window technique to keep track of the longest substring without repeating characters. By maintaining a window with the current substring, we can effectively manage and update the length of the longest substring encountered.\n\n# Explanation\nThe idea is to use two pointers to represent the window boundaries and a hashmap to keep track of the characters and their most recent positions within the string. As we extend the window by moving the right pointer, we check if the current character already exists in our hashmap and is within the current window. If it is, we shift the left pointer to just after the last occurrence of the character to ensure there are no duplicates within the substring window. We continue expanding the window by moving the right pointer and updating the maximum length of the substring encountered.\n\n# Pseudocode\n```\nfunction lengthOfLongestSubstring(s: string) -> int:\n    if s is empty:\n        return 0\n\n    chars_map = {}\n    left = 0\n    max_len = 0\n\n    for right from 0 to length of s - 1:\n        if s[right] is in chars_map and chars_map[s[right]] >= left:\n            left = chars_map[s[right]] + 1\n\n        chars_map[s[right]] = right\n        current_length = right - left + 1\n        max_len = max(max_len, current_length)\n\n    return max_len\n```\n\n1. Initialize `chars_map` as an empty dictionary, `left` to 0, and `max_len` to 0.\n2. Iterate with `right` from 0 to the end of the string:\n   - If the character `s[right]` exists in `chars_map` and its position is greater than or equal to `left`, update `left` to be one position after the last occurrence.\n   - Update `chars_map` with the current position of `s[right]`.\n   - Calculate the current length of the substring as `right - left + 1`.\n   - Update `max_len` with the maximum of the current maximum length and the current length.\n3. Return `max_len` as the length of the longest substring without repeating characters.\n\nThis approach ensures that each character is processed in constant time, resulting in an efficient O(n) time complexity where n is the length of the string.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-substring-without-repeating-characters"
    },
    {
        "name": "Median Of Two Sorted Arrays",
        "site": "LeetCode",
        "href": "/solution/LeetCode-median-of-two-sorted-arrays",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int x = nums1.size();\n        int y = nums2.size();\n        int low = 0, high = x;\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n            \n            int maxX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n            int maxY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n            \n            int minX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n            int minY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n            \n            if (maxX <= minY && maxY <= minX) {\n                if ((x + y) % 2 == 0) {\n                    return (double)(max(maxX, maxY) + min(minX, minY)) / 2;\n                } else {\n                    return (double)max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n        \n        throw invalid_argument(\"Input arrays are not sorted or of unacceptable size.\");\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            int[] temp = nums1;\n            nums1 = nums2;\n            nums2 = temp;\n        }\n\n        int m = nums1.length;\n        int n = nums2.length;\n        int totalLeft = (m + n + 1) / 2;\n        \n        int left = 0;\n        int right = m;\n        \n        while (left < right) {\n            int i = left + (right - left + 1) / 2;\n            int j = totalLeft - i;\n\n            if (nums1[i - 1] > nums2[j]) {\n                right = i - 1;\n            } else {\n                left = i;\n            }\n        }\n        \n        int i = left;\n        int j = totalLeft - i;\n        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];\n        int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];\n        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];\n        int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];\n        \n        if (((m + n) % 2) == 1) {\n            return Math.max(nums1LeftMax, nums2LeftMax) * 1.0;\n        } else {\n            return (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2.0;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n        \n        if len(B) < len(A):\n            A, B = B, A\n        \n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2 \n            j = half - i - 2\n            \n            Aleft = A[i] if i >= 0 else float('-inf')\n            Aright = A[i + 1] if (i + 1) < len(A) else float('inf')\n            Bleft = B[j] if j >= 0 else float('-inf')\n            Bright = B[j + 1] if (j + 1) < len(B) else float('inf')\n            \n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            \n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    int total = nums1Size + nums2Size;\n    int half = total / 2;\n    if (nums1Size > nums2Size) {\n        int* temp = nums1;\n        nums1 = nums2;\n        nums2 = temp;\n        int tmpSize = nums1Size;\n        nums1Size = nums2Size;\n        nums2Size = tmpSize;\n    }\n    \n    int minIndex = 0, maxIndex = nums1Size, i, j;\n    while (minIndex <= maxIndex) {\n        i = (minIndex + maxIndex) / 2;\n        j = half - i;\n        \n        if (i < maxIndex && nums2[j - 1] > nums1[i]) {\n            minIndex = i + 1;\n        } else if (i > minIndex && nums1[i - 1] > nums2[j]) {\n            maxIndex = i - 1;\n        } else {\n            int minRight;\n            if (i == nums1Size) {\n                minRight = nums2[j];\n            } else if (j == nums2Size) {\n                minRight = nums1[i];\n            } else {\n                minRight = nums2[j] < nums1[i] ? nums2[j] : nums1[i];\n            }\n            \n            if (total % 2) return minRight;\n            \n            int maxLeft;\n            if (i == 0) {\n                maxLeft = nums2[j - 1];\n            } else if (j == 0) {\n                maxLeft = nums1[i - 1];\n            } else {\n                maxLeft = nums1[i - 1] > nums2[j - 1] ? nums1[i - 1] : nums2[j - 1];\n            }\n            \n            return (maxLeft + minRight) / 2.0;\n        }\n    }\n    return 0;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.Length > nums2.Length) {\n            return FindMedianSortedArrays(nums2, nums1);\n        }\n\n        int x = nums1.Length;\n        int y = nums2.Length;\n        int low = 0, high = x;\n        \n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n\n            int maxLeftX = (partitionX == 0) ? int.MinValue : nums1[partitionX - 1];\n            int minRightX = (partitionX == x) ? int.MaxValue : nums1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? int.MinValue : nums2[partitionY - 1];\n            int minRightY = (partitionY == y) ? int.MaxValue : nums2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                if((x + y) % 2 == 0) {\n                    return ((double)Math.Max(maxLeftX, maxLeftY) + Math.Min(minRightX, minRightY)) / 2;\n                } else {\n                    return (double)Math.Max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n\n        throw new ArgumentException(\"Input arrays are not correct.\");\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var findMedianSortedArrays = function(nums1, nums2) {\n    const totalLength = nums1.length + nums2.length;\n    let index1 = 0, index2 = 0;\n    let current = 0, last = 0;\n\n    for (let i = 0; i <= Math.floor(totalLength / 2); i++) {\n        last = current;\n        if (index1 < nums1.length && (index2 >= nums2.length || nums1[index1] < nums2[index2])) {\n            current = nums1[index1++];\n        } else {\n            current = nums2[index2++];\n        }\n    }\n\n    if (totalLength % 2 === 0) {\n        return (last + current) / 2.0;\n    } else {\n        return current;\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n    const n = nums1.length;\n    const m = nums2.length;\n    if (n > m) return findMedianSortedArrays(nums2, nums1); // Ensure that nums1 is the smaller array\n\n    let low = 0, high = n;\n    const combinedLength = n + m;\n    while (low <= high) {\n        const partitionX = (low + high) >> 1;\n        const partitionY = ((n + m + 1) >> 1) - partitionX;\n\n        const maxX = partitionX === 0 ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const maxY = partitionY === 0 ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minX = partitionX === n ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        const minY = partitionY === m ? Number.POSITIVE_INFINITY : nums2[partitionY];\n\n        if (maxX <= minY && maxY <= minX) {\n            if ((combinedLength & 1) === 0) {\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n\n    return 0;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Float\n     */\n    function findMedianSortedArrays($nums1, $nums2) {\n        if (count($nums1) > count($nums2)) {\n            return $this->findMedianSortedArrays($nums2, $nums1);\n        }\n        \n        $x = count($nums1);\n        $y = count($nums2);\n        \n        $low = 0;\n        $high = $x;\n        \n        while ($low <= $high) {\n            $partitionX = ($low + $high) >> 1;\n            $partitionY = (($x + $y + 1) >> 1) - $partitionX;\n            \n            $maxLeftX = ($partitionX == 0) ? PHP_INT_MIN : $nums1[$partitionX - 1];\n            $minRightX = ($partitionX == $x) ? PHP_INT_MAX : $nums1[$partitionX];\n            \n            $maxLeftY = ($partitionY == 0) ? PHP_INT_MIN : $nums2[$partitionY - 1];\n            $minRightY = ($partitionY == $y) ? PHP_INT_MAX : $nums2[$partitionY];\n            \n            if ($maxLeftX <= $minRightY && $maxLeftY <= $minRightX) {\n                if (($x + $y) % 2 == 0) {\n                    return (max($maxLeftX, $maxLeftY) + min($minRightX, $minRightY)) / 2.0;\n                } else {\n                    return max($maxLeftX, $maxLeftY);\n                }\n            } elseif ($maxLeftX > $minRightY) {\n                $high = $partitionX - 1;\n            } else {\n                $low = $partitionX + 1;\n            }\n        }\n        return -1;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\n        let total = nums1.count + nums2.count\n        let half = total / 2\n        \n        var a = nums1, b = nums2\n        if nums1.count > nums2.count {\n            a = nums2\n            b = nums1\n        }\n        \n        var l = 0, r = a.count\n        while l <= r {\n            let i = l + (r - l) / 2\n            let j = half - i\n            \n            let aLeft = (i > 0) ? a[i - 1] : Int.min\n            let aRight = (i < a.count) ? a[i] : Int.max\n            let bLeft = (j > 0) ? b[j - 1] : Int.min\n            let bRight = (j < b.count) ? b[j] : Int.max\n            \n            if aLeft <= bRight && bLeft <= aRight {\n                if total % 2 == 0 {\n                    return Double(max(aLeft, bLeft) + min(aRight, bRight)) / 2.0\n                } else {\n                    return Double(min(aRight, bRight))\n                }\n            } else if aLeft > bRight {\n                r = i - 1\n            } else {\n                l = i + 1\n            }\n        }\n        \n        return 0.0\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        if (nums1.size > nums2.size) return findMedianSortedArrays(nums2, nums1)\n\n        val x = nums1.size\n        val y = nums2.size\n        var low = 0\n        var high = x\n        while (low <= high) {\n            val partitionX = (low + high) / 2\n            val partitionY = (x + y + 1) / 2 - partitionX\n\n            val maxLeftX = if (partitionX == 0) Int.MIN_VALUE else nums1[partitionX - 1]\n            val minRightX = if (partitionX == x) Int.MAX_VALUE else nums1[partitionX]\n\n            val maxLeftY = if (partitionY == 0) Int.MIN_VALUE else nums2[partitionY - 1]\n            val minRightY = if (partitionY == y) Int.MAX_VALUE else nums2[partitionY]\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                return if ((x + y) % 2 == 0) {\n                    (maxOf(maxLeftX, maxLeftY).toDouble() + minOf(minRightX, minRightY)) / 2.0\n                } else {\n                    maxOf(maxLeftX, maxLeftY).toDouble()\n                }\n            } else if (maxLeftX > minRightY) {\n                high = partitionX - 1\n            } else {\n                low = partitionX + 1\n            }\n        }\n\n        throw IllegalArgumentException()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  double findMedianSortedArrays(List<int> nums1, List<int> nums2) {\n    int total = nums1.length + nums2.length;\n    List<int> merged = List.filled(total, 0);\n    int i = 0, j = 0, k = 0;\n\n    // Merge two arrays\n    while (i < nums1.length && j < nums2.length) {\n      if (nums1[i] < nums2[j]) {\n        merged[k++] = nums1[i++];\n      } else {\n        merged[k++] = nums2[j++];\n      }\n    }\n    while (i < nums1.length) {\n      merged[k++] = nums1[i++];\n    }\n    while (j < nums2.length) {\n      merged[k++] = nums2[j++];\n    }\n\n    // Find median\n    if (total % 2 == 1) {\n      return merged[total ~/ 2].toDouble();\n    }\n    int mid1 = total ~/ 2 - 1;\n    int mid2 = total ~/ 2;\n    return (merged[mid1] + merged[mid2]) / 2.0;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    if len(nums1) > len(nums2) {\n        nums1, nums2 = nums2, nums1\n    }\n\n    x, y := len(nums1), len(nums2)\n    low, high := 0, x\n\n    for low <= high {\n        partitionX := (low + high) / 2\n        partitionY := (x + y + 1) / 2 - partitionX\n\n        maxX := -1 << 31\n        if partitionX != 0 {\n            maxX = nums1[partitionX-1]\n        }\n        maxY := -1 << 31\n        if partitionY != 0 {\n            maxY = nums2[partitionY-1]\n        }\n\n        minX := 1<<31 - 1\n        if partitionX != x {\n            minX = nums1[partitionX]\n        }\n        minY := 1<<31 - 1\n        if partitionY != y {\n            minY = nums2[partitionY]\n        }\n\n        if maxX <= minY && maxY <= minX {\n            if (x+y)%2 == 0 {\n                return float64(max(maxX, maxY)+min(minX, minY)) / 2.0\n            } else {\n                return float64(max(maxX, maxY))\n            }\n        } else if maxX > minY {\n            high = partitionX - 1\n        } else {\n            low = partitionX + 1\n        }\n    }\n\n    return -1\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def find_median_sorted_arrays(nums1, nums2)\n  merged = (nums1 + nums2).sort\n  len = merged.length\n  if len.even?\n    (merged[len / 2 - 1] + merged[len / 2]) / 2.0\n  else\n    merged[len / 2]\n  end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {\n        val totalLength = nums1.length + nums2.length\n        val middleIndex = totalLength / 2\n        \n        var i = 0\n        var j = 0\n        var current = 0\n        var prev = 0\n\n        while (i + j <= middleIndex) {\n            prev = current\n            if (i < nums1.length && (j >= nums2.length || nums1(i) < nums2(j))) {\n                current = nums1(i)\n                i += 1\n            } else {\n                current = nums2(j)\n                j += 1\n            }\n        }\n\n        if (totalLength % 2 == 0) (prev + current) / 2.0 else current.toDouble\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        let (mut i, mut j, m, n) = (0, 0, nums1.len(), nums2.len());\n        let total = m + n;\n        let half = total / 2;\n        let mut a = 0;\n        let mut b = 0;\n\n        while i + j <= half {\n            if i < m && (j >= n || nums1[i] < nums2[j]) {\n                a = b;\n                b = nums1[i];\n                i += 1;\n            } else {\n                a = b;\n                b = nums2[j];\n                j += 1;\n            }\n        }\n\n        if total % 2 == 0 {\n            (a as f64 + b as f64) / 2.0\n        } else {\n            b as f64\n        }\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (find-median-sorted-arrays nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) flonum?)\n  (define (merge-lists l1 l2)\n    (if (null? l1) l2\n        (if (null? l2) l1\n            (if (< (car l1) (car l2))\n                (cons (car l1) (merge-lists (cdr l1) l2))\n                (cons (car l2) (merge-lists l1 (cdr l2)))))))\n  (define merged-list (merge-lists nums1 nums2))\n  (define len (length merged-list))\n  (if (odd? len)\n      (exact->inexact (list-ref merged-list (quotient len 2)))\n      (/ (+\n          (exact->inexact (list-ref merged-list (quotient len 2)))\n          (exact->inexact (list-ref merged-list (- (quotient len 2) 1))))\n         2)))\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec find_median_sorted_arrays([integer()], [integer()]) -> float().\nfind_median_sorted_arrays(Nums1, Nums2) ->\n    Combined = lists:sort(Nums1 ++ Nums2),\n    Len = length(Combined),\n    Mid = Len div 2,\n    if\n        Len rem 2 == 1 ->\n            lists:nth(Mid + 1, Combined);\n        true ->\n            (lists:nth(Mid, Combined) + lists:nth(Mid + 1, Combined)) / 2\n    end.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec find_median_sorted_arrays(nums1 :: [integer], nums2 :: [integer]) :: float\n  def find_median_sorted_arrays(nums1, nums2) do\n    merged = Enum.sort(nums1 ++ nums2)\n    \n    length = length(merged)\n    mid = div(length, 2)\n\n    if rem(length, 2) == 0 do\n      (Enum.at(merged, mid - 1) + Enum.at(merged, mid)) / 2.0\n    else\n      Enum.at(merged, mid)\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the median of two sorted arrays with an overall run time complexity of O(log(m+n)). This problem can be efficiently solved using a binary search approach.\n\n# Explanation\n1. **Initialization**: First, we identify the shorter array and assign it to `A`, and the longer array to `B` to minimize the number of elements we iterate through during the binary search.\n2. **Binary Search**: Use binary search to partition both arrays such that:\n   - Left part of partition in `A` and `B` combined is less than or equal to the right part of the partition in `A` and `B`.\n   - Calculate partitions by choosing a middle in `A` and determining the corresponding partition point in `B`.\n3. **Calculate Median**:\n   - If the total number of elements is odd, the median is the maximum value from the left parts.\n   - If the total number of elements is even, the median is the average of the maximum value from the left parts and the minimum value from the right parts.\n4. **Adjustments**: Adjust the binary search based on the comparison results to keep narrowing down the search space until the correct partitions are found.\n\n# Pseudocode\n```\nfunction findMedianSortedArrays(nums1, nums2):\n    # Step 1: Assign A to be the shorter array and B the longer array\n    if len(nums1) > len(nums2):\n        swap(nums1, nums2)\n    \n    A, B = nums1, nums2\n    total_length = len(A) + len(B)\n    half_length = total_length // 2\n    \n    left, right = 0, len(A) - 1\n\n    while true:\n        # Step 2: Perform binary search to partition arrays\n        i = (left + right) // 2\n        j = half_length - i - 2\n        \n        A_left = A[i] if i >= 0 else -infinity\n        A_right = A[i + 1] if (i + 1) < len(A) else infinity\n        B_left = B[j] if j >= 0 else -infinity\n        B_right = B[j + 1] if (j + 1) < len(B) else infinity\n        \n        # Step 3: Check if partition is correct\n        if A_left <= B_right and B_left <= A_right:\n            # Even total length\n            if total_length % 2 == 0:\n                return (max(A_left, B_left) + min(A_right, B_right)) / 2.0\n            # Odd total length\n            else:\n                return min(A_right, B_right)\n        \n        # Step 4: Adjust binary search boundaries\n        elif A_left > B_right:\n            right = i - 1\n        else:\n            left = i + 1\n```\n\nThis pseudocode gives a clear step-by-step approach to solving the problem efficiently, respecting the O(log(m+n)) complexity requirement.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-median-of-two-sorted-arrays"
    },
    {
        "name": "String To Integer Atoi",
        "site": "LeetCode",
        "href": "/solution/LeetCode-string-to-integer-atoi",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int i = 0, sign = 1, result = 0;\n        \n        // Remove leading whitespaces\n        while (i < s.length() && s[i] == ' ') {\n            i++;\n        }\n        \n        // Check for sign\n        if (i < s.length() && (s[i] == '-' || s[i] == '+')) {\n            sign = (s[i++] == '-') ? -1 : 1;\n        }\n        \n        // Convert digits to integer\n        while (i < s.length() && isdigit(s[i])) {\n            int digit = s[i] - '0';\n            \n            // Check for overflow\n            if (result > INT_MAX / 10 || (result == INT_MAX / 10 && digit > INT_MAX % 10)) {\n                return (sign == 1) ? INT_MAX : INT_MIN;\n            }\n            \n            result = result * 10 + digit;\n            i++;\n        }\n        \n        return sign * result;\n    }\n};\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def myAtoi(self, s):\n        s = s.strip()\n        if not s:\n            return 0\n        \n        sign = 1\n        if s[0] == '-':\n            sign = -1\n            s = s[1:]\n        elif s[0] == '+':\n            s = s[1:]\n        \n        res = 0\n        for char in s:\n            if not char.isdigit():\n                break\n            res = res * 10 + int(char)\n        \n        res = max(-2**31, min(sign * res, 2**31 - 1))\n        \n        return res\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "\nint myAtoi(char* s) {\n    int result = 0;\n    int sign = 1;\n    int i = 0;\n    \n    // Skip leading whitespace\n    while (s[i] == ' ') {\n        i++;\n    }\n    \n    // Check for sign\n    if (s[i] == '-') {\n        sign = -1;\n        i++;\n    } else if (s[i] == '+') {\n        i++;\n    }\n    \n    // Read digits and convert to integer\n    while (s[i] >= '0' && s[i] <= '9') {\n        int digit = s[i] - '0';\n        \n        // Check for overflow\n        if (result > INT_MAX / 10 || (result == INT_MAX / 10 && digit > INT_MAX % 10)) {\n            return sign == 1 ? INT_MAX : INT_MIN;\n        }\n        \n        result = result * 10 + digit;\n        i++;\n    }\n    \n    return sign * result;\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "const myAtoi = (s) => {\n    const MAX_INT = Math.pow(2, 31) - 1;\n    const MIN_INT = -Math.pow(2, 31);\n\n    let sign = 1;\n    let result = 0;\n    let i = 0;\n\n    while (s[i] === ' ') {\n        i++;\n    }\n\n    if (s[i] === '+' || s[i] === '-') {\n        sign = s[i] === '+' ? 1 : -1;\n        i++;\n    }\n\n    while (i < s.length && !isNaN(parseInt(s[i]))) {\n        result = result * 10 + parseInt(s[i]);\n        i++;\n    }\n\n    result *= sign;\n\n    if (result > MAX_INT) {\n        return MAX_INT;\n    } else if (result < MIN_INT) {\n        return MIN_INT;\n    } else {\n        return result;\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function myAtoi(s: string): number {\n    const maxInt = Math.pow(2, 31) - 1;\n    const minInt = -Math.pow(2, 31);\n    \n    let sign = 1;\n    let result = 0;\n    let i = 0;\n    \n    while (s[i] === ' ') {\n        i++;\n    }\n    \n    if (s[i] === '-' || s[i] === '+') {\n        sign = s[i] === '-' ? -1 : 1;\n        i++;\n    }\n    \n    for (; i < s.length; i++) {\n        const digit = s.charCodeAt(i) - 48;\n        \n        if (digit < 0 || digit > 9) {\n            break;\n        }\n        \n        if (result > Math.floor((maxInt - digit) / 10)) {\n            return sign === 1 ? maxInt : minInt;\n        }\n        \n        result = result * 10 + digit;\n    }\n    \n    return sign * result;\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func myAtoi(_ s: String) -> Int {\n        var result = 0\n        var sign = 1\n        var i = s.startIndex\n        \n        while i < s.endIndex && s[i] == \" \" {\n            i = s.index(after: i)\n        }\n        \n        if i < s.endIndex && (s[i] == \"+\" || s[i] == \"-\") {\n            sign = s[i] == \"+\" ? 1 : -1\n            i = s.index(after: i)\n        }\n        \n        while i < s.endIndex, let digit = s[i].wholeNumberValue {\n            if result > Int32.max / 10 || (result == Int32.max / 10 && digit > Int32.max % 10) {\n                return sign == 1 ? Int(Int32.max) : Int(Int32.min)\n            }\n            \n            result = result * 10 + digit\n            i = s.index(after: i)\n        }\n        \n        return result * sign\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun myAtoi(s: String): Int {\n        var index = 0\n        var sign = 1\n        var result = 0\n\n        while (index < s.length && s[index] == ' ') {\n            index++\n        }\n\n        if (index < s.length && (s[index] == '-' || s[index] == '+')) {\n            sign = if (s[index] == '-') -1 else 1\n            index++\n        }\n\n        while (index < s.length && s[index].isDigit()) {\n            val digit = s[index] - '0'\n            if (result > Int.MAX_VALUE / 10 || (result == Int.MAX_VALUE / 10 && digit > 7)) {\n                return if (sign == 1) Int.MAX_VALUE else Int.MIN_VALUE\n            }\n            result = result * 10 + digit\n            index++\n        }\n\n        return sign * result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement the `myAtoi` function that converts a string to a 32-bit signed integer based on specific rules. The function involves handling different aspects like whitespace, signedness, conversion from string to integer, and rounding within the 32-bit integer range.\n\n# Explanation\n1. **Whitespace Handling**: Ignore any leading whitespace characters until the non-whitespace character is found.\n2. **Detecting Sign**: Check if the next character is either a negative (`-`) or a positive (`+`) sign to determine the sign of the resulting integer.\n3. **Conversion**: Read in the numbers character by character and form the integer. Skipping any non-digit characters or stop when encountering a non-digit character.\n4. **Clamping**: Ensure the resulting integer is within the bounds of a 32-bit signed integer range (`-2^31` to `2^31 - 1`). If it exceeds this range, clamp it to the nearest boundary value.\n\n# Pseudocode\n```pseudocode\nFunction myAtoi(s: String) -> Integer:\n    # Step 1: Trim leading whitespace\n    s = strip(s)\n    If s is empty:\n        Return 0\n    \n    # Step 2: Determine the sign\n    sign = 1\n    If s[0] == '-' :\n        sign = -1\n        s = s[1:]\n    Else If s[0] == '+':\n        s = s[1:]\n    \n    # Step 3: Convert characters to integer\n    result = 0\n    For each char in s:\n        If char is not a digit:\n            Break\n        result = result * 10 + int(char)\n    \n    # Step 4: Apply the sign\n    result = sign * result\n    \n    # Step 5: Clamp the result within 32-bit signed integer range\n    INT_MIN = -2^31\n    INT_MAX = 2^31 - 1\n    If result < INT_MIN:\n        result = INT_MIN\n    Else If result > INT_MAX:\n        result = INT_MAX\n    \n    Return result\n```\n\nThis pseudocode outlines the steps necessary to convert a string to a 32-bit signed integer according to the rules specified in the challenge. Each step carefully handles edge cases like leading whitespace and non-digit characters, ensuring the final result stays within the defined constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-string-to-integer-atoi"
    },
    {
        "name": "Zigzag Conversion",
        "site": "LeetCode",
        "href": "/solution/LeetCode-zigzag-conversion",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows == 1) {\n            return s;\n        }\n        \n        vector<string> rows(min(numRows, (int)s.size()));\n        int curRow = 0;\n        bool goingDown = false;\n        \n        for (char c : s) {\n            rows[curRow] += c;\n            if (curRow == 0 || curRow == numRows - 1) {\n                goingDown = !goingDown;\n            }\n            curRow += goingDown ? 1 : -1;\n        }\n        \n        string result;\n        for (string row : rows) {\n            result += row;\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1 || s.length() <= numRows) {\n            return s;\n        }\n        \n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) {\n            rows[i] = new StringBuilder();\n        }\n        \n        int direction = 1;\n        int row = 0;\n        for (char c : s.toCharArray()) {\n            rows[row].append(c);\n            row += direction;\n            if (row == 0 || row == numRows - 1) {\n                direction *= -1;\n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (StringBuilder rowString : rows) {\n            result.append(rowString);\n        }\n        \n        return result.toString();\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* convert(char* s, int numRows){\n    if (numRows == 1) {\n        return s;\n    }\n    \n    int len = strlen(s);\n    char* result = (char*)malloc(len + 1);\n    int step = 2 * (numRows - 1);\n    int index = 0;\n    \n    for (int i = 0; i < numRows; i++) {\n        for (int j = i; j < len; j += step) {\n            result[index++] = s[j];\n            if (i > 0 && i < numRows - 1 && j + step - 2 * i < len) {\n                result[index++] = s[j + step - 2 * i];\n            }\n        }\n    }\n    \n    result[len] = '\\0';\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string Convert(string s, int numRows) {\n        if (numRows == 1 || s.Length <= numRows) {\n            return s;\n        }\n        \n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) {\n            rows[i] = new StringBuilder();\n        }\n        \n        int currentRow = 0;\n        bool goingDown = false;\n        \n        foreach (char c in s) {\n            rows[currentRow].Append(c);\n            if (currentRow == 0 || currentRow == numRows - 1) {\n                goingDown = !goingDown;\n            }\n            currentRow += goingDown ? 1 : -1;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        foreach (StringBuilder row in rows) {\n            result.Append(row);\n        }\n        \n        return result.ToString();\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var convert = function(s, numRows) {\n    if (numRows === 1) return s;\n    \n    const rows = new Array(Math.min(numRows, s.length)).fill('');\n    let curRow = 0;\n    let goingDown = false;\n    \n    for (const char of s) {\n        rows[curRow] += char;\n        if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n    \n    return rows.join('');\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function convert(s: string, numRows: number): string {\n    if (numRows === 1) return s;\n\n    const rows: string[] = Array.from({ length: Math.min(numRows, s.length) }, () => \"\");\n    let currentRow = 0;\n    let goingDown = false;\n\n    for (let i = 0; i < s.length; i++) {\n        rows[currentRow] += s[i];\n        if (currentRow === 0 || currentRow === numRows - 1) {\n            goingDown = !goingDown;\n        }\n        currentRow += goingDown ? 1 : -1;\n    }\n\n    return rows.join(\"\");\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func convert(_ s: String, _ numRows: Int) -> String {\n        if numRows == 1 {\n            return s\n        }\n        \n        var rows = Array(repeating: \"\", count: min(numRows, s.count))\n        var currentRow = 0\n        var goingDown = false\n        \n        for char in s {\n            rows[currentRow] += String(char)\n            if currentRow == 0 || currentRow == numRows - 1 {\n                goingDown = !goingDown\n            }\n            currentRow += goingDown ? 1 : -1\n        }\n        \n        return rows.joined()\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func convert(s string, numRows int) string {\n    if numRows == 1 {\n        return s\n    }\n    \n    rows := make([]string, min(numRows, len(s)))\n    curRow := 0\n    goingDown := false\n    \n    for i := 0; i < len(s); i++ {\n        rows[curRow] += string(s[i])\n        if curRow == 0 || curRow == numRows-1 {\n            goingDown = !goingDown\n        }\n        if goingDown {\n            curRow++\n        } else {\n            curRow--\n        }\n    }\n    \n    result := \"\"\n    for _, row := range rows {\n        result += row\n    }\n    \n    return result\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def convert(s, num_rows)\n    return s if num_rows == 1\n    rows = Array.new([s.length, num_rows].min) { \"\" }\n    current_row = 0\n    direction = 1\n    s.each_char do |char|\n        rows[current_row] += char\n        current_row += direction\n        if current_row == num_rows - 1 || current_row == 0\n            direction *= -1\n        end\n    end\n    rows.join\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def convert(s: String, numRows: Int): String = {\n        if (numRows == 1 || s.length <= numRows) return s\n        val result = new StringBuilder\n        val step = 2 * numRows - 2\n        for (i <- 0 until numRows) {\n            var j = i\n            while (j < s.length) {\n                result.append(s(j))\n                if (i != 0 && i != numRows - 1) {\n                    val k = j + step - 2 * i\n                    if (k < s.length) result.append(s(k))\n                }\n                j += step\n            }\n        }\n        result.toString\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn convert(s: String, num_rows: i32) -> String {\n        if num_rows == 1 {\n            return s;\n        }\n        \n        let mut rows: Vec<String> = vec![String::new(); num_rows as usize];\n        let mut index = 0;\n        let mut increment = 1;\n        \n        for c in s.chars() {\n            rows[index as usize].push(c);\n            if index == 0 {\n                increment = 1;\n            } else if index == num_rows - 1 {\n                increment = -1;\n            }\n            index += increment;\n        }\n        \n        let result: String = rows.join(\"\");\n        return result;\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a given string into a zigzag pattern based on a certain number of rows. The zigzag pattern is created by placing characters in a sequence of rows, moving downward until the bottom row is reached, and then moving upward until the top row is reached, repeating this cycle.\n\nTo implement this solution, we can follow these steps:\n\n# Explanation\n\n1. **Handle Edge Cases:** If the number of rows is 1 or if the length of the string is less than or equal to the number of rows, the string remains unchanged.\n2. **Initialize Data Structures:** Create a list of strings, one for each row in the zigzag pattern. Additionally, initialize variables to keep track of the current row and the direction of movement (downward or upward).\n3. **Iterate Through Characters:** Loop through each character in the string, appending it to the appropriate row. Change the direction of movement when the top or bottom row is reached.\n4. **Combine Rows:** Finally, concatenate the strings from each row to form the resultant zigzag pattern.\n\n# Pseudocode\n\n```\nfunction convert(s, numRows):\n    # Handle edge cases\n    if numRows == 1 or len(s) <= numRows:\n        return s\n    \n    # Initialize a list of empty strings for each row\n    rows = [\"\"] * min(numRows, len(s))\n    \n    # Variables to track the current row and direction of movement\n    curRow = 0\n    goingDown = False\n    \n    # Iterate through each character in the input string\n    for char in s:\n        # Append the character to the current row\n        rows[curRow] += char\n        \n        # Change direction if we are at the first or last row\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        \n        # Move to the next or previous row based on the direction\n        curRow += 1 if goingDown else -1\n    \n    # Combine all rows into the final string\n    return \"\".join(rows)\n```\n\nIn this pseudocode:\n- We handle the special cases where no zigzag transformation is necessary.\n- We use a list to store characters for each row.\n- We track the current row and the direction of movement to correctly navigate through the characters.\n- After iteration, we join all the strings from each row to create the final converted string.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-zigzag-conversion"
    },
    {
        "name": "Reverse Integer",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reverse-integer",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int reverse(int x) {\n        long long res = 0;\n        \n        while (x != 0) {\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        \n        return (res < INT_MIN || res > INT_MAX) ? 0 : (int)res;\n    }\n};\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int reverse(int x) {\n    long reversed = 0;\n    \n    while (x != 0) {\n        int digit = x % 10;\n        x /= 10;\n        \n        reversed = reversed * 10 + digit;\n        \n        if (reversed > INT_MAX || reversed < INT_MIN) {\n            return 0;\n        }\n    }\n    \n    return (int)reversed;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Reverse(int x) {\n        int reversed = 0;\n        \n        while (x != 0) {\n            int digit = x % 10;\n            x /= 10;\n            \n            if (reversed > int.MaxValue / 10 || (reversed == int.MaxValue / 10 && digit > 7)) return 0;\n            if (reversed < int.MinValue / 10 || (reversed == int.MinValue / 10 && digit < -8)) return 0;\n            \n            reversed = reversed * 10 + digit;\n        }\n        \n        return reversed;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "const reverse = function(x) {\n    const reversed = parseInt(Math.abs(x).toString().split('').reverse().join('')) * Math.sign(x);\n    if (reversed < Math.pow(-2, 31) || reversed > Math.pow(2, 31) - 1) {\n        return 0;\n    }\n    return reversed;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function reverse(x: number): number {\n    const limit = 2 ** 31;\n    const reversed = parseInt(x.toString().split('').reverse().join(''));\n    \n    if (x < 0) {\n        return reversed > limit ? 0 : -reversed;\n    } else {\n        return reversed >= limit ? 0 : reversed;\n    }\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func reverse(_ x: Int) -> Int {\n        var input = x\n        var output = 0\n        \n        while input != 0 {\n            let digit = input % 10\n            input /= 10\n            \n            if output > Int32.max / 10 || (output == Int32.max / 10 && digit > 7) {\n                return 0\n            }\n            if output < Int32.min / 10 || (output == Int32.min / 10 && digit < -8) {\n                return 0\n            }\n            \n            output = output * 10 + digit\n        }\n        \n        return output\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func reverse(x int) int {\n    var reversed int\n    for x != 0 {\n        digit := x % 10\n        x /= 10\n        reversed = reversed*10 + digit\n        \n        if reversed > math.MaxInt32 || reversed < math.MinInt32 {\n            return 0\n        }\n    }\n    \n    return reversed\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def reverse(x)\n    reversed = x.abs.to_s.reverse.to_i\n    reversed = -reversed if x < 0\n    return 0 if reversed.bit_length >= 32\n    return reversed\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def reverse(x: Int): Int = {\n        var reverseNum = 0\n        var tempX = x\n\n        while (tempX != 0) {\n            val digit = tempX % 10\n            tempX = tempX / 10\n\n            if (reverseNum > Int.MaxValue / 10 || (reverseNum == Int.MaxValue / 10 && digit > 7)) return 0\n            if (reverseNum < Int.MinValue / 10 || (reverseNum == Int.MinValue / 10 && digit < -8)) return 0\n\n            reverseNum = reverseNum * 10 + digit\n        }\n\n        reverseNum\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn reverse(x: i32) -> i32 {\n        let mut rev = 0;\n        let mut num = x.abs();\n\n        while num != 0 {\n            let digit = num % 10;\n            num /= 10;\n\n            if rev > (i32::MAX - digit) / 10 {\n                return 0;\n            }\n\n            rev = rev * 10 + digit;\n        }\n\n        if x < 0 {\n            rev *= -1;\n        }\n\n        rev\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to reverse the digits of a given 32-bit signed integer `x`. If the reversed integer goes beyond the range of a signed 32-bit integer `[-2^31, 2^31 - 1]`, we will return `0`.\n\n## Explanation\n1. **Reading Input:**\n   - Accept an integer `x` as input.\n\n2. **Convert and Reverse:**\n   - Convert the integer to its absolute value, convert it to a string, reverse the string, and convert it back to an integer.\n   - Restore the original sign of `x`.\n\n3. **Check Range:**\n   - Verify if the reversed integer lies within the 32-bit signed integer range. If it doesn\u2019t, return `0`.\n\n4. **Return Result:**\n   - If it lies within the valid range, return the reversed integer.\n\n## Pseudocode\n```pseudocode\nFUNCTION reverseInteger(x):\n    # Define the 32-bit signed integer range constants\n    MIN_INT = -2^31\n    MAX_INT = 2^31 - 1\n    \n    # Get the absolute value and reverse the digits\n    reversed_digits = string(reverse(string(abs(x))))\n    \n    # Convert the reversed string back to integer and apply the original sign\n    reversed_int = integer(reversed_digits) * sign(x)\n    \n    # Check for overflow\n    IF reversed_int < MIN_INT OR reversed_int > MAX_INT:\n        RETURN 0\n    ELSE:\n        RETURN reversed_int\n```\n\nThis pseudocode outlines the process of how to convert an integer, reverse its digits, and check for overflow conditions as per the requirements given.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reverse-integer"
    },
    {
        "name": "Palindrome Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-palindrome-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n        return x == reversed || x == reversed / 10;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if(x < 0){\n            return false;\n        }\n        \n        int original = x;\n        int reversed = 0;\n        \n        while(x != 0){\n            int digit = x % 10;\n            reversed = reversed * 10 + digit;\n            x = x / 10;\n        }\n        \n        return original == reversed;\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, let's explain the methodology for determining whether a given integer is a palindrome without converting it to a string.\n\n## Explanation\n\n1. **Initial Check for Negative Numbers and Zero**:\n   - If the integer is negative, it cannot be a palindrome because the negative sign will not match no matter how the digits are reversed.\n   - If the integer ends in 0, it also cannot be a palindrome unless the integer itself is 0, because the leading zero on the reversed number will invalidate the condition.\n\n2. **Reversion of the Number**:\n   - We need to reverse the integer partially to compare the non-reversed part with the reversed part. This can be achieved using a loop that extracts digits and forms the reversed half of the integer.\n   - To reverse the integer partially, we can extract the last digit of the number by using the modulus operator (`x % 10`) and then add this digit to the reversed half.\n\n3. **Comparison**:\n   - We continue reversing the integer until the original number becomes smaller or equal to the reversed half.\n   - Finally, we compare the original number and the reversed half. If the length of the number is odd, we can ignore the middle digit by dividing the reversed number by 10.\n\nLet's outline the pseudocode to achieve this:\n\n## Pseudocode\n\n```\nfunction isPalindrome(x):\n    # Check if the number is negative or ends in zero but not zero itself.\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return false\n\n    reversed = 0\n\n    # Loop until the original number is less than or equal to the reversed number\n    while x > reversed:\n        reversed = reversed * 10 + x % 10\n        x = x // 10\n\n    # Check if the number is palindromic\n    # Either the number is the same as the reversed number\n    # Or the original number without the middle digit matches the reversed number \n    return x == reversed or x == reversed // 10\n```\n\nThis pseudocode will provide a guideline to implementing the `isPalindrome` function effectively while ensuring that the integer is not converted to a string. The key steps are extracting and reversing the digits and comparing the resulting values.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-palindrome-number"
    },
    {
        "name": "Regular Expression Matching",
        "site": "LeetCode",
        "href": "/solution/LeetCode-regular-expression-matching",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.length();\n        int n = p.length();\n        \n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\n        \n        dp[0][0] = true;\n        \n        for(int j=1; j<=n; j++){\n            if(p[j-1] == '*'){\n                dp[0][j] = dp[0][j-2];\n            }\n        }\n        \n        for(int i=1; i<=m; i++){\n            for(int j=1; j<=n; j++){\n                if(s[i-1] == p[j-1] || p[j-1] == '.'){\n                    dp[i][j] = dp[i-1][j-1];\n                }\n                else if(p[j-1] == '*'){\n                    dp[i][j] = dp[i][j-2] || (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j];\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\n        dp[0][0] = true;\n        \n        for (int i = 0; i <= s.length(); i++) {\n            for (int j = 1; j <= p.length(); j++) {\n                if (p.charAt(j-1) == '*') {\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.') && dp[i-1][j]);\n                } else {\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.');\n                }\n            }\n        }\n        \n        return dp[s.length()][p.length()];\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n        \n        return dp[len(s)][len(p)]\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isMatch(char* s, char* p) {\n    int len_s = strlen(s);\n    int len_p = strlen(p);\n\n    bool dp[len_s + 1][len_p + 1];\n    memset(dp, false, sizeof(dp));\n    dp[0][0] = true;\n\n    for (int i = 0; i <= len_s; i++) {\n        for (int j = 1; j <= len_p; j++) {\n            if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]);\n            } else {\n                dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');\n            }\n        }\n    }\n\n    return dp[len_s][len_p];\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a function that performs regular expression matching with support for two special characters, '.' and '*'. We'll use dynamic programming to build a solution that checks if the string `s` matches the pattern `p` completely.\n\n# Explanation\n1. **Dynamic Programming Table (dp)**: We create a 2D table `dp` where `dp[i][j]` indicates whether `s[:i]` matches `p[:j]`.\n2. **Initialization**:\n   - `dp[0][0]` is `True` because an empty string matches an empty pattern.\n   - For patterns like \"a*\", \"a*b*\", etc., which can match an empty string. Thus, we initialize the first row (`dp[0][j]`).\n3. **Filling the Table**:\n   - If the current characters match (`p[j-1] == s[i-1]` or `p[j-1] == '.'`), set `dp[i][j]` to `dp[i-1][j-1]`.\n   - If the current pattern character is '*' (`p[j-1] == '*'`), there are two cases:\n     - We can ignore the \"*\" and the preceding element (`dp[i][j] = dp[i][j-2]`).\n     - We account for the \"*\" to match multiple characters (`dp[i][j] = dp[i-1][j]`), but only if the preceding pattern character matches the current string character (`p[j-2] == s[i-1]` or `p[j-2] == '.'`).\n\n# Pseudocode\n```pseudocode\nfunction isMatch(s, p):\n    Let m be the length of s\n    Let n be the length of p\n    Create a 2D array dp of size (m+1) x (n+1) initialized to False\n    dp[0][0] = True  # Empty string and empty pattern match\n\n    # Initialize dp for patterns like a*, a*b*, etc.\n    for j from 1 to n:\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-2]\n\n    # Fill the dp table\n    for i from 1 to m:\n        for j from 1 to n:\n            if p[j-1] == s[i-1] or p[j-1] == '.':\n                dp[i][j] = dp[i-1][j-1]\n            else if p[j-1] == '*':\n                dp[i][j] = dp[i][j-2]  # Consider zero occurrences of the preceding element\n                if p[j-2] == s[i-1] or p[j-2] == '.':\n                    dp[i][j] = dp[i][j] or dp[i-1][j]  # Consider one or more occurrences\n\n    return dp[m][n]\n```\nThis pseudocode outlines how to fill the dynamic programming table to determine if the string matches the pattern, accommodating the special characters `.` and `*` according to the rules specified.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-regular-expression-matching"
    },
    {
        "name": "Longest Common Prefix",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-common-prefix",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) {\n            return \"\";\n        }\n        \n        string prefix = strs[0];\n        \n        for (int i = 1; i < strs.size(); i++) {\n            while (strs[i].find(prefix) != 0) {\n                prefix = prefix.substr(0, prefix.length() - 1);\n                if (prefix.empty()) {\n                    return \"\";\n                }\n            }\n        }\n        \n        return prefix;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n        \n        String prefix = strs[0];\n        for (int i = 1; i < strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) {\n                    return \"\";\n                }\n            }\n        }\n        \n        return prefix;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def longestCommonPrefix(self, strs):\n        if not strs:\n            return \"\"\n        \n        strs.sort()\n        \n        prefix = \"\"\n        for i in range(len(strs[0])):\n            if strs[0][i] == strs[-1][i]:\n                prefix += strs[0][i]\n            else:\n                break\n        \n        return prefix\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* longestCommonPrefix(char** strs, int strsSize) {\n    if (strsSize == 0) {\n        return \"\";\n    }\n    \n    int i, j;\n    for (i = 0; i < strlen(strs[0]); i++) {\n        for (j = 1; j < strsSize; j++) {\n            if (strs[j][i] != strs[0][i] || strs[j][i] == '\\0') {\n                char* result = (char*)malloc(sizeof(char) * (i+1));\n                strncpy(result, strs[0], i);\n                result[i] = '\\0';\n                return result;\n            }\n        }\n    }\n    \n    return strs[0]; // if input array is empty or contains only 1 element\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function(strs) {\n    if (strs.length === 0) {\n        return \"\";\n    }\n    \n    let prefix = strs[0];\n    for (let i = 1; i < strs.length; i++) {\n        while (strs[i].indexOf(prefix) !== 0) {\n            prefix = prefix.substring(0, prefix.length - 1);\n        }\n        if (prefix === \"\") {\n            break;\n        }\n    }\n    \n    return prefix;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function longestCommonPrefix(strs: string[]): string {\n    if (strs.length === 0) return \"\";\n    \n    let prefix = \"\";\n    for (let i = 0; i < strs[0].length; i++) {\n        const char = strs[0][i];\n        for (let j = 1; j < strs.length; j++) {\n            if (i === strs[j].length || strs[j][i] !== char) {\n                return prefix;\n            }\n        }\n        prefix += char;\n    }\n    \n    return prefix;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[] $strs\n     * @return String\n     */\n    function longestCommonPrefix($strs) {\n        if (empty($strs)) {\n            return \"\";\n        }\n        \n        $prefix = $strs[0];\n        \n        for ($i = 1; $i < count($strs); $i++) {\n            while (strpos($strs[$i], $prefix) !== 0) {\n                $prefix = substr($prefix, 0, -1);\n                if (empty($prefix)) {\n                    return \"\";\n                }\n            }\n        }\n        \n        return $prefix;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func longestCommonPrefix(_ strs: [String]) -> String {\n        guard let firstStr = strs.first else {\n            return \"\"\n        }\n        \n        var prefix = \"\"\n        for (i, char) in firstStr.enumerated() {\n            for str in strs.dropFirst() {\n                if i >= str.count || str[str.index(str.startIndex, offsetBy: i)] != char {\n                    return prefix\n                }\n            }\n            prefix.append(char)\n        }\n        \n        return prefix\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun longestCommonPrefix(strs: Array<String>): String {\n        if (strs.isEmpty()) {\n            return \"\"\n        }\n        \n        var prefix = strs[0]\n        for (i in 1 until strs.size) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length - 1)\n                if (prefix.isEmpty()) {\n                    return \"\"\n                }\n            }\n        }\n        \n        return prefix\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String longestCommonPrefix(List<String> strs) {\n    if (strs.isEmpty) {\n      return \"\";\n    }\n\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++) {\n      while (strs[i].indexOf(prefix) != 0) {\n        prefix = prefix.substring(0, prefix.length - 1);\n        if (prefix.isEmpty) {\n          return \"\";\n        }\n      }\n    }\n    return prefix;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func longestCommonPrefix(strs []string) string {\n    if len(strs) == 0 {\n        return \"\"\n    }\n    prefix := strs[0]\n    for i := 1; i < len(strs); i++ {\n        for strings.Index(strs[i], prefix) != 0 {\n            prefix = prefix[:len(prefix)-1]\n            if prefix == \"\" {\n                return \"\"\n            }\n        }\n    }\n    return prefix\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @return {String}\ndef longest_common_prefix(strs)\n    return \"\" if strs.empty?\n    \n    prefix = strs.min_by(&:length)\n    \n    strs.each do |str|\n        prefix = prefix.chop until str.start_with?(prefix)\n    end\n    \n    prefix\nend"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn longest_common_prefix(strs: Vec<String>) -> String {\n        if strs.is_empty() {\n            return String::new();\n        }\n        \n        let mut prefix = strs[0].clone();\n        \n        for i in 1..strs.len() {\n            while !strs[i].starts_with(&prefix) {\n                prefix.pop();\n            }\n        }\n        \n        prefix\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the longest common prefix string amongst an array of strings. If there is no common prefix, we'll return an empty string. \n\n# Explanation\n\n1. **Check for empty input**: First, we need to handle the edge case where the input list is empty. If it is, we simply return an empty string.\n\n2. **Sort the list**: Sorting the list of strings will help in simplifying the comparison because the smallest and largest strings (lexicographically) will be at the first and last positions in the list respectively. The common prefix of the entire list will be the common prefix between these two strings.\n\n3. **Initialize the prefix**: Start with an empty string for storing the prefix.\n\n4. **Character by character comparison**: Compare the characters of the first and last strings. If they match, add the character to the prefix. If they don't match, stop the comparison because no further characters will be common beyond the current position.\n\n5. **Return the prefix**: Finally, return the constructed prefix.\n\n# Pseudocode\n\n```\nFUNCTION longestCommonPrefix(strs):\n    IF strs is empty:\n        RETURN \"\"\n    \n    SORT strs\n    \n    SET first_string to strs[0]\n    SET last_string to strs[-1]\n    SET prefix to \"\"\n    \n    FOR each index in range of length of first_string:\n        IF first_string[index] is equal to last_string[index]:\n            ADD first_string[index] to prefix\n        ELSE:\n            BREAK\n    \n    RETURN prefix\n```\n\nThis approach ensures that we efficiently find the longest common prefix by leveraging the sorting property to minimize the number of comparisons.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-common-prefix"
    },
    {
        "name": "Container With Most Water",
        "site": "LeetCode",
        "href": "/solution/LeetCode-container-with-most-water",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int maxArea = 0;\n        int left = 0;\n        int right = height.size() - 1;\n        \n        while (left < right) {\n            int minHeight = min(height[left], height[right]);\n            maxArea = max(maxArea, minHeight * (right - left));\n            \n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return maxArea;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxArea(int[] height) {\n        int maxArea = 0;\n        int left = 0;\n        int right = height.length - 1;\n        \n        while (left < right) {\n            int h = Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, h * (right - left));\n            \n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return maxArea;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            h = min(height[left], height[right])\n            max_area = max(max_area, h * (right - left))\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxArea(int* height, int heightSize) {\n    int max = 0;\n    int left = 0;\n    int right = heightSize - 1;\n    \n    while (left < right) {\n        int current = (right - left) * fmin(height[left], height[right]);\n        max = fmax(max, current);\n        \n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return max;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxArea(int[] height) {\n        int maxArea = 0;\n        int left = 0;\n        int right = height.Length - 1;\n\n        while (left < right) {\n            int currentArea = Math.Min(height[left], height[right]) * (right - left);\n            maxArea = Math.Max(maxArea, currentArea);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxArea;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    let maxWater = 0;\n    let left = 0;\n    let right = height.length - 1;\n    \n    while (left < right) {\n        const h = Math.min(height[left], height[right]);\n        const w = right - left;\n        maxWater = Math.max(maxWater, h * w);\n        \n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return maxWater;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxArea(height: number[]): number {\n    let max = 0;\n    let left = 0;\n    let right = height.length - 1;\n\n    while (left < right) {\n        const currentArea = Math.min(height[left], height[right]) * (right - left);\n        max = Math.max(max, currentArea);\n\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return max;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $height\n     * @return Integer\n     */\n    function maxArea($height) {\n        $maxArea = 0;\n        $left = 0;\n        $right = count($height) - 1;\n        \n        while ($left < $right) {\n            $area = min($height[$left], $height[$right]) * ($right - $left);\n            $maxArea = max($maxArea, $area);\n            \n            if ($height[$left] < $height[$right]) {\n                $left++;\n            } else {\n                $right--;\n            }\n        }\n        \n        return $maxArea;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxArea(_ height: [Int]) -> Int {\n        var maxArea = 0\n        var left = 0\n        var right = height.count - 1\n        \n        while left < right {\n            let currentArea = min(height[left], height[right]) * (right - left)\n            maxArea = max(maxArea, currentArea)\n            \n            if height[left] < height[right] {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n        \n        return maxArea\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxArea(height: IntArray): Int {\n        var left = 0\n        var right = height.size - 1\n        var maxArea = 0\n        \n        while (left < right) {\n            val currentArea = (right - left) * minOf(height[left], height[right])\n            maxArea = maxOf(maxArea, currentArea)\n            \n            if (height[left] < height[right]) {\n                left++\n            } else {\n                right--\n            }\n        }\n        \n        return maxArea\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maxArea(List<int> height) {\n    int maxArea = 0;\n    int left = 0;\n    int right = height.length - 1;\n\n    while (left < right) {\n      int currentArea = (right - left) * (height[left] < height[right] ? height[left] : height[right]);\n      maxArea = currentArea > maxArea ? currentArea : maxArea;\n\n      if (height[left] < height[right]) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n\n    return maxArea;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxArea(height []int) int {\n    left, right := 0, len(height)-1\n    maxArea := 0\n    \n    for left < right {\n        h := min(height[left], height[right])\n        maxArea = max(maxArea, h*(right-left))\n        \n        if height[left] < height[right] {\n            left++\n        } else {\n            right--\n        }\n    }\n    \n    return maxArea\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} height\n# @return {Integer}\ndef max_area(height)\n    max_area = 0\n    left = 0\n    right = height.length - 1\n    \n    while left < right\n        current_area = [height[left], height[right]].min * (right - left)\n        max_area = [max_area, current_area].max\n        \n        if height[left] < height[right]\n            left += 1\n        else\n            right -= 1\n        end\n    end\n    \n    return max_area\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxArea(height: Array[Int]): Int = {\n        var maxArea = 0\n        var left = 0\n        var right = height.length - 1\n        \n        while (left < right) {\n            val currentArea = (right - left) * Math.min(height(left), height(right))\n            maxArea = Math.max(maxArea, currentArea)\n            \n            if (height(left) < height(right)) {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n        \n        maxArea\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_area(height: Vec<i32>) -> i32 {\n        let mut max_area = 0;\n        let mut left = 0;\n        let mut right = height.len() - 1;\n        \n        while left < right {\n            let h = std::cmp::min(height[left], height[right]);\n            max_area = std::cmp::max(max_area, h * (right - left) as i32);\n            \n            if height[left] < height[right] {\n                left += 1;\n            } else {\n                right -= 1;\n            }\n        }\n        \n        max_area\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can employ the two-pointer technique. This technique is efficient for problems where you need to check pairs of elements and can often reduce the time complexity from O(n^2) to O(n).\n\n# Explanation\n\n1. Initialize two pointers, `left` starting at the beginning (index 0) and `right` at the end (index n-1) of the array.\n2. Calculate the area formed between these two lines. The area is determined by the shorter vertical line (to ensure it forms a \"container\") multiplied by the width (distance between the pointers).\n3. Update the maximum area if the current area is greater.\n4. Move the pointer pointing to the shorter line inward to potentially find a larger container.\n5. Repeat the process until the pointers meet.\n6. The maximum area found is the result.\n\n# Pseudocode\n\n```\nfunction maxArea(height):\n    # Initialize the maximum area as 0\n    max_area = 0\n    \n    # Initialize two pointers, left and right\n    left = 0\n    right = length of height - 1\n    \n    # Loop until the two pointers meet\n    while left < right:\n        # Calculate the current area\n        h = min(height[left], height[right])\n        current_area = h * (right - left)\n        \n        # Update the maximum area if needed\n        max_area = max(max_area, current_area)\n        \n        # Move the pointer of the shorter line inward\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area\n```\n\nThis method ensures we efficiently find the maximum area by examining each potential container a single time, yielding an O(n) time complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-container-with-most-water"
    },
    {
        "name": "Integer To Roman",
        "site": "LeetCode",
        "href": "/solution/LeetCode-integer-to-roman",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string result = \"\";\n        vector<int> values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        vector<string> symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n        for (int i = 0; i < values.size(); i++) {\n            while (num >= values[i]) {\n                num -= values[i];\n                result += symbols[i];\n            }\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String intToRoman(int num) {\n        // create arrays to store the Roman numeral symbols and their corresponding values\n        String[] romanSymbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        int[] romanValues = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        \n        // create a StringBuilder to store the result\n        StringBuilder sb = new StringBuilder();\n        \n        // iterate through the arrays to construct the Roman numeral\n        for (int i = 0; i < romanValues.length; i++) {\n            while (num >= romanValues[i]) {\n                sb.append(romanSymbols[i]);\n                num -= romanValues[i];\n            }\n        }\n        \n        return sb.toString();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        val = [\n            1000, 900, 500, 400,\n            100, 90, 50, 40,\n            10, 9, 5, 4,\n            1\n        ]\n        syms = [\n            \"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"\n        ]\n        \n        res = ''\n        for i in range(len(val)):\n            while num >= val[i]:\n                num -= val[i]\n                res += syms[i]\n                \n        return res\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* intToRoman(int num) {\n    char* roman_numerals[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n    char* result = (char*)malloc(20 * sizeof(char));\n    result[0] = '\\0';\n\n    for (int i = 0; i < 13; i++) {\n        while (num >= values[i]) {\n            strcat(result, roman_numerals[i]);\n            num -= values[i];\n        }\n    }\n\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string IntToRoman(int num) {\n        StringBuilder result = new StringBuilder();\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string[] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        \n        for (int i = 0; i < values.Length; i++) {\n            while (num >= values[i]) {\n                num -= values[i];\n                result.Append(romans[i]);\n            }\n        }\n        \n        return result.ToString();\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function intToRoman(num: number): string {\n    const romanNumerals: [number, string][] = [\n        [1000, 'M'],\n        [900, 'CM'],\n        [500, 'D'],\n        [400, 'CD'],\n        [100, 'C'],\n        [90, 'XC'],\n        [50, 'L'],\n        [40, 'XL'],\n        [10, 'X'],\n        [9, 'IX'],\n        [5, 'V'],\n        [4, 'IV'],\n        [1, 'I'],\n    ];\n\n    let result = '';\n\n    for (const [value, symbol] of romanNumerals) {\n        while (num >= value) {\n            result += symbol;\n            num -= value;\n        }\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $num\n     * @return String\n     */\n    function intToRoman($num) {\n        $map = [\n            1000 => \"M\",\n            900 => \"CM\",\n            500 => \"D\",\n            400 => \"CD\",\n            100 => \"C\",\n            90 => \"XC\",\n            50 => \"L\",\n            40 => \"XL\",\n            10 => \"X\",\n            9 => \"IX\",\n            5 => \"V\",\n            4 => \"IV\",\n            1 => \"I\",\n        ];\n        \n        $result = \"\";\n        \n        foreach ($map as $value => $roman) {\n            while ($num >= $value) {\n                $result .= $roman;\n                $num -= $value;\n            }\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func intToRoman(_ num: Int) -> String {\n        let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        let romanNumerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        \n        var result = \"\"\n        var num = num\n        \n        for i in 0..<values.count {\n            while num >= values[i] {\n                result += romanNumerals[i]\n                num -= values[i]\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun intToRoman(num: Int): String {\n        val values = intArrayOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        val symbols = arrayOf(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n        var result = StringBuilder()\n        var remaining = num\n\n        for (i in values.indices) {\n            while (remaining >= values[i]) {\n                result.append(symbols[i])\n                remaining -= values[i]\n            }\n        }\n\n        return result.toString()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String intToRoman(int num) {\n    List<String> romanNumerals = [\n      \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n    ];\n    List<int> numbers = [\n      1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    ];\n\n    String result = \"\";\n    for (int i = 0; i < romanNumerals.length; i++) {\n      while (num >= numbers[i]) {\n        result += romanNumerals[i];\n        num -= numbers[i];\n      }\n    }\n\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func intToRoman(num int) string {\n    roman := \"\"\n    \n    numerals := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    symbols := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    \n    for i := 0; i < len(numerals); i++ {\n        for num >= numerals[i] {\n            num -= numerals[i]\n            roman += symbols[i]\n        }\n    }\n    \n    return roman\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} num\n# @return {String}\ndef int_to_roman(num)\n    roman_map = {\n        1000 => \"M\", 900 => \"CM\", 500 => \"D\", 400 => \"CD\", 100 => \"C\",\n        90 => \"XC\", 50 => \"L\", 40 => \"XL\", 10 => \"X\", 9 => \"IX\", 5 => \"V\",\n        4 => \"IV\", 1 => \"I\"\n    }\n    \n    roman = \"\"\n    \n    roman_map.each do |value, letter|\n        while num >= value\n            roman += letter\n            num -= value\n        end\n    end\n    \n    return roman\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def intToRoman(num: Int): String = {\n        val romanNumerals = Array(\n            \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\",\n            \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n        )\n        val decimalValues = Array(\n            1000, 900, 500, 400, 100, 90,\n            50, 40, 10, 9, 5, 4, 1\n        )\n\n        var result = \"\"\n        var remaining = num\n\n        for (i <- decimalValues.indices) {\n            while (remaining >= decimalValues(i)) {\n                result += romanNumerals(i)\n                remaining -= decimalValues(i)\n            }\n        }\n\n        result\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn int_to_roman(num: i32) -> String {\n        let mut num = num;\n        let values = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n        let symbols = vec![\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"];\n        let mut result = String::new();\n\n        for i in 0..values.len() {\n            while num >= values[i] {\n                result.push_str(symbols[i]);\n                num -= values[i];\n            }\n        }\n\n        result\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (int-to-roman num)\n  (-> exact-integer? string?)\n  (define numerals\n    '((1000 . \"M\") (900 . \"CM\") (500 . \"D\") (400 . \"CD\") (100 . \"C\")\n      (90 . \"XC\") (50 . \"L\") (40 . \"XL\") (10 . \"X\") (9 . \"IX\") (5 . \"V\")\n      (4 . \"IV\") (1 . \"I\")))\n  (define (int-to-roman-helper num numerals)\n    (cond\n      [(null? numerals) \"\"]\n      [(>= num (caar numerals))\n       (string-append (cdar numerals) (int-to-roman-helper (- num (caar numerals)) numerals))]\n      [else (int-to-roman-helper num (cdr numerals))]))\n  (int-to-roman-helper num numerals)\n  )\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec int_to_roman(num :: integer) :: String.t\n  def int_to_roman(num) do\n    roman_numerals = [\n      {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n      {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n      {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    ]\n    \n    convert(num, roman_numerals, \"\")\n  end\n  \n  defp convert(0, _roman_numerals, result), do: result\n  defp convert(num, roman_numerals, result) do\n    [{value, roman} | tail] = roman_numerals\n    \n    if num >= value do\n      convert(num - value, roman_numerals, result <> roman)\n    else\n      convert(num, tail, result)\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a given integer into its equivalent Roman numeral representation. The Roman numeral system uses specific character-literal mappings that we must leverage to perform the conversion.\n\n## Explanation\n\nThe key steps to solve the problem are as follows:\n\n1. **Map Roman Numerical Values**: Create a list of numerical values in descending order and their corresponding Roman numeral symbols.\n2. **Iterate and Convert**: Begin by iterating over the list of values, and for each value:\n   - Check if the current number (`num`) is greater than or equal to the value.\n   - Subtract the value from the number and append the corresponding Roman numeral symbol to the result string.\n   - Repeat this process until the number is reduced to zero.\n\nSince Roman numerals include symbols for specific patterns such as 4 (IV) and 9 (IX), these patterns are included in the mapping to ensure proper conversion.\n\n## Pseudocode\n\nHere is the pseudocode to guide the implementation:\n\n```\n# Given function to convert integer to Roman numeral\ndef intToRoman(num):\n    # List of values and corresponding Roman numeral symbols\n    val = [1000, 900, 500, 400,\n           100, 90, 50, 40,\n           10, 9, 5, 4,\n           1]\n    syms = [\"M\", \"CM\", \"D\", \"CD\",\n            \"C\", \"XC\", \"L\", \"XL\",\n            \"X\", \"IX\", \"V\", \"IV\",\n            \"I\"]\n\n    # Initialize the result string\n    res = ''\n\n    # Iterate through the values\n    for i in range(len(val)):\n        # For each value, check while the number is greater or equal to the value\n        while num >= val[i]:\n            # Subtract the value from the number\n            num -= val[i]\n            # Add the corresponding Roman numeral symbol to the result\n            res += syms[i]\n\n    # Return the result string containing the Roman numeral representation\n    return res\n```\n\nThis pseudocode outlines a clear step-by-step method to convert an integer into its Roman numeral equivalent by breaking down the number into its constituent Roman numeral symbols efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-integer-to-roman"
    },
    {
        "name": "Roman To Integer",
        "site": "LeetCode",
        "href": "/solution/LeetCode-roman-to-integer",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> romanMap = {\n            {'I', 1},\n            {'V', 5},\n            {'X', 10},\n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000}\n        };\n        \n        int result = 0;\n        int prevValue = 0;\n        \n        for (int i = s.size() - 1; i >= 0; i--) {\n            int curValue = romanMap[s[i]];\n            if (curValue < prevValue) {\n                result -= curValue;\n            } else {\n                result += curValue;\n            }\n            prevValue = curValue;\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int romanToInt(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        map.put('I', 1);\n        map.put('V', 5);\n        map.put('X', 10);\n        map.put('L', 50);\n        map.put('C', 100);\n        map.put('D', 500);\n        map.put('M', 1000);\n        \n        int prev = 0;\n        int result = 0;\n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            int value = map.get(s.charAt(i));\n            \n            if (value < prev) {\n                result -= value;\n            } else {\n                result += value;\n            }\n            \n            prev = value;\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = roman_dict[s[-1]]\n        \n        for i in range(len(s) - 1):\n            if roman_dict[s[i]] < roman_dict[s[i + 1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        \n        return result\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int romanToInt(char* s) {\n    int num = 0;\n    \n    for(int i = 0; s[i] != '\\0'; i++) {\n        if(s[i] == 'I' && (s[i+1] == 'V' || s[i+1] == 'X')) {\n            num -= 1;\n        } else if(s[i] == 'X' && (s[i+1] == 'L' || s[i+1] == 'C')) {\n            num -= 10;\n        } else if(s[i] == 'C' && (s[i+1] == 'D' || s[i+1] == 'M')) {\n            num -= 100;\n        } else {\n            switch(s[i]) {\n                case 'I': num += 1; break;\n                case 'V': num += 5; break;\n                case 'X': num += 10; break;\n                case 'L': num += 50; break;\n                case 'C': num += 100; break;\n                case 'D': num += 500; break;\n                case 'M': num += 1000; break;\n            }\n        }\n    }\n    \n    return num;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int RomanToInt(string s) {\n        Dictionary<char, int> romanValues = new Dictionary<char, int>\n        {\n            {'I', 1},\n            {'V', 5},\n            {'X', 10},\n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000}\n        };\n        \n        int result = 0;\n        for (int i = 0; i < s.Length; i++)\n        {\n            if (i < s.Length - 1 && romanValues[s[i]] < romanValues[s[i + 1]])\n            {\n                result -= romanValues[s[i]];\n            }\n            else\n            {\n                result += romanValues[s[i]];\n            }\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\n    const romanToIntMap = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    };\n    \n    let result = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (i < s.length - 1 && romanToIntMap[s[i]] < romanToIntMap[s[i + 1]]) {\n            result -= romanToIntMap[s[i]];\n        } else {\n            result += romanToIntMap[s[i]];\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function romanToInt(s: string): number {\n    const romanMap: { [key: string]: number } = {\n        I: 1,\n        V: 5,\n        X: 10,\n        L: 50,\n        C: 100,\n        D: 500,\n        M: 1000\n    };\n\n    let result: number = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        if (romanMap[s[i]] < romanMap[s[i + 1]]) {\n            result += romanMap[s[i + 1]] - romanMap[s[i]];\n            i++;\n        } else {\n            result += romanMap[s[i]];\n        }\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function romanToInt($s) {\n        $romanToInt = [\n            'I' => 1,\n            'V' => 5,\n            'X' => 10,\n            'L' => 50,\n            'C' => 100,\n            'D' => 500,\n            'M' => 1000\n        ];\n        \n        $result = 0;\n        \n        for ($i = 0; $i < strlen($s); $i++) {\n            if ($i < strlen($s) - 1 && $romanToInt[$s[$i]] < $romanToInt[$s[$i+1]]) {\n                $result -= $romanToInt[$s[$i]];\n            } else {\n                $result += $romanToInt[$s[$i]];\n            }\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func romanToInt(_ s: String) -> Int {\n        var romanValues: [Character: Int] = [\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000\n        ]\n        \n        var result = 0\n        var prevValue = 0\n        \n        for char in s {\n            if let value = romanValues[char] {\n                result += value\n                if value > prevValue {\n                    result -= 2 * prevValue\n                }\n                prevValue = value\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun romanToInt(s: String): Int {\n        val map = hashMapOf<Char, Int>(\n            'I' to 1,\n            'V' to 5,\n            'X' to 10,\n            'L' to 50,\n            'C' to 100,\n            'D' to 500,\n            'M' to 1000\n        )\n        \n        var result = 0\n        var prevValue = 0\n        \n        for (i in s.length - 1 downTo 0) {\n            val value = map[s[i]]!!\n            if (value < prevValue) {\n                result -= value\n            } else {\n                result += value\n            }\n            prevValue = value\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int romanToInt(String s) {\n    Map<String, int> romanMap = {\n      'I': 1,\n      'V': 5,\n      'X': 10,\n      'L': 50,\n      'C': 100,\n      'D': 500,\n      'M': 1000,\n    };\n\n    int result = 0;\n    int prevValue = 0;\n\n    for (int i = s.length - 1; i >= 0; i--) {\n      int value = romanMap[s[i]]!;\n      if (value < prevValue) {\n        result -= value;\n      } else {\n        result += value;\n      }\n      prevValue = value;\n    }\n\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func romanToInt(s string) int {\n    romanMap := map[byte]int{\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n    \n    result := 0\n    prev := 0\n    \n    for i := len(s) - 1; i >= 0; i-- {\n        value := romanMap[s[i]]\n        \n        if value < prev {\n            result -= value\n        } else {\n            result += value\n        }\n        \n        prev = value\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef roman_to_int(s)\n    roman_map = {\n        \"I\" => 1,\n        \"V\" => 5,\n        \"X\" => 10,\n        \"L\" => 50,\n        \"C\" => 100,\n        \"D\" => 500,\n        \"M\" => 1000\n    }\n    \n    result = roman_map[s[-1]]\n    \n    (s.length - 2).downto(0) do |i|\n        if roman_map[s[i]] < roman_map[s[i + 1]]\n            result -= roman_map[s[i]]\n        else\n            result += roman_map[s[i]]\n        end\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def romanToInt(s: String): Int = {\n        val map = Map('I' -> 1, 'V' -> 5, 'X' -> 10, 'L' -> 50, 'C' -> 100, 'D' -> 500, 'M' -> 1000)\n        var result = 0\n        var prev = 0\n        for (i <- s.length - 1 to 0 by -1) {\n            val curr = map(s(i))\n            if (curr < prev) {\n                result -= curr\n            } else {\n                result += curr\n            }\n            prev = curr\n        }\n        result\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn roman_to_int(s: String) -> i32 {\n        let mut result = 0;\n        let mut prev = 0;\n        let mut current = 0;\n        \n        for c in s.chars() {\n            match c {\n                'I' => current = 1,\n                'V' => current = 5,\n                'X' => current = 10,\n                'L' => current = 50,\n                'C' => current = 100,\n                'D' => current = 500,\n                'M' => current = 1000,\n                _ => current = 0,\n            }\n            \n            result += if current > prev { current - 2 * prev } else { current };\n            prev = current;\n        }\n        \n        result\n    }\n}\n  "
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of converting a Roman numeral to an integer, we need to follow a systematic approach. The problem requires that each character from the Roman numeral map to its corresponding integer value and adjust the total based on Roman numeral rules, especially the subtraction rule.\n\n# Explanation\n\n1. **Roman Numeral Mapping**: Create a dictionary to map each Roman numeral character to its integer value.\n2. **Iterate through the string**: Start from the end of the string and work backward.\n3. **Addition and Subtraction Rule**:\n   - Add the value of the last character to the result (since it's always added).\n   - For each preceding character, if it represents a smaller number than the one following it, subtract its value from the result; otherwise, add its value.\n\n# Pseudocode\n\n1. **Initialize a dictionary** with Roman numeral values.\n2. **Set the initial result** to the value of the last character in the input string.\n3. **Iterate through the string** from the second last character to the first:\n   - If the current character is less than the next character (based on dictionary values), subtract its value from the result.\n   - Otherwise, add its value to the result.\n4. **Return the result** after completing the iteration.\n\nHere is the pseudocode for clarity:\n\n```pseudocode\n# Initialize Roman numeral dictionary\nroman_dict = {\n    'I': 1, 'V': 5, 'X': 10, \n    'L': 50, 'C': 100, 'D': 500, 'M': 1000\n}\n\n# Start result with the value of the last character\nresult = roman_dict[s[-1]]\n\n# Loop through the string from the second last character to the first\nfor i in range (len(s) - 2, -1, -1):\n    if roman_dict[s[i]] < roman_dict[s[i + 1]]:\n        # Subtract if current value is less than next value\n        result -= roman_dict[s[i]]\n    else:\n        # Add in other cases\n        result += roman_dict[s[i]]\n\n# Return the final result\nreturn result\n```\n\nBy following this structured approach, we ensure that we correctly handle both the additive and subtractive properties of Roman numerals, thereby converting them accurately into integer values.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-roman-to-integer"
    },
    {
        "name": "Valid Parentheses",
        "site": "LeetCode",
        "href": "/solution/LeetCode-valid-parentheses",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for (char c : s) {\n            if (c == '(' || c == '[' || c == '{') {\n                st.push(c);\n            } else {\n                if (st.empty()) return false;\n                if ((c == ')' && st.top() != '(') || (c == ']' && st.top() != '[') || (c == '}' && st.top() != '{')) {\n                    return false;\n                }\n                st.pop();\n            }\n        }\n        \n        return st.empty();\n    }\n};\n  "
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        \n        for(char c : s.toCharArray()) {\n            if(c == '(' || c == '[' || c == '{') {\n                stack.push(c);\n            } else if(!stack.isEmpty() && \n                      ((c == ')' && stack.peek() == '(') ||\n                       (c == ']' && stack.peek() == '[') ||\n                       (c == '}' && stack.peek() == '{'))) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if the given string of parentheses is valid by checking that brackets are closed in the correct order and match the type of the corresponding opening bracket.\n\n# Explanation\n1. We use a stack to keep track of the opening brackets.\n2. We traverse each character in the string:\n   - If it\u2019s an opening bracket `(`, `{`, `[`, we push it onto the stack.\n   - If it\u2019s a closing bracket `)`, `}`, `]`, we check if the stack is not empty and if the top of the stack matches the corresponding opening bracket.\n     - If it doesn't match or the stack is empty, return false.\n     - If it matches, pop the stack.\n3. After processing all characters, the stack should be empty if the string is valid.\n\n# Pseudocode\n```\ndef isValid(s):\n    # Dictionary mapping of closing to opening brackets.\n    matching_bracket = {')': '(', ']': '[', '}': '{'}\n    \n    # Stack to keep track of opening brackets.\n    stack = []\n    \n    # Traverse each character in the string.\n    for char in s:\n        if char in matching_bracket.values():\n            # If it's an opening bracket, push it onto the stack.\n            stack.append(char)\n        elif char in matching_bracket.keys():\n            # If it's a closing bracket, check if the stack is empty or the top of the stack doesn't match.\n            if stack == [] or stack.pop() != matching_bracket[char]:\n                return False\n    \n    # If stack is empty, all brackets are matched; otherwise, return False.\n    return stack == []\n```\n\nThis algorithm ensures that the input string is validated based on the correct pairing and ordering of brackets.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-valid-parentheses"
    },
    {
        "name": "3Sum Closest",
        "site": "LeetCode",
        "href": "/solution/LeetCode-3sum-closest",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int closestSum = INT_MAX;\n        int minDiff = INT_MAX;\n        \n        for (int i = 0; i < nums.size() - 2; i++) {\n            int left = i + 1;\n            int right = nums.size() - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == target) {\n                    return sum;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n                \n                int currentDiff = abs(sum - target);\n                if (currentDiff < minDiff) {\n                    minDiff = currentDiff;\n                    closestSum = sum;\n                }\n            }\n        }\n        \n        return closestSum;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closestSum = Integer.MAX_VALUE;\n        int minDiff = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1;\n            int right = nums.length - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == target) {\n                    return sum;\n                }\n                \n                if (Math.abs(sum - target) < minDiff) {\n                    minDiff = Math.abs(sum - target);\n                    closestSum = sum;\n                }\n                \n                if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return closestSum;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        closest_sum = float('inf')\n        \n        for i in range(len(nums)-2):\n            left, right = i+1, len(nums)-1\n            \n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if abs(target - current_sum) < abs(target - closest_sum):\n                    closest_sum = current_sum\n                \n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    return target\n        \n        return closest_sum\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int threeSumClosest(int* nums, int numsSize, int target) {\n    int closestSum = nums[0] + nums[1] + nums[2];\n    int diff = abs(closestSum - target);\n    \n    for (int i = 0; i < numsSize - 2; i++) {\n        for (int j = i + 1; j < numsSize - 1; j++) {\n            for (int k = j + 1; k < numsSize; k++) {\n                int sum = nums[i] + nums[j] + nums[k];\n                int newDiff = abs(sum - target);\n                \n                if (newDiff < diff) {\n                    closestSum = sum;\n                    diff = newDiff;\n                }\n            }\n        }\n    }\n    \n    return closestSum;\n}\n  "
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closestSum = nums[0] + nums[1] + nums[2];\n    \n    for (let i = 0; i < nums.length - 2; i++) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        \n        while (left < right) {\n            const currentSum = nums[i] + nums[left] + nums[right];\n            \n            if (Math.abs(target - currentSum) < Math.abs(target - closestSum)) {\n                closestSum = currentSum;\n            }\n            \n            if (currentSum < target) {\n                left++;\n            } else if (currentSum > target) {\n                right--;\n            } else {\n                return currentSum;\n            }\n        }\n    }\n    \n    return closestSum;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function threeSumClosest(nums: number[], target: number): number {\n    nums.sort((a, b) => a - b);\n    let closestSum = nums[0] + nums[1] + nums[2];\n    \n    for (let i = 0; i < nums.length - 2; i++) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        \n        while (left < right) {\n            const currentSum = nums[i] + nums[left] + nums[right];\n            \n            if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                closestSum = currentSum;\n            }\n            \n            if (currentSum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return closestSum;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function threeSumClosest($nums, $target) {\n        sort($nums);\n        $closestSum = $nums[0] + $nums[1] + $nums[2];\n\n        for ($i = 0; $i < count($nums) - 2; $i++) {\n            $left = $i + 1;\n            $right = count($nums) - 1;\n\n            while ($left < $right) {\n                $currentSum = $nums[$i] + $nums[$left] + $nums[$right];\n\n                if (abs($target - $currentSum) < abs($target - $closestSum)) {\n                    $closestSum = $currentSum;\n                }\n\n                if ($currentSum < $target) {\n                    $left++;\n                } else {\n                    $right--;\n                }\n            }\n        }\n\n        return $closestSum;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\n        let nums = nums.sorted()\n        var closestSum = nums[0] + nums[1] + nums[2]\n\n        for i in 0..<nums.count {\n            var left = i + 1\n            var right = nums.count - 1\n            while left < right {\n                let currentSum = nums[i] + nums[left] + nums[right]\n                if abs(currentSum - target) < abs(closestSum - target) {\n                    closestSum = currentSum\n                }\n\n                if currentSum < target {\n                    left += 1\n                } else if currentSum > target {\n                    right -= 1\n                } else {\n                    return target\n                }\n            }\n        }\n\n        return closestSum\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\n        nums.sort()\n        var closestSum = nums[0] + nums[1] + nums[2]\n\n        for (i in nums.indices) {\n            var left = i + 1\n            var right = nums.size - 1\n\n            while (left < right) {\n                val currentSum = nums[i] + nums[left] + nums[right]\n\n                if (Math.abs(target - currentSum) < Math.abs(target - closestSum)) {\n                    closestSum = currentSum\n                }\n\n                if (currentSum < target) {\n                    left++\n                } else {\n                    right--\n                }\n            }\n        }\n\n        return closestSum\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int threeSumClosest(List<int> nums, int target) {\n    nums.sort();\n    int closestSum = nums[0] + nums[1] + nums[2];\n\n    for (int i = 0; i < nums.length - 2; i++) {\n      int left = i + 1;\n      int right = nums.length - 1;\n\n      while (left < right) {\n        int currentSum = nums[i] + nums[left] + nums[right];\n\n        if ((currentSum - target).abs() < (closestSum - target).abs()) {\n          closestSum = currentSum;\n        }\n\n        if (currentSum < target) {\n          left++;\n        } else {\n          right--;\n        }\n      }\n    }\n\n    return closestSum;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func threeSumClosest(nums []int, target int) int {\n    closestSum := nums[0] + nums[1] + nums[2]\n    minDiff := abs(closestSum - target)\n\n    sort.Ints(nums)\n\n    for i := 0; i < len(nums)-2; i++ {\n        left, right := i+1, len(nums)-1\n        for left < right {\n            currentSum := nums[i] + nums[left] + nums[right]\n            if currentDiff := abs(currentSum - target); currentDiff < minDiff {\n                minDiff = currentDiff\n                closestSum = currentSum\n            }\n            if currentSum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n\n    return closestSum\n}\n\nfunc abs(num int) int {\n    if num < 0 {\n        return -num\n    }\n    return num\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef three_sum_closest(nums, target)\n    nums.sort!\n    closest_sum = nums[0] + nums[1] + nums[2]\n    \n    (0...nums.length-2).each do |i|\n        left = i + 1\n        right = nums.length - 1\n        \n        while left < right\n            current_sum = nums[i] + nums[left] + nums[right]\n            if (current_sum - target).abs < (closest_sum - target).abs\n                closest_sum = current_sum\n            end\n            \n            if current_sum < target\n                left += 1\n            else\n                right -= 1\n            end\n        end\n    end\n    \n    return closest_sum\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    import scala.util.control.Breaks._\n\n    def threeSumClosest(nums: Array[Int], target: Int): Int = {\n        val sortedNums = nums.sorted\n        var closestSum = sortedNums(0) + sortedNums(1) + sortedNums(2)\n        var result = 0\n\n        for (i <- 0 until sortedNums.length - 2) {\n            var left = i + 1\n            var right = sortedNums.length - 1\n\n            breakable {\n                while (left < right) {\n                    val currentSum = sortedNums(i) + sortedNums(left) + sortedNums(right)\n\n                    if (math.abs(target - currentSum) < math.abs(target - closestSum)) {\n                        closestSum = currentSum\n                    }\n\n                    if (currentSum < target) {\n                        left += 1\n                    } else if (currentSum > target) {\n                        right -= 1\n                    } else {\n                        result = currentSum\n                        break\n                    }\n                }\n            }\n        }\n\n        if (result != 0) result else closestSum\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\n        let mut nums = nums;\n        nums.sort();\n        let mut closest_sum = nums[0] + nums[1] + nums[2];\n        \n        for i in 0..nums.len() {\n            let (mut left, mut right) = (i + 1, nums.len() - 1);\n            while left < right {\n                let sum = nums[i] + nums[left] + nums[right];\n                if (sum - target).abs() < (closest_sum - target).abs() {\n                    closest_sum = sum;\n                }\n                if sum < target {\n                    left += 1;\n                } else {\n                    right -= 1;\n                }\n            }\n        }\n        \n        closest_sum\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find a methodology for determining the sum of three integers in a given array that is closest to a specified target value.\n\n### # Explanation\n\n1. **Sorting the Array**: Start by sorting the array. This helps in efficiently managing and iterating over the elements with two-pointers to find the closest sum.\n2. **Using Three Pointers**: Use three pointers to iterate over the array - a fixed pointer and two pointers to identify the closest sum.\n3. **Calculate Sum and Compare**: Calculate the sum of the three pointers, and compare it with the target to update the closest sum if the current sum is closer than the previous closest sum.\n4. **Adjust Pointers**: Based on whether the current sum is less than or greater than the target, adjust the two pointers to try to get closer to the target sum.\n5. **Return Result**: Once all possible sums are examined, return the closest sum found.\n\n### # Pseudocode\n\n```plaintext\n# Function to find the sum of three integers closest to the target\nfunction threeSumClosest(nums, target):\n    # Sort the input array\n    sort(nums)\n    \n    # Initialize the closest_sum with a large value\n    closest_sum = infinity\n    \n    # Traverse the array with a fixed pointer\n    for i from 0 to length(nums) - 2:\n        # Initialize the left and right pointers\n        left = i + 1\n        right = length(nums) - 1\n        \n        # While left pointer is less than right pointer\n        while left < right:\n            # Calculate the current sum of the triplet\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            # If the current sum is closer to target than the closest_sum, update closest_sum\n            if absolute(target - current_sum) < absolute(target - closest_sum):\n                closest_sum = current_sum\n            \n            # Move pointers based on comparison of current_sum and target\n            if current_sum < target:\n                left = left + 1\n            elif current_sum > target:\n                right = right - 1\n            else:\n                # If the current sum is exactly the target, return the target sum\n                return target\n    \n    # Return the closest sum found\n    return closest_sum\n```\n\nThis pseudocode ensures that we efficiently find and return the sum of three integers in the array that is closest to the given target.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-3sum-closest"
    },
    {
        "name": "Letter Combinations Of A Phone Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-letter-combinations-of-a-phone-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> result;\n        if(digits.empty()) {\n            return result;\n        }\n        \n        vector<string> mappings = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        \n        string combination = \"\";\n        backtrack(result, mappings, digits, combination, 0);\n        \n        return result;\n    }\n    \n    void backtrack(vector<string>& result, vector<string>& mappings, string& digits, string& combination, int index) {\n        if(index == digits.length()) {\n            result.push_back(combination);\n            return;\n        }\n        \n        string letters = mappings[digits[index] - '0'];\n        for(char c : letters) {\n            combination.push_back(c);\n            backtrack(result, mappings, digits, combination, index + 1);\n            combination.pop_back();\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if (digits == null || digits.length() == 0) {\n            return result;\n        }\n        \n        String[] mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        \n        backtrack(digits, mapping, result, new StringBuilder(), 0);\n        \n        return result;\n    }\n    \n    private void backtrack(String digits, String[] mapping, List<String> result, StringBuilder sb, int index) {\n        if (index == digits.length()) {\n            result.add(sb.toString());\n            return;\n        }\n        \n        String letters = mapping[digits.charAt(index) - '0'];\n        for (int i = 0; i < letters.length(); i++) {\n            sb.append(letters.charAt(i));\n            backtrack(digits, mapping, result, sb, index + 1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def letterCombinations(self, digits):\n        if not digits:\n            return []\n        \n        mapping = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free\n().\n */\nchar** letterCombinations(char* digits, int* returnSize) {\n    char* mapping[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    int numDigits = strlen(digits);\n    if (numDigits == 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    int totalCombinations = 1;\n    for (int i = 0; i < numDigits; i++) {\n        int index = digits[i] - '2';\n        totalCombinations *= strlen(mapping[index]);\n    }\n    \n    char** result = (char**)malloc(sizeof(char*) * totalCombinations);\n    for (int i = 0; i < totalCombinations; i++) {\n        result[i] = (char*)malloc(sizeof(char) * (numDigits + 1));\n    }\n    \n    *returnSize = totalCombinations;\n    \n    int* indexArray = (int*)malloc(sizeof(int) * numDigits);\n    memset(indexArray, 0, sizeof(int) * numDigits);\n    \n    for (int i = 0; i < totalCombinations; i++) {\n        for (int j = 0; j < numDigits; j++) {\n            int index = digits[j] - '2';\n            result[i][j] = mapping[index][indexArray[j]];\n        }\n        \n        for (int j = numDigits - 1; j >= 0; j--) {\n            indexArray[j]++;\n            if (indexArray[j] < strlen(mapping[digits[j] - '2'])) {\n                break;\n            } else {\n                indexArray[j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 0; i < totalCombinations; i++) {\n        result[i][numDigits] = '\\0';\n    }\n    \n    free(indexArray);\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> LetterCombinations(string digits) {\n        IList<string> result = new List<string>();\n        if (string.IsNullOrEmpty(digits)) {\n            return result;\n        }\n        \n        string[] mappings = new string[] {\n            \"\", \n            \"\", \n            \"abc\",\n            \"def\",\n            \"ghi\",\n            \"jkl\",\n            \"mno\",\n            \"pqrs\",\n            \"tuv\",\n            \"wxyz\"\n        };\n        \n        GenerateCombinations(digits, mappings, 0, \"\", result);\n        \n        return result;\n    }\n    \n    private void GenerateCombinations(string digits, string[] mappings, int index, string current, IList<string> result) {\n        if (index == digits.Length) {\n            result.Add(current);\n            return;\n        }\n        \n        string letters = mappings[digits[index] - '0'];\n        for (int i = 0; i < letters.Length; i++) {\n            GenerateCombinations(digits, mappings, index + 1, current + letters[i], result);\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    if (digits.length === 0) return [];\n    \n    const map = {\n        '2': ['a', 'b', 'c'],\n        '3': ['d', 'e', 'f'],\n        '4': ['g', 'h', 'i'],\n        '5': ['j', 'k', 'l'],\n        '6': ['m', 'n', 'o'],\n        '7': ['p', 'q', 'r', 's'],\n        '8': ['t', 'u', 'v'],\n        '9': ['w', 'x', 'y', 'z']\n    };\n    \n    let result = [''];\n    \n    for (let digit of digits) {\n        const letters = map[digit];\n        let tempResult = [];\n        for (let letter of letters) {\n            for (let item of result) {\n                tempResult.push(item + letter);\n            }\n        }\n        result = tempResult;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function letterCombinations(digits: string): string[] {\n    const map: { [key: string]: string[] } = {\n        '2': ['a', 'b', 'c'],\n        '3': ['d', 'e', 'f'],\n        '4': ['g', 'h', 'i'],\n        '5': ['j', 'k', 'l'],\n        '6': ['m', 'n', 'o'],\n        '7': ['p', 'q', 'r', 's'],\n        '8': ['t', 'u', 'v'],\n        '9': ['w', 'x', 'y', 'z']\n    };\n\n    const result: string[] = [];\n\n    const backtrack = (index: number, current: string) => {\n        if (index === digits.length) {\n            if (current.length > 0) {\n                result.push(current);\n            }\n            return;\n        }\n\n        const letters = map[digits[index]];\n\n        for (let i = 0; i < letters.length; i++) {\n            backtrack(index + 1, current + letters[i]);\n        }\n    };\n\n    if (digits.length > 0) {\n        backtrack(0, '');\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $digits\n     * @return String[]\n     */\n    function letterCombinations($digits) {\n        if (empty($digits)) {\n            return [];\n        }\n        \n        $mapping = [\n            '2' => ['a', 'b', 'c'],\n            '3' => ['d', 'e', 'f'],\n            '4' => ['g', 'h', 'i'],\n            '5' => ['j', 'k', 'l'],\n            '6' => ['m', 'n', 'o'],\n            '7' => ['p', 'q', 'r', 's'],\n            '8' => ['t', 'u', 'v'],\n            '9' => ['w', 'x', 'y', 'z'],\n        ];\n        \n        $output = [''];\n        \n        for ($i = 0; $i < strlen($digits); $i++) {\n            $temp = [];\n            foreach ($output as $prev) {\n                foreach ($mapping[$digits[$i]] as $char) {\n                    $temp[] = $prev . $char;\n                }\n            }\n            $output = $temp;\n        }\n        \n        return $output;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func letterCombinations(_ digits: String) -> [String] {\n        guard !digits.isEmpty else {\n            return []\n        }\n        \n        let mappings: [Character: [String]] = [\n            \"2\": [\"a\", \"b\", \"c\"],\n            \"3\": [\"d\", \"e\", \"f\"],\n            \"4\": [\"g\", \"h\", \"i\"],\n            \"5\": [\"j\", \"k\", \"l\"],\n            \"6\": [\"m\", \"n\", \"o\"],\n            \"7\": [\"p\", \"q\", \"r\", \"s\"],\n            \"8\": [\"t\", \"u\", \"v\"],\n            \"9\": [\"w\", \"x\", \"y\", \"z\"]\n        ]\n        \n        var result: [String] = []\n        \n        func backtrack(_ index: Int, _ current: String) {\n            if index == digits.count {\n                result.append(current)\n                return\n            }\n            \n            let digit = digits[digits.index(digits.startIndex, offsetBy: index)]\n            if let letters = mappings[digit] {\n                for letter in letters {\n                    backtrack(index + 1, current + letter)\n                }\n            }\n        }\n        \n        backtrack(0, \"\")\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun letterCombinations(digits: String): List<String> {\n        if (digits.isEmpty()) {\n            return emptyList()\n        }\n        \n        val phoneMap = mapOf(\n            '2' to listOf(\"a\", \"b\", \"c\"),\n            '3' to listOf(\"d\", \"e\", \"f\"),\n            '4' to listOf(\"g\", \"h\", \"i\"),\n            '5' to listOf(\"j\", \"k\", \"l\"),\n            '6' to listOf(\"m\", \"n\", \"o\"),\n            '7' to listOf(\"p\", \"q\", \"r\", \"s\"),\n            '8' to listOf(\"t\", \"u\", \"v\"),\n            '9' to listOf(\"w\", \"x\", \"y\", \"z\")\n        )\n        \n        val result = mutableListOf<String>()\n        generateCombinations(\"\", digits, phoneMap, result)\n        \n        return result\n    }\n    \n    private fun generateCombinations(current: String, remaining: String, phoneMap: Map<Char, List<String>>, result: MutableList<String>) {\n        if (remaining.isEmpty()) {\n            result.add(current)\n            return\n        }\n        \n        val digit = remaining[0]\n        val letters = phoneMap[digit]\n        \n        letters?.forEach { letter ->\n            generateCombinations(current + letter, remaining.substring(1), phoneMap, result)\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> letterCombinations(String digits) {\n    List<String> result = [];\n    if (digits.isEmpty) {\n      return result;\n    }\n    \n    Map<String, List<String>> phoneMap = {\n      '2': ['a', 'b', 'c'],\n      '3': ['d', 'e', 'f'],\n      '4': ['g', 'h', 'i'],\n      '5': ['j', 'k', 'l'],\n      '6': ['m', 'n', 'o'],\n      '7': ['p', 'q', 'r', 's'],\n      '8': ['t', 'u', 'v'],\n      '9': ['w', 'x', 'y', 'z']\n    };\n    \n    void backtrack(int index, String current) {\n      if (index == digits.length) {\n        result.add(current);\n        return;\n      }\n      \n      String digit = digits[index];\n      for (int i = 0; i < phoneMap[digit]!.length; i++) {\n        backtrack(index + 1, current + phoneMap[digit]![i]);\n      }\n    }\n    \n    backtrack(0, '');\n    \n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func letterCombinations(digits string) []string {\n    if len(digits) == 0 {\n        return []string{}\n    }\n\n    phone := map[byte]string{\n        '2': \"abc\",\n        '3': \"def\",\n        '4': \"ghi\",\n        '5': \"jkl\",\n        '6': \"mno\",\n        '7': \"pqrs\",\n        '8': \"tuv\",\n        '9': \"wxyz\",\n    }\n\n    var result []string\n    var backtrack func(combination string, nextDigits string)\n\n    backtrack = func(combination string, nextDigits string) {\n        if len(nextDigits) == 0 {\n            result = append(result, combination)\n        } else {\n            digit := nextDigits[0]\n            letters := phone[digit]\n            for i := 0; i < len(letters); i++ {\n                letter := phone[digit][i]\n                backtrack(combination+string(letter), nextDigits[1:])\n            }\n        }\n    }\n\n    backtrack(\"\", digits)\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} digits\n# @return {String[]}\ndef letter_combinations(digits)\n    return [] if digits.empty?\n    \n    phone = {\n        '2' => ['a', 'b', 'c'],\n        '3' => ['d', 'e', 'f'],\n        '4' => ['g', 'h', 'i'],\n        '5' => ['j', 'k', 'l'],\n        '6' => ['m', 'n', 'o'],\n        '7' => ['p', 'q', 'r', 's'],\n        '8' => ['t', 'u', 'v'],\n        '9' => ['w', 'x', 'y', 'z']\n    }\n    \n    result = ['']\n    digits.chars.each do |digit|\n        temp = []\n        result.each do |res|\n            phone[digit].each do |char|\n                temp << res + char\n            end\n        end\n        result = temp\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def letterCombinations(digits: String): List[String] = {\n        val phoneMap = Map(\n            '2' -> List(\"a\", \"b\", \"c\"),\n            '3' -> List(\"d\", \"e\", \"f\"),\n            '4' -> List(\"g\", \"h\", \"i\"),\n            '5' -> List(\"j\", \"k\", \"l\"),\n            '6' -> List(\"m\", \"n\", \"o\"),\n            '7' -> List(\"p\", \"q\", \"r\", \"s\"),\n            '8' -> List(\"t\", \"u\", \"v\"),\n            '9' -> List(\"w\", \"x\", \"y\", \"z\")\n        )\n\n        def combine(prefix: String, suffix: String): List[String] = {\n            if (suffix.isEmpty) {\n                List(prefix)\n            } else {\n                val currentDigit = suffix.head\n                val currentLetters = phoneMap(currentDigit)\n                currentLetters.flatMap(letter => combine(prefix + letter, suffix.tail))\n            }\n        }\n\n        if (digits.isEmpty) {\n            List()\n        } else {\n            combine(\"\", digits)\n        }\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        let mut result = vec![];\n        if digits.is_empty() {\n            return result;\n        }\n        \n        let mapping: Vec<&str> = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n        \n        fn backtrack(result: &mut Vec<String>, mapping: &Vec<&str>, digits: &str, current: String, index: usize) {\n            if index == digits.len() {\n                result.push(current);\n                return;\n            }\n            \n            let digit = digits.chars().nth(index).unwrap() as usize - '2' as usize;\n            for letter in mapping[digit].chars() {\n                let new_current = current.clone() + &letter.to_string();\n                backtrack(result, mapping, digits, new_current, index + 1);\n            }\n        }\n        \n        backtrack(&mut result, &mapping, &digits, String::new(), 0);\n        \n        result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we must generate all possible letter combinations represented by a string of digits from 2 to 9, replicating the functionality of a telephone keypad.\n\n### # Explanation\n\n1. **Digit to Letter Mapping:** \n   We'll use a dictionary to map each digit from 2 to 9 to their corresponding letters, as seen on a standard telephone keypad.\n\n2. **Backtracking Algorithm:**\n   - We will define a helper function (`backtrack`) that constructs combinations.\n   - This function will use recursion to build combinations of letters by adding one letter at a time and moving to the next digit.\n\n3. **Edge Cases:**\n   - If the input digits string is empty, we'll return an empty list since there are no possible combinations.\n\n### # Pseudocode\n\n```plaintext\nFunction letterCombinations(digits: string) -> list of strings\n    If digits is empty\n        Return an empty list\n\n    Initialize a dictionary named 'mapping' with digit-to-letters mappings\n        '2': ['a', 'b', 'c']\n        '3': ['d', 'e', 'f']\n        '4': ['g', 'h', 'i']\n        '5': ['j', 'k', 'l']\n        '6': ['m', 'n', 'o']\n        '7': ['p', 'q', 'r', 's']\n        '8': ['t', 'u', 'v']\n        '9': ['w', 'x', 'y', 'z']\n\n    Initialize an empty list 'output' to store the final combinations\n\n    Define a recursive function backtrack(combination: string, next_digits: string)\n        If next_digits is empty\n            Append the combination to the output list\n        Else\n            For each letter in mapping[next_digits[0]]\n                Call backtrack(combination + letter, next_digits[1:])\n\n    Call backtrack(\"\", digits)\n\n    Return output list\n```\n\nBy following the above pseudocode, we can effectively implement a solution that handles the letter combinations for a given set of digits, ensuring that all possible combinations are considered and returned in a list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-letter-combinations-of-a-phone-number"
    },
    {
        "name": "4Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-4sum",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()\n        \n        def findNsum(nums, target, N, result, results):\n            if len(nums) < N or N < 2 or target < nums[0] * N or target > nums[-1] * N:\n                return\n            if N == 2:\n                l, r = 0, len(nums) - 1\n                while l < r:\n                    s = nums[l] + nums[r]\n                    if s == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        while l < r and nums[l] == nums[l - 1]:\n                            l += 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else:\n                for i in range(len(nums) - N + 1):\n                    if i == 0 or (i > 0 and nums[i] != nums[i - 1]):\n                        findNsum(nums[i + 1:], target - nums[i], N - 1, result + [nums[i]], results)\n        \n        findNsum(nums, target, 4, [], res)\n        return res\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function fourSum(nums: number[], target: number): number[][] {\n    const result: number[][] = [];\n    const n = nums.length;\n    \n    if (n < 4) {\n        return result;\n    }\n    \n    nums.sort((a, b) => a - b);\n    \n    for (let i = 0; i < n - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        \n        for (let j = i + 1; j < n - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) {\n                continue;\n            }\n            \n            let left = j + 1;\n            let right = n - 1;\n            \n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                \n                if (sum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    \n                    while (left < right && nums[left] === nums[left + 1]) {\n                        left++;\n                    }\n                    \n                    while (left < right && nums[right] === nums[right - 1]) {\n                        right--;\n                    }\n                    \n                    left++;\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function fourSum($nums, $target) {\n        $result = [];\n        sort($nums);\n        $n = count($nums);\n        \n        for ($i = 0; $i < $n - 3; $i++) {\n            if ($i > 0 && $nums[$i] == $nums[$i - 1]) {\n                continue;\n            }\n            \n            for ($j = $i + 1; $j < $n - 2; $j++) {\n                if ($j > $i + 1 && $nums[$j] == $nums[$j - 1]) {\n                    continue;\n                }\n                \n                $left = $j + 1;\n                $right = $n - 1;\n                \n                while ($left < $right) {\n                    $sum = $nums[$i] + $nums[$j] + $nums[$left] + $nums[$right];\n                    \n                    if ($sum == $target) {\n                        $result[] = [$nums[$i], $nums[$j], $nums[$left], $nums[$right]];\n                        \n                        while ($left < $right && $nums[$left] == $nums[$left + 1]) {\n                            $left++;\n                        }\n                        while ($left < $right && $nums[$right] == $nums[$right - 1]) {\n                            $right--;\n                        }\n                        \n                        $left++;\n                        $right--;\n                    } elseif ($sum < $target) {\n                        $left++;\n                    } else {\n                        $right--;\n                    }\n                }\n            }\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> fourSum(List<int> nums, int target) {\n      List<List<int>> result = [];\n      if (nums == null || nums.length < 4) {\n          return result;\n      }\n      nums.sort();\n      for (int i = 0; i < nums.length - 3; i++) {\n          if (i > 0 && nums[i] == nums[i - 1]) {\n              continue;\n          }\n          for (int j = i + 1; j < nums.length - 2; j++) {\n              if (j > i + 1 && nums[j] == nums[j - 1]) {\n                  continue;\n              }\n              int left = j + 1;\n              int right = nums.length - 1;\n              while (left < right) {\n                  int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                  if (sum == target) {\n                      result.add([nums[i], nums[j], nums[left], nums[right]]);\n                      while (left < right && nums[left] == nums[left + 1]) {\n                          left++;\n                      }\n                      while (left < right && nums[right] == nums[right - 1]) {\n                          right--;\n                      }\n                      left++;\n                      right--;\n                  } else if (sum < target) {\n                      left++;\n                  } else {\n                      right--;\n                  }\n              }\n          }\n      }\n      return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func fourSum(nums []int, target int) [][]int {\n    var res [][]int\n    if len(nums) < 4 {\n        return res\n    }\n    \n    sort.Ints(nums)\n    \n    for i := 0; i < len(nums)-3; i++ {\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        for j := i+1; j < len(nums)-2; j++ {\n            if j > i+1 && nums[j] == nums[j-1] {\n                continue\n            }\n            left := j + 1\n            right := len(nums) - 1\n            for left < right {\n                sum := nums[i] + nums[j] + nums[left] + nums[right]\n                if sum == target {\n                    res = append(res, []int{nums[i], nums[j], nums[left], nums[right]})\n                    for left < right && nums[left] == nums[left+1] {\n                        left++\n                    }\n                    for left < right && nums[right] == nums[right-1] {\n                        right--\n                    }\n                    left++\n                    right--\n                } else if sum < target {\n                    left++\n                } else {\n                    right--\n                }\n            }\n        }\n    }\n    \n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[][]}\ndef four_sum(nums, target)\n    nums.sort!\n    results = []\n    find_n_sum(nums, target, 4, [], results)\n    results\nend\n\ndef find_n_sum(nums, target, n, temp, results)\n    return if nums.length < n || n < 2 || target < nums.first * n || target > nums.last * n\n    \n    if n == 2\n        left, right = 0, nums.length - 1\n        while left < right\n            sum = nums[left] + nums[right]\n            if sum == target\n                results.push(temp + [nums[left], nums[right]])\n                left += 1\n                right -= 1\n                left += 1 while left < right && nums[left] == nums[left - 1]\n                right -= 1 while left < right && nums[right] == nums[right + 1]\n            elsif sum < target\n                left += 1\n            else\n                right -= 1\n            end\n        end\n    else\n        (0..nums.length - n).each do |i|\n            next if i > 0 && nums[i] == nums[i - 1]\n            find_n_sum(nums[i + 1..-1], target - nums[i], n - 1, temp + [nums[i]], results)\n        end\n    end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find all unique quadruplets in an array that sum to a given target value. We will use a method that involves sorting the array and then recursively finding combinations of sums, reducing the problem into smaller subproblems. Here\u2019s a detailed explanation and pseudocode to achieve this.\n\n# Explanation\n\n1. **Sort the Array**: Sorting helps in easily skipping duplicates and reducing the number of redundant calculations.\n\n2. **Recursive Function**: Use a function (`findNsum`) to find combinations of N numbers that sum to the target.\n   - If N is 2, use a two-pointer approach to find the pairs that sum up to the target.\n   - If N is greater than 2, reduce the problem by fixing one number and recursively finding the combinations for `N-1` numbers.\n\n3. **Base Case and Edge Conditions**: Check if it's possible for a combination to sum to the target under current conditions (e.g., the smallest/largest possible sum is out of bounds).\n\n4. **Avoid Duplicates**: Skip over duplicate elements to ensure all quadruplets are unique.\n\n# Pseudocode\n\n```plaintext\nfunction fourSum(nums, target):\n    sort(nums)\n    result = []\n    \n    function findNsum(nums, target, N, current, results):\n        if len(nums) < N or N < 2:\n            return\n        if N == 2:  // Two-pointer approach\n            left, right = 0, len(nums) - 1\n            while left < right:\n                s = nums[left] + nums[right]\n                if s == target:\n                    results.append(current + [nums[left], nums[right]])\n                    left += 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                elif s < target:\n                    left += 1\n                else:\n                    right -= 1\n        else:  // Reduce N-sum to (N-1)-sum\n            for i in range(len(nums) - N + 1):\n                if i == 0 or (i > 0 and nums[i] != nums[i - 1]):\n                    findNsum(nums[i + 1:], target - nums[i], N - 1, current + [nums[i]], results)\n    \n    findNsum(nums, target, 4, [], result)\n    return result\n```\n\nThis pseudocode outlines the main approach and structure needed to solve the problem.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-4sum"
    },
    {
        "name": "Remove Nth Node From End Of List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-nth-node-from-end-of-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* first = dummy;\n        ListNode* second = dummy;\n\n        for (int i = 0; i < n + 1; i++) {\n            first = first->next;\n        }\n\n        while (first != nullptr) {\n            first = first->next;\n            second = second->next;\n        }\n\n        second->next = second->next->next;\n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        ListNode first = dummy;\n        ListNode second = dummy;\n        \n        for(int i = 1; i <= n + 1; i++) {\n            first = first.next;\n        }\n        \n        while(first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        \n        second.next = second.next.next;\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        # Advances first pointer so that the gap between first and second is n nodes apart\n        for i in range(1, n + 2):\n            first = first.next\n        # Move first to the end, maintaining the gap\n        while first is not None:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->next = head;\n    struct ListNode* slow = dummy;\n    struct ListNode* fast = dummy;\n\n    for(int i = 0; i <= n; i++) {\n        fast = fast->next;\n    }\n\n    while(fast != NULL) {\n        slow = slow->next;\n        fast = fast->next;\n    }\n\n    struct ListNode* temp = slow->next;\n    slow->next = slow->next->next;\n    free(temp);\n\n    return dummy->next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode first = dummy;\n        ListNode second = dummy;\n        \n        for (int i = 1; i <= n + 1; i++) {\n            first = first.next;\n        }\n        \n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        \n        second.next = second.next.next;\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let first = dummy;\n    let second = dummy;\n    \n    for (let i = 1; i <= n + 1; i++) {\n        first = first.next;\n    }\n    \n    while (first !== null) {\n        first = first.next;\n        second = second.next;\n    }\n    \n    second.next = second.next.next;\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let first: ListNode | null = dummy;\n    let second: ListNode | null = dummy;\n\n    for (let i = 1; i <= n + 1; i++) {\n        if (first === null) return null;\n        first = first.next;\n    }\n\n    while (first !== null) {\n        first = first.next;\n        second = second.next;\n    }\n\n    second.next = second.next!.next;\n\n    return dummy.next;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param ListNode $head\n     */\n    function removeNthFromEnd($head, $n) {\n        $dummy = new ListNode(0);\n        $dummy->next = $head;\n        $first = $dummy;\n        $second = $dummy;\n        \n        for ($i = 1; $i <= $n + 1; $i++) {\n            $first = $first->next;\n        }\n        \n        while ($first != null) {\n            $first = $first->next;\n            $second = $second->next;\n        }\n        \n        $second->next = $second->next->next;\n        \n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\n        var dummyHead = ListNode(0)\n        dummyHead.next = head\n        \n        var fast: ListNode? = dummyHead\n        var slow: ListNode? = dummyHead\n        \n        for _ in 0..<n {\n            fast = fast?.next\n        }\n        \n        while fast?.next != nil {\n            fast = fast?.next\n            slow = slow?.next\n        }\n        \n        slow?.next = slow?.next?.next\n        \n        return dummyHead.next\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\n        var dummy = ListNode(0)\n        dummy.next = head\n        var first: ListNode? = dummy\n        var second: ListNode? = dummy\n        \n        for (i in 1..n + 1) {\n            first = first!!.next\n        }\n        \n        while (first != null) {\n            first = first.next\n            second = second!!.next\n        }\n        \n        second!!.next = second.next!!.next\n        \n        return dummy.next\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? removeNthFromEnd(ListNode? head, int n) {\n    ListNode? dummy = ListNode(0);\n    dummy.next = head;\n    ListNode? first = dummy;\n    ListNode? second = dummy;\n    \n    for (int i = 0; i <= n; i++) {\n      first = first!.next;\n    }\n    \n    while (first != null) {\n      first = first.next;\n      second = second!.next;\n    }\n    \n    second!.next = second.next!.next;\n    \n    return dummy.next;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    dummy := &ListNode{Val: 0, Next: head}\n    first := head\n    length := 0\n    for first != nil {\n        length++\n        first = first.Next\n    }\n    length -= n\n    first = dummy\n    for length > 0 {\n        length--\n        first = first.Next\n    }\n    first.Next = first.Next.Next\n    return dummy.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} n\n# @return {ListNode}\ndef remove_nth_from_end(head, n)\n    dummy = ListNode.new\n    dummy.next = head\n    first = dummy\n    second = dummy\n    # Advances first pointer so that the gap between first and second is n nodes apart\n    (n + 1).times do\n        first = first.next\n    end\n    # Move first to the end, maintaining the gap\n    while first != nil\n        first = first.next\n        second = second.next\n    end\n    # Remove the nth node from the end\n    second.next = second.next.next\n    return dummy.next\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {\n        var dummy = new ListNode()\n        dummy.next = head\n        var fast = dummy\n        var slow = dummy\n\n        for (_ <- 1 to n + 1) {\n            fast = fast.next\n        }\n\n        while (fast != null) {\n            fast = fast.next\n            slow = slow.next\n        }\n\n        slow.next = slow.next.next\n\n        dummy.next\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n  \nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        let mut head = head;\n        let mut fast = head.as_ref();\n        let mut len = 0;\n        \n        while let Some(node) = fast {\n            fast = node.next.as_ref();\n            len += 1;\n        }\n        \n        let mut dummy = ListNode { val: 0, next: head };\n        let mut slow = &mut dummy;\n        let nth = len - n;\n        \n        for _ in 0..nth {\n            slow = slow.next.as_mut().unwrap();\n        }\n        \n        slow.next = slow.next.as_mut().unwrap().next.take();\n        \n        dummy.next\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, follow these steps to remove the Nth node from the end of a singly linked list. This can be done efficiently in one pass using the two-pointer technique.\n\n# Explanation\n1. **Create a Dummy Node**: This simplifies edge cases by providing a non-null starting point, especially useful if the node to be removed is the head.\n2. **Initialize Pointers**: Set two pointers, `first` and `second`, both initially pointing to the dummy node.\n3. **Advance the First Pointer**: Move the `first` pointer `n + 1` steps ahead.\n4. **Move Both Pointers**: Move both `first` and `second` pointers simultaneously until `first` reaches the end of the list. At this point, `second` will point to the node just before the Nth node from the end.\n5. **Remove Nth Node**: Update the `second.next` to skip the Nth node.\n6. **Return the New Head**: The head of the modified list is `dummy.next`.\n\n# Pseudocode\n```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        # Step 1: Create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # Step 2: Initialize pointers\n        first = dummy\n        second = dummy\n        \n        # Step 3: Move the first pointer n + 1 steps ahead\n        for i in range(n + 1):\n            first = first.next\n            \n        # Step 4: Move both pointers until first reaches the end\n        while first is not None:\n            first = first.next\n            second = second.next\n        \n        # Step 5: Remove the nth node from the end\n        second.next = second.next.next\n        \n        # Step 6: Return the new head\n        return dummy.next\n```\n\nBy following this pseudocode, we ensure that the solution operates in one pass through the linked list, satisfying both the problem constraints and the follow-up requirement.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-nth-node-from-end-of-list"
    },
    {
        "name": "Swap Nodes In Pairs",
        "site": "LeetCode",
        "href": "/solution/LeetCode-swap-nodes-in-pairs",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) {\n            return head;\n        }\n        \n        ListNode* dummy = new ListNode();\n        dummy->next = head;\n        ListNode* prev = dummy;\n        \n        while (prev->next && prev->next->next) {\n            ListNode* first = prev->next;\n            ListNode* second = prev->next->next;\n            \n            // Swapping\n            prev->next = second;\n            first->next = second->next;\n            second->next = first;\n            \n            // Move to next pair\n            prev = first;\n        }\n        \n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode newHead = second;\n        \n        while (first != null && second != null) {\n            ListNode temp = second.next;\n            second.next = first;\n            if (temp == null || temp.next == null) {\n                first.next = temp;\n                break;\n            }\n            first.next = temp.next;\n            first = temp;\n            second = temp.next;\n        }\n        \n        return newHead;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev_node = dummy\n        \n        while head and head.next:\n            first_node = head\n            second_node = head.next\n            \n            prev_node.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            prev_node = first_node\n            head = first_node.next\n        \n        return dummy.next\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapPairs(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    \n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->next = head;\n    struct ListNode* prev = dummy;\n    struct ListNode* current = head;\n    \n    while (current != NULL && current->next != NULL) {\n        struct ListNode* firstNode = current;\n        struct ListNode* secondNode = current->next;\n        \n        prev->next = secondNode;\n        firstNode->next = secondNode->next;\n        secondNode->next = firstNode;\n        \n        prev = firstNode;\n        current = firstNode->next;\n    }\n    \n    head = dummy->next;\n    free(dummy);\n    \n    return head;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode SwapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode current = dummy;\n        \n        while (current.next != null && current.next.next != null) {\n            ListNode firstNode = current.next;\n            ListNode secondNode = current.next.next;\n            \n            firstNode.next = secondNode.next;\n            current.next = secondNode;\n            current.next.next = firstNode;\n            \n            current = current.next.next;\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    \n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n    \n    while (current.next && current.next.next) {\n        let first = current.next;\n        let second = current.next.next;\n        \n        first.next = second.next;\n        current.next = second;\n        current.next.next = first;\n        \n        current = current.next.next;\n    }\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return head;\n    }\n    \n    let firstNode = head;\n    let secondNode = head.next;\n    \n    firstNode.next = swapPairs(secondNode.next);\n    secondNode.next = firstNode;\n    \n    return secondNode;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function swapPairs($head) {\n        $dummy = new ListNode(0);\n        $dummy->next = $head;\n        $current = $dummy;\n        \n        while ($current->next != null && $current->next->next != null) {\n            $first = $current->next;\n            $second = $current->next->next;\n            \n            $first->next = $second->next;\n            $current->next = $second;\n            $current->next->next = $first;\n            \n            $current = $current->next->next; // Move to the next pair\n        }\n        \n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func swapPairs(_ head: ListNode?) -> ListNode? {\n        if head == nil || head?.next == nil {\n            return head\n        }\n        \n        let newHead = head?.next\n        head?.next = swapPairs(newHead?.next)\n        newHead?.next = head\n        \n        return newHead\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun swapPairs(head: ListNode?): ListNode? {\n        if (head?.next == null) {\n            return head\n        }\n        \n        val newHead = head.next\n        head.next = swapPairs(newHead?.next)\n        newHead.next = head\n        \n        return newHead\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    \n    dummy := &ListNode{Val: 0, Next: head}\n    prev := dummy\n    \n    for prev.Next != nil && prev.Next.Next != nil {\n        first := prev.Next\n        second := prev.Next.Next\n        \n        first.Next = second.Next\n        second.Next = first\n        prev.Next = second\n        \n        prev = first\n    }\n    \n    return dummy.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @return {ListNode}\ndef swap_pairs(head)\n    return head if head.nil? || head.next.nil?\n    \n    new_head = head.next\n    current = head\n    \n    while !current.nil? && !current.next.nil?\n        temp = current.next.next\n        current.next.next = current\n        current.next = temp&.next || temp\n        current = temp\n    end\n    \n    new_head\nend"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to understand how to manipulate the nodes of a singly-linked list rather than the values they contain. Specifically, we aim to swap every two adjacent nodes in the list. Let's break down the solution.\n\n# Explanation\n\n1. **Initial Checks**: First, we check if the list is empty or has only one node. In either case, we return the head since no swaps are needed.\n   \n2. **Dummy Node**: We create a dummy node that acts as a predecessor to the head of the list. This simplifies edge cases where the head itself might be swapped.\n\n3. **Swapping Nodes**: Using a loop, we traverse the list in pairs:\n    - We identify the two nodes to be swapped (`first_node` and `second_node`).\n    - We adjust the pointers to swap the nodes.\n    - We move the `prev_node` pointer and the `head` pointer to the next pair of nodes.\n\n4. **Return New Head**: Finally, we return the next node of the dummy, which now acts as the head of the modified list.\n\nHere's the pseudocode for a clear step-by-step understanding:\n\n# Pseudocode\n\n```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head):\n        # Step 1: Check if the list has 0 or 1 node\n        if not head or not head.next:\n            return head\n\n        # Step 2: Initialize a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        prev_node = dummy\n\n        # Step 3: Traverse the list in pairs\n        while head and head.next:\n            # Identify the two nodes to swap\n            first_node = head\n            second_node = head.next\n\n            # Adjust the pointers to swap nodes\n            prev_node.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n\n            # Move to the next pair\n            prev_node = first_node\n            head = first_node.next\n\n        # Step 4: Return the new head of the list\n        return dummy.next\n```\n\nIn this pseudocode:\n\n- The `ListNode` class models the nodes in our singly-linked list.\n- The `Solution` class contains the method `swapPairs` which performs the node swapping.\n- The dummy node helps manage the edge cases and simplifies pointer manipulation.\n- The loop iterates through the list and rearranges the nodes pair by pair.\n\nThis approach ensures we do not modify the list node values but rather change the node pointers to achieve the desired swap.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-swap-nodes-in-pairs"
    },
    {
        "name": "Merge Two Sorted Lists",
        "site": "LeetCode",
        "href": "/solution/LeetCode-merge-two-sorted-lists",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy(0);\n        ListNode* tail = &dummy;\n        \n        while (list1 && list2) {\n            if (list1->val < list2->val) {\n                tail->next = list1;\n                list1 = list1->next;\n            } else {\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n        \n        tail->next = list1 ? list1 : list2;\n        \n        return dummy.next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        if (list1 == null) {\n            return list2;\n        }\n        if (list2 == null) {\n            return list1;\n        }\n        \n        if (list1.val < list2.val) {\n            list1.next = mergeTwoLists(list1.next, list2);\n            return list1;\n        } else {\n            list2.next = mergeTwoLists(list1, list2.next);\n            return list2;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class  ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode(0)\n        current = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        if list1:\n            current.next = list1\n        if list2:\n            current.next = list2\n        return dummy.next\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n    struct ListNode dummy;\n    struct ListNode* tail = &dummy;\n    dummy.next = NULL;\n    \n    while (list1 && list2) {\n        struct ListNode** pp = list1->val < list2->val ? &list1 : &list2;\n        tail->next = *pp;\n        *pp = (*pp)->next;\n        tail = tail->next;\n    }\n    \n    tail->next = list1 ? list1 : list2;\n    return dummy.next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        if (list1 == null) return list2;\n        if (list2 == null) return list1;\n        \n        if (list1.val < list2.val)\n        {\n            list1.next = MergeTwoLists(list1.next, list2);\n            return list1;\n        }\n        else\n        {\n            list2.next = MergeTwoLists(list1, list2.next);\n            return list2;\n        }\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction mergeTwoLists(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    if (!l1) return l2;\n    if (!l2) return l1;\n    \n    if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param ListNode $list1\n     * @param ListNode $list2\n     * @return ListNode\n     */\n    function mergeTwoLists($list1, $list2) {\n        $dummy = new ListNode();\n        $tail = $dummy;\n        \n        while ($list1 != null && $list2 != null) {\n            if ($list1->val < $list2->val) {\n                $tail->next = $list1;\n                $list1 = $list1->next;\n            } else {\n                $tail->next = $list2;\n                $list2 = $list2->next;\n            }\n            $tail = $tail->next;\n        }\n        \n        if ($list1 != null) {\n            $tail->next = $list1;\n        }\n        \n        if ($list2 != null) {\n            $tail->next = $list2;\n        }\n        \n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n        if list1 == nil {\n            return list2\n        } else if list2 == nil {\n            return list1\n        } else if list1!.val < list2!.val {\n            list1!.next = mergeTwoLists(list1!.next, list2)\n            return list1\n        } else {\n            list2!.next = mergeTwoLists(list1, list2!.next)\n            return list2\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {\n        if (list1 == null) {\n            return list2\n        }\n        if (list2 == null) {\n            return list1\n        }\n        \n        if (list1.`val` < list2.`val`) {\n            list1.next = mergeTwoLists(list1.next, list2)\n            return list1\n        } else {\n            list2.next = mergeTwoLists(list1, list2.next)\n            return list2\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeTwoLists(ListNode? list1, ListNode? list2) {\n      if (list1 == null) return list2;\n      if (list2 == null) return list1;\n      \n      if (list1.val < list2.val) {\n        list1.next = mergeTwoLists(list1.next, list2);\n        return list1;\n      } else {\n        list2.next = mergeTwoLists(list1, list2.next);\n        return list2;\n      }\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    dummy := &ListNode{}\n    current := dummy\n\n    for list1 != nil && list2 != nil {\n        if list1.Val < list2.Val {\n            current.Next = list1\n            list1 = list1.Next\n        } else {\n            current.Next = list2\n            list2 = list2.Next\n        }\n        current = current.Next\n    }\n\n    if list1 != nil {\n        current.Next = list1\n    }\n\n    if list2 != nil {\n        current.Next = list2\n    }\n\n    return dummy.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} list1\n# @param {ListNode} list2\n# @return {ListNode}\ndef merge_two_lists(list1, list2)\n    dummy = ListNode.new\n    current = dummy\n    \n    while list1 && list2\n        if list1.val < list2.val\n            current.next = list1\n            list1 = list1.next\n        else\n            current.next = list2\n            list2 = list2.next\n        end\n        current = current.next\n    end\n    \n    current.next = list1 if list1\n    current.next = list2 if list2\n    \n    return dummy.next\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def mergeTwoLists(list1: ListNode, list2: ListNode): ListNode = {\n        if (list1 == null) return list2\n        if (list2 == null) return list1\n\n        if (list1.x < list2.x) {\n            list1.next = mergeTwoLists(list1.next, list2)\n            list1\n        } else {\n            list2.next = mergeTwoLists(list1, list2.next)\n            list2\n        }\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n-spec merge_two_lists(List1 :: #list_node{} | null, List2 :: #list_node{} | null) -> #list_node{} | null.\nmerge_two_lists(null, List2) ->\n    List2;\nmerge_two_lists(List1, null) ->\n    List1;\nmerge_two_lists(#list_node{val = Val1, next = Next1} = List1, #list_node{val = Val2, next = Next2} = List2) when Val1 =< Val2 ->\n    List1#list_node{next = merge_two_lists(Next1, List2)};\nmerge_two_lists(List1, List2) ->\n    merge_two_lists(List2, List1).\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "# Definition for singly-linked list.\n\ndefmodule ListNode do\n  @type t :: %__MODULE__{\n          val: integer,\n          next: ListNode.t() | nil\n        }\n  defstruct val: 0, next: nil\nend\n\ndefmodule Solution do\n  @spec merge_two_lists(list1 :: ListNode.t | nil, list2 :: ListNode.t | nil) :: ListNode.t | nil\n  def merge_two_lists(nil, list) do\n    list\n  end\n\n  def merge_two_lists(list, nil) do\n    list\n  end\n\n  def merge_two_lists(list1 = %ListNode{val: val1, next: next1}, list2 = %ListNode{val: val2, next: next2}) when val1 <= val2 do\n    new_next = merge_two_lists(next1, list2)\n    %ListNode{val: val1, next: new_next}\n  end\n\n  def merge_two_lists(list1, list2) do\n    merge_two_lists(list2, list1)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to merge two sorted linked lists into a single sorted linked list. Here's a step-by-step breakdown of the logic and pseudocode.\n\n# Explanation\n1. **Initialize a Dummy Node**: Create a dummy node that will serve as the starting point of the merged list. This helps in simplifying the code as we don\u2019t have to handle special cases for the head of the merged list.\n\n2. **Use a Pointer for the Current Position**: Maintain a pointer (`current`) that tracks the last node in the merged list.\n\n3. **Traverse Both Lists**: Simultaneously iterate through both `list1` and `list2`, comparing the values at each step.\n    - If the value in `list1` is less than the value in `list2`, append the `list1` node to the merged list.\n    - Otherwise, append the `list2` node to the merged list.\n    - Move the appropriate pointer (`list1` or `list2`) to the next node.\n\n4. **Append the Remaining Nodes**: Once one of the lists is completely traversed, append any remaining nodes from the other list to the merged list.\n\n5. **Return the Head of the Merged List**: The head of the merged list is the next node of the dummy node.\n\n# Pseudocode\n```\n# Pseudocode for merging two sorted linked lists\n\n# Define the ListNode class\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Define function to merge two sorted lists\ndef mergeTwoLists(list1, list2):\n    # Step 1: Initialize a dummy node\n    dummy = ListNode(0)\n    \n    # Step 2: Initialize a pointer for the current position\n    current = dummy\n    \n    # Step 3: Traverse both lists\n    while list1 is not None and list2 is not None:\n        if list1.val < list2.val:\n            current.next = list1    # Append list1 node\n            list1 = list1.next      # Move list1 pointer\n        else:\n            current.next = list2    # Append list2 node\n            list2 = list2.next      # Move list2 pointer\n        current = current.next\n    \n    # Step 4: Append the remaining nodes\n    if list1 is not None:\n        current.next = list1\n    if list2 is not None:\n        current.next = list2\n    \n    # Step 5: Return the head of the merged list\n    return dummy.next\n```\n\nIn this pseudocode, `ListNode` is a class defining the structure of a node in the linked list, including a value and a pointer to the next node. The `mergeTwoLists` function performs the merging operation as described in the steps above.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-merge-two-sorted-lists"
    },
    {
        "name": "Generate Parentheses",
        "site": "LeetCode",
        "href": "/solution/LeetCode-generate-parentheses",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> result;\n        backtrack(result, \"\", 0, 0, n);\n        return result;\n    }\n    \n    void backtrack(vector<string>& result, string current, int open, int close, int max) {\n        if (current.size() == 2 * max) {\n            result.push_back(current);\n            return;\n        }\n        \n        if (open < max) {\n            backtrack(result, current + \"(\", open + 1, close, max);\n        }\n        if (close < open) {\n            backtrack(result, current + \")\", open, close + 1, max);\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        backtrack(result, \"\", 0, 0, n);\n        return result;\n    }\n    \n    public void backtrack(List<String> result, String current, int open, int close, int max) {\n        if (current.length() == max * 2) {\n            result.add(current);\n            return;\n        }\n        \n        if (open < max) {\n            backtrack(result, current + \"(\", open + 1, close, max);\n        }\n        if (close < open) {\n            backtrack(result, current + \")\", open, close + 1, max);\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def generateParenthesis(self, n):\n        def backtrack(result, curr, open_count, close_count):\n            if len(curr) == 2 * n:\n                result.append(curr)\n                return\n            if open_count < n:\n                backtrack(result, curr + '(', open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(result, curr + ')', open_count, close_count + 1)\n        \n        result = []\n        backtrack(result, \"\", 0, 0)\n        return result\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> GenerateParenthesis(int n) {\n        IList<string> result = new List<string>();\n        GenerateParenthesisHelper(n, n, \"\", result);\n        return result;\n    }\n    \n    private void GenerateParenthesisHelper(int left, int right, string current, IList<string> result) {\n        if (left == 0 && right == 0) {\n            result.Add(current);\n            return;\n        }\n        \n        if (left > 0) {\n            GenerateParenthesisHelper(left - 1, right, current + \"(\", result);\n        }\n        \n        if (right > left) {\n            GenerateParenthesisHelper(left, right - 1, current + \")\", result);\n        }\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function generateParenthesis(n: number): string[] {\n    const result: string[] = [];\n\n    const backtrack = (str: string, open: number, close: number) => {\n        if (str.length === 2 * n) {\n            result.push(str);\n            return;\n        }\n\n        if (open < n) {\n            backtrack(str + '(', open + 1, close);\n        }\n        if (close < open) {\n            backtrack(str + ')', open, close + 1);\n        }\n    };\n\n    backtrack('', 0, 0);\n\n    return result;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func generateParenthesis(_ n: Int) -> [String] {\n        var result = [String]()\n        \n        func backtrack(_ str: String, _ open: Int, _ close: Int) {\n            if str.count == 2 * n {\n                result.append(str)\n                return\n            }\n            \n            if open < n {\n                backtrack(str + \"(\", open + 1, close)\n            }\n            if close < open {\n                backtrack(str + \")\", open, close + 1)\n            }\n        }\n        \n        backtrack(\"\", 0, 0)\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun generateParenthesis(n: Int): List<String> {\n        val result = mutableListOf<String>()\n        \n        fun backtrack(s: String, open: Int, close: Int) {\n            if (s.length == 2 * n) {\n                result.add(s)\n                return\n            }\n            if (open < n) {\n                backtrack(\"$s(\", open + 1, close)\n            }\n            if (close < open) {\n                backtrack(\"$s)\", open, close + 1)\n            }\n        }\n        \n        backtrack(\"\", 0, 0)\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> generateParenthesis(int n) {\n    List<String> result = [];\n    \n    void backtrack(String current, int open, int close) {\n      if (current.length == n * 2) {\n        result.add(current);\n        return;\n      }\n      \n      if (open < n) {\n        backtrack(current + '(', open + 1, close);\n      }\n      if (close < open) {\n        backtrack(current + ')', open, close + 1);\n      }\n    }\n    \n    backtrack('', 0, 0);\n    \n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func generateParenthesis(n int) []string {\n    var res []string\n    backtrack(\"\", 0, 0, n, &res)\n    return res\n}\n\nfunc backtrack(current string, open, close, max int, res *[]string) {\n    if len(current) == max*2 {\n        *res = append(*res, current)\n        return\n    }\n\n    if open < max {\n        backtrack(current+\"(\", open+1, close, max, res)\n    }\n    if close < open {\n        backtrack(current+\")\", open, close+1, max, res)\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {String[]}\ndef generate_parenthesis(n)\n    result = []\n    backtrack(result, \"\", 0, 0, n)\n    result\nend\n\ndef backtrack(result, current, open, close, max)\n    if current.length == max * 2\n        result << current\n        return\n    end\n\n    if open < max\n        backtrack(result, current + \"(\", open + 1, close, max)\n    end\n\n    if close < open\n        backtrack(result, current + \")\", open, close + 1, max)\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def generateParenthesis(n: Int): List[String] = {\n        def backtrack(open: Int, close: Int, current: String, result: List[String]): List[String] = {\n            if (open == 0 && close == 0) {\n                current :: result\n            } else {\n                var newResult = result\n                if (open > 0) {\n                    newResult = backtrack(open - 1, close, current + \"(\", newResult)\n                }\n                if (close > open) {\n                    newResult = backtrack(open, close - 1, current + \")\", newResult)\n                }\n                newResult\n            }\n        }\n        \n        if (n <= 0) {\n            List()\n        } else {\n            backtrack(n, n, \"\", List())\n        }\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\n        let mut result = Vec::new();\n        \n        fn generate(s: String, left: i32, right: i32, result: &mut Vec<String>) {\n            if left == 0 && right == 0 {\n                result.push(s);\n                return;\n            }\n            \n            if left > 0 {\n                generate(format!(\"{}(\", s), left - 1, right, result);\n            }\n            \n            if right > left {\n                generate(format!(\"{})\", s), left, right - 1, result);\n            }\n        }\n        \n        generate(\"\".to_string(), n, n, &mut result);\n        \n        result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to generate all combinations of well-formed parentheses for a given number of pairs \\( n \\). This can be efficiently achieved using a backtracking approach.\n\n### # Explanation\nThe key idea is to generate all possible strings of parentheses using a depth-first search (DFS) approach. We maintain counts of the open and close parentheses used so far to ensure the generated strings are valid.\n\n### # Pseudocode\n\n```\nfunction generateParenthesis(n):\n    initialize result as an empty list\n    \n    function backtrack(result, curr, open_count, close_count):\n        if length of curr is equal to 2 * n:\n            append curr to result\n            return\n        \n        if open_count < n:\n            call backtrack(result, curr + '(', open_count + 1, close_count)\n        \n        if close_count < open_count:\n            call backtrack(result, curr + ')', open_count, close_count + 1)\n    \n    call backtrack(result, \"\", 0, 0)\n    \n    return result\n```\n\n### Steps Explained:\n1. **Initialization:** Start with an empty result list that will store all valid parentheses combinations.\n2. **Backtracking Function:** Use a helper function `backtrack` to build the parentheses string (`curr`) recursively.\n    - If the current string's length reaches `2 * n`, it means we have used `n` pairs of parentheses, hence we add the current string `curr` to the result list.\n    - If the number of open parentheses used (`open_count`) is less than `n`, add an open parenthesis `'('` and recursively call `backtrack` with the updated open count.\n    - If the number of close parentheses used (`close_count`) is less than the open parentheses used, add a close parenthesis `')'` and recursively call `backtrack` with the updated close count.\n3. **Initial Call:** Start the backtracking with an empty current string and zero counts for both open and close parentheses.\n4. **Return Result:** Finally, return the result list which contains all valid combinations of well-formed parentheses.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-generate-parentheses"
    },
    {
        "name": "Merge K Sorted Lists",
        "site": "LeetCode",
        "href": "/solution/LeetCode-merge-k-sorted-lists",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if (lists.empty()) return nullptr;\n        \n        auto cmp = [](ListNode* a, ListNode* b) {\n            return a->val > b->val;\n        };\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\n        \n        for (auto list : lists) {\n            if (list) pq.push(list);\n        }\n        \n        ListNode dummy(0);\n        ListNode* tail = &dummy;\n        \n        while (!pq.empty()) {\n            ListNode* node = pq.top();\n            pq.pop();\n            tail->next = node;\n            tail = tail->next;\n            if (node->next) pq.push(node->next);\n        }\n        \n        return dummy.next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        \n        for (ListNode node : lists) {\n            if (node != null) {\n                pq.offer(node);\n            }\n        }\n        \n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            current.next = node;\n            current = current.next;\n            \n            if (node.next != null) {\n                pq.offer(node.next);\n            }\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "import heapq\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        heap = []\n        for idx, node in enumerate(lists):\n            if node:\n                heap.append((node.val, idx, node))\n        heapq.heapify(heap)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while heap:\n            val, idx, node = heapq.heappop(heap)\n            curr.next = ListNode(val)\n            curr = curr.next\n            if node.next:\n                heapq.heappush(heap, (node.next.val, idx, node.next))\n        \n        return dummy.next\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode MergeKLists(ListNode[] lists) {\n        if (lists == null || lists.Length == 0) return null;\n        \n        ListNode result = null;\n        foreach (var list in lists)\n        {\n            result = MergeTwoLists(result, list);\n        }\n        \n        return result;\n    }\n    \n    private ListNode MergeTwoLists(ListNode l1, ListNode l2)\n    {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n        \n        if (l1.val < l2.val)\n        {\n            l1.next = MergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else\n        {\n            l2.next = MergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    const mergeTwoLists = (l1, l2) => {\n        if (!l1) return l2;\n        if (!l2) return l1;\n        \n        if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n    \n    const merge = (lists, start, end) => {\n        if (start === end) return lists[start];\n        if (start > end) return null;\n        \n        const mid = Math.floor((start + end) / 2);\n        const left = merge(lists, start, mid);\n        const right = merge(lists, mid + 1, end);\n        \n        return mergeTwoLists(left, right);\n    }\n    \n    return merge(lists, 0, lists.length - 1);\n};\n\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n    if (lists.length === 0) return null;\n\n    const mergeTwoLists = (l1: ListNode | null, l2: ListNode | null): ListNode | null => {\n        if (!l1) return l2;\n        if (!l2) return l1;\n\n        if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    };\n\n    const merge = (left: number, right: number): ListNode | null => {\n        if (left === right) return lists[left];\n        const mid = Math.floor((left + right) / 2);\n        const l1 = merge(left, mid);\n        const l2 = merge(mid + 1, right);\n        return mergeTwoLists(l1, l2);\n    };\n\n    return merge(0, lists.length - 1);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param ListNode[] $lists\n     * @return ListNode\n     */\n    function mergeKLists($lists) {\n        $arr = [];\n        foreach ($lists as $list) {\n            while ($list != null) {\n                $arr[] = $list->val;\n                $list = $list->next;\n            }\n        }\n        sort($arr);\n        \n        $dummy = new ListNode(0);\n        $cur = $dummy;\n        foreach ($arr as $val) {\n            $cur->next = new ListNode($val);\n            $cur = $cur->next;\n        }\n        \n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\n        var values = [Int]()\n        \n        for list in lists {\n            var current = list\n            while current != nil {\n                values.append(current!.val)\n                current = current?.next\n            }\n        }\n        \n        values.sort()\n        \n        var newHead: ListNode?\n        var current: ListNode?\n        \n        for value in values {\n            if newHead == nil {\n                newHead = ListNode(value)\n                current = newHead\n            } else {\n                current?.next = ListNode(value)\n                current = current?.next\n            }\n        }\n        \n        return newHead\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun mergeKLists(lists: Array<ListNode?>): ListNode? {\n        if (lists.isEmpty()) return null\n        return merge(lists, 0, lists.size - 1)\n    }\n    \n    fun merge(lists: Array<ListNode?>, left: Int, right: Int): ListNode? {\n        if (left == right) return lists[left]\n        \n        val mid = left + (right - left) / 2\n        val l1 = merge(lists, left, mid)\n        val l2 = merge(lists, mid + 1, right)\n        \n        return mergeTwoLists(l1, l2)\n    }\n    \n    fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? {\n        if (l1 == null) return l2\n        if (l2 == null) return l1\n        \n        if (l1.`val` < l2.`val`) {\n            l1.next = mergeTwoLists(l1.next, l2)\n            return l1\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next)\n            return l2\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? mergeKLists(List<ListNode?> lists) {\n    List<int> allNodes = [];\n    for (var listNode in lists) {\n      while (listNode != null) {\n        allNodes.add(listNode.val);\n        listNode = listNode.next;\n      }\n    }\n    allNodes.sort();\n    ListNode dummy = ListNode();\n    ListNode current = dummy;\n    for (int nodeVal in allNodes) {\n      current.next = ListNode(nodeVal);\n      current = current.next!;\n    }\n    return dummy.next;\n  }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n-spec merge_k_lists(Lists :: [#list_node{} | null]) -> #list_node{} | \nnull.\nmerge_k_lists(Lists) ->\n    merge(Lists).\n\nmerge([H|T]) ->\n    merge_two_lists(H, merge(T));\nmerge([]) ->\n    null.\n\nmerge_two_lists(null, L) ->\n    L;\nmerge_two_lists(L, null) ->\n    L;\nmerge_two_lists(L1 = #list_node{val = Val1, next = Next1}, L2 = #list_node{val = Val2, next = Next2}) when Val1 < Val2 ->\n    L1#list_node{next = merge_two_lists(Next1, L2)};\nmerge_two_lists(L1, L2) ->\n    L2#list_node{next = merge_two_lists(L1, L2#list_node.next)}.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will use a min-heap to efficiently merge k sorted linked lists into one sorted linked list. Below is a detailed explanation followed by the pseudocode.\n\n# Explanation\n1. **Understanding Linked Lists:** Each linked list node contains a value (`val`) and a pointer (`next`) to the next node. Given `k` sorted linked lists, our goal is to merge them into a single sorted linked list.\n2. **Using a Min-Heap:** A min-heap is useful in this scenario because it allows us to efficiently retrieve the smallest element among the currently available nodes from each list.\n3. **Heap Operations:**\n   - **Inserting Nodes:** Initially, insert the first node of each linked list into the heap.\n   - **Extracting and Adding Nodes:** Continuously extract the smallest node from the heap and add it to the result list. If this node has a next node, insert the next node into the heap.\n4. **Constructing the Result:** Use a dummy node to simplify the list construction process, then traverse from the dummy node to build the result linked list.\n\n# Pseudocode\n\n```pseudocode\n# Define the structure of a ListNode\nclass ListNode:\n    val: Integer\n    next: ListNode\n    \n    # constructor\n    function __init__(val=0, next=None):\n        this.val = val\n        this.next = next\n\nfunction mergeKLists(lists):\n    # Initialize the min-heap\n    heap = []\n    \n    # Add the initial nodes of each list to the heap\n    for i from 0 to length(lists) - 1:\n        if lists[i] is not None:\n            heap.append((lists[i].val, i, lists[i]))\n    \n    # Heapify the list to turn it into a min-heap\n    heapq.heapify(heap)\n    \n    # Create a dummy node to help with result list creation\n    dummy = ListNode()\n    current = dummy\n    \n    # While there are elements in the heap\n    while heap is not empty:\n        # Extract the smallest element from the heap\n        val, node_idx, node = heapq.heappop(heap)\n        \n        # Add the smallest element to the result list\n        current.next = ListNode(val)\n        current = current.next\n        \n        # If the extracted node has a next node, add it to the heap\n        if node.next is not None:\n            heapq.heappush(heap, (node.next.val, node_idx, node.next))\n    \n    # Return the merged linked list, starting from the node after the dummy\n    return dummy.next\n```\n\nThis pseudocode provides a clear and concise plan to merge multiple sorted linked lists using a min-heap in a way that maintains efficient time complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-merge-k-sorted-lists"
    },
    {
        "name": "Remove Element",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-element",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int k = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] != val) {\n                nums[k++] = nums[i];\n            }\n        }\n        return k;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int k = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != val) {\n                nums[k] = nums[i];\n                k++;\n            }\n        }\n        return k;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        k = 0\n        for num in nums:\n            if num != val:\n                nums[k] = num\n                k += 1\n        return k\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int removeElement(int* nums, int numsSize, int val) {\n    int k = 0;\n    for(int i = 0; i < numsSize; i++) {\n        if(nums[i] != val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    return k;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int RemoveElement(int[] nums, int val) {\n        int k = 0;\n        for (int i = 0; i < nums.Length; i++) {\n            if (nums[i] != val) {\n                nums[k] = nums[i];\n                k++;\n            }\n        }\n        return k;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    let k = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    \n    return k;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function removeElement(nums: number[], val: number): number {\n    let k = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    return k;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $val\n     * @return Integer\n     */\n    function removeElement(&$nums, $val) {\n        $k = 0;\n        foreach($nums as $num){\n            if($num != $val){\n                $nums[$k++] = $num;\n            }\n        }\n        return $k;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\n        var k = 0\n        for i in 0..<nums.count {\n            if nums[i] != val {\n                nums[k] = nums[i]\n                k += 1\n            }\n        }\n        return k\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun removeElement(nums: IntArray, `val`: Int): Int {\n        var k = 0\n        for (num in nums) {\n            if (num != `val`) {\n                nums[k] = num\n                k++\n            }\n        }\n        return k\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you can employ a simple in-place iteration and modification methodology. The core idea is to iterate through the `nums` array, and whenever you encounter an element that is not equal to `val`, you copy it to the current position of a separate index (`k`). This index (`k`) keeps track of the position where the next non-`val` element should be placed, effectively pushing all non-`val` elements to the front of the array.\n\nHere is the step-by-step methodology along with the pseudocode:\n\n# Explanation\n\n1. Initialize an index `k` to 0. This index will be used to track the position of the next non-`val` element in the array.\n2. Iterate over each element in the `nums` array.\n3. For each element in the array:\n   - If the element is not equal to `val`, place it at the `k`-th index position in the array and increment `k`.\n4. After the iteration is complete, `k` will contain the number of elements that are not equal to `val`.\n5. Return `k`.\n\n# Pseudocode\n\n```\nfunction removeElement(nums, val):\n    k := 0\n    \n    for each element num in nums:\n        if num is not equal to val:\n            nums[k] := num\n            k := k + 1\n            \n    return k\n```\n\nThis algorithm modifies the array in-place, ensuring that the first `k` elements are those that are not equal to `val`. The elements beyond position `k` are not important as they can be left as is (or considered irrelevant). The returned value `k` represents the count of elements that are not equal to `val`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-element"
    },
    {
        "name": "Reverse Nodes In K Group",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reverse-nodes-in-k-group",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* curr = head;\n        int count = 0;\n        while (curr != nullptr && count < k) {\n            curr = curr->next;\n            count++;\n        }\n        if (count == k) {\n            ListNode* reversedHead = reverseLinkedList(head, k);\n            head->next = reverseKGroup(curr, k);\n            return reversedHead;\n        }\n        return head;\n    }\n\n    ListNode* reverseLinkedList(ListNode* head, int k) {\n        ListNode *prev = nullptr, *curr = head, *next = nullptr;\n        while (k > 0 && curr != nullptr) {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n            k--;\n        }\n        return prev;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || k == 1) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode start = dummy;\n        ListNode end = head;\n        int count = 0;\n        \n        while (end != null) {\n            count++;\n            if (count % k == 0) {\n                start = reverse(start, end.next);\n                end = start.next;\n            } else {\n                end = end.next;\n            }\n        }\n        \n        return dummy.next;\n    }\n    \n    private ListNode reverse(ListNode start, ListNode end) {\n        ListNode prev = start;\n        ListNode curr = start.next;\n        ListNode first = curr;\n        \n        while (curr != end) {\n            ListNode temp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = temp;\n        }\n        \n        start.next = prev;\n        first.next = curr;\n        return first;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        def reverseLinkedList(head, k):\n            prev = None\n            curr = head\n            while k > 0:\n                next_node = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_node\n                k -= 1\n            return prev\n\n        def getLength(head):\n            length = 0\n            while head:\n                length += 1\n                head = head.next\n            return length\n\n        length = getLength(head)\n        dummy = ListNode(0)\n        dummy.next = head\n        prev_group_end = dummy\n        while length >= k:\n            group_start = prev_group_end.next\n            group_end = group_start\n            for _ in range(k - 1):\n                group_end = group_end.next\n            next_group_start = group_end.next\n            group_end.next = None\n            prev_group_end.next = reverseLinkedList(group_start, k)\n            group_start.next = next_group_start\n            prev_group_end = group_start\n            length -= k\n        return dummy.next\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    if (!head || k == 1) {\n        return head;\n    }\n    \n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->next = head;\n    struct ListNode *cur = dummy, *nex = dummy, *pre = dummy;\n    int count = 0;\n    \n    while (cur->next) {\n        cur = cur->next;\n        count++;\n    }\n    \n    while (count >= k) {\n        cur = pre->next;\n        nex = cur->next;\n        for (int i = 1; i < k; i++) {\n            cur->next = nex->next;\n            nex->next = pre->next;\n            pre->next = nex;\n            nex = cur->next;\n        }\n        pre = cur;\n        count -= k;\n    }\n    \n    return dummy->next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        if (head == null || k == 1) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        ListNode prev = dummy;\n        ListNode curr = head;\n        \n        int length = 0;\n        while (curr != null) {\n            length++;\n            curr = curr.next;\n        }\n        \n        while (length >= k) {\n            curr = prev.next;\n            ListNode next = curr.next;\n            for (int i = 1; i < k; i++) {\n                curr.next = next.next;\n                next.next = prev.next;\n                prev.next = next;\n                next = curr.next;\n            }\n            prev = curr;\n            length -= k;\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n    const reverse = (start: ListNode, end: ListNode) => {\n        let prev = null;\n        let curr = start;\n        while (curr !== end) {\n            const nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    };\n    \n    let count = 0;\n    let current = head;\n    while (count < k && current) {\n        current = current.next;\n        count++;\n    }\n    \n    if (count < k) {\n        return head;\n    }\n    \n    const newHead = reverse(head, current);\n    head.next = reverseKGroup(current, k);\n    \n    return newHead;\n}\n\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function reverseKGroup($head, $k) {\n        $count = 0;\n        $current = $head;\n        while ($count < $k && $current != null) {\n            $current = $current->next;\n            $count++;\n        }\n        \n        if ($count == $k) {\n            $reversedHead = $this->reverseList($head, $k);\n            $head->next = $this->reverseKGroup($current, $k);\n            return $reversedHead;\n        }\n        \n        return $head;\n    }\n    \n    function reverseList($head, $k) {\n        $prev = null;\n        $current = $head;\n        $next = null;\n        \n        while ($k > 0 && $current != null) {\n            $next = $current->next;\n            $current->next = $prev;\n            $prev = $current;\n            $current = $next;\n            $k--;\n        }\n        \n        return $prev;\n    }\n}\n\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func reverseKGroup(_ head: ListNode?, _ k: Int) -> ListNode? {\n        var count = 0\n        var current = head\n        \n        while current != nil, count < k {\n            current = current?.next\n            count += 1\n        }\n        \n        if count == k {\n            var prev: ListNode? = nil\n            var next: ListNode? = nil\n            var current = head\n            \n            for _ in 0..<k {\n                next = current?.next\n                current?.next = prev\n                prev = current\n                current = next\n            }\n            \n            if let next = next {\n                head?.next = reverseKGroup(next, k)\n            }\n            \n            return prev\n        }\n        \n        return head\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\n        fun reverseLinkedList(head: ListNode?, k: Int): ListNode? {\n            var count = 0\n            var temp = head\n            while (count < k) {\n                if (temp == null) {\n                    return head\n                }\n                temp = temp.next\n                count++\n            }\n            \n            var prev: ListNode? = null\n            var current = head\n            var next: ListNode?\n            count = 0\n            while (count < k) {\n                next = current?.next\n                current?.next = prev\n                prev = current\n                current = next\n                count++\n            }\n            \n            head?.next = reverseLinkedList(current, k)\n            return prev\n        }\n        \n        return reverseLinkedList(head, k)\n    }\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def reverseKGroup(head: ListNode, k: Int): ListNode = {\n        def reverse(head: ListNode, tail: ListNode): ListNode = {\n            var prev: ListNode = null\n            var curr = head\n            while (curr != tail) {\n                val nextTemp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = nextTemp\n            }\n            prev\n        }\n\n        var count = 0\n        var curr = head\n        while (count < k && curr != null) {\n            curr = curr.next\n            count += 1\n        }\n\n        if (count == k) {\n            val reversedHead = reverse(head, curr)\n            head.next = reverseKGroup(curr, k)\n            reversedHead\n        } else {\n            head\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to reverse the nodes of a linked list in groups of size `k`. If the number of remaining nodes is less than `k` then those nodes should remain unchanged.\n\n# Explanation\n1. **Reverse Function**: Create a helper function to reverse a linked list segment of size `k`.\n2. **Length Calculation**: Calculate the total length of the linked list to know the number of complete `k`-sized segments.\n3. **Dummy Node**: Use a dummy node to simplify edge cases such as reversing the first segment.\n4. **Group Reversal Loop**: Traverse the list and reverse each `k`-sized segment until less than `k` nodes are left.\n\n# Pseudocode\n```\nfunction reverseKGroup(head, k):\n    function reverseLinkedList(head, k):\n        prev = None\n        curr = head\n        while k > 0:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n            k -= 1\n        return prev  // returns the new head after reversal\n\n    function getLength(head):\n        length = 0\n        while head is not None:\n            length += 1\n            head = head.next\n        return length\n\n    length = getLength(head)\n    dummy = ListNode(0)  // a dummy node to handle edge cases\n    dummy.next = head\n    prev_group_end = dummy\n    \n    while length >= k:\n        group_start = prev_group_end.next\n        group_end = group_start\n        for i = 1 to k - 1:  // find the end of the current group\n            group_end = group_end.next\n        next_group_start = group_end.next\n        group_end.next = None  // cut the connection to the next group\n        prev_group_end.next = reverseLinkedList(group_start, k)  // reverse the current group and connect it\n        group_start.next = next_group_start  // connect the reversed group to the next group\n        prev_group_end = group_start  // update the end of the previous group\n        length -= k\n\n    return dummy.next  // return the new head of the modified list\n```\n\nThis pseudocode lays out all necessary steps and helper functions to accomplish the challenge, ensuring the nodes are reversed in groups of `k` while respecting the remaining nodes if they are fewer than `k`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reverse-nodes-in-k-group"
    },
    {
        "name": "Remove Duplicates From Sorted Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-duplicates-from-sorted-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\nint removeDuplicates(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        \n        int index = 1;\n        for(int i = 1; i < nums.size(); i++){\n            if(nums[i] != nums[i-1]){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0) return 0;\n        \n        int index = 1;\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] != nums[i-1]){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        k = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1]:\n                nums[k] = nums[i]\n                k += 1\n        \n        return k\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to remove duplicates from a sorted array in-place, ensuring that each element appears only once. The objective is to update the array such that the first k elements contain the unique elements, maintaining their initial order. Here's how you can approach this:\n\n# Explanation\n1. **Initialization**: Start by checking if the list is empty. If it is, return 0 since there are no elements to process.\n2. **Unique Count**: Initialize a counter `k` to 1. This will represent the number of unique elements found so far.\n3. **Iterate Through List**: Starting from the second element, compare each element with the previous one.\n4. **Update Unique Elements**:\n   - If the current element is different from the previous element, it means we have found a new unique element.\n   - Assign this new unique element to the position indexed by `k` and increment the counter `k`.\n5. **Return the Unique Count**: After the loop, `k` will represent the number of unique elements, and the first `k` elements in the array will be the required unique elements.\n\n# Pseudocode\n```\nfunction removeDuplicates(nums: List of Integers) -> Integer:\n    if nums is empty:\n        return 0\n    \n    # Initialize the counter for unique elements\n    k = 1\n    \n    # Iterate through the list starting from the second element\n    for i from 1 to length of nums - 1:\n        # If the current element is different from the previous one\n        if nums[i] != nums[i - 1]:\n            # Place it at the kth index of the array\n            nums[k] = nums[i]\n            # Increment the counter\n            k += 1\n    \n    # Return the number of unique elements\n    return k\n```\n\nThis approach ensures that the duplicates are removed in-place with a time complexity of O(n) and a space complexity of O(1), making it efficient for large input sizes.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-duplicates-from-sorted-array"
    },
    {
        "name": "Divide Two Integers",
        "site": "LeetCode",
        "href": "/solution/LeetCode-divide-two-integers",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN && divisor == -1) return INT_MAX;\n        \n        long dvd = labs(dividend);\n        long dvs = labs(divisor);\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n        \n        long result = 0;\n        while(dvd >= dvs) {\n            long temp = dvs, multiple = 1;\n            while(dvd >= (temp << 1)) {\n                temp <<= 1;\n                multiple <<= 1;\n            }\n            dvd -= temp;\n            result += multiple;\n        }\n        \n        return sign * result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE;\n        }\n        \n        int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\n        \n        long dvd = Math.abs((long)dividend);\n        long dvs = Math.abs((long)divisor);\n        \n        int result = 0;\n        while(dvd >= dvs) {\n            long temp = dvs, multiple = 1;\n            while(dvd >= (temp << 1)) {\n                temp <<= 1;\n                multiple <<= 1;\n            }\n            dvd -= temp;\n            result += multiple;\n        }\n        \n        return sign == 1 ? result : -result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def divide(self, dividend, divisor):\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n        \n        negative = (dividend < 0) != (divisor < 0)\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        \n        while dividend >= divisor:\n            temp, i = divisor, 1\n            while dividend >= temp:\n                dividend -= temp\n                quotient += i\n                i <<= 1\n                temp <<= 1\n        \n        if negative:\n            return -quotient\n        else:\n            return quotient\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int divide(int dividend, int divisor) {\n    int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    long long quotient = 0;\n    \n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        \n        dvd -= temp;\n        quotient += multiple;\n    }\n    \n    quotient *= sign;\n    if (quotient > INT_MAX) return INT_MAX;\n    if (quotient < INT_MIN) return INT_MIN;\n    \n    return quotient;\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function divide(dividend: number, divisor: number): number {\n    if (dividend === 0) return 0;\n    if (divisor === 1) return dividend;\n    if (divisor === -1) return dividend === -Math.pow(2, 31) ? Math.pow(2, 31) - 1 : -dividend;\n\n    const sign = (dividend < 0) !== (divisor < 0) ? -1 : 1;\n    dividend = Math.abs(dividend);\n    divisor = Math.abs(divisor);\n\n    let result = 0;\n    while (dividend >= divisor) {\n        let currentDivisor = divisor;\n        let currentResult = 1;\n\n        while (dividend >= currentDivisor << 1) {\n            currentDivisor <<= 1;\n            currentResult <<= 1;\n        }\n\n        result += currentResult;\n        dividend -= currentDivisor;\n    }\n\n    return sign === 1 ? Math.min(Math.pow(2, 31) - 1, result) : -result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $dividend\n     * @param Integer $divisor\n     * @return Integer\n     */\n    function divide($dividend, $divisor) {\n        $sign = ($dividend < 0) ^ ($divisor < 0) ? -1 : 1;\n        $dividend = abs($dividend);\n        $divisor = abs($divisor);\n        $result = 0;\n        while ($dividend >= $divisor) {\n            $temp = $divisor;\n            $quotient = 1;\n            while ($dividend >= ($temp << 1)) {\n                $temp <<= 1;\n                $quotient <<= 1;\n            }\n            $dividend -= $temp;\n            $result += $quotient;\n        }\n        $result *= $sign;\n        if ($result < -(pow(2, 31)) || $result > (pow(2, 31) - 1)) {\n            return pow(2, 31) - 1;\n        } else {\n            return $result;\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to develop an algorithm that divides two integers without using multiplication, division, or modulo operations, and truncates the result towards zero. We also need to manage the constraints regarding a 32-bit signed integer range.\n\n# Explanation\n\n1. **Handle edge cases**: Specifically, when the `dividend` is 0 (output should be 0) and when the `dividend` is the minimum 32-bit integer and the `divisor` is -1 (output should be capped at the maximum 32-bit integer).\n2. **Determine the sign of the result**: If the `dividend` and `divisor` have different signs, the result should be negative.\n3. **Work with absolute values**: To simplify the division logic, work with the absolute values of `dividend` and `divisor`.\n4. **Repeated subtraction**: Use repeated subtraction combined with bit shifting to efficiently compute the quotient.\n5. **Output the result**: Adjust the result for the sign determined in step 2, and ensure it falls within the 32-bit signed integer range.\n\n# Pseudocode\n\n```\nFUNCTION divide(dividend, divisor):\n    CONSTANT INT_MAX = 2**31 - 1\n    CONSTANT INT_MIN = -2**31\n    \n    IF dividend == 0:\n        RETURN 0\n    \n    IF dividend == INT_MIN AND divisor == -1:\n        RETURN INT_MAX\n    \n    negative = (dividend < 0) XOR (divisor < 0)\n    \n    dividend = ABS(dividend)\n    divisor = ABS(divisor)\n    \n    quotient = 0\n    \n    WHILE dividend >= divisor:\n        temp = divisor\n        multiple = 1\n        WHILE dividend >= temp:\n            dividend = dividend - temp\n            quotient = quotient + multiple\n            multiple = multiple << 1\n            temp = temp << 1\n    \n    IF negative:\n        RETURN -quotient\n    ELSE:\n        RETURN quotient\n```\n\nThis pseudocode outlines the main steps: handling special cases, determining the sign of the result, using efficient repeated subtraction, and ensuring the result is within the valid range for 32-bit signed integers.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-divide-two-integers"
    },
    {
        "name": "Find The Index Of The First Occurrence In A String",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-the-index-of-the-first-occurrence-in-a-string",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if (needle.empty()) {\n            return 0;\n        }\n        \n        int n = haystack.length();\n        int m = needle.length();\n        \n        for (int i = 0; i <= n - m; ++i) {\n            int j = 0;\n            while (j < m && haystack[i + j] == needle[j]) {\n                ++j;\n            }\n            if (j == m) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.isEmpty()) {\n            return 0;\n        }\n        \n        int n = haystack.length();\n        int m = needle.length();\n        \n        for (int i = 0; i <= n - m; i++) {\n            if (haystack.substring(i, i + m).equals(needle)) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n        if needle not in haystack:\n            return -1\n        return haystack.index(needle)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int strStr(char* haystack, char* needle) {\n    if (*needle == '\\0') {\n        return 0;\n    }\n    \n    int haystack_len = strlen(haystack);\n    int needle_len = strlen(needle);\n    \n    for (int i = 0; i <= haystack_len - needle_len; i++) {\n        int j;\n        for (j = 0; j < needle_len; j++) {\n            if (haystack[i+j] != needle[j]) {\n                break;\n            }\n        }\n        if (j == needle_len) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int StrStr(string haystack, string needle) {\n        if (string.IsNullOrEmpty(needle)) return 0;\n        \n        for (int i = 0; i <= haystack.Length - needle.Length; i++) {\n            if (haystack.Substring(i, needle.Length) == needle) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function strStr(haystack: string, needle: string): number {\n    if (needle === \"\") {\n        return 0;\n    }\n    \n    for (let i = 0; i < haystack.length; i++) {\n        if (haystack.slice(i, i + needle.length) === needle) {\n            return i;\n        }\n    }\n    \n    return -1;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $haystack\n     * @param String $needle\n     * @return Integer\n     */\n    function strStr($haystack, $needle) {\n        $haystackLen = strlen($haystack);\n        $needleLen = strlen($needle);\n        \n        if ($needleLen == 0) {\n            return 0;\n        }\n        \n        for ($i = 0; $i <= $haystackLen - $needleLen; $i++) {\n            if (substr($haystack, $i, $needleLen) == $needle) {\n                return $i;\n            }\n        }\n        \n        return -1;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func strStr(_ haystack: String, _ needle: String) -> Int {\n        if haystack.isEmpty && needle.isEmpty {\n            return 0\n        }\n        \n        guard let range = haystack.range(of: needle) else {\n            return -1\n        }\n        \n        return haystack.distance(from: haystack.startIndex, to: range.lowerBound)\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun strStr(haystack: String, needle: String): Int {\n        if (needle.isEmpty()) return 0\n        \n        for (i in 0..haystack.length - needle.length) {\n            if (haystack.substring(i, i + needle.length) == needle) {\n                return i\n            }\n        }\n        \n        return -1\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int strStr(String haystack, String needle) {\n    if (haystack.isEmpty || needle.isEmpty) {\n      return -1;\n    }\n    \n    for (int i = 0; i <= haystack.length - needle.length; i++) {\n      if (haystack.substring(i, i + needle.length) == needle) {\n        return i;\n      }\n    }\n    \n    return -1;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func strStr(haystack string, needle string) int {\n    if len(needle) == 0 {\n        return 0\n    }\n    \n    for i := 0; i < len(haystack) - len(needle) + 1; i++ {\n        if haystack[i:i+len(needle)] == needle {\n            return i\n        }\n    }\n    \n    return -1\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} haystack\n# @param {String} needle\n# @return {Integer}\ndef str_str(haystack, needle)\n    haystack.index(needle) || -1\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        if needle.is_empty() {\n            return 0;\n        }\n        \n        if let Some(index) = haystack.find(&needle) {\n            return index as i32;\n        } else {\n            return -1;\n        }\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec str_str(haystack :: String.t, needle :: String.t) :: integer\n  def str_str(haystack, needle) do\n    case String.split(haystack, needle) do\n      [prefix, _ | _] -> String.length(prefix)\n      _ -> -1\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to find the index of the first occurrence of the string `needle` within the string `haystack`. If `needle` is not found in `haystack`, return `-1`.\n\n# Explanation\n1. First, check if the `needle` is an empty string. If it is, return `0` because an empty string is considered to be found at the beginning of any string.\n2. Check if `needle` exists in `haystack`. If it does not, return `-1`.\n3. Use the built-in string method `index` to find and return the index of the first occurrence of `needle` in `haystack`.\n\n# Pseudocode\n```\nfunction findFirstOccurrence(haystack, needle):\n    # Step 1: Check if the needle is an empty string\n    if needle is empty:\n        return 0\n\n    # Step 2: Check if the needle is in the haystack\n    if needle is not in haystack:\n        return -1\n\n    # Step 3: Find and return the index of the first occurrence of the needle in the haystack\n    return haystack.index(needle)\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-the-index-of-the-first-occurrence-in-a-string"
    },
    {
        "name": "Substring With Concatenation Of All Words",
        "site": "LeetCode",
        "href": "/solution/LeetCode-substring-with-concatenation-of-all-words",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        if (s == null || s.length() == 0 || words == null || words.length == 0) {\n            return result;\n        }\n        \n        int wordLength = words[0].length();\n        int totalLength = wordLength * words.length;\n        \n        Map<String, Integer> wordCount = new HashMap<>();\n        for (String word : words) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n        \n        for (int i = 0; i <= s.length() - totalLength; i++) {\n            String sub = s.substring(i, i + totalLength);\n            if (isConcatenation(sub, wordCount, wordLength)) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n    \n    private boolean isConcatenation(String s, Map<String, Integer> wordCount, int wordLength) {\n        Map<String, Integer> seen = new HashMap<>();\n        for (int j = 0; j < s.length(); j += wordLength) {\n            String word = s.substring(j, j + wordLength);\n            seen.put(word, seen.getOrDefault(word, 0) + 1);\n        }\n        return wordCount.equals(seen);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        words_count = len(words)\n        words_len = word_len * words_count\n        word_freq = {}\n        for word in words:\n            if word in word_freq:\n                word_freq[word] += 1\n            else:\n                word_freq[word] = 1\n        \n        result = []\n        for i in range(len(s) - words_len + 1):\n            seen = {}\n            for j in range(words_count):\n                word_start = i + j * word_len\n                word = s[word_start:word_start + word_len]\n                if word in word_freq:\n                    if word in seen:\n                        seen[word] += 1\n                    else:\n                        seen[word] = 1\n                    if seen[word] > word_freq[word]:\n                        break\n                else:\n                    break\n                if j + 1 == words_count:\n                    result.append(i)\n        \n        return result\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> FindSubstring(string s, string[] words) {\n        List<int> result = new List<int>();\n        if (string.IsNullOrEmpty(s) || words == null || words.Length == 0) {\n            return result;\n        }\n        \n        int wordLen = words[0].Length;\n        int wordsCount = words.Length;\n        int totalLen = wordLen * wordsCount;\n        \n        Dictionary<string, int> wordFreq = new Dictionary<string, int>();\n        foreach (string word in words) {\n            if (wordFreq.ContainsKey(word)) {\n                wordFreq[word]++;\n            } else {\n                wordFreq[word] = 1;\n            }\n        }\n        \n        for (int i = 0; i <= s.Length - totalLen; i++) {\n            Dictionary<string, int> seen = new Dictionary<string, int>();\n            int j = 0;\n            while (j < wordsCount) {\n                string currWord = s.Substring(i + j * wordLen, wordLen);\n                if (wordFreq.ContainsKey(currWord)) {\n                    if (seen.ContainsKey(currWord)) {\n                        seen[currWord]++;\n                    } else {\n                        seen[currWord] = 1;\n                    }\n                    if (seen[currWord] > wordFreq[currWord]) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n                j++;\n            }\n            if (j == wordsCount) {\n                result.Add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    if (s.length === 0 || words.length === 0) {\n        return [];\n    }\n    \n    const wordLength = words[0].length;\n    const wordCount = words.length;\n    \n    const totalWordsLength = wordLength * wordCount;\n    const wordFrequency = {};\n    \n    for (let word of words) {\n        if (wordFrequency[word] === undefined) {\n            wordFrequency[word] = 0;\n        }\n        wordFrequency[word]++;\n    }\n    \n    const result = [];\n    \n    for (let i = 0; i <= s.length - totalWordsLength; i++) {\n        const seen = {};\n        let j = 0;\n        \n        while (j < wordCount) {\n            const currentWord = s.substr(i + (j * wordLength), wordLength);\n            \n            if (!(currentWord in wordFrequency)) {\n                break;\n            }\n            \n            if (currentWord in seen) {\n                seen[currentWord]++;\n            } else {\n                seen[currentWord] = 1;\n            }\n            \n            if (seen[currentWord] > wordFrequency[currentWord]) {\n                break;\n            }\n            \n            j++;\n        }\n        \n        if (j === wordCount) {\n            result.push(i);\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    if (s.length === 0 || words.length === 0) {\n        return [];\n    }\n    const wordLength = words[0].length;\n    const wordCount = words.length;\n    const totalWordsLength = wordLength * wordCount;\n    const wordFrequency = {};\n\n    for (let word of words) {\n        if (wordFrequency[word] === undefined) {\n            wordFrequency[word] = 0;\n        }\n        wordFrequency[word]++;\n    }\n\n    const result = [];\n    for (let i = 0; i <= s.length - totalWordsLength; i++) {\n        const seen = {};\n        let j = 0;\n        while (j < wordCount) {\n            let nextWordIndex = i + j * wordLength;\n            let currentWord = s.substring(nextWordIndex, nextWordIndex + wordLength);\n            if (wordFrequency[currentWord] === undefined) {\n                break;\n            }\n            if (seen[currentWord] === undefined) {\n                seen[currentWord] = 0;\n            }\n            seen[currentWord]++;\n            if (seen[currentWord] > wordFrequency[currentWord]) {\n                break;\n            }\n            if (j + 1 === wordCount) {\n                result.push(i);\n            }\n            j++;\n        }\n    }\n    \n    return result;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify starting indices of substrings in `s` that are concatenations of all strings in `words`, check if the substrings exactly contain every word in words, and return the indices.\n\n### # Explanation\n1. **Check Inputs**: Ensure the input string `s` and `words` array are not empty.\n2. **Determine Lengths**: Calculate the length of each word (assuming all words are the same length), total number of words, and the concatenated length of all words combined.\n3. **Frequency Map**: Create a frequency map to count the occurrences of each word in `words`.\n4. **Sliding Window**: Use a sliding window technique to traverse through the string `s`. For each possible starting index, extract substrings and compare the counts of words with the frequency map.\n5. **Collect Indices**: If a valid concatenated substring is found, store the starting index.\n\n### # Pseudocode\n```plaintext\n# 1. Check for empty input\nif s is empty or words is empty:\n    return []\n\n# 2. Calculate lengths\nword_len = length of first word in words\nwords_count = count of words in words\nwords_len = word_len * words_count\n\n# 3. Create a frequency map for words\nword_freq = empty dictionary\nfor each word in words:\n    if word in word_freq:\n        word_freq[word] += 1\n    else:\n        word_freq[word] = 1\n\n# 4. Initialize result list\nresult = empty list\n\n# 5. Sliding window to find valid starting indices\nfor i from 0 to length of s - words_len + 1:\n    seen = empty dictionary\n    for j from 0 to words_count:\n        word_start = i + j * word_len\n        word = substring of s from word_start to word_start + word_len\n        if word in word_freq:\n            if word in seen:\n                seen[word] += 1\n            else:\n                seen[word] = 1\n            \n            # Break if word frequency exceeds the allowed count\n            if seen[word] > word_freq[word]:\n                break\n        else:\n            break\n        \n        # If all words matched, add starting index to result\n        if j + 1 == words_count:\n            result.append(i)\n\n# 6. Return the result list\nreturn result\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-substring-with-concatenation-of-all-words"
    },
    {
        "name": "Next Permutation",
        "site": "LeetCode",
        "href": "/solution/LeetCode-next-permutation",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int n = nums.size();\n        \n        int i = n - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        \n        if (i >= 0) {\n            int j = n - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums[i], nums[j]);\n        }\n        \n        reverse(nums.begin() + i + 1, nums.end());\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void nextPermutation(int[] nums) {\n        // Find the first decreasing element from the right\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        \n        // Find the element to swap with\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        \n        reverse(nums, i + 1, nums.length - 1);\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            swap(nums, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place \ninstead.\n        \"\"\"\n        \n        # Find the first decreasing element from the right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # Find the element just larger than nums[i]\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the elements from i+1 to the end\n        left, right = i+1, len(nums)-1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void nextPermutation(int* nums, int numsSize) {\n    int i = numsSize - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n    if (i >= 0) {\n        int j = numsSize - 1;\n        while (j >= 0 && nums[j] <= nums[i]) {\n            j--;\n        }\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    int left = i + 1;\n    int right = numsSize - 1;\n    while (left < right) {\n        int tmp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = tmp;\n        left++;\n        right--;\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void NextPermutation(int[] nums) {\n        int i = nums.Length - 2;\n        \n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        \n        if (i >= 0) {\n            int j = nums.Length - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n            Swap(nums, i, j);\n        }\n        \n        Reverse(nums, i + 1);\n    }\n    \n    private void Swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    private void Reverse(int[] nums, int start) {\n        int i = start, j = nums.Length - 1;\n        while (i < j) {\n            Swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify nums in-place instead.\n */\nfunction nextPermutation(nums: number[]): void {\n    let i = nums.length - 2;\n\n    // Find the first decreasing element from the right\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n\n    if (i >= 0) {\n        let j = nums.length - 1;\n\n        // Find the next greater element from the right\n        while (j >= 0 && nums[j] <= nums[i]) {\n            j--;\n        }\n\n        // Swap the elements at positions i and j\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n\n    // Reverse the subarray from i+1 to the end\n    let left = i + 1;\n    let right = nums.length - 1;\n\n    while (left < right) {\n        [nums[left], nums[right]] = [nums[right], nums[left]];\n        left++;\n        right--;\n    }\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return NULL\n     */\n    function nextPermutation(&$nums) {\n        $i = count($nums) - 2;\n        while ($i >= 0 && $nums[$i] >= $nums[$i + 1]) {\n            $i--;\n        }\n        if ($i >= 0) {\n            $j = count($nums) - 1;\n            while ($nums[$j] <= $nums[$i]) {\n                $j--;\n            }\n            $this->swap($nums, $i, $j);\n        }\n        $this->reverse($nums, $i + 1);\n    }\n    \n    function swap(&$nums, $i, $j) {\n        $temp = $nums[$i];\n        $nums[$i] = $nums[$j];\n        $nums[$j] = $temp;\n    }\n    \n    function reverse(&$nums, $start) {\n        $i = $start;\n        $j = count($nums) - 1;\n        while ($i < $j) {\n            $this->swap($nums, $i, $j);\n            $i++;\n            $j--;\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func nextPermutation(_ nums: inout [Int]) {\n        var i = nums.count - 2\n        \n        while i >= 0 && nums[i] >= nums[i + 1] {\n            i -= 1\n        }\n        \n        if i >= 0 {\n            var j = nums.count - 1\n            while j >= 0 && nums[j] <= nums[i] {\n                j -= 1\n            }\n            nums.swapAt(i, j)\n        }\n        \n        reverse(&nums, start: i + 1)\n    }\n    \n    func reverse(_ nums: inout [Int], start: Int) {\n        var i = start\n        var j = nums.count - 1\n        while i < j {\n            nums.swapAt(i, j)\n            i += 1\n            j -= 1\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun nextPermutation(nums: IntArray): Unit {\n        var k = nums.lastIndex - 1\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\n            k--\n        }\n        \n        if (k == -1) {\n            nums.reverse()\n            return\n        }\n        \n        var l = nums.lastIndex\n        while (l > k && nums[l] <= nums[k]) {\n            l--\n        }\n        \n        nums[k] = nums[l].also { nums[l] = nums[k] }\n        var left = k + 1\n        var right = nums.lastIndex\n        while (left < right) {\n            nums[left] = nums[right].also { nums[right] = nums[left] }\n            left++\n            right--\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void nextPermutation(List<int> nums) {\n    int i = nums.length - 2;\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\n      i--;\n    }\n    \n    if (i >= 0) {\n      int j = nums.length - 1;\n      while (j >= 0 && nums[j] <= nums[i]) {\n        j--;\n      }\n      swap(nums, i, j);\n    }\n    \n    reverse(nums, i + 1);\n  }\n  \n  void swap(List<int> nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n  }\n  \n  void reverse(List<int> nums, int start) {\n    int i = start;\n    int j = nums.length - 1;\n    while (i < j) {\n      swap(nums, i, j);\n      i++;\n      j--;\n    }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func nextPermutation(nums []int)  {\n    n := len(nums)\n    i := n - 2\n    for i >= 0 && nums[i+1] <= nums[i] {\n        i--\n    }\n    if i >= 0 {\n        j := n - 1\n        for j >= 0 && nums[j] <= nums[i] {\n            j--\n        }\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    reverse(nums[i+1:])\n}\n\nfunc reverse(nums []int) {\n    i, j := 0, len(nums)-1\n    for i < j {\n        nums[i], nums[j] = nums[j], nums[i]\n        i++\n        j--\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Void} Do not return anything, modify nums in-place instead.\ndef next_permutation(nums)\n    i = nums.length - 2\n    while i >= 0 && nums[i] >= nums[i + 1]\n        i -= 1\n    end\n    \n    if i >= 0\n        j = nums.length - 1\n        while j >= 0 && nums[j] <= nums[i]\n            j -= 1\n        end\n        nums[i], nums[j] = nums[j], nums[i]\n    end\n    \n    nums[i+1..] = nums[i+1..].reverse\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def nextPermutation(nums: Array[Int]): Unit = {\n        var i = nums.length - 2\n        while (i >= 0 && nums(i) >= nums(i + 1)) {\n            i -= 1\n        }\n        \n        if (i >= 0) {\n            var j = nums.length - 1\n            while (j >= 0 && nums(j) <= nums(i)) {\n                j -= 1\n            }\n            swap(nums, i, j)\n        }\n        \n        reverse(nums, i + 1)\n    }\n    \n    def swap(nums: Array[Int], i: Int, j: Int): Unit = {\n        val temp = nums(i)\n        nums(i) = nums(j)\n        nums(j) = temp\n    }\n    \n    def reverse(nums: Array[Int], start: Int): Unit = {\n        var i = start\n        var j = nums.length - 1\n        while (i < j) {\n            swap(nums, i, j)\n            i += 1\n            j -= 1\n        }\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn next_permutation(nums: &mut Vec<i32>) {\n        let mut i = nums.len() as i32 - 2;\n        while i >= 0 && nums[i as usize] >= nums[(i + 1) as usize] {\n            i -= 1;\n        }\n        \n        if i >= 0 {\n            let mut j = nums.len() as i32 - 1;\n            while j >= 0 && nums[j as usize] <= nums[i as usize] {\n                j -= 1;\n            }\n            nums.swap(i as usize, j as usize);\n        }\n        \n        nums[(i + 1) as usize..].reverse();\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the next lexicographically greater permutation of a given array of integers. This task involves rearranging the array in place. If no greater permutation is possible, we need to rearrange the array into its smallest possible order (i.e., sorted in ascending order).\n\n## # Explanation\n1. **Identify Point of Decrease**: Traverse the array from right to left to find the first element that is not in descending order. This is the point where the permutation needs to change to get the next greater permutation.\n2. **Find Next Larger Element**: From this identified point, continue scanning to find the smallest element that is greater than this element. This ensures that the change we make is the smallest possible increase.\n3. **Swap**: Swap these two elements.\n4. **Reverse the Succeeding Sequence**: The sequence after the initially identified point is still in descending order. To get the next permutation, reverse this sequence to make it the smallest possible sequence in ascending order.\n\n## # Pseudocode\n```\nfunction nextPermutation(nums):\n    # Step 1: Find the first decreasing element from the right\n    i = length(nums) - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    \n    # Step 2: If not the last permutation, find the element just larger than nums[i]\n    if i >= 0:\n        j = length(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        swap(nums[i], nums[j])\n\n    # Step 3: Reverse the sequence from i+1 to the end of the array\n    reverse(nums, i + 1, length(nums) - 1)\n\nfunction reverse(nums, start, end):\n    while start < end:\n        swap(nums[start], nums[end])\n        start += 1\n        end -= 1\n\nfunction swap(a, b):\n    temp = a\n    a = b\n    b = temp\n```\n\nThis pseudocode outlines the steps to achieve the next permutation with minimal changes to the array, ensuring the permutation is the smallest possible increment.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-next-permutation"
    },
    {
        "name": "Permutations Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-permutations-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> result;\n        vector<int> current;\n        vector<bool> used(nums.size(), false);\n        sort(nums.begin(), nums.end());\n        backtrack(nums, current, result, used);\n        return result;\n    }\n    \n    void backtrack(vector<int>& nums, vector<int>& current, vector<vector<int>>& result, vector<bool>& used) {\n        if (current.size() == nums.size()) {\n            result.push_back(current);\n            return;\n        }\n        \n        for (int i = 0; i < nums.size(); ++i) {\n            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) {\n                continue;\n            }\n            used[i] = true;\n            current.push_back(nums[i]);\n            backtrack(nums, current, result, used);\n            current.pop_back();\n            used[i] = false;\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(res, new ArrayList<>(), nums, new boolean[nums.length]);\n        return res;\n    }\n    \n    private void backtrack(List<List<Integer>> res, List<Integer> tempList, int[] nums, boolean[] used) {\n        if (tempList.size() == nums.length) {\n            res.add(new ArrayList<>(tempList));\n        } else {\n            for (int i = 0; i < nums.length; i++) {\n                if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\n                    continue;\n                }\n                used[i] = true;\n                tempList.add(nums[i]);\n                backtrack(res, tempList, nums, used);\n                used[i] = false;\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start):\n            if start == len(nums):\n                result.append(nums[:])\n                return\n            seen = set()\n            for i in range(start, len(nums)):\n                if nums[i] in seen:\n                    continue\n                seen.add(nums[i])\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n            \n        result = []\n        backtrack(0)\n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> PermuteUnique(int[] nums) {\n        IList<IList<int>> result = new List<IList<int>>();\n        Array.Sort(nums);\n        bool[] used = new bool[nums.Length];\n        Permute(nums, used, new List<int>(), result);\n        return result;\n    }\n    \n    private void Permute(int[] nums, bool[] used, List<int> permutation, IList<IList<int>> result) {\n        if (permutation.Count == nums.Length) {\n            result.Add(new List<int>(permutation));\n            return;\n        }\n        \n        for (int i = 0; i < nums.Length; i++) {\n            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) {\n                continue;\n            }\n            used[i] = true;\n            permutation.Add(nums[i]);\n            Permute(nums, used, permutation, result);\n            used[i] = false;\n            permutation.RemoveAt(permutation.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    const result = [];\n    \n    const backtrack = (current, remaining) => {\n        if (remaining.length === 0) {\n            result.push([...current]);\n            return;\n        }\n        \n        const visited = new Set();\n        for (let i = 0; i < remaining.length; i++) {\n            if (visited.has(remaining[i])) continue;\n            visited.add(remaining[i]);\n            \n            current.push(remaining[i]);\n            backtrack(current, [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\n            current.pop();\n        }\n    };\n    \n    backtrack([], nums);\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function permuteUnique(nums: number[]): number[][] {\n    const result: number[][] = [];\n    \n    const backtrack = (temp: number[], countMap: Map<number, number>) => {\n        if (temp.length === nums.length) {\n            result.push([...temp]);\n            return;\n        }\n        \n        for (const [num, count] of countMap) {\n            if (count > 0) {\n                temp.push(num);\n                countMap.set(num, count - 1);\n                \n                backtrack(temp, countMap);\n                \n                temp.pop();\n                countMap.set(num, count);\n            }\n        }\n    };\n    \n    const countMap = new Map<number, number>();\n    for (const num of nums) {\n        countMap.set(num, (countMap.get(num) || 0) + 1);\n    }\n    \n    backtrack([], countMap);\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function permuteUnique($nums) {\n        $result = [];\n        sort($nums);\n        $this->backtrack($nums, [], $result, []);\n        return $result;\n    }\n\n    function backtrack($nums, $temp, &$result, $used) {\n        if (count($temp) == count($nums)) {\n            $result[] = $temp;\n            return;\n        }\n\n        for ($i = 0; $i < count($nums); $i++) {\n            if (in_array($i, $used) || ($i > 0 && $nums[$i] == $nums[$i - 1] && !in_array($i - 1, $used))) {\n                continue;\n            }\n            $used[] = $i;\n            $temp[] = $nums[$i];\n            $this->backtrack($nums, $temp, $result, $used);\n            array_pop($temp);\n            array_pop($used);\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\n        var result = [[Int]]()\n        var tempList = [Int]()\n        var visited = Array(repeating: false, count: nums.count)\n        \n        let sortedNums = nums.sorted()\n        backtrack(&result, &tempList, sortedNums, &visited)\n        \n        return result\n    }\n    \n    func backtrack(_ result: inout [[Int]], _ tempList: inout [Int], _ nums: [Int], _ visited: inout [Bool]) {\n        if tempList.count == nums.count {\n            result.append(tempList)\n            return\n        }\n        \n        for i in 0..<nums.count {\n            if visited[i] || (i > 0 && nums[i] == nums[i-1] && !visited[i-1]) {\n                continue\n            }\n            visited[i] = true\n            tempList.append(nums[i])\n            backtrack(&result, &tempList, nums, &visited)\n            visited[i] = false\n            tempList.removeLast()\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun permuteUnique(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        nums.sort()\n        backtrack(nums.toMutableList(), mutableListOf(), result)\n        return result\n    }\n\n    private fun backtrack(nums: MutableList<Int>, tempList: MutableList<Int>, result: MutableList<List<Int>>) {\n        if (nums.isEmpty()) {\n            result.add(tempList.toList())\n            return\n        }\n\n        val seen = mutableSetOf<Int>()\n        for (i in 0 until nums.size) {\n            if (seen.contains(nums[i])) continue\n            seen.add(nums[i])\n            val num = nums[i]\n            nums.removeAt(i)\n            tempList.add(num)\n            backtrack(nums, tempList, result)\n            tempList.removeAt(tempList.size - 1)\n            nums.add(i, num)\n        }\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> permuteUnique(List<int> nums) {\n    List<List<int>> result = [];\n    \n    void backtrack(int start) {\n      if (start == nums.length) {\n        result.add(List.of(nums));\n        return;\n      }\n      \n      Set<int> used = {};\n      for (int i = start; i < nums.length; i++) {\n        if (used.contains(nums[i])) continue;\n        used.add(nums[i]);\n        \n        int temp = nums[start];\n        nums[start] = nums[i];\n        nums[i] = temp;\n        \n        backtrack(start + 1);\n        \n        temp = nums[start];\n        nums[start] = nums[i];\n        nums[i] = temp;\n      }\n    }\n    \n    backtrack(0);\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func permuteUnique(nums []int) [][]int {\n    var results [][]int\n    var backtrack func([]int, int)\n    \n    backtrack = func(nums []int, start int) {\n        if start == len(nums) {\n            temp := make([]int, len(nums))\n            copy(temp, nums)\n            results = append(results, temp)\n            return\n        }\n        \n        unique := make(map[int]bool)\n        \n        for i := start; i < len(nums); i++ {\n            if unique[nums[i]] {\n                continue\n            }\n            nums[i], nums[start] = nums[start], nums[i]\n            backtrack(nums, start+1)\n            nums[i], nums[start] = nums[start], nums[i]\n            unique[nums[i]] = true\n        }\n    }\n    \n    backtrack(nums, 0)\n    \n    return results\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef permute_unique(nums)\n    nums.permutation(nums.length).to_a.uniq\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\n        import scala.collection.mutable.ListBuffer\n        \n        def backtrack(nums: Array[Int], tempList: ListBuffer[Int], res: ListBuffer[List[Int]], used: Array[Boolean]): Unit = {\n            if (tempList.length == nums.length) {\n                res += tempList.toList\n            } else {\n                for (i <- nums.indices) {\n                    if (used(i) || (i > 0 && nums(i) == nums(i - 1) && !used(i - 1))) {\n                        // skip duplicates\n                    } else {\n                        used(i) = true\n                        tempList += nums(i)\n                        backtrack(nums, tempList, res, used)\n                        used(i) = false\n                        tempList.remove(tempList.length - 1)\n                    }\n                }\n            }\n        }\n        \n        val res = ListBuffer[List[Int]]()\n        val tempList = ListBuffer[Int]()\n        val used = Array.fill[Boolean](nums.length)(false)\n        val sortedNums = nums.sorted\n        \n        backtrack(sortedNums, tempList, res, used)\n        \n        res.toList\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut nums = nums;\n        nums.sort();\n        Self::backtrack(&nums, &mut vec![], &mut result);\n        result\n    }\n\n    fn backtrack(nums: &Vec<i32>, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {\n        if nums.is_empty() {\n            result.push(path.clone());\n        } else {\n            for i in 0..nums.len() {\n                if i > 0 && nums[i] == nums[i - 1] {\n                    continue;\n                }\n                let num = nums[i];\n                path.push(num);\n                let mut nums = nums.clone();\n                nums.remove(i);\n                Self::backtrack(&nums, path, result);\n                path.pop();\n            }\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate all possible unique permutations of the given list of numbers that might contain duplicates. We can use a backtracking approach with a mechanism to skip duplicates to ensure uniqueness.\n\n# Explanation\n1. **Backtracking**: We will use backtracking to generate permutations by swapping elements.\n2. **Avoiding Duplicates**: During permutation generation, we need to ensure that we do not generate duplicate permutations by using a set to record elements we have already seen at the current position.\n3. **Base Case**: When the permutation is complete (when we have fixed every position), we add this permutation to the result list.\n4. **Recursive Case**: For each element in the list, we swap it with the current position and recursively generate permutations for the remaining elements. After recursion, we swap the elements back.\n\n# Pseudocode\n```\nfunction permuteUnique(nums):\n    function backtrack(start):\n        if start == length of nums:\n            add a copy of nums to result\n            return\n        seen = set()\n        for i from start to length of nums:\n            if nums[i] in seen:\n                continue\n            add nums[i] to seen\n            swap nums[start] with nums[i]\n            backtrack(start + 1)\n            swap nums[start] with nums[i]  # backtrack\n\n    result = []\n    backtrack(0)\n    return result\n```\n\nThis pseudocode outlines the solution clearly. The `backtrack` function explores all permutations by recursively swapping elements. The `seen` set helps avoid processing duplicate elements at each level, ensuring the uniqueness of the permutations. The `result` list collects all valid unique permutations to be returned at the end.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-permutations-ii"
    },
    {
        "name": "Longest Valid Parentheses",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-valid-parentheses",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length();\n        if (n == 0) return 0;\n        \n        stack<int> st;\n        st.push(-1);\n        int maxLen = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') {\n                st.push(i);\n            } else {\n                st.pop();\n                if (st.empty()) {\n                    st.push(i);\n                } else {\n                    maxLen = max(maxLen, i - st.top());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int longestValidParentheses(String s) {\n        int max = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        \n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    max = Math.max(max, i - stack.peek());\n                }\n            }\n        }\n        \n        return max;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def longestValidParentheses(self, s):\n        stack = [-1]\n        max_length = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_length = max(max_length, i - stack[-1])\n        \n        return max_length"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int longestValidParentheses(char* s) {\n    int max = 0;\n    int n = strlen(s);\n    int* dp = (int*)malloc(sizeof(int) * n);\n    memset(dp, 0, sizeof(int) * n);\n    \n    for(int i = 1; i < n; i++) {\n        if(s[i] == ')') {\n            if(s[i - 1] == '(') {\n                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n            } else if(i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {\n                dp[i] = dp[i - 1] + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n            }\n            max = fmax(max, dp[i]);\n        }\n    }\n    \n    free(dp);\n    return max;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LongestValidParentheses(string s) {\n        if (string.IsNullOrEmpty(s)) {\n            return 0;\n        }\n        \n        int max = 0;\n        Stack<int> stack = new Stack<int>();\n        stack.Push(-1);\n        \n        for (int i = 0; i < s.Length; i++) {\n            if (s[i] == '(') {\n                stack.Push(i);\n            } else {\n                stack.Pop();\n                if (stack.Count == 0) {\n                    stack.Push(i);\n                } else {\n                    max = Math.Max(max, i - stack.Peek());\n                }\n            }\n        }\n        \n        return max;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    let stack = [-1];\n    let max = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            stack.push(i);\n        } else {\n            stack.pop();\n            if (stack.length === 0) {\n                stack.push(i);\n            } else {\n                max = Math.max(max, i - stack[stack.length - 1]);\n            }\n        }\n    }\n    \n    return max;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function longestValidParentheses(s: string): number {\n    const stack: number[] = [-1];\n    let maxLen = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            stack.push(i);\n        } else {\n            stack.pop();\n            if (stack.length === 0) {\n                stack.push(i);\n            } else {\n                maxLen = Math.max(maxLen, i - stack[stack.length - 1]);\n            }\n        }\n    }\n\n    return maxLen;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function longestValidParentheses($s) {\n        $stack = [];\n        $stack[] = -1;\n        $max_length = 0;\n        \n        for ($i = 0; $i < strlen($s); $i++) {\n            if ($s[$i] == '(') {\n                $stack[] = $i;\n            } else {\n                array_pop($stack);\n                if (empty($stack)) {\n                    $stack[] = $i;\n                } else {\n                    $max_length = max($max_length, $i - end($stack));\n                }\n            }\n        }\n        \n        return $max_length;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func longestValidParentheses(_ s: String) -> Int {\n        var stack = [-1]\n        var longest = 0\n        \n        for (index, char) in s.enumerated() {\n            if char == \"(\" {\n                stack.append(index)\n            } else {\n                stack.removeLast()\n                if stack.isEmpty {\n                    stack.append(index)\n                } else {\n                    longest = max(longest, index - stack.last!)\n                }\n            }\n        }\n        \n        return longest\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun longestValidParentheses(s: String): Int {\n        var maxLen = 0\n        val stack = mutableListOf<Int>()\n        stack.add(-1)\n        for (i in s.indices) {\n            if (s[i] == '(') {\n                stack.add(i)\n            } else {\n                stack.removeAt(stack.size - 1)\n                if (stack.isEmpty()) {\n                    stack.add(i)\n                } else {\n                    maxLen = maxOf(maxLen, i - stack[stack.size - 1])\n                }\n            }\n        }\n        return maxLen\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int longestValidParentheses(String s) {\n    if (s.isEmpty) return 0;\n    \n    List<int> dp = List.filled(s.length, 0);\n    int maxLen = 0;\n    \n    for (int i = 1; i < s.length; i++) {\n      if (s[i] == ')') {\n        if (s[i - 1] == '(') {\n          dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n        } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {\n          dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n        }\n        maxLen = maxLen > dp[i] ? maxLen : dp[i];\n      }\n    }\n    \n    return maxLen;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func longestValidParentheses(s string) int {\n    if len(s) == 0 {\n        return 0\n    }\n    \n    stack := []int{-1}\n    maxLen := 0\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == '(' {\n            stack = append(stack, i)\n        } else {\n            stack = stack[:len(stack)-1]\n            if len(stack) == 0 {\n                stack = append(stack, i)\n            } else {\n                maxLen = max(maxLen, i - stack[len(stack)-1])\n            }\n        }\n    }\n    \n    return maxLen\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef longest_valid_parentheses(s)\n    stack = []\n    max_length = 0\n    stack.push(-1)\n    \n    for i in 0..s.length-1\n        if s[i] == '('\n            stack.push(i)\n        else\n            stack.pop\n            if stack.empty?\n                stack.push(i)\n            else\n                max_length = [max_length, i - stack.last].max\n            end\n        end\n    end\n    \n    return max_length\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def longestValidParentheses(s: String): Int = {\n        var maxLen = 0\n        var stack = List(-1)\n        \n        for (i <- 0 until s.length) {\n            if (s(i) == '(') {\n                stack = i :: stack\n            } else {\n                stack = stack.tail\n                if (stack.isEmpty) {\n                    stack = i :: stack\n                } else {\n                    maxLen = Math.max(maxLen, i - stack.head)\n                }\n            }\n        }\n        \n        maxLen\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn longest_valid_parentheses(s: String) -> i32 {\n        let mut stack: Vec<i32> = vec![-1];\n        let mut max_length = 0;\n\n        for (i, c) in s.chars().enumerate() {\n            if c == '(' {\n                stack.push(i as i32);\n            } else {\n                stack.pop();\n                if stack.is_empty() {\n                    stack.push(i as i32);\n                } else {\n                    max_length = max_length.max(i as i32 - stack.last().unwrap());\n                }\n            }\n        }\n\n        max_length as i32\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the longest valid (well-formed) parentheses substring within a given string comprising only the characters '(' and ')'. \n\n# Explanation\nWe'll use a stack to assist in solving this problem. The stack helps us track the indices of the parentheses, enabling us to calculate the length of valid substrings effectively. Here\u2019s a step-by-step explanation of the approach:\n\n1. **Initialization**:\n   - Start with a stack initialized with -1 to handle edge cases.\n   - Initialize `max_length` to keep track of the longest valid substring found.\n\n2. **Iteration**:\n   - Traverse each character of the string using a loop.\n   - If the character is '(', push its index onto the stack.\n   - If the character is ')':\n     - Pop the top element from the stack.\n     - Check if the stack is empty:\n       - If yes, push the current index onto the stack; this serves as a new base for the next valid substring.\n       - If no, calculate the length of the current valid substring by subtracting the current index from the index of the new top of the stack.\n     - Update `max_length` if the current valid substring's length is greater than the previously recorded maximum length.\n\n3. **Return Result**:\n   - After the loop ends, `max_length` will hold the length of the longest valid parentheses substring.\n\n# Pseudocode\nHere\u2019s the pseudocode for solving the problem:\n\n```\nfunction longestValidParentheses(s):\n    stack = [-1]\n    max_length = 0\n\n    for i from 0 to len(s)-1:\n        if s[i] == '(':\n            push i onto stack\n        else:\n            pop from stack\n            if stack is empty:\n                push i onto stack\n            else:\n                current_length = i - stack[top of stack]\n                max_length = max(max_length, current_length)\n\n    return max_length\n```\n\nThis pseudocode captures the essence of the stack-based approach to finding the longest valid parentheses substring efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-valid-parentheses"
    },
    {
        "name": "Search In Rotated Sorted Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-search-in-rotated-sorted-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            if (nums[mid] >= nums[left]) {\n                if (target >= nums[left] && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (target > nums[mid] && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                    \n        return -1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int search(int* nums, int numsSize, int target) {\n    int left = 0;\n    int right = numsSize - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (nums[mid] == target) {\n            return mid;\n        }\n        \n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.Length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[left] <= nums[mid]) {\n                if (target >= nums[left] && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (target > nums[mid] && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) {\n            return mid;\n        }\n\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function search(nums: number[], target: number): number {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) {\n            return mid;\n        }\n\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function search($nums, $target) {\n        $left = 0;\n        $right = count($nums) - 1;\n        \n        while ($left <= $right) {\n            $mid = $left + intdiv($right - $left, 2);\n            if ($nums[$mid] == $target) {\n                return $mid;\n            }\n            \n            if ($nums[$left] <= $nums[$mid]) {\n                if ($nums[$left] <= $target && $target < $nums[$mid]) {\n                    $right = $mid - 1;\n                } else {\n                    $left = $mid + 1;\n                }\n            } else {\n                if ($nums[$mid] < $target && $target <= $nums[$right]) {\n                    $left = $mid + 1;\n                } else {\n                    $right = $mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Int {\n        var left = 0\n        var right = nums.count - 1\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            \n            if nums[mid] == target {\n                return mid\n            }\n            \n            if nums[left] <= nums[mid] {\n                if nums[left] <= target && target < nums[mid] {\n                    right = mid - 1\n                } else {\n                    left = mid + 1\n                }\n            } else {\n                if nums[mid] < target && target <= nums[right] {\n                    left = mid + 1\n                } else {\n                    right = mid - 1\n                }\n            }\n        }\n        \n        return -1\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun search(nums: IntArray, target: Int): Int {\n        var left = 0\n        var right = nums.size - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            \n            if (nums[mid] == target) {\n                return mid\n            }\n            \n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1\n                } else {\n                    left = mid + 1\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1\n                } else {\n                    right = mid - 1\n                }\n            }\n        }\n        \n        return -1\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int search(List<int> nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n      int mid = left + (right - left) ~/ 2;\n      \n      if (nums[mid] == target) {\n        return mid;\n      } else if (nums[left] <= nums[mid]) {\n        if (nums[left] <= target && target < nums[mid]) {\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      } else {\n        if (nums[mid] < target && target <= nums[right]) {\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n      }\n    }\n\n    return -1;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func search(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n    \n    for left <= right {\n        mid := left + (right-left)/2\n        \n        if nums[mid] == target {\n            return mid\n        } else if nums[left] <= nums[mid] {\n            if nums[left] <= target && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if nums[mid] < target && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return -1\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search(nums, target)\n    left, right = 0, nums.size - 1\n    \n    while left <= right\n        mid = left + (right - left) / 2\n        \n        return mid if nums[mid] == target\n        \n        if nums[left] <= nums[mid]\n            if nums[left] <= target && target < nums[mid]\n                right = mid - 1\n            else\n                left = mid + 1\n            end\n        else\n            if nums[mid] < target && target <= nums[right]\n                left = mid + 1\n            else\n                right = mid - 1\n            end\n        end\n    end\n    \n    -1\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def search(nums: Array[Int], target: Int): Int = {\n        var left = 0\n        var right = nums.length - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            \n            if (nums(mid) == target) {\n                return mid\n            }\n            \n            if (nums(left) <= nums(mid)) {\n                if (nums(left) <= target && target < nums(mid)) {\n                    right = mid - 1\n                } else {\n                    left = mid + 1\n                }\n            } else {\n                if (nums(mid) < target && target <= nums(right)) {\n                    left = mid + 1\n                } else {\n                    right = mid - 1\n                }\n            }\n        }\n        \n        -1\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() as i32 - 1;\n        \n        while left <= right {\n            let mid = left + (right - left) / 2;\n            \n            if nums[mid as usize] == target {\n                return mid as i32;\n            }\n            \n            if nums[left as usize] <= nums[mid as usize] {\n                if nums[left as usize] <= target && target < nums[mid as usize] {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if nums[mid as usize] < target && target <= nums[right as usize] {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        -1\n    }\n}"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: integer\n  def search(nums, target) do\n    case Enum.find_index(nums, &(&1 == target)) do\n      nil -> -1\n      index -> index\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform a binary search on a possibly rotated sorted array to find the target in O(log n) time complexity.\n\n# Explanation\n1. **Binary Search Basics**:\n   Start with two pointers, `left` and `right`, which represent the bounds of the array. Calculate the midpoint `mid`.\n\n2. **Check the Midpoint**:\n   If `nums[mid]` is equal to the target, return `mid`.\n\n3. **Determine the Sorted Half**:\n   - Check if the left part (`nums[left]` to `nums[mid]`) is sorted. If `nums[left] <= nums[mid]`, this half is sorted.\n   - Otherwise, the right part (`nums[mid]` to `nums[right]`) is sorted.\n\n4. **Narrow Down the Search**:\n   - If the left part is sorted and the target is in this range (`nums[left] <= target < nums[mid]`), adjust the `right` pointer to `mid - 1`.\n   - If the target is not in the sorted left part, adjust the `left` pointer to `mid + 1`.\n   - Similarly, for the sorted right part, if the target is in this range (`nums[mid] < target <= nums[right]`), adjust the `left` pointer to `mid + 1`.\n   - If the target is not in the sorted right part, adjust the `right` pointer to `mid - 1`.\n\n5. **Exit Condition**:\n   If `left` exceeds `right`, the target is not present in the array, return `-1`.\n\n# Pseudocode\n\n```\nfunction search(nums, target):\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:  # Left part is sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right part is sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1\n\n# Example Usage\n# nums = [4,5,6,7,0,1,2], target = 0\n# Output: 4\nsearch([4,5,6,7,0,1,2], 0)\n```\nThis pseudocode explains the step-by-step process to handle the search in a rotated sorted array ensuring O(log n) time complexity via binary search.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-search-in-rotated-sorted-array"
    },
    {
        "name": "Find First And Last Position Of Element In Sorted Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-first-and-last-position-of-element-in-sorted-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> result = {-1, -1};\n        int left = 0;\n        int right = nums.size() - 1;\n        \n        // Find the starting position of target\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        if (left < nums.size() && nums[left] == target) {\n            result[0] = left;\n        } else {\n            return result;\n        }\n        \n        // Find the ending position of target\n        right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        result[1] = right;\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] result = new int[]{-1, -1};\n        \n        // Find the starting position\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] >= target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (left < nums.length && nums[left] == target) {\n            result[0] = left;\n        }\n        \n        // Find the ending position\n        left = 0;\n        right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        if (right >= 0 && nums[right] == target) {\n            result[1] = right;\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def binary_search_left(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left\n        \n        def binary_search_right(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return right\n        \n        left_idx = binary_search_left(nums, target)\n        right_idx = binary_search_right(nums, target)\n        \n        if left_idx <= right_idx:\n            return [left_idx, right_idx]\n        else:\n            return [-1, -1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free\n().\n */\nint* searchRange(int* nums, int numsSize, int target, int* returnSize) \n{\n    // find the leftmost index of the target\n    int left = 0, right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    int startIndex = (left < numsSize && nums[left] == target) ? left : -1;\n\n    // find the rightmost index of the target\n    left = 0;\n    right = numsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] <= target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    int endIndex = (right >= 0 && nums[right] == target) ? right : -1;\n\n    int* result = (int*)malloc(2 * sizeof(int));\n    result[0] = startIndex;\n    result[1] = endIndex;\n\n    *returnSize = 2;\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] SearchRange(int[] nums, int target) {\n        int[] result = new int[] { -1, -1 };\n\n        if (nums == null || nums.Length == 0) {\n            return result;\n        }\n\n        int left = findLeftIndex(nums, target);\n        int right = findRightIndex(nums, target);\n\n        result[0] = left;\n        result[1] = right;\n\n        return result;\n    }\n\n    private int findLeftIndex(int[] nums, int target) {\n        int index = -1;\n        int left = 0;\n        int right = nums.Length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                index = mid;\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return index;\n    }\n\n    private int findRightIndex(int[] nums, int target) {\n        int index = -1;\n        int left = 0;\n        int right = nums.Length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                index = mid;\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return index;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function searchRange(nums: number[], target: number): number[] {\n    let result = [-1, -1];\n    \n    let left = 0;\n    let right = nums.length - 1;\n    \n    // Find the leftmost index\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] === target) {\n            result[0] = mid;\n            right = mid - 1;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    // Find the rightmost index\n    left = 0;\n    right = nums.length - 1;\n    \n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] === target) {\n            result[1] = mid;\n            left = mid + 1;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function searchRange($nums, $target) {\n        $start = -1;\n        $end = -1;\n        \n        $left = 0;\n        $right = count($nums) - 1;\n\n        while ($left <= $right) {\n            $mid = $left + intdiv(($right - $left), 2);\n\n            if ($nums[$mid] == $target) {\n                $start = $mid;\n                $end = $mid;\n\n                // Find left boundary\n                $left = $mid;\n                while ($left > 0 && $nums[$left - 1] == $target) {\n                    $left--;\n                    $start = $left;\n                }\n\n                // Find right boundary\n                $right = $mid;\n                while ($right < count($nums) - 1 && $nums[$right + 1] == $target) {\n                    $right++;\n                    $end = $right;\n                }\n\n                break;\n            } elseif ($nums[$mid] < $target) {\n                $left = $mid + 1;\n            } else {\n                $right = $mid - 1;\n            }\n        }\n\n        return [$start, $end];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\n        guard !nums.isEmpty else {\n            return [-1, -1]\n        }\n        \n        // Binary search to find the start position\n        var start = -1\n        var left = 0\n        var right = nums.count - 1\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            if nums[mid] >= target {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n            if nums[mid] == target {\n                start = mid\n            }\n        }\n        \n        if start == -1 {\n            return [-1, -1]\n        }\n        \n        // Binary search to find the end position\n        var end = -1\n        left = 0\n        right = nums.count - 1\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            if nums[mid] <= target {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n            if nums[mid] == target {\n                end = mid\n            }\n        }\n        \n        return [start, end]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun searchRange(nums: IntArray, target: Int): IntArray {\n        var left = 0\n        var right = nums.size - 1\n        var startPos = findStartingPosition(nums, target, left, right)\n        var endPos = findEndingPosition(nums, target, left, right)\n        return intArrayOf(startPos, endPos)\n    }\n    \n    private fun findStartingPosition(nums: IntArray, target: Int, left: Int, right: Int): Int {\n        var start = -1\n        var l = left\n        var r = right\n        while (l <= r) {\n            var mid = l + (r - l) / 2\n            if (nums[mid] >= target) {\n                r = mid - 1\n            } else {\n                l = mid + 1\n            }\n            if (nums[mid] == target) {\n                start = mid\n            }\n        }\n        return start\n    }\n    \n    private fun findEndingPosition(nums: IntArray, target: Int, left: Int, right: Int): Int {\n        var end = -1\n        var l = left\n        var r = right\n        while (l <= r) {\n            var mid = l + (r - l) / 2\n            if (nums[mid] <= target) {\n                l = mid + 1\n            } else {\n                r = mid - 1\n            }\n            if (nums[mid] == target) {\n                end = mid\n            }\n        }\n        return end\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> searchRange(List<int> nums, int target) {\n    if (nums.isEmpty) {\n      return [-1, -1];\n    }\n    \n    int findFirst(int target) {\n      int left = 0;\n      int right = nums.length - 1;\n      while (left < right) {\n        int mid = left + ((right - left) ~/ 2);\n        if (nums[mid] < target) {\n          left = mid + 1;\n        } else {\n          right = mid;\n        }\n      }\n      return nums[left] == target ? left : -1;\n    }\n    \n    int findLast(int target) {\n      int left = 0;\n      int right = nums.length - 1;\n      while (left < right) {\n        int mid = left + ((right - left + 1) ~/ 2);\n        if (nums[mid] > target) {\n          right = mid - 1;\n        } else {\n          left = mid;\n        }\n      }\n      return nums[left] == target ? left : -1;\n    }\n    \n    return [findFirst(target), findLast(target)];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func searchRange(nums []int, target int) []int {\n    result := []int{-1, -1}\n    \n    left := 0\n    right := len(nums) - 1\n    \n    // Find the leftmost target\n    for left <= right {\n        mid := left + (right - left) / 2\n        if nums[mid] == target {\n            result[0] = mid\n            right = mid - 1\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    if result[0] == -1 {\n        return result\n    }\n    \n    // Find the rightmost target\n    left = result[0]\n    right = len(nums) - 1\n    \n    for left <= right {\n        mid := left + (right - left) / 2\n        if nums[mid] == target {\n            result[1] = mid\n            left = mid + 1\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef search_range(nums, target)\n    left = search_bound(nums, target, true)\n    right = search_bound(nums, target, false)\n    \n    if left < nums.length && nums[left] == target\n        [left, right - 1]\n    else\n        [-1, -1]\n    end\nend\n\ndef search_bound(nums, target, isFirst)\n    left = 0\n    right = nums.length\n    \n    while left < right\n        mid = left + (right - left) / 2\n        \n        if nums[mid] > target || (isFirst && nums[mid] >= target)\n            right = mid\n        else\n            left = mid + 1\n        end\n    end\n    \n    left\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def searchRange(nums: Array[Int], target: Int): Array[Int] = {\n        def binarySearch(nums: Array[Int], target: Int, left: Boolean): Int = {\n            var lo = 0\n            var hi = nums.length\n            while (lo < hi) {\n                val mid = (lo + hi) / 2\n                if (nums(mid) > target || (left && nums(mid) == target)) {\n                    hi = mid\n                } else {\n                    lo = mid + 1\n                }\n            }\n            lo\n        }\n\n        val leftIdx = binarySearch(nums, target, left = true)\n        if (leftIdx == nums.length || nums(leftIdx) != target) {\n            return Array(-1, -1)\n        }\n        val rightIdx = binarySearch(nums, target, left = false) - 1\n        Array(leftIdx, rightIdx)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        if nums.is_empty() { return vec![-1, -1]; }\n        \n        let left = match nums.binary_search(&target) {\n            Ok(mut idx) => {\n                while idx > 0 && nums[idx - 1] == target {\n                    idx -= 1;\n                }\n                idx\n            },\n            _ => return vec![-1, -1],\n        };\n        \n        let right = match nums.binary_search(&target) {\n            Ok(mut idx) => {\n                while idx < nums.len() - 1 && nums[idx + 1] == target {\n                    idx += 1;\n                }\n                idx\n            },\n            _ => return vec![-1, -1],\n        };\n        \n        vec![left as i32, right as i32]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement an algorithm that searches for the starting and ending positions of a given target value in a sorted array with a runtime complexity of O(log n). We can achieve this using the binary search technique as it provides the required runtime complexity.\n\n### # Explanation\n\n1. **Binary Search Left**: We first perform a binary search to find the leftmost index where the target value appears in the array.\n2. **Binary Search Right**: Next, we perform a binary search to find the rightmost index where the target value appears in the array.\n3. **Check Validity**: After performing the two binary searches, we check if the found indices are valid (i.e., the target exists in the array at those indices). If the indices are valid, we return them; otherwise, we return `[-1, -1]`.\n\n### # Pseudocode\n\n```\n# Function to find the first and last positions of a target value in a sorted array\nfunction searchRange(nums, target):\n    # Function to find the leftmost index of the target\n    function binary_search_left(nums, target):\n        left = 0\n        right = length(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # Function to find the rightmost index of the target\n    function binary_search_right(nums, target):\n        left = 0\n        right = length(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    # Find the leftmost index of the target\n    left_idx = binary_search_left(nums, target)\n    \n    # Find the rightmost index of the target\n    right_idx = binary_search_right(nums, target)\n    \n    # Check if the target exists in the array at the found indices\n    if left_idx <= right_idx and left_idx < length(nums) and nums[left_idx] == target and nums[right_idx] == target:\n        return [left_idx, right_idx]\n    else:\n        return [-1, -1]\n```\n\nBy following this algorithm, we can efficiently determine the starting and ending positions of the target value within the sorted array, adhering to the imposed time complexity constraint of O(log n).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-first-and-last-position-of-element-in-sorted-array"
    },
    {
        "name": "Search Insert Position",
        "site": "LeetCode",
        "href": "/solution/LeetCode-search-insert-position",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return left;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return left;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def searchInsert(self, nums, target):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int searchInsert(int* nums, int numsSize, int target) {\n    int left = 0;\n    int right = numsSize - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return left;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int SearchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.Length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length-1;\n\n    while(left <= right){\n        let mid = Math.floor((left+right) / 2);\n\n        if(nums[mid] === target){\n            return mid;\n        }else if(nums[mid] < target){\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n\n    return left;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function searchInsert(nums: number[], target: number): number {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return left;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function searchInsert($nums, $target) {\n        $left = 0;\n        $right = count($nums) - 1;\n        \n        while ($left <= $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            \n            if ($nums[$mid] == $target) {\n                return $mid;\n            } elseif ($nums[$mid] < $target) {\n                $left = $mid + 1;\n            } else {\n                $right = $mid - 1;\n            }\n        }\n        \n        return $left;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\n        var left = 0\n        var right = nums.count - 1\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            \n            if nums[mid] == target {\n                return mid\n            } else if nums[mid] < target {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        return left\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun searchInsert(nums: IntArray, target: Int): Int {\n        var left = 0\n        var right = nums.size - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            \n            if (nums[mid] == target) {\n                return mid\n            } else if (nums[mid] < target) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        return left\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int searchInsert(List<int> nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n    \n    while (left <= right) {\n      int mid = left + (right - left) ~/ 2;\n      \n      if (nums[mid] == target) {\n        return mid;\n      } else if (nums[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return left;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func searchInsert(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return left\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search_insert(nums, target)\n    left = 0\n    right = nums.length - 1\n    \n    while left <= right\n        mid = left + (right - left) / 2\n        \n        if nums[mid] == target\n            return mid\n        elsif nums[mid] < target\n            left = mid + 1\n        else\n            right = mid - 1\n        end\n    end\n    \n    return left\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def searchInsert(nums: Array[Int], target: Int): Int = {\n        var left = 0\n        var right = nums.length - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            \n            if (nums(mid) == target) {\n                return mid\n            } else if (nums(mid) < target) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        return left\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n        match nums.binary_search(&target) {\n            Ok(index) => index as i32,\n            Err(index) => index as i32,\n        }\n    }\n}"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec search_insert(nums :: [integer], target :: integer) :: integer\n  def search_insert(nums, target) do\n    Enum.find_index(nums, &( &1 >= target )) || length(nums)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to devise a plan that leverages a binary search algorithm, as it provides O(log n) runtime complexity. The challenge requires us to find either the exact position of the target in the sorted array or determine where it would be inserted if it doesn't already exist in the array.\n\n# Explanation\nGiven a sorted array and a target value, we utilize binary search to either find the target or the position where it can be inserted to maintain the sorted order. Binary search is optimal here due to its logarithmic runtime complexity.\n\n1. Initialize two pointers: `left` to 0 and `right` to the last index of the array.\n2. While `left` is less than or equal to `right`, calculate `mid` as the average of `left` and `right`.\n3. Compare the target with the middle element of the array:\n   - If they are equal, return `mid`.\n   - If the target is less than the middle element, adjust `right` to `mid - 1` (search in the left half).\n   - If the target is greater than the middle element, adjust `left` to `mid + 1` (search in the right half).\n4. If the target is not found and the loop ends, `left` will be at the position where the target should be inserted.\n\n# Pseudocode\n```\nfunction searchInsert(nums, target):\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n```\n\nThis pseudocode outlines the core logic of using binary search to either locate or determine the insertion point for the target value in a sorted array.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-search-insert-position"
    },
    {
        "name": "Valid Sudoku",
        "site": "LeetCode",
        "href": "/solution/LeetCode-valid-sudoku",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        vector<unordered_set<char>> rows(9);\n        vector<unordered_set<char>> cols(9);\n        vector<unordered_set<char>> boxes(9);\n\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                char num = board[i][j];\n                if (num == '.') continue;\n\n                if (rows[i].count(num) || cols[j].count(num) || boxes[i / 3 * 3 + j / 3].count(num))\n                    return false;\n\n                rows[i].insert(num);\n                cols[j].insert(num);\n                boxes[i / 3 * 3 + j / 3].insert(num);\n            }\n        }\n\n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        Set<String> set = new HashSet<>();\n        \n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char currentVal = board[i][j];\n                if (currentVal != '.') {\n                    if (!set.add(currentVal + \" in row \" + i) ||\n                        !set.add(currentVal + \" in column \" + j) ||\n                        !set.add(currentVal + \" in sub-box \" + i/3 + \"-\" + j/3)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if (i, board[i][j]) in seen or (board[i][j], j) in seen or (i//3, j//3, board[i][j]) in seen:\n                        return False\n                    seen.add((i, board[i][j]))\n                    seen.add((board[i][j], j))\n                    seen.add((i//3, j//3, board[i][j]))\n        return True"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isValidSudoku(char** board, int boardSize, int* boardColSize) {\n    int row[9][9] = {0};\n    int col[9][9] = {0};\n    int box[3][3][9] = {0};\n\n    for (int i = 0; i < boardSize; i++) {\n        for (int j = 0; j < *boardColSize; j++) {\n            if (board[i][j] != '.') {\n                int num = board[i][j] - '0' - 1;\n                if (row[i][num] || col[j][num] || box[i / 3][j / 3][num]) return false;\n                row[i][num] = 1;\n                col[j][num] = 1;\n                box[i / 3][j / 3][num] = 1;\n            }\n        }\n    }\n\n    return true;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsValidSudoku(char[][] board) {\n        HashSet<string> seen = new HashSet<string>();\n        \n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char currentVal = board[i][j];\n                if (currentVal != '.') {\n                    if (!seen.Add(\"Row \" + i + \" \" + currentVal) || \n                        !seen.Add(\"Column \" + j + \" \" + currentVal) || \n                        !seen.Add(\"Box \" + i/3 + \"-\" + j/3 + \" \" + currentVal)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    const isValid = (arr) => {\n        const set = new Set();\n        for (let num of arr) {\n            if (num !== \".\") {\n                if (set.has(num)) {\n                    return false;\n                }\n                set.add(num);\n            }\n        }\n        return true;\n    };\n    \n    for (let i = 0; i < 9; i++) {\n        const row = [];\n        const col = [];\n        const box = [];\n        \n        for (let j = 0; j < 9; j++) {\n            row.push(board[i][j]);\n            col.push(board[j][i]);\n            box.push(board[3*Math.floor(i/3) + Math.floor(j/3)][3*(i%3) + j%3]);\n        }\n        \n        if (!isValid(row) || !isValid(col) || !isValid(box)) {\n            return false;\n        }\n    }\n    \n    return true;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isValidSudoku(board: string[][]): boolean {\n    const rows: Set<string>[] = Array.from({ length: 9 }, () => new Set());\n    const columns: Set<string>[] = Array.from({ length: 9 }, () => new Set());\n    const boxes: Set<string>[] = Array.from({ length: 9 }, () => new Set());\n\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            const num = board[i][j];\n            if (num !== '.') {\n                if (rows[i].has(num) || columns[j].has(num) || boxes[Math.floor(i / 3) * 3 + Math.floor(j / 3)].has(num)) {\n                    return false;\n                }\n                rows[i].add(num);\n                columns[j].add(num);\n                boxes[Math.floor(i / 3) * 3 + Math.floor(j / 3)].add(num);\n            }\n        }\n    }\n\n    return true;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $board\n     * @return Boolean\n     */\n    function isValidSudoku($board) {\n        $rows = array_fill(0, 9, []);\n        $cols = array_fill(0, 9, []);\n        $boxes = array_fill(0, 9, []);\n\n        for ($i = 0; $i < 9; $i++) {\n            for ($j = 0; $j < 9; $j++) {\n                $num = $board[$i][$j];\n                if ($num != '.') {\n                    if (in_array($num, $rows[$i]) || in_array($num, $cols[$j]) || in_array($num, $boxes[intval($i/3)*3 + intval($j/3)])) {\n                        return false;\n                    }\n                    $rows[$i][] = $num;\n                    $cols[$j][] = $num;\n                    $boxes[intval($i/3)*3 + intval($j/3)][] = $num;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\n\n        var rows = Array(repeating: Set<Character>(), count: 9)\n        var cols = Array(repeating: Set<Character>(), count: 9)\n        var boxes = Array(repeating: Set<Character>(), count: 9)\n\n        for i in 0..<9 {\n            for j in 0..<9 {\n                let currentChar = board[i][j]\n                if currentChar == \".\" {\n                    continue\n                }\n\n                if rows[i].contains(currentChar) || cols[j].contains(currentChar) || boxes[(i/3)*3 + j/3].contains(currentChar) {\n                    return false\n                }\n\n                rows[i].insert(currentChar)\n                cols[j].insert(currentChar)\n                boxes[(i/3)*3 + j/3].insert(currentChar)\n            }\n        }\n\n        return true\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\n        // Check each row\n        for (i in board.indices) {\n            val rowSet = HashSet<Char>()\n            for (j in board[i].indices) {\n                if (board[i][j] != '.') {\n                    if (rowSet.contains(board[i][j])) {\n                        return false\n                    } else {\n                        rowSet.add(board[i][j])\n                    }\n                }\n            }\n        }\n        \n        // Check each column\n        for (j in board[0].indices) {\n            val colSet = HashSet<Char>()\n            for (i in board.indices) {\n                if (board[i][j] != '.') {\n                    if (colSet.contains(board[i][j])) {\n                        return false\n                    } else {\n                        colSet.add(board[i][j])\n                    }\n                }\n            }\n        }\n        \n        // Check each 3x3 sub-box\n        for (k in 0 until 3) {\n            for (l in 0 until 3) {\n                val subBoxSet = HashSet<Char>()\n                for (m in 3*k until 3*k+3) {\n                    for (n in 3*l until 3*l+3) {\n                        if (board[m][n] != '.') {\n                            if (subBoxSet.contains(board[m][n])) {\n                                return false\n                            } else {\n                                subBoxSet.add(board[m][n])\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return true\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isValidSudoku(List<List<String>> board) {\n    // Check rows\n    for (int i = 0; i < 9; i++) {\n      Set<String> rowSet = Set();\n      for (int j = 0; j < 9; j++) {\n        if (board[i][j] != '.') {\n          if (rowSet.contains(board[i][j])) {\n            return false;\n          }\n          rowSet.add(board[i][j]);\n        }\n      }\n    }\n\n    // Check columns\n    for (int j = 0; j < 9; j++) {\n      Set<String> colSet = Set();\n      for (int i = 0; i < 9; i++) {\n        if (board[i][j] != '.') {\n          if (colSet.contains(board[i][j])) {\n            return false;\n          }\n          colSet.add(board[i][j]);\n        }\n      }\n    }\n\n    // Check sub-boxes\n    for (int k = 0; k < 9; k++) {\n      Set<String> boxSet = Set();\n      int boxStartRow = (k ~/ 3) * 3;\n      int boxStartCol = (k % 3) * 3;\n      for (int i = boxStartRow; i < boxStartRow + 3; i++) {\n        for (int j = boxStartCol; j < boxStartCol + 3; j++) {\n          if (board[i][j] != '.') {\n            if (boxSet.contains(board[i][j])) {\n              return false;\n            }\n            boxSet.add(board[i][j]);\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isValidSudoku(board [][]byte) bool {\n    seenRow := make(map[string]bool)\n    seenCol := make(map[string]bool)\n    seenBox := make(map[string]bool)\n\n    for i := 0; i < 9; i++ {\n        for j := 0; j < 9; j++ {\n            if board[i][j] != '.' {\n                rowKey := string(board[i][j]) + \" in row \" + string(i)\n                colKey := string(board[i][j]) + \" in col \" + string(j)\n                boxKey := string(board[i][j]) + \" in box \" + string(i/3) + \" \" + string(j/3)\n\n                if seenRow[rowKey] || seenCol[colKey] || seenBox[boxKey] {\n                    return false\n                }\n\n                seenRow[rowKey] = true\n                seenCol[colKey] = true\n                seenBox[boxKey] = true\n            }\n        }\n    }\n\n    return true\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[][]} board\n# @return {Boolean}\ndef is_valid_sudoku(board)\n    seen = Set.new\n    board.each_with_index do |row, i|\n        row.each_with_index do |val, j|\n            next if val == \".\"\n\n            row_val = \"#{val}_row_#{i}\"\n            col_val = \"#{val}_col_#{j}\"\n            box_val = \"#{val}_box_#{i / 3}_#{j / 3}\"\n\n            return false if seen.include?(row_val) || seen.include?(col_val) || seen.include?(box_val)\n\n            seen.add(row_val)\n            seen.add(col_val)\n            seen.add(box_val)\n        end\n    end\n\n    true\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        fn is_valid_row(row: Vec<char>) -> bool {\n            let mut seen = vec![false; 9];\n            for &c in row.iter() {\n                if c == '.' {\n                    continue;\n                }\n                let index = c.to_digit(10).unwrap() as usize - 1;\n                if seen[index] {\n                    return false;\n                }\n                seen[index] = true;\n            }\n            true\n        }\n\n        fn is_valid_col(board: &Vec<Vec<char>>, col: usize) -> bool {\n            let mut seen = vec![false; 9];\n            for row in board.iter() {\n                if row[col] == '.' {\n                    continue;\n                }\n                let index = row[col].to_digit(10).unwrap() as usize - 1;\n                if seen[index] {\n                    return false;\n                }\n                seen[index] = true;\n            }\n            true\n        }\n\n        fn is_valid_sub_box(board: &Vec<Vec<char>>, start_row: usize, start_col: usize) -> bool {\n            let mut seen = vec![false; 9];\n            for i in 0..3 {\n                for j in 0..3 {\n                    if board[start_row + i][start_col + j] == '.' {\n                        continue;\n                    }\n                    let index = board[start_row + i][start_col + j].to_digit(10).unwrap() as usize - 1;\n                    if seen[index] {\n                        return false;\n                    }\n                    seen[index] = true;\n                }\n            }\n            true\n        }\n\n        for row in 0..9 {\n            if !is_valid_row(board[row].clone()) {\n                return false;\n            }\n        }\n\n        for col in 0..9 {\n            if !is_valid_col(&board, col) {\n                return false;\n            }\n        }\n\n        for i in (0..9).step_by(3) {\n            for j in (0..9).step_by(3) {\n                if !is_valid_sub_box(&board, i, j) {\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to validate a 9x9 Sudoku board based on three main rules: each row must contain the digits 1-9 without repetition, each column must contain the digits 1-9 without repetition, and each 3x3 sub-box of the grid must contain the digits 1-9 without repetition. Below, I will break down the approach using pseudocode.\n\n# Explanation\n1. **Initialize a set**: Use a set to keep track of all the seen entries to avoid duplicates.\n2. **Iterate through the grid**: We need to check every cell in the 9x9 board.\n3. **Check non-empty cells**: For each cell that contains a number (not a '.'), we need to create a unique identifier for:\n    - The row.\n    - The column.\n    - The 3x3 sub-box it belongs to.\n4. **Check for duplicates**: If any of these identifiers are already in the set, it means there's a repetition, and the board is not valid.\n5. **Add valid entries**: If the identifiers are not already in the set, add them to the set.\n6. **Return the result**: If all cells are checked without finding duplicates, return true. If a duplicate is found, return false.\n\n# Pseudocode\n``` \n# Pseudocode\n\nfunction isValidSudoku(board):\n    seen = set()\n    \n    for i from 0 to 8:\n        for j from 0 to 8:\n            if board[i][j] is not '.':\n                current_val = board[i][j]\n                \n                row_check = (i, current_val)\n                col_check = (current_val, j)\n                sub_box_check = (i // 3, j // 3, current_val)\n                \n                if row_check in seen or col_check in seen or sub_box_check in seen:\n                    return false\n                \n                add row_check to seen\n                add col_check to seen\n                add sub_box_check to seen\n                \n    return true\n```\n\nThis pseudocode iterates through each cell in the Sudoku board and creates unique identifiers for the row, column, and 3x3 sub-box constraints. It ensures no duplicates exist by keeping a set of seen entries. If it encounters a duplicate, it returns false indicating the board is invalid. Otherwise, after all cells are processed without issues, it returns true indicating the board is valid.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-valid-sudoku"
    },
    {
        "name": "Sudoku Solver",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sudoku-solver",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n    \n    bool solve(vector<vector<char>>& board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n                            if (solve(board)) {\n                                return true;\n                            }\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    bool isValid(vector<vector<char>>& board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void solveSudoku(char[][] board) {\n        if (board == null || board.length == 0) {\n            return;\n        }\n        solve(board);\n    }\n    \n    private boolean solve(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n                            \n                            if (solve(board)) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def solveSudoku(self, board):\n        def is_valid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            startRow, startCol = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[i + startRow][j + startCol] == num:\n                        return False\n            return True\n        \n        def solve():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in map(str, range(1, 10)):\n                            if is_valid(i, j, num):\n                                board[i][j] = num\n                                if solve():\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve()\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isSafe(char** board, int row, int col, char num) {\n    for (int i = 0; i < 9; i++) {\n        if (board[row][i] == num) return false;\n        if (board[i][col] == num) return false;\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) return false;\n    }\n    return true;\n}\n\nbool solve(char** board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isSafe(board, i, j, c)) {\n                        board[i][j] = c;\n                        if (solve(board)) return true;\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(char** board, int boardSize, int* boardColSize) {\n    solve(board);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void SolveSudoku(char[][] board) {\n        if(board == null || board.Length == 0) return;\n        Solve(board);\n    }\n    \n    private bool Solve(char[][] board) {\n        for(int i = 0; i < 9; i++) {\n            for(int j = 0; j < 9; j++) {\n                if(board[i][j] == '.') {\n                    for(char c = '1'; c <= '9'; c++) {\n                        if(isValid(board, i, j, c)) {\n                            board[i][j] = c;\n                            if(Solve(board)) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private bool isValid(char[][] board, int row, int col, char c) {\n        for(int i = 0; i < 9; i++) {\n            if(board[i][col] == c) return false;\n            if(board[row][i] == c) return false;\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] == c) return false;\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place \ninstead.\n */\nvar solveSudoku = function(board) {\n    const solve = () => {\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                if (board[i][j] === '.') {\n                    for (let num = 1; num <= 9; num++) {\n                        if (isValid(i, j, num.toString())) {\n                            board[i][j] = num.toString();\n                            if (solve()) {\n                                return true;\n                            }\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    const isValid = (row, col, num) => {\n        for (let i = 0; i < 9; i++) {\n            if (board[i][col] === num) return false;\n            if (board[row][i] === num) return false;\n            if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === num) return false;\n        }\n        return true;\n    };\n\n    solve();\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify board in-place instead.\n */\nfunction solveSudoku(board: string[][]): void {\n    const solve = (): boolean => {\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                if (board[i][j] === '.') {\n                    for (let num = 1; num <= 9; num++) {\n                        const numStr = num.toString();\n                        if (isValid(i, j, numStr)) {\n                            board[i][j] = numStr;\n                            if (solve()) {\n                                return true;\n                            }\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    const isValid = (row: number, col: number, num: string): boolean => {\n        for (let i = 0; i < 9; i++) {\n            if (board[i][col] === num || board[row][i] === num) {\n                return false;\n            }\n            const startRow = 3 * Math.floor(row / 3);\n            const startCol = 3 * Math.floor(col / 3);\n            for (let i = 0; i < 3; i++) {\n                for (let j = 0; j < 3; j++) {\n                    if (board[startRow + i][startCol + j] === num) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    };\n\n    solve();\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func solveSudoku(_ board: inout [[Character]]) {\n        func solve(_ board: inout [[Character]]) -> Bool {\n            for i in 0..<9 {\n                for j in 0..<9 {\n                    if board[i][j] == \".\" {\n                        for num in 1...9 {\n                            let char = Character(String(num))\n                            if isValid(board, i, j, char) {\n                                board[i][j] = char\n                                if solve(&board) {\n                                    return true\n                                } else {\n                                    board[i][j] = \".\"\n                                }\n                            }\n                        }\n                        return false\n                    }\n                }\n            }\n            return true\n        }\n\n        func isValid(_ board: [[Character]], _ row: Int, _ col: Int, _ char: Character) -> Bool {\n            for i in 0..<9 {\n                if board[row][i] == char || board[i][col] == char || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == char {\n                    return false\n                }\n            }\n            return true\n        }\n\n        solve(&board)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun solveSudoku(board: Array<CharArray>): Unit {\n        fun isValid(board: Array<CharArray>, row: Int, col: Int, num: Char): Boolean {\n            for (i in 0 until 9) {\n                if (board[row][i] == num || board[i][col] == num || \n                    board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) {\n                    return false\n                }\n            }\n            return true\n        }\n        \n        fun solve(): Boolean {\n            for (i in 0 until 9) {\n                for (j in 0 until 9) {\n                    if (board[i][j] == '.') {\n                        for (num in '1'..'9') {\n                            if (isValid(board, i, j, num)) {\n                                board[i][j] = num\n                                if (solve()) {\n                                    return true\n                                }\n                                board[i][j] = '.'\n                            }\n                        }\n                        return false\n                    }\n                }\n            }\n            return true\n        }\n        \n        solve()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void solveSudoku(List<List<String>> board) {\n    if (board == null || board.isEmpty) return;\n    \n    _solve(board);\n  }\n  \n  bool _solve(List<List<String>> board) {\n    for (int i = 0; i < 9; i++) {\n      for (int j = 0; j < 9; j++) {\n        if (board[i][j] == '.') {\n          for (int k = 1; k <= 9; k++) {\n            String c = k.toString();\n            if (_isValidMove(board, i, j, c)) {\n              board[i][j] = c;\n              if (_solve(board)) {\n                return true;\n              } else {\n                board[i][j] = '.';\n              }\n            }\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  \n  bool _isValidMove(List<List<String>> board, int row, int col, String c) {\n    for (int i = 0; i < 9; i++) {\n      if (board[row][i] == c) return false;\n      if (board[i][col] == c) return false;\n      if (board[3 * (row ~/ 3) + i ~/ 3][3 * (col ~/ 3) + i % 3] == c) return false;\n    }\n    return true;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func solveSudoku(board [][]byte)  {\n    solve(board)\n}\n\nfunc solve(board [][]byte) bool {\n    for i := 0; i < 9; i++ {\n        for j := 0; j < 9; j++ {\n            if board[i][j] == '.' {\n                for num := byte('1'); num <= byte('9'); num++ {\n                    if isValid(board, i, j, num) {\n                        board[i][j] = num\n                        if solve(board) {\n                            return true\n                        } else {\n                            board[i][j] = '.'\n                        }\n                    }\n                }\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc isValid(board [][]byte, row, col int, num byte) bool {\n    for i := 0; i < 9; i++ {\n        if board[i][col] == num || board[row][i] == num || board[3*(row/3)+i/3][3*(col/3)+i%3] == num {\n            return false\n        }\n    }\n    return true\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[][]} board\n# @return {Void} Do not return anything, modify board in-place instead.\ndef solve_sudoku(board)\n    def solve(board)\n        (0..8).each do |i|\n            (0..8).each do |j|\n                if board[i][j] == \".\"\n                    (1..9).each do |k|\n                        if is_valid(board, i, j, k.to_s)\n                            board[i][j] = k.to_s\n                            if solve(board) \n                                return true\n                            end\n                            board[i][j] = \".\"\n                        end\n                    end\n                    return false\n                end\n            end\n        end\n        return true\n    end\n\n    def is_valid(board, row, col, num)\n        (0..8).each do |i|\n            return false if board[i][col] == num || board[row][i] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num\n        end\n        true\n    end\n\n    solve(board)\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn solve_sudoku(board: &mut Vec<Vec<char>>) {\n        fn is_valid(board: &Vec<Vec<char>>, row: usize, col: usize, num: char) -> bool {\n            for i in 0..9 {\n                if board[row][i] == num || board[i][col] == num || board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num {\n                    return false;\n                }\n            }\n            true\n        }\n        \n        fn solve(board: &mut Vec<Vec<char>>) -> bool {\n            for i in 0..9 {\n                for j in 0..9 {\n                    if board[i][j] == '.' {\n                        for num in (b'1'..=b'9').map(char::from) {\n                            if is_valid(board, i, j, num) {\n                                board[i][j] = num;\n                                if solve(board) {\n                                    return true;\n                                }\n                                board[i][j] = '.';\n                            }\n                        }\n                        return false;\n                    }\n                }\n            }\n            true\n        }\n        \n        solve(board);\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can approach the problem using a backtracking algorithm. Backtracking is an efficient way to explore possible configurations and return true if a valid solution is found or backtrack if the configuration is invalid.\n\n# Explanation\nThe solution involves:\n1. **Validation Function**: Checking if placing a particular number in the cell adheres to Sudoku's rules.\n2. **Solving Function**: Recursively trying to fill each cell with valid numbers from 1 to 9 using backtracking.\n\n# Pseudocode\n```\n1. Define function `solveSudoku(board)`\n    2. Define nested function `is_valid(row, col, num)`:\n        a. Iterate through `i` from 0 to 8:\n            i. Check if number is present in the current row or column\n            ii. If found, return False\n        b. Calculate starting indices of the 3x3 sub-box\n        c. Iterate through the sub-box:\n            i. If number is present in sub-box, return False\n        d. Return True (if all checks pass)\n\n    3. Define nested function `solve()`:\n        a. Iterate through each cell in the board:\n            i. If the cell is empty (indicated by '.'):\n                a. Iterate through numbers 1 to 9:\n                    i. If placing the number is valid:\n                        a. Place the number\n                        b. Recursively call `solve()`:\n                            i. If recursive call returns True, return True\n                        c. If recursive call returns False, reset the cell to '.'\n                b. If no number can be placed, return False\n        b. If all cells are filled, return True\n\n    4. Call `solve()` to start the backtracking process\n```\n\nThis provides a high-level overview of the algorithm. The nested `solve()` function will explore filling each empty cell and backtrack whenever it encounters an invalid configuration. The `is_valid()` function ensures the Sudoku rules are adhered to.\n\nThe key is the recursive approach where `solve()` attempts to solve one cell at a time and backtracks when needed, thus ensuring the entire grid is filled correctly according to Sudoku rules.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sudoku-solver"
    },
    {
        "name": "Count And Say",
        "site": "LeetCode",
        "href": "/solution/LeetCode-count-and-say",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        \n        string result = \"1\";\n        for (int i = 2; i <= n; ++i) {\n            string current = \"\";\n            int count = 1;\n            char prev = result[0];\n            \n            for (int j = 1; j < result.size(); ++j) {\n                if (result[j] == prev) {\n                    count++;\n                } else {\n                    current += to_string(count) + prev;\n                    prev = result[j];\n                    count = 1;\n                }\n            }\n            current += to_string(count) + prev;\n            result = current;\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String countAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }\n        \n        String prev = countAndSay(n-1);\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        for (int i = 1; i < prev.length(); i++) {\n            if (prev.charAt(i) == prev.charAt(i-1)) {\n                count++;\n            } else {\n                sb.append(count);\n                sb.append(prev.charAt(i-1));\n                count = 1;\n            }\n        }\n        sb.append(count);\n        sb.append(prev.charAt(prev.length()-1));\n        \n        return sb.toString();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def countAndSay(self, n):\n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        result = \"\"\n        \n        count = 1\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i-1]:\n                count += 1\n            else:\n                result += str(count) + prev[i-1]\n                count = 1\n        \n        result += str(count) + prev[-1]\n        \n        return result\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char *countAndSay(int n) {\n    if (n == 1) {\n        return \"1\";\n    }\n    \n    char *prev = countAndSay(n - 1);\n    char *result = (char *)malloc(2 * strlen(prev) + 1);\n    \n    int i = 0, count = 1, j = 0;\n    while (prev[i] != '\\0') {\n        if (prev[i] == prev[i + 1]) {\n            count++;\n        } else {\n            result[j++] = count + '0';\n            result[j++] = prev[i];\n            count = 1;\n        }\n        i++;\n    }\n    result[j] = '\\0';\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string CountAndSay(int n) {\n        if (n == 1) {\n            return \"1\";\n        }\n        \n        string prev = CountAndSay(n - 1);\n        StringBuilder result = new StringBuilder();\n        int count = 1;\n        \n        for (int i = 0; i < prev.Length; i++) {\n            if (i + 1 < prev.Length && prev[i] == prev[i + 1]) {\n                count++;\n            } else {\n                result.Append(count);\n                result.Append(prev[i]);\n                count = 1;\n            }\n        }\n        \n        return result.ToString();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    let result = \"1\";\n    for (let i = 1; i < n; i++) {\n        let temp = \"\";\n        let count = 1;\n        for (let j = 0; j < result.length; j++) {\n            if (result[j] === result[j + 1]) {\n                count++;\n            } else {\n                temp += count + result[j];\n                count = 1;\n            }\n        }\n        result = temp;\n    }\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function countAndSay(n: number): string {\n    if (n === 1) return \"1\";\n    \n    let result = \"1\";\n    for (let i = 2; i <= n; i++) {\n        let temp = \"\";\n        let count = 1;\n        for (let j = 1; j < result.length; j++) {\n            if (result[j] === result[j - 1]) {\n                count++;\n            } else {\n                temp += count.toString() + result[j - 1];\n                count = 1;\n            }\n        }\n        temp += count.toString() + result[result.length - 1];\n        result = temp;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return String\n     */\n    function countAndSay($n) {\n        $result = \"1\";\n        \n        for ($i = 1; $i < $n; $i++) {\n            $temp = \"\";\n            $count = 1;\n            \n            for ($j = 0; $j < strlen($result); $j++) {\n                if ($j + 1 < strlen($result) && $result[$j] == $result[$j + 1]) {\n                    $count++;\n                } else {\n                    $temp .= $count . $result[$j];\n                    $count = 1;\n                }\n            }\n            \n            $result = $temp;\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func countAndSay(_ n: Int) -> String {\n        var result = \"1\"\n        \n        for _ in 1..<n {\n            var current = \"\"\n            var i = 0\n            \n            while i < result.count {\n                var count = 1\n                let currentChar = result[result.index(result.startIndex, offsetBy: i)]\n                \n                while i + 1 < result.count && result[result.index(result.startIndex, offsetBy: i)] == result[result.index(result.startIndex, offsetBy: i + 1)] {\n                    i += 1\n                    count += 1\n                }\n                \n                current += \"\\(count)\\(currentChar)\"\n                i += 1\n            }\n            \n            result = current\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun countAndSay(n: Int): String {\n        var result = \"1\"\n        for (x in 1 until n) {\n            var current = StringBuilder()\n            var i = 0\n            while (i < result.length) {\n                var count = 1\n                var currentChar = result[i]\n                while (i + 1 < result.length && result[i] == result[i + 1]) {\n                    count++\n                    i++\n                }\n                current.append(count)\n                current.append(currentChar)\n                i++\n            }\n            result = current.toString()\n        }\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String countAndSay(int n) {\n    if (n == 1) {\n      return '1';\n    }\n    \n    String result = '1';\n    for (int i = 2; i <= n; i++) {\n      result = generateNext(result);\n    }\n    \n    return result;\n  }\n  \n  String generateNext(String s) {\n    String result = '';\n    int count = 1;\n    for (int i = 1; i < s.length; i++) {\n      if (s[i] == s[i - 1]) {\n        count++;\n      } else {\n        result += '$count${s[i - 1]}';\n        count = 1;\n      }\n    }\n    result += '$count${s[s.length - 1]}';\n    \n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func countAndSay(n int) string {\n    if n == 1 {\n        return \"1\"\n    }\n    \n    prev := countAndSay(n - 1)\n    result := \"\"\n    count := 1\n    \n    for i := 0; i < len(prev); i++ {\n        if i+1 < len(prev) && prev[i] == prev[i+1] {\n            count++\n        } else {\n            result += strconv.Itoa(count) + string(prev[i])\n            count = 1\n        }\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {String}\ndef count_and_say(n)\n    return \"1\" if n == 1\n    prev = count_and_say(n-1)\n    result = \"\"\n    count = 1\n    (1..prev.length).each do |i|\n        if prev[i] != prev[i-1]\n            result += count.to_s + prev[i-1]\n            count = 1\n        else\n            count += 1\n        end\n    end\n    return result\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def countAndSay(n: Int): String = {\n        if (n == 1) \"1\"\n        else {\n            val prev = countAndSay(n - 1)\n            var result = \"\"\n            var count = 1\n            var i = 0\n            while (i < prev.length) {\n                if (i + 1 < prev.length && prev(i) == prev(i + 1)) {\n                    count += 1\n                } else {\n                    result += count.toString + prev(i)\n                    count = 1\n                }\n                i += 1\n            }\n            result\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn count_and_say(n: i32) -> String {\n        if n == 1 {\n            return \"1\".to_string();\n        }\n        \n        let mut prev = \"1\".to_string();\n        \n        for _ in 2..=n {\n            let mut new_str = String::new();\n            let mut chars = prev.chars().collect::<Vec<char>>();\n            \n            let mut count = 1;\n            let mut curr_char = chars[0];\n            \n            for j in 1..chars.len() {\n                if chars[j] == curr_char {\n                    count += 1;\n                } else {\n                    new_str.push_str(&count.to_string());\n                    new_str.push(curr_char);\n                    count = 1;\n                    curr_char = chars[j];\n                }\n            }\n            \n            new_str.push_str(&count.to_string());\n            new_str.push(curr_char);\n            \n            prev = new_str;\n        }\n        \n        prev\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate the nth element of the count-and-say sequence. The sequence starts with \"1\" and each subsequent element is derived from the previous element by describing the count and value of its repeated characters.\n\nHere's the step-by-step methodology for solving this coding challenge:\n\n# Explanation\n1. **Base Case Handling**:\n   - If `n` is 1, return \u201c1\u201d as it is the base case.\n   \n2. **Recursive Approach**:\n   - For `n > 1`, derive `countAndSay(n)` by generating the run-length encoding of `countAndSay(n-1)`.\n\n3. **Run-Length Encoding (RLE)**:\n   - Traverse the string of the previous sequence.\n   - Count consecutive occurrences of the same digit and create a new string with the format \"<count><digit>\".\n\n# Pseudocode\n```plaintext\nfunction countAndSay(n):\n    if n == 1:\n        return \"1\"\n    \n    prev = countAndSay(n - 1)\n    result = \"\"\n    count = 1\n\n    for i from 1 to length(prev) - 1:\n        if prev[i] == prev[i-1]:\n            count += 1\n        else:\n            result += str(count) + prev[i-1]\n            count = 1\n    \n    result += str(count) + prev[length(prev) - 1]\n\n    return result\n```\n\nThis pseudocode describes a recursive approach to solving the problem, where each call builds upon the result of the previous sequence, encoding it using run-length encoding. With these steps, we can generate the nth element of the count-and-say sequence effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-count-and-say"
    },
    {
        "name": "Combination Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-combination-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> res;\n        vector<int> combination;\n        backtrack(candidates, target, 0, combination, res);\n        return res;\n    }\n    \n    void backtrack(vector<int>& candidates, int target, int start, vector<int>& combination, vector<vector<int>>& res) {\n        if (target == 0) {\n            res.push_back(combination);\n            return;\n        }\n        \n        for (int i = start; i < candidates.size(); i++) {\n            if (candidates[i] <= target) {\n                combination.push_back(candidates[i]);\n                backtrack(candidates, target - candidates[i], i, combination, res);\n                combination.pop_back();\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<>(), candidates, target, 0);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] candidates, int remain, int start) {\n        if (remain < 0) {\n            return;\n        } else if (remain == 0) {\n            result.add(new ArrayList<>(tempList));\n        } else {\n            for (int i = start; i < candidates.length; i++) {\n                tempList.add(candidates[i]);\n                backtrack(result, tempList, candidates, remain - candidates[i], i);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(remain, path, start):\n            if remain == 0:\n                res.append(path[:])\n                return\n            if remain < 0:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(remain - candidates[i], path, i)\n                path.pop()\n        \n        res = []\n        backtrack(target, [], 0)\n        return res"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> CombinationSum(int[] candidates, int target) {\n        IList<IList<int>> result = new List<IList<int>>();\n        IList<int> current = new List<int>();\n        Backtrack(candidates, target, 0, current, result);\n        return result;\n    }\n    \n    private void Backtrack(int[] candidates, int target, int start, IList<int> current, IList<IList<int>> result) {\n        if (target < 0) {\n            return;\n        }\n        if (target == 0) {\n            result.Add(new List<int>(current));\n            return;\n        }\n        \n        for (int i = start; i < candidates.Length; i++) {\n            current.Add(candidates[i]);\n            Backtrack(candidates, target - candidates[i], i, current, result);\n            current.RemoveAt(current.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    const result = [];\n    \n    const backtrack = (current, start, target) => {\n        if (target === 0) {\n            result.push([...current]);\n            return;\n        }\n        \n        for (let i = start; i < candidates.length; i++) {\n            if (candidates[i] > target) continue;\n            current.push(candidates[i]);\n            backtrack(current, i, target - candidates[i]);\n            current.pop();\n        }\n    };\n    \n    backtrack([], 0, target);\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function combinationSum(candidates: number[], target: number): number[][] {\n    const result: number[][] = [];\n    \n    const backtrack = (start: number, path: number[], target: number) => {\n        if (target === 0) {\n            result.push([...path]);\n            return;\n        }\n        \n        for (let i = start; i < candidates.length; i++) {\n            if (candidates[i] > target) continue;\n            path.push(candidates[i]);\n            backtrack(i, path, target - candidates[i]);\n            path.pop();\n        }\n    };\n    \n    backtrack(0, [], target);\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum($candidates, $target) {\n        $result = [];\n        $this->backtrack($candidates, $target, 0, [], $result);\n        return $result;\n    }\n\n    function backtrack($candidates, $target, $start, $path, &$result) {\n        if ($target < 0) {\n            return;\n        }\n        if ($target === 0) {\n            $result[] = $path;\n            return;\n        }\n        for ($i = $start; $i < count($candidates); $i++) {\n            $path[] = $candidates[$i];\n            $this->backtrack($candidates, $target - $candidates[$i], $i, $path, $result);\n            array_pop($path);\n        }\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        var result = [[Int]]()\n        \n        func backtrack(_ target: Int, _ start: Int, _ path: [Int]) {\n            if target == 0 {\n                result.append(path)\n                return\n            }\n            \n            for i in start..<candidates.count {\n                if candidates[i] > target {\n                    continue\n                }\n                \n                backtrack(target - candidates[i], i, path + [candidates[i]])\n            }\n        }\n        \n        backtrack(target, 0, [])\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun combinationSum(candidates: IntArray, target: Int): \nList<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        backtrack(0, target, mutableListOf(), candidates.sorted(), result)\n        return result\n    }\n    \n    private fun backtrack(start: Int, target: Int, path: MutableList<Int>, candidates: List<Int>, result: MutableList<List<Int>>) {\n        if (target == 0) {\n            result.add(ArrayList(path))\n            return\n        }\n        if (target < 0) {\n            return\n        }\n        \n        for (i in start until candidates.size) {\n            path.add(candidates[i])\n            backtrack(i, target - candidates[i], path, candidates, result)\n            path.removeAt(path.size - 1)\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> combinationSum(List<int> candidates, int target) {\n    List<List<int>> result = [];\n    List<int> current = [];\n    \n    void backtrack(int index, int currentSum) {\n      if (currentSum == target) {\n        result.add(List.from(current));\n        return;\n      }\n      \n      if (currentSum > target || index == candidates.length) {\n        return;\n      }\n      \n      current.add(candidates[index]);\n      backtrack(index, currentSum + candidates[index]);\n      current.removeLast();\n      backtrack(index + 1, currentSum);\n    }\n    \n    backtrack(0, 0);\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func combinationSum(candidates []int, target int) [][]int {\n    var result [][]int\n    var backtrack func(start, currentSum int, path []int)\n\n    backtrack = func(start, currentSum int, path []int) {\n        if currentSum == target {\n            temp := make([]int, len(path))\n            copy(temp, path)\n            result = append(result, temp)\n            return\n        }\n\n        if currentSum > target {\n            return\n        }\n\n        for i := start; i < len(candidates); i++ {\n            path = append(path, candidates[i])\n            backtrack(i, currentSum+candidates[i], path)\n            path = path[:len(path)-1]\n        }\n    }\n\n    backtrack(0, 0, []int{})\n    \n    return result\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum(candidates, target)\n    result = []\n    dfs(candidates, target, [], result, 0)\n    result\nend\n\ndef dfs(candidates, target, path, result, index)\n    if target < 0\n        return\n    elsif target == 0\n        result << path.dup\n        return\n    end\n    \n    (index...candidates.length).each do |i|\n        path << candidates[i]\n        dfs(candidates, target - candidates[i], path, result, i)\n        path.pop\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {\n        def backtrack(start: Int, path: List[Int], target: Int): List[List[Int]] = {\n            if (target == 0) {\n                List(path)\n            } else if (target < 0) {\n                List()\n            } else {\n                var res = List[List[Int]]()\n                for (i <- start until candidates.length) {\n                    res = res ::: backtrack(i, path :+ candidates(i), target - candidates(i))\n                }\n                res\n            }\n        }\n        \n        backtrack(0, List(), target)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let mut res = Vec::new();\n        let mut path = Vec::new();\n        \n        Self::dfs(&candidates, target, 0, &mut path, &mut res);\n        \n        res\n    }\n    \n    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, path: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {\n        if target == 0 {\n            res.push(path.clone());\n            return;\n        }\n        \n        for i in start..candidates.len() {\n            if target - candidates[i] >= 0 {\n                path.push(candidates[i]);\n                Self::dfs(candidates, target - candidates[i], i, path, res);\n                path.pop();\n            }\n        }\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec combination_sum(Candidates :: [integer()], Target :: integer()) \n-> [[integer()]].\ncombination_sum(Candidates, Target) ->\n    Combinations = combination_sum_helper(Candidates, Target),\n    lists:usort(Combinations).\n\ncombination_sum_helper(_, 0) ->\n    [[]];\ncombination_sum_helper([], _) ->\n    [];\ncombination_sum_helper([C|Cs], T) when C =< T ->\n    [ [C|X] || X <- combination_sum_helper([C|Cs], T-C)] ++\n    combination_sum_helper(Cs, T);\ncombination_sum_helper([_|Cs], T) ->\n    combination_sum_helper(Cs, T)."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate all unique combinations of numbers from a list that sum up to a given target value, considering that each candidate number can be used an unlimited number of times.\n\nHere's how we can approach this problem using a backtracking algorithm:\n\n# Explanation\n1. **Define the Function**: We'll define a function that takes in the list of candidate numbers and the target sum.\n2. **Backtracking**: We use a helper function to perform backtracking. This function will explore each combination, keeping track of:\n   - Remaining sum required (`remain`).\n   - Current path or combination being explored (`path`).\n   - Starting index for candidates to ensure combinations are unique (to avoid using smaller elements after a larger one in combination).\n3. **Base Case**:\n   - If `remain` becomes zero, it means the current path sums to the target. We add a copy of the path to our result list.\n   - If `remain` becomes negative, we stop further exploration of this path.\n4. **Recursive Case**:\n   - For each candidate number starting from the `start` index, we add the candidate to the path and recursively call the function with the updated remaining sum and path.\n   - We backtrack by removing the last added candidate and try the next candidate.\n5. **Collect Results**: We initialize an empty result list and invoke the backtracking function.\n\n# Pseudocode\n```pseudo\nFunction combinationSum(candidates, target):\n    Initialize result list res as an empty list\n    \n    Define backtrack function(remain, path, start):\n        If remain == 0:\n            Append a copy of path to res\n            Return\n        If remain < 0:\n            Return\n        For i from start to length of candidates:\n            Append candidates[i] to path\n            Call backtrack with (remain - candidates[i], path, i)\n            Remove last element from path (backtrack)\n    \n    Call backtrack with (target, empty list, 0)\n\n    Return res\n```\n\nThis methodology ensures that we explore all possible combinations and backtrack appropriately to avoid redundant computations. The constraints guarantee that the problem size is manageable.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-combination-sum"
    },
    {
        "name": "Combination Sum Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-combination-sum-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int \ntarget) {\n        vector<vector<int>> res;\n        vector<int> combination;\n        sort(candidates.begin(), candidates.end());\n        backtrack(candidates, target, 0, combination, res);\n        return res;\n    }\n    \n    void backtrack(vector<int>& candidates, int target, int start, vector<int>& combination, vector<vector<int>>& res) {\n        if (target == 0) {\n            res.push_back(combination);\n            return;\n        } else if (target < 0) {\n            return;\n        }\n        \n        for (int i = start; i < candidates.size(); i++) {\n            if (i > start && candidates[i] == candidates[i-1]) continue;\n            combination.push_back(candidates[i]);\n            backtrack(candidates, target - candidates[i], i + 1, combination, res);\n            combination.pop_back();\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(candidates);\n        backtrack(result, new ArrayList<>(), candidates, target, 0);\n        return result;\n    }\n    \n    private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] candidates, int remain, int start){\n        if(remain < 0) return;\n        else if(remain == 0) result.add(new ArrayList<>(tempList));\n        else{\n            for(int i = start; i < candidates.length; i++){\n                if(i > start && candidates[i] == candidates[i-1]) continue;\n                tempList.add(candidates[i]);\n                backtrack(result, tempList, candidates, remain - candidates[i], i + 1);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, path, target):\n            if target == 0:\n                result.append(path[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                path.append(candidates[i])\n                backtrack(i + 1, path, target - candidates[i])\n                path.pop()\n\n        candidates.sort()\n        result = []\n        backtrack(0, [], target)\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid backtrack(int* candidates, int candidatesSize, int target, int start, int* combination, int index, int** result, int* returnSize, int* returnColumnSizes) {\n    if (target == 0) {\n        result[*returnSize] = (int*)malloc(index * sizeof(int));\n        returnColumnSizes[*returnSize] = index;\n        for (int i = 0; i < index; i++) {\n            result[*returnSize][i] = combination[i];\n        }\n        (*returnSize)++;\n        return;\n    }\n    \n    for (int i = start; i < candidatesSize; i++) {\n        if (i > start && candidates[i] == candidates[i-1]) continue;\n        \n        if (target - candidates[i] < 0) break;\n        \n        combination[index] = candidates[i];\n        backtrack(candidates, candidatesSize, target - candidates[i], i + 1, combination, index + 1, result, returnSize, returnColumnSizes);\n    }\n}\n\nint** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    int** result = (int**)malloc(100 * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(100 * sizeof(int));\n    *returnSize = 0;\n    \n    qsort(candidates, candidatesSize, sizeof(int), compare);\n    \n    int* combination = (int*)malloc(candidatesSize * sizeof(int));\n    backtrack(candidates, candidatesSize, target, 0, combination, 0, result, returnSize, *returnColumnSizes);\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\n        Array.Sort(candidates);\n        IList<IList<int>> result = new List<IList<int>>();\n        Backtrack(candidates, target, 0, new List<int>(), result);\n        \n        return result;\n    }\n    \n    private void Backtrack(int[] candidates, int target, int start, List<int> tempList, IList<IList<int>> result) {\n        if (target == 0) {\n            result.Add(new List<int>(tempList));\n            return;\n        }\n        \n        for (int i = start; i < candidates.Length; i++) {\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n            \n            if (candidates[i] > target) {\n                break;\n            }\n            \n            tempList.Add(candidates[i]);\n            Backtrack(candidates, target - candidates[i], i + 1, tempList, result);\n            tempList.RemoveAt(tempList.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    const result = [];\n    \n    const backtrack = (start, target, path) => {\n        if (target < 0) {\n            return;\n        }\n        \n        if (target === 0) {\n            result.push([...path]);\n            return;\n        }\n        \n        for (let i = start; i < candidates.length; i++) {\n            if (i > start && candidates[i] === candidates[i - 1]) {\n                continue;\n            }\n            path.push(candidates[i]);\n            backtrack(i + 1, target - candidates[i], path);\n            path.pop();\n        }\n    };\n    \n    candidates.sort((a, b) => a - b);\n    backtrack(0, target, []);\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function combinationSum2(candidates: number[], target: number): number[][] {\n    const result: number[][] = [];\n    \n    candidates.sort((a, b) => a - b);\n    \n    const dfs = (startIndex: number, currArr: number[], currSum: number) => {\n        if (currSum === target) {\n            result.push([...currArr]);\n            return;\n        }\n        \n        if (currSum > target) {\n            return;\n        }\n        \n        for (let i = startIndex; i < candidates.length; i++) {\n            if (i > startIndex && candidates[i] === candidates[i - 1]) {\n                continue;\n            }\n            currArr.push(candidates[i]);\n            dfs(i + 1, currArr, currSum + candidates[i]);\n            currArr.pop();\n        }\n    };\n    \n    dfs(0, [], 0);\n    \n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $candidates\n     * @param Integer $target\n     * @return Integer[][]\n     */\n    function combinationSum2($candidates, $target) {\n        $result = [];\n        sort($candidates);\n        $this->backtrack($candidates, $target, 0, [], $result);\n        return $result;\n    }\n    \n    function backtrack($candidates, $target, $start, $path, &$result) {\n        if ($target < 0) {\n            return;\n        }\n        if ($target === 0) {\n            $result[] = $path;\n            return;\n        }\n        \n        for ($i = $start; $i < count($candidates); $i++) {\n            if ($i > $start && $candidates[$i] === $candidates[$i-1]) {\n                continue;\n            }\n            array_push($path, $candidates[$i]);\n            $this->backtrack($candidates, $target - $candidates[$i], $i+1, $path, $result);\n            array_pop($path);\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        var result = [[Int]]()\n        var current = [Int]()\n        \n        let candidates = candidates.sorted()\n        backtrack(&result, &current, candidates, target, 0)\n        \n        return result\n    }\n    \n    func backtrack(_ result: inout [[Int]], _ current: inout [Int], _ candidates: [Int], _ target: Int, _ start: Int) {\n        if target == 0 {\n            result.append(current)\n            return\n        }\n        \n        for i in start..<candidates.count {\n            if i > start && candidates[i] == candidates[i-1] {\n                continue\n            }\n            \n            if candidates[i] > target {\n                break\n            }\n            \n            current.append(candidates[i])\n            backtrack(&result, &current, candidates, target - candidates[i], i + 1)\n            current.removeLast()\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun combinationSum2(candidates: IntArray, target: Int): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        candidates.sort()\n        backtrack(result, mutableListOf(), candidates, target, 0)\n        return result\n    }\n    \n    private fun backtrack(\n        result: MutableList<List<Int>>,\n        tempList: MutableList<Int>,\n        candidates: IntArray,\n        remain: Int,\n        start: Int\n    ) {\n        if (remain < 0) return\n        if (remain == 0) {\n            result.add(tempList.toList())\n        } else {\n            for (i in start until candidates.size) {\n                if (i > start && candidates[i] == candidates[i - 1]) continue\n                tempList.add(candidates[i])\n                backtrack(result, tempList, candidates, remain - candidates[i], i + 1)\n                tempList.removeAt(tempList.size - 1)\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> combinationSum2(List<int> candidates, int target) {\n    List<List<int>> result = [];\n    candidates.sort();\n    findCombinations(candidates, target, 0, [], result);\n    return result;\n  }\n\n  void findCombinations(List<int> candidates, int target, int index, List<int> current, List<List<int>> result) {\n    if (target == 0) {\n      result.add(List.from(current));\n      return;\n    }\n\n    for (int i = index; i < candidates.length; i++) {\n      if (i == index || candidates[i] != candidates[i - 1]) {\n        if (candidates[i] > target) {\n          break;\n        }\n        current.add(candidates[i]);\n        findCombinations(candidates, target - candidates[i], i + 1, current, result);\n        current.removeLast();\n      }\n    }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func combinationSum2(candidates []int, target int) [][]int {\n    var result [][]int\n    var path []int\n    var backtrack func(int, int)\n\n    sort.Ints(candidates)\n\n    backtrack = func(start, remain int) {\n        if remain == 0 {\n            temp := make([]int, len(path))\n            copy(temp, path)\n            result = append(result, temp)\n            return\n        }\n\n        for i := start; i < len(candidates); i++ {\n            if i > start && candidates[i] == candidates[i-1] {\n                continue\n            }\n\n            if remain < candidates[i] {\n                break\n            }\n\n            path = append(path, candidates[i])\n            backtrack(i+1, remain-candidates[i])\n            path = path[:len(path)-1]\n        }\n    }\n\n    backtrack(0, target)\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} candidates\n# @param {Integer} target\n# @return {Integer[][]}\ndef combination_sum2(candidates, target)\n    res = []\n    candidates.sort!\n    dfs(candidates, target, 0, [], res)\n    res\nend\n\ndef dfs(candidates, target, start, path, res)\n    if target < 0\n        return\n    elsif target == 0\n        res << path.dup\n    else\n        (start...candidates.length).each do |i|\n            break if candidates[i] > target\n            next if i > start && candidates[i] == candidates[i-1]\n            path << candidates[i]\n            dfs(candidates, target - candidates[i], i + 1, path, res)\n            path.pop\n        end\n    end\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn combination_sum2(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut path = Vec::new();\n        \n        fn backtrack(\n            candidates: &Vec<i32>,\n            target: i32,\n            start: usize,\n            path: &mut Vec<i32>,\n            result: &mut Vec<Vec<i32>>,\n        ) {\n            if target == 0 {\n                result.push(path.clone());\n                return;\n            }\n            \n            for i in start..candidates.len() {\n                if i > start && candidates[i] == candidates[i - 1] {\n                    continue;\n                }\n                \n                if candidates[i] <= target {\n                    path.push(candidates[i]);\n                    backtrack(candidates, target - candidates[i], i + 1, path, result);\n                    path.pop();\n                }\n            }\n        }\n        \n        let mut candidates = candidates;\n        candidates.sort();\n        backtrack(&candidates, target, 0, &mut path, &mut result);\n        \n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll implement a backtracking algorithm to explore all possible combinations of candidate numbers that sum up to a target value. Each candidate number can only be used once, and the results should only include unique combinations.\n\n# Explanation\n\nThe backtracking approach is instrumental in exploring all subsets of candidates to identify those summing up to the target value. The solution involves the following steps:\n1. **Sort Candidates**: Sorting helps in managing duplicates more effectively.\n2. **Backtracking Function**: This function recursively explores each possible combination, only choosing candidates that don't exceed the target.\n3. **Checking for Duplicates**: Skip duplicate elements to avoid redundant combinations.\n4. **Termination Condition**: When the target sum is achieved, add the current combination to the result list.\n5. **Pruning**: If a candidate exceeds the remaining target, break the loop since further elements will also exceed.\n\n# Pseudocode\n\n```\nfunction combinationSum2(candidates, target):\n    define backtrack(start, path, target):\n        if target == 0:\n            append a copy of path to result\n            return\n        for i from start to length of candidates:\n            if i > start and candidates[i] == candidates[i - 1]:  # Skip duplicates \n                continue\n            if candidates[i] > target:  # Prune the recursion tree\n                break\n            append candidates[i] to path\n            backtrack(i + 1, path, target - candidates[i])  # Move to the next index\n            remove last element from path  # Backtrack\n\n    sort candidates array\n    initialize result as empty list\n    call backtrack(0, [], target)\n    return result\n```\n\nThe pseudocode encapsulates the entire approach encompassing sorting the candidates, initializing the backtracking process, avoiding duplicates, pruning the search space, and finally obtaining the desired unique combinations that sum up to the target.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-combination-sum-ii"
    },
    {
        "name": "First Missing Positive",
        "site": "LeetCode",
        "href": "/solution/LeetCode-first-missing-positive",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        \n        for (int i = 0; i < n; ++i) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                swap(nums[i], nums[nums[i] - 1]);\n            }\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        \n        return n + 1;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                int temp = nums[nums[i] - 1];\n                nums[nums[i] - 1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        \n        return n + 1;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int firstMissingPositive(int* nums, int numsSize) {\n    int i;\n    for (i = 0; i < numsSize; i++) {\n        while (nums[i] > 0 && nums[i] <= numsSize && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[nums[i] - 1];\n            nums[nums[i] - 1] = nums[i];\n            nums[i] = temp;\n        }\n    }\n    \n    for (i = 0; i < numsSize; i++) {\n        if (nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    \n    return numsSize + 1;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FirstMissingPositive(int[] nums) {\n        int n = nums.Length;\n        \n        for (int i = 0; i < n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                int temp = nums[i];\n                nums[i] = nums[temp - 1];\n                nums[temp - 1] = temp;\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        \n        return n + 1;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    let n = nums.length;\n    \n    for (let i = 0; i < n; i++) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n        }\n    }\n    \n    for (let i = 0; i < n; i++) {\n        if (nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    \n    return n + 1;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function firstMissingPositive(nums: number[]): number {\n    const n = nums.length;\n    for (let i = 0; i < n; i++) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n        }\n    }\n    \n    for (let i = 0; i < n; i++) {\n        if (nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    \n    return n + 1;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function firstMissingPositive($nums) {\n        $n = count($nums);\n        for ($i = 0; $i < $n; $i++) {\n            while ($nums[$i] > 0 && $nums[$i] <= $n && $nums[$i] != $nums[$nums[$i] - 1]) {\n                $temp = $nums[$i];\n                $nums[$i] = $nums[$temp - 1];\n                $nums[$temp - 1] = $temp;\n            }\n        }\n        \n        for ($i = 0; $i < $n; $i++) {\n            if ($nums[$i] != $i + 1) {\n                return $i + 1;\n            }\n        }\n        \n        return count($nums) + 1;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func firstMissingPositive(_ nums: [Int]) -> Int {\n        var nums = nums\n        var i = 0\n        \n        while i < nums.count {\n            if nums[i] > 0 && nums[i] <= nums.count && nums[nums[i] - 1] != nums[i] {\n                nums.swapAt(i, nums[i] - 1)\n            } else {\n                i += 1\n            }\n        }\n        \n        for i in 0..<nums.count {\n            if nums[i] != i + 1 {\n                return i + 1\n            }\n        }\n        \n        return nums.count + 1\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun firstMissingPositive(nums: IntArray): Int {\n        var i = 0\n        while (i < nums.size) {\n            if (nums[i] > 0 && nums[i] <= nums.size && nums[nums[i] - 1] != nums[i]) {\n                val temp = nums[nums[i] - 1]\n                nums[nums[i] - 1] = nums[i]\n                nums[i] = temp\n            } else {\n                i++\n            }\n        }\n        \n        for (j in 0 until nums.size) {\n            if (nums[j] != j + 1) {\n                return j + 1\n            }\n        }\n        \n        return nums.size + 1\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int firstMissingPositive(List<int> nums) {\n    Set<int> numSet = Set.from(nums);\n    int i = 1;\n    while (numSet.contains(i)) {\n      i++;\n    }\n    return i;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func firstMissingPositive(nums []int) int {\n    n := len(nums)\n\n    for i := 0; i < n; i++ {\n        for nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i] {\n            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n        }\n    }\n\n    for i := 0; i < n; i++ {\n        if nums[i] != i+1 {\n            return i + 1\n        }\n    }\n\n    return n + 1\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef first_missing_positive(nums)\n    n = nums.length\n    (0..n-1).each do |i|\n        while nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i] do\n            nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n        end\n    end\n\n    (0..n-1).each do |i|\n        return i + 1 if nums[i] != i + 1\n    end\n\n    return n + 1\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn first_missing_positive(nums: Vec<i32>) -> i32 {\n        let mut nums = nums;\n        let n = nums.len() as i32;\n\n        for i in 0..n {\n            while nums[i as usize] > 0 && nums[i as usize] <= n && nums[(nums[i as usize] - 1) as usize] != nums[i as usize] {\n                let idx = nums[i as usize] as usize - 1;\n                let tmp = nums[idx];\n                nums[idx] = nums[i as usize];\n                nums[i as usize] = tmp;\n            }\n        }\n\n        for i in 0..n {\n            if nums[i as usize] != i + 1 {\n                return i + 1;\n            }\n        }\n\n        n + 1\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (first-missing-positive nums)\n  (-> (listof exact-integer?) exact-integer?)\n  (let ((n (+ 1 (apply max nums))))\n    (let loop ((i 1))\n      (cond\n        ((not (member i nums)) i)\n        (else (loop (+ i 1)))\n        ))\n  ))"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec first_missing_positive(Nums :: [integer()]) -> integer().\nfirst_missing_positive(Nums) ->\n    case lists:seq(1, length(Nums) + 1) -- Nums of\n        [] -> length(Nums) + 1;\n        [X | _] -> X\n    end.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify the smallest missing positive integer in an unsorted list of integers. The constraint of achieving this in O(n) time complexity and O(1) auxiliary space will guide our approach.\n\n# Explanation\n1. **Objective**: Find the smallest missing positive integer in an unsorted array. We must optimize the solution to work in linear time, O(n), while using constant space, O(1) (excluding the input and output).\n  \n2. **Approach**:\n   - Utilize the array itself for marking the presence of elements.\n   - Adjust elements such that each positive integer `i` is placed at index `i-1`.\n   - Iterate through the array, and place every number `x` in its right position `nums[x-1]` if it's in the range from `1` to `n` (inclusive).\n   - After positioning all valid numbers correctly, the first index position `i` which does not have the value `i+1` corresponds to the smallest missing positive integer.\n\n3. **Steps**:\n   - First pass: Reorder the elements.\n   - Second pass: Identify the smallest missing positive integer by checking the reordered elements.\n\n# Pseudocode\n\n```plaintext\n# Function to find the first missing positive integer\nfunction firstMissingPositive(nums):\n    n = length of nums\n    \n    # Step 1: Placement of elements to their correct positions\n    for i from 0 to n-1 do:\n        while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:\n            # Swap the elements to their correct positions\n            swap nums[nums[i]-1] and nums[i]\n        end while\n    end for\n    \n    # Step 2: Identify the smallest missing positive integer\n    for i from 0 to n-1 do:\n        if nums[i] != i + 1 then:\n            return i + 1\n    end for\n    \n    # If all positions are correct, return n + 1\n    return n + 1\n```\n\nIn the pseudocode above:\n1. We iterate through the array and place each value in its correct position.\n2. For the final check, we iterate through the array again to find the first position that does not have the expected value `(index + 1)`, and return that as the smallest missing positive integer.\n\nThis approach ensures that we achieve the required time complexity of O(n) and utilize only constant additional space.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-first-missing-positive"
    },
    {
        "name": "Trapping Rain Water",
        "site": "LeetCode",
        "href": "/solution/LeetCode-trapping-rain-water",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) {\n            return 0;\n        }\n        \n        vector<int> leftMax(n), rightMax(n);\n        leftMax[0] = height[0];\n        rightMax[n - 1] = height[n - 1];\n        \n        for (int i = 1; i < n; i++) {\n            leftMax[i] = max(leftMax[i - 1], height[i]);\n        }\n        \n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = max(rightMax[i + 1], height[i]);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += min(leftMax[i], rightMax[i]) - height[i];\n        }\n        \n        return ans;\n    }\n};\n  "
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n        \n        int n = height.length;\n        int left = 0, right = n - 1;\n        int leftMax = 0, rightMax = 0;\n        int res = 0;\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    res += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    res += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        \n        return res;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n        \n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        left_max[0] = height[0]\n        right_max[-1] = height[-1]\n        \n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i-1], height[i])\n        \n        for i in range(len(height) - 2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i])\n            \n        total_water = 0\n        for i in range(1, len(height) - 1):\n            water_level = min(left_max[i], right_max[i])\n            if water_level > height[i]:\n                total_water += water_level - height[i]\n        \n        return total_water\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int trap(int* height, int heightSize) {\n    int left = 0, right = heightSize - 1;\n    int leftMax = 0, rightMax = 0;\n    int totalWater = 0;\n    \n    while (left < right) {\n        if (height[left] <= height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                totalWater += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                totalWater += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n    \n    return totalWater;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Trap(int[] height) {\n        int n = height.Length;\n        if (n == 0) {\n            return 0;\n        }\n        \n        int left = 0;\n        int right = n - 1;\n        int leftMax = 0;\n        int rightMax = 0;\n        int result = 0;\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    result += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    result += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    let left = 0;\n    let right = height.length - 1;\n    let leftMax = 0;\n    let rightMax = 0;\n    let result = 0;\n\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                result += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                result += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function trap(height: number[]): number {\n    let left = 0;\n    let right = height.length - 1;\n    let leftMax = 0;\n    let rightMax = 0;\n    let result = 0;\n\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                result += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                result += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $height\n     * @return Integer\n     */\n    function trap($height) {\n        $n = count($height);\n        if ($n == 0) return 0;\n        \n        $left = 0;\n        $right = $n - 1;\n        $leftMax = 0;\n        $rightMax = 0;\n        $result = 0;\n        \n        while ($left < $right) {\n            if ($height[$left] < $height[$right]) {\n                if ($height[$left] >= $leftMax) {\n                    $leftMax = $height[$left];\n                } else {\n                    $result += $leftMax - $height[$left];\n                }\n                $left++;\n            } else {\n                if ($height[$right] >= $rightMax) {\n                    $rightMax = $height[$right];\n                } else {\n                    $result += $rightMax - $height[$right];\n                }\n                $right--;\n            }\n        }\n        \n        return $result;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func trap(_ height: [Int]) -> Int {\n        var left = 0\n        var right = height.count - 1\n        var leftMax = 0\n        var rightMax = 0\n        var result = 0\n        \n        while left < right {\n            if height[left] < height[right] {\n                if height[left] >= leftMax {\n                    leftMax = height[left]\n                } else {\n                    result += leftMax - height[left]\n                }\n                left += 1\n            } else {\n                if height[right] >= rightMax {\n                    rightMax = height[right]\n                } else {\n                    result += rightMax - height[right]\n                }\n                right -= 1\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun trap(height: IntArray): Int {\n        var left = 0\n        var right = height.size - 1\n        var leftMax = 0\n        var rightMax = 0\n        var result = 0\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left]\n                } else {\n                    result += leftMax - height[left]\n                }\n                left++\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right]\n                } else {\n                    result += rightMax - height[right]\n                }\n                right--\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int trap(List<int> height) {\n    if (height.isEmpty) return 0;\n    \n    int left = 0;\n    int right = height.length - 1;\n    int leftMax = 0;\n    int rightMax = 0;\n    int trappedWater = 0;\n    \n    while (left < right) {\n      if (height[left] < height[right]) {\n        if (height[left] >= leftMax) {\n          leftMax = height[left];\n        } else {\n          trappedWater += leftMax - height[left];\n        }\n        left++;\n      } else {\n        if (height[right] >= rightMax) {\n          rightMax = height[right];\n        } else {\n          trappedWater += rightMax - height[right];\n        }\n        right--;\n      }\n    }\n    \n    return trappedWater;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func trap(height []int) int {\n    if len(height) == 0 {\n        return 0\n    }\n\n    leftMax := make([]int, len(height))\n    rightMax := make([]int, len(height))\n    trappedWater := 0\n\n    leftMax[0] = height[0]\n    for i := 1; i < len(height); i++ {\n        leftMax[i] = max(leftMax[i-1], height[i])\n    }\n\n    rightMax[len(height)-1] = height[len(height)-1]\n    for i := len(height) - 2; i >= 0; i-- {\n        rightMax[i] = max(rightMax[i+1], height[i])\n    }\n\n    for i := 0; i < len(height); i++ {\n        trappedWater += min(leftMax[i], rightMax[i]) - height[i]\n    }\n\n    return trappedWater\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} height\n# @return {Integer}\ndef trap(height)\n    return 0 if height.nil? || height.length == 0\n    \n    left = 0\n    right = height.length - 1\n    left_max = 0\n    right_max = 0\n    result = 0\n    \n    while left < right\n        if height[left] < height[right]\n            if height[left] >= left_max\n                left_max = height[left]\n            else\n                result += left_max - height[left]\n            end\n            left += 1\n        else\n            if height[right] >= right_max\n                right_max = height[right]\n            else\n                result += right_max - height[right]\n            end\n            right -= 1\n        end\n    end\n    \n    return result\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def trap(height: Array[Int]): Int = {\n        var left = 0\n        var right = height.length - 1\n        var leftMax = 0\n        var rightMax = 0\n        var result = 0\n        \n        while (left < right) {\n            if (height(left) < height(right)) {\n                if (height(left) >= leftMax) {\n                    leftMax = height(left)\n                } else {\n                    result += leftMax - height(left)\n                }\n                left += 1\n            } else {\n                if (height(right) >= rightMax) {\n                    rightMax = height(right)\n                } else {\n                    result += rightMax - height(right)\n                }\n                right -= 1\n            }\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        let mut left = 0;\n        let mut right = height.len() - 1;\n        let mut left_max = 0;\n        let mut right_max = 0;\n        let mut result = 0;\n\n        while left < right {\n            if height[left] < height[right] {\n                if height[left] >= left_max {\n                    left_max = height[left];\n                } else {\n                    result += left_max - height[left];\n                }\n                left += 1;\n            } else {\n                if height[right] >= right_max {\n                    right_max = height[right];\n                } else {\n                    result += right_max - height[right];\n                }\n                right -= 1;\n            }\n        }\n\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to compute how much water can be trapped between the bars represented by an elevation map. The methodology involves using two auxiliary arrays to track the maximum heights to the left and right of each bar.\n\n# Explanation:\nTo solve the trapping rainwater problem, we can follow these steps:\n1. **Initialize Two Arrays**: Create two arrays, `left_max` and `right_max`, of the same length as the input array `height`. These arrays will store the maximum bar height to the left and right of each bar, respectively.\n2. **Populate `left_max` Array**: Traverse from left to right through the `height` array, populating `left_max` where each element stores the maximum height encountered up to that index from the left.\n3. **Populate `right_max` Array**: Traverse from right to left through the `height` array, populating `right_max` where each element stores the maximum height encountered up to that index from the right.\n4. **Calculate Water Trapped**: Traverse the `height` array again. For each index, calculate the potential trapped water by finding the minimum of `left_max[i]` and `right_max[i]`, subtracting the height at that index, and summing these values.\n5. **Edge Cases**: Handle edge cases, like when the `height` array is empty.\n\n# Pseudocode:\n```\nfunction trap(height):\n    if height is empty:\n        return 0\n\n    n = length of height\n    left_max = array of length n\n    right_max = array of length n\n\n    left_max[0] = height[0]\n    for i from 1 to n-1:\n        left_max[i] = max(left_max[i-1], height[i])\n\n    right_max[n-1] = height[n-1]\n    for i from n-2 to 0:\n        right_max[i] = max(right_max[i+1], height[i])\n\n    total_water = 0\n    for i from 1 to n-1:\n        water_level = min(left_max[i], right_max[i])\n        if water_level > height[i]:\n            total_water += water_level - height[i]\n\n    return total_water\n```\n\nThis pseudocode outlines the steps needed to solve the problem by calculating the trapped rainwater between elevation bars. It starts by checking if the input array is empty, then initializes the auxiliary arrays, populates them by iterating through the `height` array, and finally computes the total trapped water by iterating again and summing up the trapped water at each index.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-trapping-rain-water"
    },
    {
        "name": "Multiply Strings",
        "site": "LeetCode",
        "href": "/solution/LeetCode-multiply-strings",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        int m = num1.size();\n        int n = num2.size();\n        vector<int> result(m + n, 0);\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int mul = (num1[i] - '0') * (num2[j] - '0');\n                int sum = mul + result[i + j + 1];\n                \n                result[i + j] += sum / 10;\n                result[i + j + 1] = sum % 10;\n            }\n        }\n        \n        string res;\n        for (int num : result) {\n            if (!(res.empty() && num == 0)) {\n                res.push_back(num + '0');\n            }\n        }\n        \n        return res.empty() ? \"0\" : res;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1.equals(\"0\") || num2.equals(\"0\")) {\n            return \"0\";\n        }\n        \n        int[] result = new int[num1.length() + num2.length()];\n        \n        for (int i = num1.length() - 1; i >= 0; i--) {\n            for (int j = num2.length() - 1; j >= 0; j--) {\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                int sum = mul + result[i + j + 1];\n                \n                result[i + j] += sum / 10;\n                result[i + j + 1] = sum % 10;\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (int n : result) {\n            if (!(sb.length() == 0 && n == 0)) {\n                sb.append(n);\n            }\n        }\n        \n        return sb.toString();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def multiply(self, num1, num2):\n        res = [0] * (len(num1) + len(num2))\n        for i in reversed(range(len(num1))):\n            for j in reversed(range(len(num2))):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                pos1, pos2 = i + j, i + j + 1\n                summation = mul + res[pos2]\n                res[pos1] += summation // 10\n                res[pos2] = summation % 10\n        res_str = ''.join(map(str, res)).lstrip('0')\n        return res_str if res_str else '0'"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string Multiply(string num1, string num2) {\n        if (num1.Equals(\"0\") || num2.Equals(\"0\")) {\n            return \"0\"; \n        }\n        \n        int m = num1.Length, n = num2.Length;\n        int[] pos = new int[m + n];\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int mul = (num1[i] - '0') * (num2[j] - '0');\n                int p1 = i + j, p2 = i + j + 1;\n                int sum = mul + pos[p2];\n                \n                pos[p1] += sum / 10;\n                pos[p2] = (sum) % 10;\n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        foreach (int p in pos) {\n            if (!(result.Length == 0 && p == 0)) {\n                result.Append(p);\n            }\n        }\n        \n        return result.Length == 0 ? \"0\" : result.ToString();\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function multiply(num1: string, num2: string): string {\n    if (num1 === \"0\" || num2 === \"0\") return \"0\";\n    \n    const m = num1.length, n = num2.length;\n    const result = new Array(m + n).fill(0);\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            const mul = (num1.charCodeAt(i) - '0'.charCodeAt(0)) * (num2.charCodeAt(j) - '0'.charCodeAt(0));\n            const sum = mul + result[i + j + 1];\n            result[i + j] += Math.floor(sum / 10);\n            result[i + j + 1] = sum % 10;\n        }\n    }\n\n    return result.join('').replace(/^0+/, '') || \"0\";\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $num1\n     * @param String $num2\n     * @return String\n     */\n    function multiply($num1, $num2) {\n        $len1 = strlen($num1);\n        $len2 = strlen($num2);\n        $result = array_fill(0, $len1 + $len2, 0);\n        \n        for ($i = $len1 - 1; $i >= 0; $i--) {\n            for ($j = $len2 - 1; $j >= 0; $j--) {\n                $mul = intval($num1[$i]) * intval($num2[$j]);\n                $sum = $mul + $result[$i + $j + 1];\n                $result[$i + $j] += intdiv($sum, 10);\n                $result[$i + $j + 1] = $sum % 10;\n            }\n        }\n        \n        $res = ltrim(implode(\"\", $result), '0');\n        return $res === \"\" ? \"0\" : $res;\n    }\n}  "
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func multiply(_ num1: String, _ num2: String) -> String {\n        if num1 == \"0\" || num2 == \"0\" {\n            return \"0\"\n        }\n        \n        let m = num1.count\n        let n = num2.count\n        var result = Array(repeating: 0, count: m + n)\n        \n        let num1Array = Array(num1.reversed())\n        let num2Array = Array(num2.reversed())\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                let digit1 = Int(String(num1Array[i]))! \n                let digit2 = Int(String(num2Array[j]))!\n                let product = digit1 * digit2\n                let sum = product + result[i + j]\n                \n                result[i + j] = sum % 10\n                result[i + j + 1] += sum / 10\n            }\n        }\n        \n        var finalResult = \"\"\n        for digit in result.reversed() {\n            if !(finalResult.isEmpty && digit == 0) {\n                finalResult.append(String(digit))\n            }\n        }\n        \n        return finalResult\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun multiply(num1: String, num2: String): String {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\"\n        }\n        \n        val m = num1.length\n        val n = num2.length\n        val result = IntArray(m + n)\n        \n        for (i in m - 1 downTo 0) {\n            for (j in n - 1 downTo 0) {\n                val mul = (num1[i] - '0') * (num2[j] - '0')\n                val sum = mul + result[i + j + 1]\n                result[i + j] += sum / 10\n                result[i + j + 1] = sum % 10\n            }\n        }\n        \n        val sb = StringBuilder()\n        for (num in result) {\n            if (!(sb.isEmpty() && num == 0)) {\n                sb.append(num)\n            }\n        }\n        \n        return sb.toString()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String multiply(String num1, String num2) {\n      if (num1 == \"0\" || num2 == \"0\") {\n          return \"0\";\n      }\n      \n      int m = num1.length;\n      int n = num2.length;\n      List<int> result = List<int>.filled(m + n, 0);\n      \n      for (int i = m - 1; i >= 0; i--) {\n          int x = int.parse(num1[i]);\n          for (int j = n - 1; j >= 0; j--) {\n              int y = int.parse(num2[j]);\n              int product = x * y;\n              int p1 = i + j;\n              int p2 = i + j + 1;\n              int sum = product + result[p2];\n              \n              result[p1] += sum ~/ 10;\n              result[p2] = sum % 10;\n          }\n      }\n      \n      String res = \"\";\n      for (int digit in result) {\n          if (res.isEmpty && digit == 0) {\n              continue;\n          }\n          res += digit.toString();\n      }\n      \n      return res;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func multiply(num1 string, num2 string) string {\n    if num1 == \"0\" || num2 == \"0\" {\n        return \"0\"\n    }\n\n    m, n := len(num1), len(num2)\n    res := make([]int, m+n)\n\n    for i := m - 1; i >= 0; i-- {\n        for j := n - 1; j >= 0; j-- {\n            mul := int((num1[i] - '0') * (num2[j] - '0'))\n            sum := mul + res[i+j+1]\n            res[i+j] += sum / 10\n            res[i+j+1] = sum % 10\n        }\n    }\n\n    result := \"\"\n    for _, digit := range res {\n        if !(len(result) == 0 && digit == 0) {\n            result += strconv.Itoa(digit)\n        }\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} num1\n# @param {String} num2\n# @return {String}\ndef multiply(num1, num2)\n    if num1 == \"0\" || num2 == \"0\"\n        return \"0\"\n    end\n    \n    m = num1.length\n    n = num2.length\n    pos = Array.new(m + n, 0)\n    \n    (m - 1).downto(0) do |i|\n        (n - 1).downto(0) do |j|\n            mul = (num1[i].ord - '0'.ord) * (num2[j].ord - '0'.ord)\n            p1 = i + j\n            p2 = i + j + 1\n            sum = mul + pos[p2]\n            \n            pos[p1] += sum / 10\n            pos[p2] = sum % 10\n        end\n    end\n    \n    pos.each_with_index do |num, i|\n        if num != 0 || i == m + n - 1\n            return pos[i..].join\n        end\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def multiply(num1: String, num2: String): String = {\n        if (num1 == \"0\" || num2 == \"0\") return \"0\"\n        \n        val len1 = num1.length\n        val len2 = num2.length\n        val result = Array.fill(len1 + len2)(0)\n        \n        for {\n            i <- (len1 - 1 to 0 by -1)\n            j <- (len2 - 1 to 0 by -1)\n        } {\n            val mul = (num1(i) - '0') * (num2(j) - '0')\n            val sum = mul + result(i + j + 1)\n            \n            result(i + j) += sum / 10\n            result(i + j + 1) = sum % 10\n        }\n        \n        result.mkString(\"\").dropWhile(_ == '0')\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn multiply(num1: String, num2: String) -> String {\n        if num1 == \"0\" || num2 == \"0\" {\n            return \"0\".to_string();\n        }\n        \n        let m = num1.len();\n        let n = num2.len();\n        let mut res = vec![0; m + n];\n        \n        let num1 = num1.chars().rev().collect::<Vec<char>>();\n        let num2 = num2.chars().rev().collect::<Vec<char>>();\n        \n        for i in 0..m {\n            for j in 0..n {\n                let product = (num1[i].to_digit(10).unwrap() as i32) * (num2[j].to_digit(10).unwrap() as i32);\n                let sum = product + res[i + j];\n                res[i + j] = sum % 10;\n                res[i + j + 1] += sum / 10;\n            }\n        }\n        \n        while res.len() > 1 && res[res.len() - 1] == 0 {\n            res.pop();\n        }\n        \n        res.iter().rev().map(|&x| char::from_digit(x as u32, 10).unwrap()).collect()\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (multiply num1 num2)\n  (-> string? string? string?)\n  (number->string (* (string->number num1) (string->number num2))))"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec multiply(num1 :: String.t, num2 :: String.t) :: String.t\n  def multiply(num1, num2) do\n    result = Integer.to_string(String.to_integer(num1) * String.to_integer(num2))\n    result\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to accurately multiply two non-negative integers represented as strings without converting them to integers directly. We also have to avoid using built-in BigInteger libraries. Our approach will simulate the manual multiplication process.\n\n# Explanation\n\n1. **Initialization**:\n   - Create an array `res` to store the intermediate multiplication results. The size of `res` will be the sum of the lengths of the two input strings, `num1` and `num2`.\n\n2. **Multiplication**:\n   - Traverse both strings from the last digit to the first, mimicking the manual column-by-column multiplication method.\n   - Calculate the product of two digits and add it to the appropriate position in the `res` array.\n   - Manage carry-over values by adjusting the next position in the `res` array.\n\n3. **Result Construction**:\n   - Convert the digits stored in the `res` array back to a string.\n   - Strip leading zeros from the result string.\n   - Handle special cases where the result might be \"0\".\n\n# Pseudocode\n\n```\nfunction multiplyStrings(num1, num2):\n    # Step 1: Initialize the result array\n    n1 = length of num1\n    n2 = length of num2\n    res = array of integers with size (n1 + n2), initialized to zero\n\n    # Step 2: Perform the multiplication\n    for i from n1-1 to 0:\n        for j from n2-1 to 0:\n            # Multiply the digits\n            mul = (num1[i] - '0') * (num2[j] - '0')\n            # Calculate positions in the result array\n            pos1 = i + j\n            pos2 = i + j + 1\n            # Add current multiplication result to the existing number at pos2\n            total = mul + res[pos2]\n            # Carry over\n            res[pos1] += total // 10\n            # Store the unit digit\n            res[pos2] = total % 10\n\n    # Step 3: Convert result array to string\n    resultStr = concatenate each digit in res from start to end\n\n    # Step 4: Remove leading zeros\n    resultStr = resultStr.lstrip('0')\n\n    # Step 5: Return the result string or \"0\"\n    if resultStr is empty:\n        return \"0\"\n    else:\n        return resultStr\n```\n\nThis is a complete logical plan to multiply large numbers represented as strings without converting them to integers directly, adhering to the constraints of the challenge.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-multiply-strings"
    },
    {
        "name": "Wildcard Matching",
        "site": "LeetCode",
        "href": "/solution/LeetCode-wildcard-matching",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size();\n        int n = p.size();\n        \n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\n        dp[0][0] = true;\n        \n        for(int j = 1; j <= n; j++) {\n            if(p[j-1] == '*') {\n                dp[0][j] = dp[0][j-1];\n            }\n        }\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(s[i-1] == p[j-1] || p[j-1] == '?') {\n                    dp[i][j] = dp[i-1][j-1];\n                } else if(p[j-1] == '*') {\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int sPointer = 0, pPointer = 0, match = 0, starIdx = -1;\n        \n        while (sPointer < s.length()) {\n            if (pPointer < p.length() && (p.charAt(pPointer) == '?' || s.charAt(sPointer) == p.charAt(pPointer))) {\n                sPointer++;\n                pPointer++;\n            } else if (pPointer < p.length() && p.charAt(pPointer) == '*') {\n                starIdx = pPointer;\n                match = sPointer;\n                pPointer++;\n            } else if (starIdx != -1) {\n                pPointer = starIdx + 1;\n                match++;\n                sPointer = match;\n            } else {\n                return false;\n            }\n        }\n        \n        while (pPointer < p.length() && p.charAt(pPointer) == '*') {\n            pPointer++;\n        }\n        \n        return pPointer == p.length();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        \n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == '*' and (dp[i][j - 1] or dp[i - 1][j]):\n                    dp[i][j] = True\n                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        \n        return dp[len(s)][len(p)]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isMatch(char* s, char* p) {\n    int sLen = strlen(s);\n    int pLen = strlen(p);\n    \n    bool dp[sLen + 1][pLen + 1];\n    memset(dp, false, sizeof(dp));\n    dp[0][0] = true;\n    \n    for (int i = 1; i <= pLen; i++) {\n        if (p[i - 1] == '*') {\n            dp[0][i] = dp[0][i - 1];\n        }\n    }\n    \n    for (int i = 1; i <= sLen; i++) {\n        for (int j = 1; j <= pLen; j++) {\n            if (s[i - 1] == p[j - 1] || p[j - 1] == '?') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            }\n        }\n    }\n    \n    return dp[sLen][pLen];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsMatch(string s, string p) {\n        int sIndex = 0, pIndex = 0, match = 0, startIndex = -1;\n        \n        while (sIndex < s.Length) {\n            if (pIndex < p.Length && (p[pIndex] == '?' || s[sIndex] == p[pIndex])) {\n                sIndex++;\n                pIndex++;\n            } else if (pIndex < p.Length && p[pIndex] == '*') {\n                match = sIndex;\n                startIndex = pIndex;\n                pIndex++;\n            } else if (startIndex != -1) {\n                match++;\n                sIndex = match;\n                pIndex = startIndex + 1;\n            } else {\n                return false;\n            }\n        }\n        \n        while (pIndex < p.Length && p[pIndex] == '*') {\n            pIndex++;\n        }\n        \n        return pIndex == p.Length;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    const dp = Array(s.length + 1).fill(false);\n    dp[0] = true;\n    \n    for (let i = 1; i <= p.length; i++) {\n        if (p[i - 1] === '*') {\n            for (let j = 1; j <= s.length; j++) {\n                dp[j] = dp[j] || dp[j - 1];\n            }\n        } else {\n            for (let j = s.length; j > 0; j--) {\n                dp[j] = dp[j - 1] && (p[i - 1] === '?' || p[i - 1] === s[j - 1]);\n            }\n            dp[0] = false;\n        }\n    }\n    \n    return dp[s.length];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isMatch(s: string, p: string): boolean {\n    const dp: boolean[][] = Array.from({ length: s.length + 1 }, () =>\n        Array(p.length + 1).fill(false)\n    );\n\n    dp[0][0] = true;\n\n    for (let col = 1; col <= p.length; col++) {\n        if (p[col - 1] === '*') {\n            dp[0][col] = dp[0][col - 1];\n        }\n    }\n\n    for (let row = 1; row <= s.length; row++) {\n        for (let col = 1; col <= p.length; col++) {\n            if (p[col - 1] === '?' || s[row - 1] === p[col - 1]) {\n                dp[row][col] = dp[row - 1][col - 1];\n            } else if (p[col - 1] === '*') {\n                dp[row][col] = dp[row - 1][col] || dp[row][col - 1];\n            }\n        }\n    }\n\n    return dp[s.length][p.length];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        $m = strlen($s);\n        $n = strlen($p);\n        \n        $dp = array_fill(0, $m + 1, array_fill(0, $n + 1, false));\n        $dp[0][0] = true;\n        \n        for ($i = 1; $i <= $n; $i++) {\n            if ($p[$i - 1] == '*') {\n                $dp[0][$i] = $dp[0][$i - 1];\n            }\n        }\n        \n        for ($i = 1; $i <= $m; $i++) {\n            for ($j = 1; $j <= $n; $j++) {\n                if ($p[$j - 1] == '*' && ($dp[$i-1][$j] || $dp[$i][$j-1])) {\n                    $dp[$i][$j] = true;\n                } elseif ($p[$j - 1] == '?' || $s[$i - 1] == $p[$j - 1]) {\n                    $dp[$i][$j] = $dp[$i-1][$j-1];\n                }\n            }\n        }\n        \n        return $dp[$m][$n];\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isMatch(s: String, p: String): Boolean {\n        val dp = Array(s.length + 1) { BooleanArray(p.length + 1) }\n        dp[0][0] = true\n        \n        for (j in 1..p.length) {\n            if (p[j - 1] == '*') {\n                dp[0][j] = dp[0][j - 1]\n            }\n        }\n        \n        for (i in 1..s.length) {\n            for (j in 1..p.length) {\n                if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1]\n                } else if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1]\n                }\n            }\n        }\n        \n        return dp[s.length][p.length]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isMatch(String s, String p) {\n    bool dp(s, p, i, j, memo) {\n      if (memo[i][j] != null) {\n        return memo[i][j];\n      }\n      bool ans = false;\n      if (j == p.length) {\n        ans = i == s.length;\n      } else {\n        if (i < s.length && (s[i] == p[j] || p[j] == '?')) {\n          ans = dp(s, p, i + 1, j + 1, memo);\n        } else if (p[j] == '*') {\n          ans = dp(s, p, i, j + 1, memo) || (i < s.length && dp(s, p, i + 1, j, memo));\n        }\n      }\n      memo[i][j] = ans;\n      return ans;\n    }\n\n    var memo = List.generate(s.length + 1, (_) => List<bool?>.filled(p.length + 1, null));\n\n    return dp(s, p, 0, 0, memo);\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isMatch(s string, p string) bool {\n    dp := make([][]bool, len(s)+1)\n    for i := range dp {\n        dp[i] = make([]bool, len(p)+1)\n    }\n    dp[0][0] = true\n\n    for j := 1; j <= len(p); j++ {\n        if p[j-1] == '*' {\n            dp[0][j] = dp[0][j-1]\n        }\n    }\n\n    for i := 1; i <= len(s); i++ {\n        for j := 1; j <= len(p); j++ {\n            if p[j-1] == '*' {\n                dp[i][j] = dp[i][j-1] || dp[i-1][j]\n            } else if p[j-1] == '?' || s[i-1] == p[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            }\n        }\n    }\n\n    return dp[len(s)][len(p)]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {String} p\n# @return {Boolean}\ndef is_match(s, p)\n    m, n = s.length, p.length\n    dp = Array.new(m + 1) { Array.new(n + 1, false) }\n    dp[0][0] = true\n\n    (1..n).each do |i|\n        dp[0][i] = dp[0][i - 1] if p[i - 1] == '*'\n    end\n\n    (1..m).each do |i|\n        (1..n).each do |j|\n            if p[j - 1] == '*'\n                dp[i][j] = dp[i][j - 1] || dp[i - 1][j]\n            elsif p[j - 1] == '?' || s[i - 1] == p[j - 1]\n                dp[i][j] = dp[i - 1][j - 1]\n            end\n        end\n    end\n\n    dp[m][n]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isMatch(s: String, p: String): Boolean = {\n        val dp = Array.ofDim[Boolean](s.length + 1, p.length + 1)\n        dp(0)(0) = true\n        \n        for (j <- 1 to p.length) {\n            if (p(j - 1) == '*') {\n                dp(0)(j) = dp(0)(j - 1)\n            }\n        }\n        \n        for (i <- 1 to s.length; j <- 1 to p.length) {\n            if (s(i - 1) == p(j - 1) || p(j - 1) == '?') {\n                dp(i)(j) = dp(i - 1)(j - 1)\n            } else if (p(j - 1) == '*') {\n                dp(i)(j) = dp(i - 1)(j) || dp(i)(j - 1)\n            }\n        }\n        \n        dp(s.length)(p.length)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        let s_chars: Vec<char> = s.chars().collect();\n        let p_chars: Vec<char> = p.chars().collect();\n        \n        let mut dp = vec![vec![false; p_chars.len() + 1]; s_chars.len() + 1];\n        dp[0][0] = true;\n        \n        for j in 1..=p_chars.len() {\n            if p_chars[j - 1] == '*' {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n        \n        for i in 1..=s_chars.len() {\n            for j in 1..=p_chars.len() {\n                if s_chars[i - 1] == p_chars[j - 1] || p_chars[j - 1] == '?' {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if p_chars[j - 1] == '*' {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }\n            }\n        }\n        \n        dp[s_chars.len()][p_chars.len()]\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a wildcard pattern matching for a given input string `s` and pattern `p`, with support for the wildcard characters '?' (which matches any single character) and '*' (which matches any sequence of characters, including the empty sequence).\n\n# Explanation\nWe will use dynamic programming to solve this pattern matching problem. Our approach includes:\n1. Initializing a 2D array `dp` where `dp[i][j]` represents whether the first `i` characters of string `s` match the first `j` characters of the pattern `p`.\n2. Setting `dp[0][0]` to `True` because an empty pattern matches an empty string.\n3. Pre-filling the first row of `dp` based on the pattern containing only `*`, because `*` can match an empty string.\n4. Filling the rest of the `dp` table by iterating over the string and pattern:\n   - If we encounter `*` in the pattern, we check if the preceding subproblem without `*` (`dp[i][j-1]`) or the preceding subproblem without the current character in `s` (`dp[i-1][j]`) is `True`.\n   - If we encounter `?`, or if the characters in string `s` and pattern `p` match, we carry forward the result from the previous subproblem `dp[i-1][j-1]`.\n\n# Pseudocode\n```\ndef isMatch(s, p):\n\n    # Initialize dp table with False values\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    \n    # Base case: Empty pattern matches empty string\n    dp[0][0] = True\n    \n    # Handle patterns that start with '*', as '*' can match empty string\n    for j in range(1, len(p) + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    # Main DP loop\n    for i in range(1, len(s) + 1):\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n            elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    # The result is stored in dp[len(s)][len(p)]\n    return dp[len(s)][len(p)]\n```\n\nThis approach ensures that we cover all possible cases for matching the entire input string with the given pattern, including handling the special wildcard characters `'?'` and `'*'`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-wildcard-matching"
    },
    {
        "name": "Jump Game Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-jump-game-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int n = nums.size();\n        int jumps = 0;\n        int curEnd = 0;\n        int curFarthest = 0;\n\n        for (int i = 0; i < n - 1; i++) {\n            curFarthest = max(curFarthest, i + nums[i]);\n            if (i == curEnd) {\n                jumps++;\n                curEnd = curFarthest;\n            }\n        }\n\n        return jumps;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int jump(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return 0;\n        }\n        \n        int jumps = 0, curEnd = 0, curFarthest = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            curFarthest = Math.max(curFarthest, i + nums[i]);\n            \n            if (i == curEnd) {\n                jumps++;\n                curEnd = curFarthest;\n            }\n        }\n        \n        return jumps;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def jump(self, nums):\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        jumps = 0\n        cur_end = 0\n        cur_farthest = 0\n        \n        for i in range(n-1):\n            cur_farthest = max(cur_farthest, i + nums[i])\n            if i == cur_end:\n                jumps += 1\n                cur_end = cur_farthest\n                if cur_end >= n-1:\n                    break\n        \n        return jumps\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int jump(int* nums, int numsSize) {\n    int jumps = 0;\n    \n    int currentJumpEnd = 0;\n    int farthestJump = 0;\n    \n    for (int i = 0; i < numsSize - 1; i++) {\n        farthestJump = (i + nums[i] > farthestJump) ? i + nums[i] : farthestJump;\n        \n        if (i == currentJumpEnd) {\n            jumps++;\n            currentJumpEnd = farthestJump;\n        }\n    }\n    \n    return jumps;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Jump(int[] nums) {\n        int n = nums.Length;\n        int jumps = 0;\n        int currentEnd = 0;\n        int farthest = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            farthest = Math.Max(farthest, i + nums[i]);\n            if (i == currentEnd) {\n                jumps++;\n                currentEnd = farthest;\n            }\n        }\n        \n        return jumps;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    if (nums.length === 1) {\n        return 0;\n    }\n    \n    let steps = 0;\n    let maxReach = nums[0];\n    let edge = nums[0];\n    \n    for (let i = 1; i < nums.length - 1; i++) {\n        maxReach = Math.max(maxReach, i + nums[i]);\n        \n        if (i === edge) {\n            steps++;\n            edge = maxReach;\n        }\n    }\n    \n    return steps + 1;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function jump(nums: number[]): number {\n    if (nums.length === 1) return 0;\n    \n    let jumps = 0;\n    let currentJumpEnd = 0;\n    let farthest = 0;\n    \n    for (let i = 0; i < nums.length - 1; i++) {\n        farthest = Math.max(farthest, i + nums[i]);\n        \n        if (i === currentJumpEnd) {\n            jumps++;\n            currentJumpEnd = farthest;\n        }\n    }\n    \n    return jumps;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function jump($nums) {\n        $n = count($nums);\n        $maxPosition = 0;\n        $end = 0;\n        $jumps = 0;\n        \n        for ($i = 0; $i < $n - 1; $i++) {\n            $maxPosition = max($maxPosition, $i + $nums[$i]);\n            if ($i == $end) {\n                $end = $maxPosition;\n                $jumps++;\n            }\n        }\n        \n        return $jumps;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func jump(_ nums: [Int]) -> Int {\n        if nums.count == 1 {\n            return 0\n        }\n        \n        var steps = 0\n        var maxReach = nums[0]\n        var nextReach = nums[0]\n        \n        for i in 1..<nums.count {\n            if i > maxReach {\n                steps += 1\n                maxReach = nextReach\n            }\n            \n            nextReach = max(nextReach, i + nums[i])\n        }\n        \n        return steps + 1\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun jump(nums: IntArray): Int {\n        if(nums.size <= 1) return 0\n        \n        var jumps = 0\n        var currentEnd = 0\n        var farthest = 0\n        \n        for(i in 0 until nums.size - 1) {\n            farthest = maxOf(farthest, i + nums[i])\n            \n            if(i == currentEnd) {\n                jumps++\n                currentEnd = farthest\n            }\n        }\n        \n        return jumps\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int jump(List<int> nums) {\n    if (nums.length <= 1) {\n      return 0;\n    }\n    \n    int jumps = 0;\n    int currentEnd = 0;\n    int farthest = 0;\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n      farthest = i + nums[i] > farthest ? i + nums[i] : farthest;\n      \n      if (i == currentEnd) {\n        jumps++;\n        currentEnd = farthest;\n      }\n    }\n    \n    return jumps;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func jump(nums []int) int {\n    if len(nums) <= 1 {\n        return 0\n    }\n\n    maxPos := nums[0]\n    maxSteps := nums[0]\n    jumps := 1\n\n    for i := 1; i < len(nums); i++ {\n        if maxSteps < i {\n            jumps++\n            maxSteps = maxPos\n        }\n        \n        if maxPos < i+nums[i] {\n            maxPos = i + nums[i]\n        }\n    }\n\n    return jumps\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef jump(nums)\n    n = nums.length \n    return 0 if n == 1\n\n    jumps = 0\n    curr_end = 0\n    curr_farthest = 0\n\n    (0..n-2).each do |i|\n        curr_farthest = [curr_farthest, i + nums[i]].max\n\n        if i == curr_end\n            jumps += 1\n            curr_end = curr_farthest\n\n            return jumps if curr_end >= n - 1\n        end\n    end\n\n    jumps\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def jump(nums: Array[Int]): Int = {\n        val n = nums.length\n        var jumps = 0\n        var currentJumpEnd = 0\n        var farthest = 0\n        \n        for (i <- 0 until n - 1) {\n            farthest = Math.max(farthest, i + nums(i))\n            if (i == currentJumpEnd) {\n                jumps += 1\n                currentJumpEnd = farthest\n            }\n        }\n        \n        jumps\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        let mut jumps = 0;\n        let mut current_end = 0;\n        let mut farthest = 0;\n        \n        for i in 0..nums.len() - 1 {\n            farthest = farthest.max(i + nums[i] as usize);\n            \n            if i == current_end {\n                jumps += 1;\n                current_end = farthest;\n            }\n        }\n        \n        jumps\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we use a greedy approach to find the minimum number of jumps needed to reach the last index of the array. \n\n## Explanation\n\n1. **Initialization**: We initialize three variables:\n   - `jumps` to keep track of the number of jumps made,\n   - `cur_end` to mark the end of the range that we can reach with the current number of jumps,\n   - `cur_farthest` to mark the farthest index that can be reached from the current or previous indices.\n\n2. **Iterate through the array**: Traverse the array and for each index, update `cur_farthest` to the farthest index we can reach from the current index. \n\n3. **Update jumps**: When we reach the end of the current range (`cur_end`), it implies we need another jump to continue. Therefore, increase the jump count and update `cur_end` to `cur_farthest`.\n\n4. **Break the loop**: If the end of the current range reaches or exceeds the last index (`n-1`), we can stop as we have found the minimum number of jumps required.\n\n## Pseudocode\n\n```\nfunction jump(nums):\n    n = length of nums\n    \n    if n == 1:\n        return 0\n    \n    jumps = 0\n    cur_end = 0\n    cur_farthest = 0\n    \n    for i from 0 to n-2:\n        cur_farthest = max(cur_farthest, i + nums[i])\n        \n        if i == cur_end:\n            jumps += 1\n            cur_end = cur_farthest\n            \n            if cur_end >= n-1:\n                break\n    \n    return jumps\n```\n\nIn this pseudocode:\n- The loop runs from the start of the array to the second last element since the last element does not require checks.\n- We keep updating `cur_farthest` to always get the farthest index we can reach in the current iteration.\n- When `i` equals `cur_end`, it means we have utilized all potential jumps, so we increment the jump count and update `cur_end` to the farthest index we could reach.\n- The loop breaks once `cur_end` reaches or exceeds `n-1` because we can reach the last index from here.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-jump-game-ii"
    },
    {
        "name": "Permutations",
        "site": "LeetCode",
        "href": "/solution/LeetCode-permutations",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> result;\n        vector<int> current;\n        vector<bool> used(nums.size(), false);\n        backtrack(nums, current, used, result);\n        return result;\n    }\n    \n    void backtrack(vector<int>& nums, vector<int>& current, vector<bool>& used, vector<vector<int>>& result) {\n        if (current.size() == nums.size()) {\n            result.push_back(current);\n            return;\n        }\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (used[i]) continue;\n            current.push_back(nums[i]);\n            used[i] = true;\n            backtrack(nums, current, used, result);\n            current.pop_back();\n            used[i] = false;\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> tempList = new ArrayList<>();\n        backtrack(result, tempList, nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {\n        if (tempList.size() == nums.length) {\n            result.add(new ArrayList<>(tempList));\n        } else {\n            for (int i = 0; i < nums.length; i++) {\n                if (tempList.contains(nums[i])) {\n                    continue;\n                }\n                tempList.add(nums[i]);\n                backtrack(result, tempList, nums);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(path, nums, result):\n            if not nums:\n                result.append(path)\n            for i in range(len(nums)):\n                backtrack(path + [nums[i]], nums[:i] + nums[i+1:], result)\n        \n        result = []\n        backtrack([], nums, result)\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, \n * assume caller calls free().\n */\nint factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\nvoid backtrack(int* nums, int numsSize, int** result, int* returnSize, int level) {\n    if (level == numsSize - 1) {\n        int* perm = (int*)malloc(numsSize * sizeof(int));\n        for (int i = 0; i < numsSize; i++) {\n            perm[i] = nums[i];\n        }\n        result[(*returnSize)++] = perm;\n        return;\n    }\n    for (int i = level; i < numsSize; i++) {\n        int temp = nums[i];\n        nums[i] = nums[level];\n        nums[level] = temp;\n        backtrack(nums, numsSize, result, returnSize, level + 1);\n        temp = nums[i];\n        nums[i] = nums[level];\n        nums[level] = temp;\n    }\n}\n\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0;\n    int totalPermutations = factorial(numsSize);\n    int** result = (int**)malloc(totalPermutations * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(totalPermutations * sizeof(int));\n    backtrack(nums, numsSize, result, returnSize, 0);\n    for (int i = 0; i < totalPermutations; i++) {\n        (*returnColumnSizes)[i] = numsSize;\n    }\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> Permute(int[] nums) {\n        IList<IList<int>> result = new List<IList<int>>();\n        List<int> tempList = new List<int>();\n        bool[] used = new bool[nums.Length];\n        \n        Backtrack(result, tempList, nums, used);\n        \n        return result;\n    }\n    \n    private void Backtrack(IList<IList<int>> result, List<int> tempList, int[] nums, bool[] used) {\n        if(tempList.Count == nums.Length) {\n            result.Add(new List<int>(tempList));\n        } else {\n            for(int i = 0; i < nums.Length; i++) {\n                if(used[i]) continue;\n                \n                tempList.Add(nums[i]);\n                used[i] = true;\n                Backtrack(result, tempList, nums, used);\n                tempList.RemoveAt(tempList.Count - 1);\n                used[i] = false;\n            }\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    const result = [];\n    \n    const backtrack = (current, remaining) => {\n        if (remaining.length === 0) {\n            result.push([...current]);\n            return;\n        }\n        \n        for (let i = 0; i < remaining.length; i++) {\n            current.push(remaining[i]);\n            backtrack(current, remaining.slice(0, i).concat(remaining.slice(i + 1)));\n            current.pop();\n        }\n    };\n    \n    backtrack([], nums);\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function permute(nums: number[]): number[][] {\n    const result: number[][] = [];\n    \n    const backtrack = (curr: number[], remaining: number[]) => {\n        if (remaining.length === 0) {\n            result.push(curr.slice());\n            return;\n        }\n        \n        for (let i = 0; i < remaining.length; i++) {\n            curr.push(remaining[i]);\n            const newRemaining = remaining.filter((_, index) => index !== i);\n            backtrack(curr, newRemaining);\n            curr.pop();\n        }\n    };\n    \n    backtrack([], nums);\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function permute($nums) {\n        $result = [];\n        $this->backtrack($nums, [], $result);\n        return $result;\n    }\n    \n    function backtrack($nums, $temp, &$result) {\n        if (count($temp) == count($nums)) {\n            $result[] = $temp;\n            return;\n        }\n        \n        for ($i = 0; $i < count($nums); $i++) {\n            if (in_array($nums[$i], $temp)) continue;\n            $temp[] = $nums[$i];\n            $this->backtrack($nums, $temp, $result);\n            array_pop($temp);\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func permute(_ nums: [Int]) -> [[Int]] {\n        var result = [[Int]]()\n        backtrack(nums, temp: [], result: &result)\n        return result\n    }\n    \n    func backtrack(_ nums: [Int], temp: [Int], result: inout [[Int]]) {\n        if temp.count == nums.count {\n            result.append(temp)\n            return\n        }\n        \n        for i in 0..<nums.count {\n            if temp.contains(nums[i]) {\n                continue\n            }\n            var newTemp = temp\n            newTemp.append(nums[i])\n            backtrack(nums, temp: newTemp, result: &result)\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun permute(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        \n        fun backtrack(tempList: MutableList<Int>) {\n            if (tempList.size == nums.size) {\n                result.add(tempList.toList())\n            } else {\n                for (num in nums) {\n                    if (!tempList.contains(num)) {\n                        tempList.add(num)\n                        backtrack(tempList)\n                        tempList.removeAt(tempList.size - 1)\n                    }\n                }\n            }\n        }\n        \n        backtrack(mutableListOf())\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> permute(List<int> nums) {\n    List<List<int>> result = [];\n    void backtrack(int n, List<int> nums) {\n      if (n == nums.length) {\n        result.add(List.of(nums));\n        return;\n      }\n      for (int i = n; i < nums.length; i++) {\n        List<int> temp = List.of(nums);\n        temp[n] = nums[i];\n        temp[i] = nums[n];\n        backtrack(n + 1, temp);\n      }\n    }\n    backtrack(0, nums);\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func permute(nums []int) [][]int {\n    var result [][]int\n    var backtrack func(start int)\n    \n    backtrack = func(start int) {\n        if start == len(nums) {\n            temp := make([]int, len(nums))\n            copy(temp, nums)\n            result = append(result, temp)\n            return\n        }\n        \n        for i := start; i < len(nums); i++ {\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n        }\n    }\n    \n    backtrack(0)\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef permute(nums)\n    nums.permutation.to_a\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def permute(nums: Array[Int]): List[List[Int]] = {\n        def backtrack(list: List[Int], tempList: List[Int], res: List[List[Int]]): List[List[Int]] = {\n            if (tempList.length == nums.length) {\n                tempList :: res\n            } else {\n                list.foldLeft(res) { (acc, num) =>\n                    if (!tempList.contains(num)) {\n                        val newTempList = num :: tempList\n                        val newRes = backtrack(list, newTempList, acc)\n                        newRes\n                    } else {\n                        acc\n                    }\n                }\n            }\n        }\n\n        nums.permutations.map(_.toList).toList\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut result = vec![];\n        Self::backtrack(&mut result, &mut vec![], &nums);\n        result\n    }\n\n    fn backtrack(result: &mut Vec<Vec<i32>>, current: &mut Vec<i32>, nums: &Vec<i32>) {\n        if current.len() == nums.len() {\n            result.push(current.clone());\n            return;\n        }\n\n        for num in nums {\n            if !current.contains(num) {\n                current.push(*num);\n                Self::backtrack(result, current, nums);\n                current.pop();\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (permute nums)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\n  \n  (define (permute-helper lst)\n    (cond\n      [(empty? lst) (list empty)]\n      [else\n       (for*/list ([x (in-list lst)]\n                   [rest (in-list (permute-helper (remove x lst)))])\n         (cons x rest))]))\n  \n  (permute-helper nums)\n  )"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec permute(Nums :: [integer()]) -> [[integer()]].\npermute(Nums) ->\n    permute([], Nums).\n\npermute(_, []) ->\n    [[]];\npermute(Prefix, Suffix) ->\n    [[X | Y] || X <- Suffix, Y <- permute([X | Prefix], lists:delete(X, Suffix))]."
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec permute(nums :: [integer]) :: [[integer]]\n  def permute(nums) do\n    case nums do\n      [] -> [[]]\n      _ -> for x <- nums, y <- permute(List.delete(nums, x)), do: [x | y]\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to generate all possible permutations of a given list of distinct integers. \n\n# Explanation\nPermutations involve rearranging the elements of a list into all possible orders. A common approach to generate permutations is backtracking, which involves using recursion to build possible solutions and then discarding them if they do not fulfill the criteria. \n\n**Steps**:\n1. **Define a helper function (backtrack)** to recursively generate permutations.\n2. **Base Case**: When the list of numbers (nums) is empty, add the current path (current permutation) to the result list.\n3. For each element in nums, append it to the current path, and recursively call the helper function with the remaining elements.\n4. **Result**: Collect all valid permutations in a list and return it.\n\n# Pseudocode\n```\nfunction permute(nums):\n    define function backtrack(path, remaining_nums, result):\n        if remaining_nums is empty:\n            add path to result\n        for each index i in range of length of remaining_nums:\n            call backtrack(path + [remaining_nums[i]], remaining_nums[:i] + remaining_nums[i+1:], result)\n    \n    result = []\n    call backtrack([], nums, result)\n    return result\n```\n\nThe pseudocode defines a primary function `permute` which initializes `result` and calls the recursive `backtrack` function. The `backtrack` function generates all permutations recursively and appends them to the `result` when the base case is met. The `result` is then returned containing all possible permutations of the input list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-permutations"
    },
    {
        "name": "N Queens Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-n-queens-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        vector<vector<string>> res;\n        vector<string> board(n, string(n, '.'));\n        solveNQueens(res, board, 0);\n        return res.size();\n    }\n    \n    void solveNQueens(vector<vector<string>>& res, vector<string>& board, int row) {\n        if (row == board.size()) {\n            res.push_back(board);\n            return;\n        }\n        \n        for (int col = 0; col < board.size(); ++col) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                solveNQueens(res, board, row + 1);\n                board[row][col] = '.';\n            }\n        }\n    }\n    \n    bool isValid(vector<string>& board, int row, int col) {\n        for (int i = 0; i < row; ++i) {\n            if (board[i][col] == 'Q') return false;\n        }\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n            if (board[i][j] == 'Q') return false;\n        }\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.size(); --i, ++j) {\n            if (board[i][j] == 'Q') return false;\n        }\n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int totalNQueens(int n) {\n        List<List<String>> res = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (char[] row : board) {\n            Arrays.fill(row, '.');\n        }\n        solveNQueens(board, 0, res);\n        return res.size();\n    }\n    \n    private void solveNQueens(char[][] board, int col, List<List<String>> res) {\n        if (col == board.length) {\n            res.add(construct(board));\n            return;\n        }\n        for (int i = 0; i < board.length; i++) {\n            if (isValid(board, i, col)) {\n                board[i][col] = 'Q';\n                solveNQueens(board, col + 1, res);\n                board[i][col] = '.';\n            }\n        }\n    }\n    \n    private boolean isValid(char[][] board, int row, int col) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < col; j++) {\n                if (board[i][j] == 'Q' && (row == i || Math.abs(row - i) == Math.abs(col - j))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private List<String> construct(char[][] board) {\n        List<String> list = new ArrayList<>();\n        for (char[] row : board) {\n            list.add(new String(row));\n        }\n        return list;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def totalNQueens(self, n):\n        def backtrack(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                output.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    backtrack(queens + [q], xy_dif + [p-q], xy_sum + [p+q])\n        \n        output = []\n        backtrack([], [], [])\n        return len(output)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int totalNQueens(int n) {\n    int count = 0;\n    \n    backtrack(&count, n, 0, 0, 0, 0);\n    \n    return count;\n}\n\nvoid backtrack(int* count, int n, int row, int cols, int diags1, int diags2) {\n    if (row == n) {\n        (*count)++;\n        return;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        int col = 1 << i;\n        int diag1 = 1 << (row + i);\n        int diag2 = 1 << (row - i + n - 1);\n        \n        if ((cols & col) || (diags1 & diag1) || (diags2 & diag2)) {\n            continue;\n        }\n        \n        backtrack(count, n, row + 1, cols | col, diags1 | diag1, diags2 | diag2);\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int TotalNQueens(int n) {\n        if (n <= 0) return 0;\n\n        int count = 0;\n        int[] columns = new int[n];\n        SolveNQueens(n, 0, columns, ref count);\n\n        return count;\n    }\n\n    private void SolveNQueens(int n, int row, int[] columns, ref int count)\n    {\n        if (row == n)\n        {\n            count++;\n            return;\n        }\n\n        for (int col = 0; col < n; col++)\n        {\n            columns[row] = col;\n            if (IsValid(columns, row))\n            {\n                SolveNQueens(n, row + 1, columns, ref count);\n            }\n        }\n    }\n\n    private bool IsValid(int[] columns, int row)\n    {\n        for (int i = 0; i < row; i++)\n        {\n            if (columns[i] == columns[row] || Math.Abs(columns[i] - columns[row]) == row - i)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    let count = 0;\n\n    const isSafe = (board, row, col) => {\n        for (let i = 0; i < row; i++) {\n            if (board[i] === col || board[i] - col === i - row || board[i] - col === row - i) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    const solve = (board, row) => {\n        if (row === n) {\n            count++;\n            return;\n        }\n\n        for (let col = 0; col < n; col++) {\n            if (isSafe(board, row, col)) {\n                board[row] = col;\n                solve(board, row + 1);\n                board[row] = undefined;\n            }\n        }\n    };\n\n    solve([], 0);\n\n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function totalNQueens(n: number): number {\n    let count = 0;\n  \n    const backtracking = (row: number, cols: number[], diag1: number[], diag2: number[]) => {\n        if (row === n) {\n            count++;\n            return;\n        }\n        \n        for (let col = 0; col < n; col++) {\n            const d1 = row + col;\n            const d2 = row - col + n - 1;\n            \n            if (!cols[col] && !diag1[d1] && !diag2[d2]) {\n                cols[col] = 1;\n                diag1[d1] = 1;\n                diag2[d2] = 1;\n                \n                backtracking(row + 1, cols, diag1, diag2);\n                \n                cols[col] = 0;\n                diag1[d1] = 0;\n                diag2[d2] = 0;\n            }\n        }\n    };\n  \n    backtracking(0, Array(n).fill(0), Array(2 * n - 1).fill(0), Array(2 * n - 1).fill(0));\n    \n    return count;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create an algorithm that counts the number of possible ways to place n queens on an n x n chessboard such that no two queens can attack each other.\n\n# Explanation\n1. **Backtracking Approach**: We'll use a backtracking algorithm to explore all possible placements for the queens.\n2. **State Tracking**:\n   - `queens`: Keeps track of the columns where the queens are placed.\n   - `xy_dif`: Keeps track of the diagonals (difference of row and column indices) that would be attacked by queens.\n   - `xy_sum`: Keeps track of the anti-diagonals (sum of row and column indices) that would be attacked by queens.\n3. **Recursive Function**:\n   - We'll use a recursive function `backtrack` to try placing a queen in each column of the current row one by one and check if it's safe.\n   - If it is safe, we move to the next row and continue the process.\n   - If a valid configuration is found (all rows have been successfully processed), we store it.\n4. **Counting Solutions**: At the end of our backtracking process, the number of valid solutions will be the length of the stored solutions.\n\n# Pseudocode\n```\nfunction totalNQueens(n):\n    def backtrack(queens, xy_dif, xy_sum):\n        row = length(queens)\n        if row == n:\n            add queens to output\n            return\n        for col from 0 to n-1:\n            if col not in queens and (row - col) not in xy_dif and (row + col) not in xy_sum:\n                backtrack(queens + [col], xy_dif + [row - col], xy_sum + [row + col])\n    \n    output = []\n    backtrack([], [], [])\n    return length(output)\n```\n\nIn this pseudocode, the `backtrack` function attempts to place queens in each column of the current row and recursively continues this process for each valid placement. The `output` list collects all the valid queen placements, and the final result is the count of these valid configurations.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-n-queens-ii"
    },
    {
        "name": "Rotate Image",
        "site": "LeetCode",
        "href": "/solution/LeetCode-rotate-image",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        \n        // Transpose the matrix\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        \n        // Reverse each row\n        for(int i=0; i<n; i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i < n / 2; i++) {\n            for (int j = i; j < n - i - 1; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - 1 - j][i];\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\n                matrix[j][n - 1 - i] = temp;\n            }\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def rotate(self, matrix):\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                tmp = matrix[i][j]\n                matrix[i][j] = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n                matrix[j][n - 1 - i] = tmp"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void rotate(int** matrix, int matrixSize, int* matrixColSize) {\n    int i, j, temp;\n    \n    // Transpose the matrix\n    for(i = 0; i < matrixSize; i++) {\n        for(j = i; j < matrixColSize[i]; j++) {\n            temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n    \n    // Reverse each row\n    for(i = 0; i < matrixSize; i++) {\n        for(j = 0; j < matrixColSize[i] / 2; j++) {\n            temp = matrix[i][j];\n            matrix[i][j] = matrix[i][matrixColSize[i] - 1 - j];\n            matrix[i][matrixColSize[i] - 1 - j] = temp;\n        }\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void Rotate(int[][] matrix) {\n        int n = matrix.Length;\n        \n        // Transpose the matrix\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        \n        // Reverse each row\n        for(int i=0; i<n; i++){\n            Array.Reverse(matrix[i]);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var rotate = function(matrix) {\n    const n = matrix.length;\n\n    // Transpose the matrix\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n\n    // Reverse each row\n    for (let i = 0; i < n; i++) {\n        matrix[i].reverse();\n    }\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify matrix in-place instead.\n */\nfunction rotate(matrix: number[][]): void {\n    const n = matrix.length;\n    \n    // Transpose the matrix\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n    \n    // Reverse each row\n    for (let i = 0; i < n; i++) {\n        matrix[i].reverse();\n    }\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $matrix\n     * @return NULL\n     */\n    function rotate(&$matrix) {\n        $n = count($matrix);\n        // Transpose the matrix\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = $i; $j < $n; $j++) {\n                $temp = $matrix[$i][$j];\n                $matrix[$i][$j] = $matrix[$j][$i];\n                $matrix[$j][$i] = $temp;\n            }\n        }\n        \n        // Reverse each row\n        for ($i = 0; $i < $n; $i++) {\n            $start = 0;\n            $end = $n - 1;\n            while ($start < $end) {\n                $temp = $matrix[$i][$start];\n                $matrix[$i][$start] = $matrix[$i][$end];\n                $matrix[$i][$end] = $temp;\n                $start++;\n                $end--;\n            }\n        }\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func rotate(_ matrix: inout [[Int]]) {\n        let n = matrix.count\n        \n        // Transpose the matrix\n        for i in 0..<n {\n            for j in i..<n {\n                let temp = matrix[i][j]\n                matrix[i][j] = matrix[j][i]\n                matrix[j][i] = temp\n            }\n        }\n        \n        // Reverse each row\n        for i in 0..<n {\n            matrix[i].reverse()\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun rotate(matrix: Array<IntArray>): Unit {\n        val n = matrix.size\n        for (i in 0 until n / 2) {\n            for (j in i until n - i - 1) {\n                val temp = matrix[i][j]\n                matrix[i][j] = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n                matrix[j][n - 1 - i] = temp\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void rotate(List<List<int>> matrix) {\n      int n = matrix.length;\n      \n      for (int i = 0; i < (n + 1) ~/ 2; i++) {\n        for (int j = 0; j < n ~/ 2; j++) {\n          int temp = matrix[n - 1 - j][i];\n          matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\n          matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 - i];\n          matrix[j][n - 1 - i] = matrix[i][j];\n          matrix[i][j] = temp;\n        }\n      }\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func rotate(matrix [][]int) {\n    n := len(matrix)\n\n    // Transpose the matrix\n    for i := 0; i < n; i++ {\n        for j := i; j < n; j++ {\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        }\n    }\n\n    // Reverse each row\n    for i := 0; i < n; i++ {\n        left := 0\n        right := n - 1\n        for left < right {\n            matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]\n            left++\n            right--\n        }\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @return {Void} Do not return anything, modify matrix in-place \n# instead.\ndef rotate(matrix)\n    n = matrix.length\n    (0...n).each do |i|\n        (i...n).each do |j|\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        end\n    end\n    matrix.each { |row| row.reverse! }\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def rotate(matrix: Array[Array[Int]]): Unit = {\n        val n = matrix.length\n        for (i <- 0 until n / 2) {\n            for (j <- i until n - i - 1) {\n                val temp = matrix(i)(j)\n                matrix(i)(j) = matrix(n - j - 1)(i)\n                matrix(n - j - 1)(i) = matrix(n - i - 1)(n - j - 1)\n                matrix(n - i - 1)(n - j - 1) = matrix(j)(n - i - 1)\n                matrix(j)(n - i - 1) = temp\n            }\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        let n = matrix.len();\n        \n        for i in 0..n/2 {\n            for j in i..n-i-1 {\n                let temp = matrix[i][j];\n                matrix[i][j] = matrix[n-1-j][i];\n                matrix[n-1-j][i] = matrix[n-1-i][n-1-j];\n                matrix[n-1-i][n-1-j] = matrix[j][n-1-i];\n                matrix[j][n-1-i] = temp;\n            }\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to rotate a given \\( n \\times n \\) 2D matrix representing an image by 90 degrees clockwise, modifying the input 2D matrix directly.\n\n# Explanation\n1. **Understanding the Rotation**: Rotating a matrix 90 degrees clockwise means the element at position \\((i, j)\\) will move to position \\((j, n-1-i)\\).\n2. **In-place Rotation**: We need to make these changes in-place, without using an additional matrix for storage.\n\nTo achieve this, we'll swap the elements in four corresponding positions per cycle:\n- Top-left: \\((i, j)\\)\n- Bottom-left: \\((n-1-j, i)\\)\n- Bottom-right: \\((n-1-i, n-1-j)\\)\n- Top-right: \\((j, n-1-i)\\)\n\nWe would perform this rotation layer by layer, from outermost to innermost. \n\n# Pseudocode\n1. **Start Loop**: Loop through each layer of the matrix, starting from the outermost layer to the midpoint.\n2. **Nested Loop**: For each element in the current layer, move elements from the top to their respective new positions in a clockwise direction.\n3. **Temporarily Store**: Temporarily store the element that is being displaced to ensure no data is lost during the swapping process.\n4. **Rotation Logic**: Perform the swaps for four elements to rotate 90 degrees clockwise.\n\nBelow is the pseudocode implementation:\n\n```\n# Pseudocode\n1. Define the function `rotate(matrix)`:\n2.   Determine the size of the matrix `n`\n3.   For each layer `i` from 0 to n//2 (exclusive):\n4.     For each element `j` from i to n - i - 1:\n5.       Temporarily store the value of matrix[i][j] in `tmp`\n6.       Set matrix[i][j] to matrix[n - 1 - j][i]\n7.       Set matrix[n - 1 - j][i] to matrix[n - 1 - i][n - 1 - j]\n8.       Set matrix[n - 1 - i][n - 1 - j] to matrix[j][n - 1 - i]\n9.       Set matrix[j][n - 1 - i] to `tmp`\n10. End function\n```\n\nThis pseudocode walks through the process of rotating the image efficiently by performing the required swaps in place.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-rotate-image"
    },
    {
        "name": "Group Anagrams",
        "site": "LeetCode",
        "href": "/solution/LeetCode-group-anagrams",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> mp;\n        for (string s : strs) {\n            string sortedStr = s;\n            sort(sortedStr.begin(), sortedStr.end());\n            mp[sortedStr].push_back(s);\n        }\n        \n        vector<vector<string>> result;\n        for (auto it = mp.begin(); it != mp.end(); it++) {\n            result.push_back(it->second);\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        for (String str : strs) {\n            char[] charArray = str.toCharArray();\n            Arrays.sort(charArray);\n            String sortedStr = String.valueOf(charArray);\n            List<String> anagramList = map.getOrDefault(sortedStr, new ArrayList<>());\n            anagramList.add(str);\n            map.put(sortedStr, anagramList);\n        }\n        return new ArrayList<>(map.values());\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = collections.defaultdict(list)\n        for word in strs:\n            sorted_word = ''.join(sorted(word))\n            anagrams[sorted_word].append(word)\n        return list(anagrams.values())"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "#define MAX_CHAR 26\n\n// Function to sort a string\nvoid sortString(char* str) {\n    int count[MAX_CHAR] = {0};\n\n    // Count frequency of characters\n    for (int i = 0; i < strlen(str); i++) {\n        count[str[i] - 'a']++;\n    }\n\n    // Update the string with sorted characters\n    int index = 0;\n    for (int i = 0; i < MAX_CHAR; i++) {\n        while (count[i] > 0) {\n            str[index++] = i + 'a';\n            count[i]--;\n        }\n    }\n}\n\nchar*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0;\n    *returnColumnSizes = (int*)malloc(strsSize * sizeof(int));\n    char*** result = (char***)malloc(strsSize * sizeof(char**));\n\n    // Create a hash map to store groups of anagrams\n    // Key -> sorted string, Value -> list of anagrams\n    struct hash_table {\n        char* key;\n        int index;\n    };\n\n    struct hash_table* hashMap = (struct hash_table*)malloc(strsSize * sizeof(struct hash_table));\n\n    for (int i = 0; i < strsSize; i++) {\n        // Sort current string\n        char* sortedStr = strdup(strs[i]);\n        sortString(sortedStr);\n\n        // Check if the sorted string is already in the hash map\n        int found = 0;\n        for (int j = 0; j < *returnSize; j++) {\n            if (strcmp(hashMap[j].key, sortedStr) == 0) {\n                found = 1;\n                int idx = hashMap[j].index;\n                result[idx] = (char**)realloc(result[idx], ((*returnColumnSizes)[idx] + 1) * sizeof(char*));\n                result[idx][(*returnColumnSizes)[idx]] = strdup(strs[i]);\n                (*returnColumnSizes)[idx]++;\n                break;\n            }\n        }\n\n        // If sorted string not found, add it to hashmap\n        if (!found) {\n            int idx = *returnSize;\n            hashMap[idx].key = sortedStr;\n            hashMap[idx].index = idx;\n            result[idx] = (char**)malloc(sizeof(char*));\n            result[idx][0] = strdup(strs[i]);\n            (*returnColumnSizes)[idx] = 1;\n            (*returnSize)++;\n        }\n    }\n\n    // Free memory\n    free(hashMap);\n\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\n        \n        foreach(var str in strs){\n            char[] arr = str.ToCharArray();\n            Array.Sort(arr);\n            string key = new string(arr);\n            \n            if(!map.ContainsKey(key)){\n                map[key] = new List<string>();\n            }\n            \n            map[key].Add(str);\n        }\n        \n        IList<IList<string>> result = new List<IList<string>>();\n        \n        foreach(var list in map.Values){\n            result.Add(list);\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    const map = {};\n    for (let str of strs) {\n        const key = str.split('').sort().join('');\n        if (!map[key]) {\n            map[key] = [str];\n        } else {\n            map[key].push(str);\n        }\n    }\n    return Object.values(map);\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function groupAnagrams(strs: string[]): string[][] {\n    const map: Map<string, string[]> = new Map();\n    \n    for (const str of strs) {\n        const sortedStr = str.split(\"\").sort().join(\"\");\n        if (map.has(sortedStr)) {\n            map.get(sortedStr)?.push(str);\n        } else {\n            map.set(sortedStr, [str]);\n        }\n    }\n    \n    return Array.from(map.values());\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[] $strs\n     * @return String[][]\n     */\n    function groupAnagrams($strs) {\n        $map = [];\n        foreach ($strs as $str) {\n            $key = str_split($str);\n            sort($key);\n            $key = implode('', $key);\n            $map[$key][] = $str;\n        }\n        \n        return array_values($map);\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\n        var anagramDict: [String: [String]] = [:]\n        \n        for str in strs {\n            let sortedStr = String(str.sorted())\n            \n            if var anagrams = anagramDict[sortedStr] {\n                anagrams.append(str)\n                anagramDict[sortedStr] = anagrams\n            } else {\n                anagramDict[sortedStr] = [str]\n            }\n        }\n        \n        return Array(anagramDict.values)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "import java.util.*\n\nclass Solution {\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\n        val map = HashMap<String, MutableList<String>>()\n        for (str in strs) {\n            val charArray = str.toCharArray()\n            charArray.sort()\n            val key = String(charArray)\n            \n            if (!map.containsKey(key)) {\n                map[key] = mutableListOf()\n            }\n            map[key]?.add(str)\n        }\n        \n        return ArrayList(map.values)\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<String>> groupAnagrams(List<String> strs) {\n    Map<String, List<String>> map = {};\n\n    for (String str in strs) {\n      List<int> count = List.filled(26, 0);\n      for (int i = 0; i < str.length; i++) {\n        count[str.codeUnitAt(i) - 'a'.codeUnitAt(0)]++;\n      }\n      String key = count.join('#');\n      map[key] = map[key] ?? [];\n      map[key]!.add(str);\n    }\n\n    return map.values.toList();\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func groupAnagrams(strs []string) [][]string {\n    groups := make(map[string][]string)\n    \n    for _, str := range strs {\n        key := sortString(str)\n        groups[key] = append(groups[key], str)\n    }\n    \n    result := make([][]string, 0, len(groups))\n    for _, group := range groups {\n        result = append(result, group)\n    }\n    \n    return result\n}\n\nfunc sortString(s string) string {\n    r := []rune(s)\n    sort.Slice(r, func(i, j int) bool {\n        return r[i] < r[j]\n    })\n    return string(r)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String[]} strs\n# @return {String[][]}\ndef group_anagrams(strs)\n    hash = {}\n    strs.each do |str|\n        key = str.chars.sort.join\n        if hash[key]\n            hash[key] << str\n        else\n            hash[key] = [str]\n        end\n    end\n    hash.values\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n    def groupAnagrams(strs: Array[String]): List[List[String]] = {\n        val map = scala.collection.mutable.Map[String, ListBuffer[String]]()\n        \n        for (str <- strs) {\n            val key = str.sorted\n            if (!map.contains(key)) {\n                map(key) = ListBuffer[String]()\n            }\n            map(key) += str\n        }\n        \n        map.values.toList.map(_.toList)\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        use std::collections::HashMap;\n        \n        let mut map: HashMap<Vec<u8>, Vec<String>> = HashMap::new();\n        \n        for word in strs {\n            let mut sorted_word = word.as_bytes().to_vec();\n            sorted_word.sort();\n            \n            map.entry(sorted_word).or_insert(Vec::new()).push(word);\n        }\n        \n        map.into_iter().map(|(_, v)| v).collect()\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec group_anagrams(strs :: [String.t]) :: [[String.t]]\n  def group_anagrams(strs) do\n    Enum.group_by(strs, &sort_chars/1)\n    |> Map.values()\n  end\n\n  defp sort_chars(str) do\n    str\n    |> String.split(\"\", trim: true)\n    |> Enum.sort()\n    |> Enum.join(\"\")\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to group anagrams in a given array of strings. An anagram is a word that can be rearranged to form another word using exactly the same letters.\n\nThe solution involves the following steps:\n\n# Explanation\n1. **Initialization**: Create a dictionary to store lists of anagrams. We use the sorted version of each word as the key.\n2. **Sorting Words**: For each word in the list, sort the characters in the word and use the sorted version as the key in the dictionary.\n3. **Group Anagrams**: Append the original word to the list corresponding to its sorted version key.\n4. **Return Result**: The values of the dictionary will be the grouped anagrams. Return these values as a list of lists.\n\n# Pseudocode\n1. Initialize an empty dictionary, `anagrams`, to hold lists of anagrams.\n2. For each word in the input list `strs`:\n    - Sort the characters in the word to create a `sorted_word`.\n    - Use `sorted_word` as the key in the `anagrams` dictionary.\n    - Append the original word to the list in the dictionary for this `sorted_word` key.\n3. Convert the values of the dictionary to a list and return it.\n\nHere is the pseudocode for the solution:\n\n```pseudocode\nfunction groupAnagrams(strs):\n    initialize an empty dictionary called anagrams\n\n    for each word in strs do:\n        sorted_word = sort the characters in word\n        if sorted_word not in anagrams:\n            anagrams[sorted_word] = an empty list\n        append word to the list anagrams[sorted_word]\n\n    return the list of values from the anagrams dictionary\n```\n\nThis methodology efficiently groups anagrams together using the sorted version of each word as a unique key in the dictionary. The solution is both clear and efficient, ensuring all possible anagrams are grouped correctly.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-group-anagrams"
    },
    {
        "name": "Powx N",
        "site": "LeetCode",
        "href": "/solution/LeetCode-powx-n",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) {\n            return 1.0;\n        }\n        \n        double temp = myPow(x, n/2);\n        \n        if (n % 2 == 0) {\n            return temp * temp;\n        } else {\n            if (n > 0) {\n                return x * temp * temp;\n            } else {\n                return (temp * temp) / x;\n            }\n        }\n    }\n};"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1\n        if n < 0:\n            x = 1 / x\n            n = -n\n        result = 1\n        while n > 0:\n            if n % 2 == 1:\n                result *= x\n            x *= x\n            n //= 2\n        return result\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "double myPow(double x, int n) {\n    if(n == 0) {\n        return 1;\n    }\n    \n    double result = 1.0;\n    \n    long N = n;\n    if(N < 0) {\n        x = 1 / x;\n        N = -N;\n    }\n    \n    while(N > 0) {\n        if(N % 2 == 1) {\n            result *= x;\n        }\n        x *= x;\n        N /= 2;\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public double MyPow(double x, int n) {\n        if (n == 0) {\n            return 1;\n        }\n        if (n < 0) {\n            if (n == int.MinValue) {\n                return 1 / (x * MyPow(x, int.MaxValue));\n            }\n            x = 1 / x;\n            n = -n;\n        }\n        double result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                result *= x;\n            }\n            x *= x;\n            n /= 2;\n        }\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function(x, n) {\n    return Math.pow(x, n);\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function myPow(x: number, n: number): number {\n    if (n === 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    let result = 1;\n    while (n > 0) {\n        if (n % 2 === 1) {\n            result *= x;\n        }\n        x *= x;\n        n = Math.floor(n / 2);\n    }\n    return result;\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func myPow(_ x: Double, _ n: Int) -> Double {\n        if n == 0 {\n            return 1.0\n        }\n        \n        var result = 1.0\n        var pow = abs(n)\n        \n        var base = x\n        \n        while pow > 0 {\n            if pow % 2 == 1 {\n                result *= base\n            }\n            base *= base\n            pow /= 2\n        }\n        \n        return n < 0 ? 1 / result : result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun myPow(x: Double, n: Int): Double {\n        var result = 1.0\n        var number = x\n        var power = n.toLong()\n        \n        if (power < 0) {\n            number = 1 / number\n            power = -power\n        }\n        \n        while (power > 0) {\n            if (power % 2 == 1L) {\n                result *= number\n            }\n            number *= number\n            power /= 2\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  double myPow(double x, int n) {\n    if (n == 0) {\n      return 1;\n    }\n\n    if (n < 0) {\n      x = 1 / x;\n      n = -n;\n    }\n\n    double result = 1;\n    while (n > 0) {\n      if (n % 2 == 1) {\n        result *= x;\n      }\n      x *= x;\n      n ~/= 2;\n    }\n\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func myPow(x float64, n int) float64 {\n    if n < 0 {\n        return 1 / myPowHelper(x, -n)\n    }\n    return myPowHelper(x, n)\n}\n\nfunc myPowHelper(x float64, n int) float64 {\n    if n == 0 {\n        return 1\n    }\n    \n    temp := myPowHelper(x, n/2)\n    \n    if n%2 == 0 {\n        return temp * temp\n    }\n    \n    return x * temp * temp\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Float} x\n# @param {Integer} n\n# @return {Float}\ndef my_pow(x, n)\n    if n < 0\n        return 1.0 / my_pow(x, -n)\n    elsif n == 0\n        return 1.0\n    elsif n % 2 == 0\n        return my_pow(x * x, n / 2)\n    else\n        return x * my_pow(x, n - 1)\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def myPow(x: Double, n: Int): Double = {\n        if(n == 0) return 1\n        var result = 1.0\n        var tempX = x\n        var tempN = n.toLong\n        if(tempN < 0){\n            tempX = 1 / tempX\n            tempN = -tempN\n        }\n        var powN = tempN\n        while(powN > 0){\n            if(powN % 2 == 1){\n                result *= tempX\n            }\n            tempX *= tempX\n            powN /= 2\n        }\n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn my_pow(x: f64, n: i32) -> f64 {\n        if n == 0 {\n            return 1.0;\n        }\n        let mut result = 1.0;\n        let mut power = n as i64;\n        \n        if power < 0 {\n            power = -power;\n            let mut x = 1.0 / x;\n            let mut base = x;\n            while power > 0 {\n                if power % 2 == 1 {\n                    result *= base;\n                }\n                base *= base;\n                power /= 2;\n            }\n        } else {\n            let mut base = x;\n            while power > 0 {\n                if power % 2 == 1 {\n                    result *= base;\n                }\n                base *= base;\n                power /= 2;\n            }\n        }\n        \n        result\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec my_pow(x :: float, n :: integer) :: float\n  def my_pow(x, n) do\n    Float.pow(x, n)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a function that calculates `x` raised to the power `n` (i.e., \\(x^n\\)). We'll use an iterative approach with some optimizations to achieve an efficient solution.\n\n## # Explanation\n1. **Base Cases**:\n   - If `n` is 0, then \\(x^0 = 1\\) for any non-zero `x`.\n   - If `n` is negative, we can convert the problem to a positive exponent by taking the reciprocal of `x` and making `n` positive.\n\n2. **Iterative Approach**:\n   - We initialize a variable `result` to 1.\n   - We iterate until `n` becomes 0:\n     - If `n` is odd, we multiply `result` by `x`.\n     - We square `x` for the next step.\n     - We perform integer division of `n` by 2.\n   - This approach leverages the properties of exponents to reduce the number of multiplications needed.\n\n## # Pseudocode\n```\nfunction myPow(x, n):\n    if n == 0:\n        return 1\n    \n    if n < 0:\n        x = 1 / x\n        n = -n\n    \n    result = 1\n    \n    while n > 0:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n = n // 2\n    \n    return result\n```\n\nThis pseudocode outlines how to efficiently calculate the power of a number using an iterative method, managing both positive and negative exponents, and optimizing the number of operations through exponentiation by squaring.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-powx-n"
    },
    {
        "name": "N Queens",
        "site": "LeetCode",
        "href": "/solution/LeetCode-n-queens",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> res;\n        vector<string> board(n, string(n, '.'));\n        solve(res, board, 0);\n        return res;\n    }\n    \n    void solve(vector<vector<string>>& res, vector<string>& board, int row) {\n        int n = board.size();\n        if (row == n) {\n            res.push_back(board);\n            return;\n        }\n        \n        for (int col = 0; col < n; col++) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                solve(res, board, row + 1);\n                board[row][col] = '.';\n            }\n        }\n    }\n    \n    bool isValid(vector<string>& board, int row, int col) {\n        int n = board.size();\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        \n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> res = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], '.');\n        }\n        backtrack(n, 0, board, res);\n        return res;\n    }\n    \n    private void backtrack(int n, int row, char[][] board, List<List<String>> res) {\n        if (row == n) {\n            List<String> tempList = new ArrayList<>();\n            for (char[] rowArray : board) {\n                tempList.add(String.valueOf(rowArray));\n            }\n            res.add(new ArrayList<>(tempList));\n            return;\n        }\n        \n        for (int col = 0; col < n; col++) {\n            if (isValid(board, row, col, n)) {\n                board[row][col] = 'Q';\n                backtrack(n, row + 1, board, res);\n                board[row][col] = '.';\n            }\n        }\n    }\n    \n    private boolean isValid(char[][] board, int row, int col, int n) {\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        \n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def solveNQueens(self, n):\n        def solve(row, cols, diag1, diag2):\n            if row == n:\n                result.append([''.join(board[i]) for i in range(n)])\n                return\n            for col in range(n):\n                if col in cols or row + col in diag1 or row - col in diag2:\n                    continue\n                board[row][col] = \"Q\"\n                cols.add(col)\n                diag1.add(row + col)\n                diag2.add(row - col)\n                solve(row + 1, cols, diag1, diag2)\n                board[row][col] = \".\"\n                cols.remove(col)\n                diag1.remove(row + col)\n                diag2.remove(row - col)\n        \n        result = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        solve(0, set(), set(), set())\n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<string>> SolveNQueens(int n) {\n        IList<IList<string>> result = new List<IList<string>>();\n        char[][] board = new char[n][];\n        for (int i = 0; i < n; i++) {\n            board[i] = new char[n];\n            for (int j = 0; j < n; j++) {\n                board[i][j] = '.';\n            }\n        }\n        SolveNQueensHelper(result, board, 0);\n        return result;\n    }\n\n    private void SolveNQueensHelper(IList<IList<string>> result, char[][] board, int row) {\n        if (row == board.Length) {\n            IList<string> solution = new List<string>();\n            foreach (var r in board) {\n                solution.Add(new string(r));\n            }\n            result.Add(solution);\n            return;\n        }\n\n        for (int col = 0; col < board.Length; col++) {\n            if (IsSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                SolveNQueensHelper(result, board, row + 1);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    private bool IsSafe(char[][] board, int row, int col) {\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.Length; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    const result = [];\n    const board = Array.from({ length: n }, () => Array(n).fill('.'));\n    \n    const isValid = (row, col) => {\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') return false;\n        }\n        \n        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] === 'Q') return false;\n        }\n        \n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 'Q') return false;\n        }\n        \n        return true;\n    };\n    \n    const backtrack = (row) => {\n        if (row === n) {\n            result.push(board.map(row => row.join('')));\n        } else {\n            for (let col = 0; col < n; col++) {\n                if (isValid(row, col)) {\n                    board[row][col] = 'Q';\n                    backtrack(row + 1);\n                    board[row][col] = '.';\n                }\n            }\n        }\n    };\n    \n    backtrack(0);\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function solveNQueens(n: number): string[][] {\n    const result: string[][] = [];\n    const board: string[][] = Array.from({ length: n }, () => Array(n).fill('.'));\n\n    const isValid = (row: number, col: number): boolean => {\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') return false;\n            const diagonal1 = col - (row - i);\n            if (diagonal1 >= 0 && board[i][diagonal1] === 'Q') return false;\n            const diagonal2 = col + (row - i);\n            if (diagonal2 < n && board[i][diagonal2] === 'Q') return false;\n        }\n        return true;\n    };\n\n    const backtrack = (row: number): void => {\n        if (row === n) {\n            result.push(board.map(row => row.join('')));\n            return;\n        }\n\n        for (let col = 0; col < n; col++) {\n            if (isValid(row, col)) {\n                board[row][col] = 'Q';\n                backtrack(row + 1);\n                board[row][col] = '.';\n            }\n        }\n    };\n\n    backtrack(0);\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return String[][]\n     */\n    function solveNQueens($n) {\n        $result = [];\n        $board = array_fill(0, $n, str_repeat('.', $n));\n\n        $this->backtrack($result, $board, 0, $n);\n\n        return $result;\n    }\n\n    function backtrack(&$result, &$board, $row, $n) {\n        if ($row == $n) {\n            $temp = [];\n            foreach ($board as $r) {\n                $temp[] = $r;\n            }\n            $result[] = $temp;\n            return;\n        }\n\n        for ($i = 0; $i < $n; $i++) {\n            if ($this->isValid($board, $row, $i, $n)) {\n                $board[$row][$i] = 'Q';\n                $this->backtrack($result, $board, $row + 1, $n);\n                $board[$row][$i] = '.';\n            }\n        }\n    }\n\n    function isValid(&$board, $row, $col, $n) {\n        for ($i = 0; $i < $row; $i++) {\n            if ($board[$i][$col] == 'Q') return false;\n        }\n\n        for ($i = $row - 1, $j = $col - 1; $i >= 0 && $j >= 0; $i--, $j--) {\n            if ($board[$i][$j] == 'Q') return false;\n        }\n\n        for ($i = $row - 1, $j = $col + 1; $i >= 0 && $j < $n; $i--, $j++) {\n            if ($board[$i][$j] == 'Q') return false;\n        }\n\n        return true;\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun solveNQueens(n: Int): List<List<String>> {\n        val result = mutableListOf<List<String>>()\n        val col = BooleanArray(n)\n        val diag1 = BooleanArray(2 * n - 1)\n        val diag2 = BooleanArray(2 * n - 1)\n        val board = Array(n) { CharArray(n) { '.' } }\n        \n        fun placeQueens(row: Int) {\n            if (row == n) {\n                result.add(board.map { it.joinToString(\"\") })\n                return\n            }\n            for (i in 0 until n) {\n                if (col[i] || diag1[row + i] || diag2[row - i + n - 1]) continue\n                col[i] = true\n                diag1[row + i] = true\n                diag2[row - i + n - 1] = true\n                board[row][i] = 'Q'\n                placeQueens(row + 1)\n                col[i] = false\n                diag1[row + i] = false\n                diag2[row - i + n - 1] = false\n                board[row][i] = '.'\n            }\n        }\n        \n        placeQueens(0)\n        return result\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func solveNQueens(n int) [][]string {\n    solutions := [][]string{}\n    cols := make([]bool, n)\n    diagonal1 := make([]bool, 2*n-1)\n    diagonal2 := make([]bool, 2*n-1)\n    board := make([]string, n)\n    for i := range board {\n        board[i] = strings.Repeat(\".\", n)\n    }\n\n    var backtrack func(row int)\n    backtrack = func(row int) {\n        if row == n {\n            tmp := make([]string, n)\n            copy(tmp, board)\n            solutions = append(solutions, tmp)\n            return\n        }\n\n        for col := 0; col < n; col++ {\n            id1 := row - col + n - 1\n            id2 := row + col\n            if cols[col] || diagonal1[id1] || diagonal2[id2] {\n                continue\n            }\n\n            cols[col], diagonal1[id1], diagonal2[id2] = true, true, true\n            board[row] = board[row][:col] + \"Q\" + board[row][col+1:]\n            backtrack(row + 1)\n            board[row] = board[row][:col] + \".\" + board[row][col+1:]\n            cols[col], diagonal1[id1], diagonal2[id2] = false, false, false\n        }\n    }\n\n    backtrack(0)\n    return solutions\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {String[][]}\ndef solve_n_queens(n)\n    result = []\n    cols = Array.new(n, false)\n    diag1 = Array.new(2 * n - 1, false)\n    diag2 = Array.new(2 * n - 1, false)\n    board = Array.new(n) { Array.new(n, '.') }\n\n    backtrack(0, n, board, cols, diag1, diag2, result)\n    result\nend\n\ndef backtrack(row, n, board, cols, diag1, diag2, result)\n    if row == n\n        result << board.map { |row| row.join('') }\n        return\n    end\n\n    (0...n).each do |col|\n        id1 = n - 1 + row - col\n        id2 = row + col\n        next if cols[col] || diag1[id1] || diag2[id2]\n\n        cols[col] = true\n        diag1[id1] = true\n        diag2[id2] = true\n        board[row][col] = 'Q'\n\n        backtrack(row + 1, n, board, cols, diag1, diag2, result)\n\n        cols[col] = false\n        diag1[id1] = false\n        diag2[id2] = false\n        board[row][col] = '.'\n    end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to write a function that finds all possible ways to place `n` queens on an `n x n` chessboard such that no two queens can attack each other. The solution needs to efficiently search through possible board configurations and ensure that each solution adheres to the rules of the puzzle.\n\nHere's a full explanation of the solution and corresponding pseudocode for clarity:\n\n# Explanation\n\n1. **Initialization**: Begin by setting up an empty `board` for the given `n`, where each cell starts as an empty space.\n2. **Recursive Backtracking Function**: \n    - This function tries to place a queen in each row, ensuring it is placed such that it is not attacked by any previously placed queens.\n    - Use sets to keep track of columns and diagonals that are already attacked by queens.\n3. **Base Case**: If `row == n`, it means all rows are processed, and a valid board configuration is found. Add this configuration to the result list.\n4. **Iterative Placement**: Within each recursive call, iterate over columns to place a queen in the current row (`row`), checking if it's safe to place.\n5. **Backtracking**: After placing a queen and moving to the next row, remove the queen (backtrack) if subsequent placements fail, and explore other placements.\n6. **Return Result**: After processing all rows and exploring all possible placements, return the list of valid board configurations.\n\n# Pseudocode\n\n```text\nfunction solveNQueens(n: integer) -> list of list of strings:\n    function solve(row: integer, cols: set, diag1: set, diag2: set):\n        if row == n:\n            add current board configuration to result\n            return\n        for col in 0 to n-1:\n            if col in cols or row + col in diag1 or row - col in diag2:\n                continue\n            place queen at board[row][col]\n            add col to cols\n            add row + col to diag1\n            add row - col to diag2\n            solve(row + 1, cols, diag1, diag2)\n            remove queen from board[row][col]\n            remove col from cols\n            remove row + col from diag1\n            remove row - col from diag2\n\n    initialize result as empty list\n    initialize board as n x n matrix filled with '.'\n    call solve(0, empty set, empty set, empty set)\n    return result\n```\n\nThis pseudocode outlines the structure of the algorithm. It initializes the necessary variables, defines the recursive backtracking process with proper constraint checks, and accumulates the solutions within a results list to be returned.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-n-queens"
    },
    {
        "name": "Plus One",
        "site": "LeetCode",
        "href": "/solution/LeetCode-plus-one",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size();\n        \n        for (int i = n - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        \n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] newDigits = new int[digits.length + 1];\n        newDigits[0] = 1;\n        return newDigits;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        return [1] + digits"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\n    for (int i = digitsSize - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            *returnSize = digitsSize;\n            return digits;\n        } else {\n            digits[i] = 0;\n        }\n    }\n    \n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\n    result[0] = 1;\n    for (int i = 1; i <= digitsSize; i++) {\n        result[i] = digits[i - 1];\n    }\n    *returnSize = digitsSize + 1;\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] PlusOne(int[] digits) {\n        int n = digits.Length;\n        for (int i = n - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] newNumber = new int[n + 1];\n        newNumber[0] = 1;\n        return newNumber;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        } else {\n            digits[i] = 0;\n        }\n    }\n    digits.unshift(1);\n    return digits;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function plusOne(digits: number[]): number[] {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        } else {\n            digits[i] = 0;\n        }\n    }\n    digits.unshift(1);\n    return digits;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $digits\n     * @return Integer[]\n     */\n    function plusOne($digits) {\n        $n = count($digits);\n        \n        for ($i = $n - 1; $i >= 0; $i--) {\n            if ($digits[$i] < 9) {\n                $digits[$i]++;\n                return $digits;\n            }\n            $digits[$i] = 0;\n        }\n        \n        array_unshift($digits, 1);\n        \n        return $digits;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func plusOne(_ digits: [Int]) -> [Int] {\n        var digits = digits\n        for i in (0..<digits.count).reversed() {\n            if digits[i] < 9 {\n                digits[i] += 1\n                return digits\n            } else {\n                digits[i] = 0\n            }\n        }\n        digits.insert(1, at: 0)\n        return digits\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun plusOne(digits: IntArray): IntArray {\n        for (i in digits.indices.reversed()) {\n            if (digits[i] < 9) {\n                digits[i]++\n                return digits\n            }\n            digits[i] = 0\n        }\n        val newNumber = IntArray(digits.size + 1)\n        newNumber[0] = 1\n        return newNumber\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> plusOne(List<int> digits) {\n    int n = digits.length;\n    \n    for (int i = n - 1; i >= 0; i--) {\n      if (digits[i] < 9) {\n          digits[i]++;\n          return digits;\n      }\n      digits[i] = 0;\n    }\n    \n    List<int> newDigits = List.filled(n + 1, 0);\n    newDigits[0] = 1;\n    \n    return newDigits;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func plusOne(digits []int) []int {\n    n := len(digits)\n    \n    for i := n - 1; i >= 0; i-- {\n        if digits[i] < 9 {\n            digits[i]++\n            return digits\n        }\n        digits[i] = 0\n    }\n    \n    return append([]int{1}, digits...)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} digits\n# @return {Integer[]}\ndef plus_one(digits)\n    (digits.join.to_i + 1).to_s.chars.map(&:to_i)\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def plusOne(digits: Array[Int]): Array[Int] = {\n        var carry = 1\n        for (i <- digits.length - 1 to 0 by -1) {\n            val sum = digits(i) + carry\n            digits(i) = sum % 10\n            carry = sum / 10\n        }\n        if (carry == 0) {\n            digits\n        } else {\n            val result = new Array[Int](digits.length + 1)\n            result(0) = carry\n            for (i <- 1 until result.length) {\n                result(i) = digits(i - 1)\n            }\n            result\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\n        let mut result = digits.clone();\n        \n        for i in (0..result.len()).rev() {\n            if result[i] < 9 {\n                result[i] += 1;\n                return result;\n            } else {\n                result[i] = 0;\n            }\n        }\n        \n        result.insert(0, 1);\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to increment a large integer represented as an array of digits by one and return the resulting array of digits.\n\n# Explanation\n\n1. **Iterating from Right to Left**: Begin from the least significant digit (rightmost) and move towards the most significant digit (leftmost).\n2. **Incrementing Digits**:\n   - If the current digit is less than 9, increment the digit and return the array as the result.\n   - If the digit is 9, set it to 0 and move to the next digit to the left.\n3. **Handling Carry Over**: \n   - If all the digits are 9 (e.g., `[9, 9, 9]`), then after setting all digits to 0, prepend 1 to the array (e.g., the result for `[9, 9, 9]` would be `[1, 0, 0, 0]`).\n\n# Pseudocode\n\n```\nfunction plusOne(digits):\n    n = length of digits\n    \n    for i from n-1 to 0:\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n    \n    return [1] + digits\n```\n\nIn this pseudocode:\n- We iterate through the digits starting from the last digit.\n- We check if the digit is less than 9 and increment it if so.\n- If the digit happens to be 9, we set it to 0 and continue to the next digit.\n- If we have processed all digits and needed to set all of them to 0, we prepend 1 to the list and return the new list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-plus-one"
    },
    {
        "name": "Maximum Subarray",
        "site": "LeetCode",
        "href": "/solution/LeetCode-maximum-subarray",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        \n        for(int i = 1; i < nums.size(); i++){\n            currentSum = max(nums[i], currentSum + nums[i]);\n            maxSum = max(maxSum, currentSum);\n        }\n        \n        return maxSum;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n        \n        return maxSum;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum = nums[0]\n        current_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            current_sum = max(nums[i], current_sum + nums[i])\n            max_sum = max(max_sum, current_sum)\n            \n        return max_sum\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxSubArray(int* nums, int numsSize) {\n    int max_sum = nums[0];\n    int current_sum = nums[0];\n    \n    for (int i = 1; i < numsSize; i++) {\n        current_sum = (current_sum + nums[i] > nums[i]) ? current_sum + nums[i] : nums[i];\n        max_sum = (current_sum > max_sum) ? current_sum : max_sum;\n    }\n    \n    return max_sum;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxSubArray(int[] nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n\n        for (int i = 1; i < nums.Length; i++) {\n            currentSum = Math.Max(nums[i], currentSum + nums[i]);\n            maxSum = Math.Max(maxSum, currentSum);\n        }\n\n        return maxSum;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    if (nums.length === 1) return nums[0];\n    \n    let maxSum = nums[0];\n    let currentSum = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxSubArray(nums: number[]): number {\n    let currentSum = nums[0];\n    let maxSum = nums[0];\n\n    for (let i = 1; i < nums.length; i++) {\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n\n    return maxSum;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxSubArray($nums) {\n        $maxSum = $nums[0];\n        $tempSum = $nums[0];\n        \n        for ($i = 1; $i < count($nums); $i++) {\n            $tempSum = max($nums[$i], $tempSum + $nums[$i]);\n            $maxSum = max($maxSum, $tempSum);\n        }\n        \n        return $maxSum;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxSubArray(_ nums: [Int]) -> Int {\n        var maxSum = nums[0]\n        var currentSum = nums[0]\n        \n        for i in 1..<nums.count {\n            currentSum = max(nums[i], currentSum + nums[i])\n            maxSum = max(maxSum, currentSum)\n        }\n        \n        return maxSum\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxSubArray(nums: IntArray): Int {\n        var maxSum = nums[0]\n        var currentSum = nums[0]\n        \n        for (i in 1 until nums.size) {\n            currentSum = maxOf(nums[i], currentSum + nums[i])\n            maxSum = maxOf(maxSum, currentSum)\n        }\n        \n        return maxSum\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maxSubArray(List<int> nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n      currentSum = nums[i] + (currentSum > 0 ? currentSum : 0);\n      if (currentSum > maxSum) {\n        maxSum = currentSum;\n      }\n    }\n    \n    return maxSum;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxSubArray(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    \n    maxSum := nums[0]\n    currentSum := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        currentSum = max(nums[i], currentSum+nums[i])\n        maxSum = max(maxSum, currentSum)\n    }\n    \n    return maxSum\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_sub_array(nums)\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    (1..nums.length - 1).each do |i|\n        current_sum = [nums[i], current_sum + nums[i]].max\n        max_sum = [max_sum, current_sum].max\n    end\n    \n    max_sum\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxSubArray(nums: Array[Int]): Int = {\n        var maxSum = nums(0)\n        var currentSum = nums(0)\n        \n        for (i <- 1 until nums.length) {\n            currentSum = Math.max(nums(i), currentSum + nums(i))\n            maxSum = Math.max(maxSum, currentSum)\n        }\n        \n        maxSum\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_sub_array(nums: Vec<i32>) -> i32 {\n        let mut max_sum = nums[0];\n        let mut current_sum = nums[0];\n\n        for i in 1..nums.len() {\n            current_sum = current_sum.max(0) + nums[i];\n            max_sum = max_sum.max(current_sum);\n        }\n\n        max_sum\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (max-sub-array nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (let loop ([max-sum (car nums)]\n             [current-sum (car nums)]\n             [rest (cdr nums)])\n    (cond\n      [(null? rest) max-sum]\n      [(< (car rest) (+ current-sum (car rest)))\n       (loop (max max-sum (+ current-sum (car rest)))\n             (+ current-sum (car rest))\n             (cdr rest))]\n      [else\n       (loop (max max-sum (car rest))\n             (car rest)\n             (cdr rest))])))\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec max_sub_array(Nums :: [integer()]) -> integer().\nmax_sub_array(Nums) ->\n    {_, _, Max} = lists:foldl(fun(X, {SoFar, EndHere, Max}) ->\n                                  NewSoFar = max(X, SoFar + X),\n                                  NewEndHere = max(NewSoFar, EndHere),\n                                  NewMax = max(Max, NewEndHere),\n                                  {NewSoFar, NewEndHere, NewMax}\n                              end, {-9999999, -9999999, -9999999}, Nums),\n    Max.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec max_sub_array(nums :: [integer]) :: integer\n  def max_sub_array(nums) do\n    {_, max_sum} = Enum.reduce(tl(nums), {hd(nums), hd(nums)}, fn num, {current_sum, max_sum} ->\n      current_sum = max(num, current_sum + num)\n      max_sum = max(current_sum, max_sum)\n\n      {current_sum, max_sum}\n    end)\n\n    max_sum\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will use Kadane's Algorithm, which is an efficient way to find the maximum sum of a contiguous subarray in an array.\n\n## Explanation\n\nKadane's Algorithm works by iterating through the array, maintaining a running sum (`current_sum`) of the subarray ending at the current position, and a global maximum sum (`max_sum`) found so far. For each element in the array, we update `current_sum` to be the maximum of the current element itself or the current element plus the `current_sum`. This way, if adding the current element to `current_sum` makes it smaller, we simply start a new subarray from the current element. The `max_sum` is updated to be the maximum between `max_sum` and `current_sum` during each iteration.\n\n## Pseudocode\n\n```\n# Initialize variables:\n# max_sum to store the maximum subarray sum found so far\n# current_sum to store the current subarray sum ending at each position\n\nmax_sum = nums[0]\ncurrent_sum = nums[0]\n\n# Iterate through the array starting from the second element\nfor i from 1 to length of nums - 1:\n    # Update current_sum to be the maximum of nums[i] and current_sum + nums[i]\n    current_sum = max(nums[i], current_sum + nums[i])\n    \n    # Update max_sum to be the maximum of max_sum and current_sum\n    max_sum = max(max_sum, current_sum)\n\n# Return the maximum subarray sum found\nreturn max_sum\n```\n\nThis approach ensures that we pass through the array only once, achieving an optimal time complexity of O(n).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-maximum-subarray"
    },
    {
        "name": "Spiral Matrix",
        "site": "LeetCode",
        "href": "/solution/LeetCode-spiral-matrix",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> result;\n        if (matrix.empty()) {\n            return result;\n        }\n        \n        int top = 0, bottom = matrix.size() - 1;\n        int left = 0, right = matrix[0].size() - 1;\n        \n        while (top <= bottom && left <= right) {\n            for (int i = left; i <= right; i++) {\n                result.push_back(matrix[top][i]);\n            }\n            top++;\n            \n            for (int i = top; i <= bottom; i++) {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n            \n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) {\n                    result.push_back(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n            \n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) {\n                    result.push_back(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if(matrix == null || matrix.length == 0) {\n            return result;\n        }\n        \n        int top = 0;\n        int bottom = matrix.length - 1;\n        int left = 0;\n        int right = matrix[0].length - 1;\n        \n        while(top <= bottom && left <= right) {\n            for(int i = left; i <= right; i++) {\n                result.add(matrix[top][i]);\n            }\n            top++;\n            \n            for(int i = top; i <= bottom; i++) {\n                result.add(matrix[i][right]);\n            }\n            right--;\n            \n            if(top <= bottom) {\n                for(int i = right; i >= left; i--) {\n                    result.add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n            \n            if(left <= right) {\n                for(int i = bottom; i >= top; i--) {\n                    result.add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix:\n            return []\n        \n        result = []\n        top_row = 0\n        bottom_row = len(matrix) - 1\n        left_col = 0\n        right_col = len(matrix[0]) - 1\n        \n        while top_row <= bottom_row and left_col <= right_col:\n            for i in range(left_col, right_col + 1):\n                result.append(matrix[top_row][i])\n            top_row += 1\n            \n            for i in range(top_row, bottom_row + 1):\n                result.append(matrix[i][right_col])\n            right_col -= 1\n            \n            if top_row <= bottom_row:\n                for i in range(right_col, left_col - 1, -1):\n                    result.append(matrix[bottom_row][i])\n                bottom_row -= 1\n            \n            if left_col <= right_col:\n                for i in range(bottom_row, top_row - 1, -1):\n                    result.append(matrix[i][left_col])\n                left_col += 1\n                \n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free\n().\n */\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, \nint* returnSize) {\n    int rowStart = 0, rowEnd = matrixSize - 1;\n    int colStart = 0, colEnd = *matrixColSize - 1;\n    int* result = (int*)malloc(matrixSize * (*matrixColSize) * sizeof(int));\n    *returnSize = matrixSize * (*matrixColSize);\n    int idx = 0;\n    \n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        // Traverse Right\n        for (int i = colStart; i <= colEnd; i++) {\n            result[idx++] = matrix[rowStart][i];\n        }\n        rowStart++;\n\n        // Traverse Down\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result[idx++] = matrix[i][colEnd];\n        }\n        colEnd--;\n\n        // Traverse Left\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result[idx++] = matrix[rowEnd][i];\n            }\n            rowEnd--;\n        }\n\n        // Traverse Up\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result[idx++] = matrix[i][colStart];\n            }\n            colStart++;\n        }\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> SpiralOrder(int[][] matrix) {\n        IList<int> result = new List<int>();\n        \n        if(matrix == null || matrix.Length == 0) {\n            return result;\n        }\n        \n        int top = 0, bottom = matrix.Length - 1;\n        int left = 0, right = matrix[0].Length - 1;\n        \n        while(top <= bottom && left <= right) {\n            for(int i = left; i <= right; i++) {\n                result.Add(matrix[top][i]);\n            }\n            top++;\n            \n            for(int i = top; i <= bottom; i++) {\n                result.Add(matrix[i][right]);\n            }\n            right--;\n            \n            if(top <= bottom) {\n                for(int i = right; i >= left; i--) {\n                    result.Add(matrix[bottom][i]);\n                }\n                bottom--;\n            }\n            \n            if(left <= right) {\n                for(int i = bottom; i >= top; i--) {\n                    result.Add(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function(matrix) {\n    const result = [];\n    if (matrix === null || matrix.length === 0) {\n        return result;\n    }\n    \n    let top = 0;\n    let bottom = matrix.length - 1;\n    let left = 0;\n    let right = matrix[0].length - 1;\n    let direction = 0;\n\n    while (top <= bottom && left <= right) {\n        if (direction === 0) {\n            for (let i = left; i <= right; i++) {\n                result.push(matrix[top][i]);\n            }\n            top++;\n        } else if (direction === 1) {\n            for (let i = top; i <= bottom; i++) {\n                result.push(matrix[i][right]);\n            }\n            right--;\n        } else if (direction === 2) {\n            for (let i = right; i >= left; i--) {\n                result.push(matrix[bottom][i]);\n            }\n            bottom--;\n        } else if (direction === 3) {\n            for (let i = bottom; i >= top; i--) {\n                result.push(matrix[i][left]);\n            }\n            left++;\n        }\n        direction = (direction + 1) % 4;\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function spiralOrder(matrix: number[][]): number[] {\n    const result: number[] = [];\n    let topRow = 0;\n    let bottomRow = matrix.length - 1;\n    let leftCol = 0;\n    let rightCol = matrix[0].length - 1;\n    \n    while (topRow <= bottomRow && leftCol <= rightCol) {\n        for (let i = leftCol; i <= rightCol; i++) {\n            result.push(matrix[topRow][i]);\n        }\n        topRow++;\n        \n        for (let i = topRow; i <= bottomRow; i++) {\n            result.push(matrix[i][rightCol]);\n        }\n        rightCol--;\n        \n        if (topRow <= bottomRow) {\n            for (let i = rightCol; i >= leftCol; i--) {\n                result.push(matrix[bottomRow][i]);\n            }\n            bottomRow--;\n        }\n        \n        if (leftCol <= rightCol) {\n            for (let i = bottomRow; i >= topRow; i--) {\n                result.push(matrix[i][leftCol]);\n            }\n            leftCol++;\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $matrix\n     * @return Integer[]\n     */\n    function spiralOrder($matrix) {\n        $result = [];\n        $top = 0;\n        $bottom = count($matrix) - 1;\n        $left = 0;\n        $right = count($matrix[0]) - 1;\n        \n        while ($top <= $bottom && $left <= $right) {\n            for ($i = $left; $i <= $right; $i++) {\n                $result[] = $matrix[$top][$i];\n            }\n            $top++;\n\n            for ($i = $top; $i <= $bottom; $i++) {\n                $result[] = $matrix[$i][$right];\n            }\n            $right--;\n\n            if ($top <= $bottom) {\n                for ($i = $right; $i >= $left; $i--) {\n                    $result[] = $matrix[$bottom][$i];\n                }\n                $bottom--;\n            }\n\n            if ($left <= $right) {\n                for ($i = $bottom; $i >= $top; $i--) {\n                    $result[] = $matrix[$i][$left];\n                }\n                $left++;\n            }\n        }\n        \n        return $result;\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\n        val result = mutableListOf<Int>()\n        \n        if (matrix.isEmpty()) return result\n        \n        var top = 0\n        var bottom = matrix.size - 1\n        var left = 0\n        var right = matrix[0].size - 1\n        \n        while (top <= bottom && left <= right) {\n            for (i in left..right) {\n                result.add(matrix[top][i])\n            }\n            top++\n            \n            for (i in top..bottom) {\n                result.add(matrix[i][right])\n            }\n            right--\n            \n            if (top <= bottom) {\n                for (i in right downTo left) {\n                    result.add(matrix[bottom][i])\n                }\n                bottom--\n            }\n            \n            if (left <= right) {\n                for (i in bottom downTo top) {\n                    result.add(matrix[i][left])\n                }\n                left++\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> spiralOrder(List<List<int>> matrix) {\n    List<int> result = [];\n    if (matrix.isEmpty) return result;\n\n    int rowBegin = 0;\n    int rowEnd = matrix.length - 1;\n    int colBegin = 0;\n    int colEnd = matrix[0].length - 1;\n\n    while (rowBegin <= rowEnd && colBegin <= colEnd) {\n      for (int i = colBegin; i <= colEnd; i++) {\n        result.add(matrix[rowBegin][i]);\n      }\n      rowBegin++;\n\n      for (int i = rowBegin; i <= rowEnd; i++) {\n        result.add(matrix[i][colEnd]);\n      }\n      colEnd--;\n\n      if (rowBegin <= rowEnd) {\n        for (int i = colEnd; i >= colBegin; i--) {\n          result.add(matrix[rowEnd][i]);\n        }\n      }\n      rowEnd--;\n\n      if (colBegin <= colEnd) {\n        for (int i = rowEnd; i >= rowBegin; i--) {\n          result.add(matrix[i][colBegin]);\n        }\n      }\n      colBegin++;\n    }\n\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func spiralOrder(matrix [][]int) []int {\n    if len(matrix) == 0 {\n        return []int{}\n    }\n    \n    rows, cols := len(matrix), len(matrix[0])\n    result := make([]int, rows*cols)\n    \n    top, bottom, left, right := 0, rows-1, 0, cols-1\n    idx := 0\n    \n    for {\n        // Traverse top row\n        for i := left; i <= right; i++ {\n            result[idx] = matrix[top][i]\n            idx++\n        }\n        top++\n        if top > bottom || left > right {\n            break\n        }\n        \n        // Traverse right column\n        for i := top; i <= bottom; i++ {\n            result[idx] = matrix[i][right]\n            idx++\n        }\n        right--\n        if top > bottom || left > right {\n            break\n        }\n        \n        // Traverse bottom row\n        for i := right; i >= left; i-- {\n            result[idx] = matrix[bottom][i]\n            idx++\n        }\n        bottom--\n        if top > bottom || left > right {\n            break\n        }\n        \n        // Traverse left column\n        for i := bottom; i >= top; i-- {\n            result[idx] = matrix[i][left]\n            idx++\n        }\n        left++\n        if top > bottom || left > right {\n            break\n        }\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @return {Integer[]}\ndef spiral_order(matrix)\n    result = []\n    while matrix.any?\n        result += matrix.shift\n        matrix = matrix.transpose.reverse\n    end\n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\n        if (matrix.isEmpty) return List()\n\n        var top = 0\n        var bottom = matrix.length - 1\n        var left = 0\n        var right = matrix(0).length - 1\n\n        var direction = 0 // 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        var result = List[Int]()\n\n        while (top <= bottom && left <= right) {\n            if (direction == 0) {\n                for (i <- left to right) {\n                    result = result :+ matrix(top)(i)\n                }\n                top += 1\n            } else if (direction == 1) {\n                for (i <- top to bottom) {\n                    result = result :+ matrix(i)(right)\n                }\n                right -= 1\n            } else if (direction == 2) {\n                for (i <- right to left by -1) {\n                    result = result :+ matrix(bottom)(i)\n                }\n                bottom -= 1\n            } else if (direction == 3) {\n                for (i <- bottom to top by -1) {\n                    result = result :+ matrix(i)(left)\n                }\n                left += 1\n            }\n            direction = (direction + 1) % 4\n        }\n\n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        let (mut top, mut bottom, mut left, mut right) = (0, matrix.len() as i32 - 1, 0, matrix[0].len() as i32 - 1);\n        let mut result = Vec::new();\n\n        while top <= bottom && left <= right {\n            for i in left..=right {\n                result.push(matrix[top as usize][i as usize]);\n            }\n            top += 1;\n\n            for i in top..=bottom {\n                result.push(matrix[i as usize][right as usize]);\n            }\n            right -= 1;\n\n            if top <= bottom {\n                for i in (left..=right).rev() {\n                    result.push(matrix[bottom as usize][i as usize]);\n                }\n                bottom -= 1;\n            }\n\n            if left <= right {\n                for i in (top..=bottom).rev() {\n                    result.push(matrix[i as usize][left as usize]);\n                }\n                left += 1;\n            }\n        }\n\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of returning elements of an m x n matrix in spiral order, you'll need to traverse the matrix in a spiral pattern (right, down, left, and up). The challenge boils down to controlling boundaries and moving pointers appropriately to mimic a spiral traversal.\n\n# Explanation\n1. **Initialize Boundaries**: Set up boundary pointers for `top_row`, `bottom_row`, `left_col`, and `right_col`. These define the current limits of traversal.\n2. **Traverse Right**: From the left boundary to the right boundary within the top row.\n3. **Move Down**: From top boundary to bottom boundary within the right column.\n4. **Traverse Left**: From right boundary to left boundary within the bottom row (only if there are rows left to traverse after moving down).\n5. **Move Up**: From bottom boundary to top boundary within the left column (only if there are columns left after moving up).\n6. **Adjust Boundaries**: After traversing each side, adjust the corresponding boundary to shrink the traversal field.\n7. Repeat this process until all boundaries converge.\n\n# Pseudocode\n```\n# Pseudocode\nfunction spiralOrder(matrix):\n    # Initialize boundaries\n    top_row = 0\n    bottom_row = len(matrix) - 1\n    left_col = 0\n    right_col = len(matrix[0]) - 1\n    result = []\n\n    while top_row <= bottom_row and left_col <= right_col:\n        # Traverse from left to right along the top row\n        for col from left_col to right_col:\n            result.append(matrix[top_row][col])\n        top_row += 1\n        \n        # Traverse from top to bottom along the right column\n        for row from top_row to bottom_row:\n            result.append(matrix[row][right_col])\n        right_col -= 1\n        \n        if top_row <= bottom_row:\n            # Traverse from right to left along the bottom row\n            for col from right_col to left_col step -1:\n                result.append(matrix[bottom_row][col])\n            bottom_row -= 1\n        \n        if left_col <= right_col:\n            # Traverse from bottom to top along the left column\n            for row from bottom_row to top_row step -1:\n                result.append(matrix[row][left_col])\n            left_col += 1\n\n    return result\n```\nThis approach ensures we only access each element once and systematically reduce the boundaries to follow the spiral order. The `while` loop guarantees that we quit the traversal once all the bounds have been met. Adjustments to the boundaries after each directional traversal prevent overlaps and ensure the spiral ordering correctly.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-spiral-matrix"
    },
    {
        "name": "Jump Game",
        "site": "LeetCode",
        "href": "/solution/LeetCode-jump-game",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        int reachable = 0;\n        for (int i = 0; i < n; i++) {\n            if (i > reachable) {\n                return false;\n            }\n            reachable = max(reachable, i + nums[i]);\n            if (reachable >= n - 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int maxReach = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (i > maxReach) {\n                return false;\n            }\n            maxReach = Math.max(maxReach, i + nums[i]);\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_reachable = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reachable:\n                return False\n            max_reachable = max(max_reachable, i + nums[i])\n            if max_reachable >= n - 1:\n                return True\n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool canJump(int* nums, int numsSize) {\n    int maxReach = 0;\n    for (int i = 0; i < numsSize; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        maxReach = fmax(maxReach, i + nums[i]);\n        if (maxReach >= numsSize - 1) {\n            return true;\n        }\n    }\n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool CanJump(int[] nums) {\n        int maxReach = 0;\n        \n        for (int i = 0; i < nums.Length; i++) {\n            if (i > maxReach) {\n                return false;\n            }\n            maxReach = Math.Max(maxReach, i + nums[i]);\n            if (maxReach >= nums.Length - 1) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    let maxReach = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function canJump(nums: number[]): boolean {\n    let maxReach = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (i > maxReach) {\n            return false;\n        }\n        maxReach = Math.max(maxReach, i + nums[i]);\n        if (maxReach >= nums.length - 1) {\n            return true;\n        }\n    }\n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canJump($nums) {\n        $maxReach = 0;\n        for ($i = 0; $i < count($nums); $i++) {\n            if ($i > $maxReach) {\n                return false;\n            }\n            $maxReach = max($maxReach, $i + $nums[$i]);\n            if ($maxReach >= count($nums)-1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func canJump(_ nums: [Int]) -> Bool {\n        var maxReach = 0\n        for i in 0..<nums.count {\n            if i > maxReach {\n                return false\n            }\n            maxReach = max(maxReach, i + nums[i])\n            if maxReach >= nums.count - 1 {\n                return true\n            }\n        }\n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun canJump(nums: IntArray): Boolean {\n        var maxReach = 0\n        for (i in nums.indices) {\n            if (i > maxReach) return false\n            maxReach = maxOf(maxReach, i + nums[i])\n            if (maxReach >= nums.size - 1) return true\n        }\n        return false\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool canJump(List<int> nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; i++) {\n      if (i > maxReach) {\n        return false;\n      }\n      maxReach = max(maxReach, i + nums[i]);\n      if (maxReach >= nums.length - 1) {\n        return true;\n      }\n    }\n    return false;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func canJump(nums []int) bool {\n    maxJump := 0\n    for i := 0; i < len(nums); i++ {\n        if i > maxJump {\n            return false\n        }\n        maxJump = max(maxJump, i+nums[i])\n        if maxJump >= len(nums)-1 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_jump(nums)\n    max_reach = 0\n    (0...nums.length).each do |i|\n        return false if i > max_reach\n        max_reach = [max_reach, i + nums[i]].max\n    end\n    return true\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        let mut max_jump = 0;\n        for i in 0..nums.len() {\n            if i > max_jump {\n                return false;\n            }\n            max_jump = max_jump.max(i + nums[i] as usize);\n            if max_jump >= nums.len() - 1 {\n                return true;\n            }\n        }\n        false\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine whether it's possible to reach the last index of the array starting from the first index. The integer values within the array represent the maximum jump length at that position.\n\n# Explanation:\n1. We start at the first position of the array.\n2. For each position, we update the furthest position that can be reached.\n3. If at any position, the furthest reachable point is less than the current position, it means we are stuck and can't reach the end.\n4. If at any point the furthest reachable position is greater than or equal to the last index of the array, then we can reach the end.\n\n# Pseudocode:\n```\nfunction canJump(nums):\n    max_reachable = 0  # Initialize the maximum reachable index\n    n = length of nums\n    \n    for i from 0 to n-1 do:\n        if i > max_reachable then:\n            return False  # If any index is not reachable, return False\n        max_reachable = max(max_reachable, i + nums[i])  # Update the maximum reachable index\n        if max_reachable >= n - 1 then:\n            return True  # If last index or beyond is reachable, return True\n    \n    return False  # In case we exit the loop without finding a solution, return False\n```\n\nWith this approach, we can determine if it's possible to reach the last index within linear time O(n).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-jump-game"
    },
    {
        "name": "Merge Intervals",
        "site": "LeetCode",
        "href": "/solution/LeetCode-merge-intervals",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        if(intervals.empty()){\n            return {};\n        }\n        \n        sort(intervals.begin(), intervals.end());\n        \n        vector<vector<int>> res;\n        res.push_back(intervals[0]);\n        \n        for(int i = 1; i < intervals.size(); i++){\n            if(intervals[i][0] <= res.back()[1]){\n                res.back()[1] = max(res.back()[1], intervals[i][1]);\n            } else {\n                res.push_back(intervals[i]);\n            }\n        }\n        \n        return res;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        List<int[]> result = new ArrayList<>();\n        int[] currentInterval = intervals[0];\n        result.add(currentInterval);\n        \n        for (int[] interval : intervals) {\n            if (interval[0] <= currentInterval[1]) {\n                currentInterval[1] = Math.max(currentInterval[1], interval[1]);\n            } else {\n                currentInterval = interval;\n                result.add(currentInterval);\n            }\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort(key=lambda x: x[0])\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[][] Merge(int[][] intervals) {\n        if (intervals.Length <= 1) {\n            return intervals;\n        }\n        \n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\n        \n        List<int[]> result = new List<int[]>();\n        int[] currentInterval = intervals[0];\n        result.Add(currentInterval);\n        \n        foreach (var interval in intervals) {\n            int currentEnd = currentInterval[1];\n            int nextStart = interval[0];\n            int nextEnd = interval[1];\n            \n            if (currentEnd >= nextStart) {\n                currentInterval[1] = Math.Max(currentEnd, nextEnd);\n            } else {\n                currentInterval = interval;\n                result.Add(currentInterval);\n            }\n        }\n        \n        return result.ToArray();\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function merge(intervals: number[][]): number[][] {\n    if (intervals.length <= 1) {\n        return intervals;\n    }\n    \n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const result: number[][] = [intervals[0]];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        const lastInterval = result[result.length - 1];\n        const currentInterval = intervals[i];\n        \n        if (currentInterval[0] <= lastInterval[1]) {\n            lastInterval[1] = Math.max(lastInterval[1], currentInterval[1]);\n        } else {\n            result.push(currentInterval);\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $intervals\n     * @return Integer[][]\n     */\n    function merge($intervals) {\n        if (count($intervals) == 0) {\n            return [];\n        }\n        \n        usort($intervals, function($a, $b) {\n            return $a[0] - $b[0];\n        });\n        \n        $result = [];\n        $current = $intervals[0];\n        \n        for ($i = 1; $i < count($intervals); $i++) {\n            if ($current[1] >= $intervals[$i][0]) {\n                $current[1] = max($current[1], $intervals[$i][1]);\n            } else {\n                $result[] = $current;\n                $current = $intervals[$i];\n            }\n        }\n        \n        $result[] = $current;\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\n        var sortedIntervals = intervals.sorted { $0[0] < $1[0] }\n        var result = [[Int]]()\n        \n        for interval in sortedIntervals {\n            if result.isEmpty || interval[0] > result.last![1] {\n                result.append(interval)\n            } else {\n                result[result.count - 1][1] = max(result.last![1], interval[1])\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun merge(intervals: Array<IntArray>): Array<IntArray> {\n        if (intervals.isEmpty()) {\n            return emptyArray()\n        }\n        \n        intervals.sortBy { it[0] }\n        \n        val result = mutableListOf<IntArray>()\n        var currentInterval = intervals[0]\n        \n        for (i in 1 until intervals.size) {\n            val interval = intervals[i]\n            if (interval[0] <= currentInterval[1]) {\n                currentInterval[1] = maxOf(currentInterval[1], interval[1])\n            } else {\n                result.add(currentInterval)\n                currentInterval = interval\n            }\n        }\n        \n        result.add(currentInterval)\n        \n        return result.toTypedArray()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> merge(List<List<int>> intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    List<List<int>> merged = [];\n    \n    for (List<int> interval in intervals) {\n      if (merged.isEmpty || merged.last[1] < interval[0]) {\n        merged.add(interval);\n      } else {\n        merged.last[1] = interval[1] > merged.last[1] ? interval[1] : merged.last[1];\n      }\n    }\n    \n    return merged;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func merge(intervals [][]int) [][]int {\n    if len(intervals) == 0 {\n        return [][]int{}\n    }\n\n    sort.Slice(intervals, func(i, j int) bool {\n        return intervals[i][0] < intervals[j][0]\n    })\n\n    result := make([][]int, 0)\n    currentInterval := intervals[0]\n\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i][0] <= currentInterval[1] {\n            currentInterval[1] = max(currentInterval[1], intervals[i][1])\n        } else {\n            result = append(result, currentInterval)\n            currentInterval = intervals[i]\n        }\n    }\n\n    result = append(result, currentInterval)\n\n    return result\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} intervals\n# @return {Integer[][]}\ndef merge(intervals)\n    intervals.sort_by! { |interval| interval[0] }\n    result = [intervals[0]]\n    \n    for i in 1..intervals.length-1\n        current_interval = intervals[i]\n        last_merged_interval = result.last\n        \n        if current_interval[0] <= last_merged_interval[1]\n            last_merged_interval[1] = [last_merged_interval[1], current_interval[1]].max\n        else\n            result << current_interval\n        end\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {\n        intervals.sortBy(_(0)).foldLeft(List[Array[Int]]()) { (result, interval) =>\n            result match {\n                case Nil => List(interval)\n                case head :: tail if interval(0) <= head(1) =>\n                    head(1) = Math.max(head(1), interval(1))\n                    result\n                case _ => interval :: result\n            }\n        }.reverse.toArray\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut intervals = intervals;\n        intervals.sort_by_key(|interval| interval[0]);\n        \n        let mut result: Vec<Vec<i32>> = Vec::new();\n        \n        for interval in intervals {\n            if result.is_empty() || result.last().unwrap()[1] < interval[0] {\n                result.push(interval);\n            } else {\n                result.last_mut().unwrap()[1] = result.last().unwrap()[1].max(interval[1]);\n            }\n        }\n        \n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will follow a structured approach to merge the overlapping intervals into the smallest possible set of non-overlapping intervals.\n\n# Explanation\n\n1. **Sort the Intervals**: First, sort the intervals based on their starting values. This helps in easily identifying overlapping intervals.\n2. **Initialize a Merged List**: Create an empty list to store the merged intervals.\n3. **Iterate Through the Intervals**: For each interval in the sorted list:\n    * If the merged list is empty or if the current interval does not overlap with the last interval in the merged list (i.e., the end of the last merged interval is less than the start of the current interval), add the current interval to the merged list.\n    * If the current interval overlaps with the last interval in the merged list (i.e., the end of the last merged interval is greater than or equal to the start of the current interval), merge them by updating the end of the last merged interval to the maximum end of the two intervals.\n4. **Return the Merged List**: Once all intervals are processed, return the merged list.\n\n# Pseudocode\n\n```\nFUNCTION merge(intervals)\n    // Sort intervals based on the starting values\n    SORT intervals BY interval[0]\n    \n    // Initialize merged list\n    merged = []\n    \n    // Iterate through the sorted intervals\n    FOR interval IN intervals\n        // If merged list is empty or the current interval does not overlap\n        IF merged IS EMPTY OR merged[-1][1] < interval[0]\n            // Add the current interval to the merged list\n            APPEND interval TO merged\n        ELSE\n            // Merge the intervals by updating the end of the last interval\n            merged[-1][1] = MAX(merged[-1][1], interval[1])\n    \n    RETURN merged\nEND FUNCTION\n```\n\nThis structured approach ensures that we merge overlapping intervals efficiently and obtain the correct result as shown in the example outputs.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-merge-intervals"
    },
    {
        "name": "Insert Interval",
        "site": "LeetCode",
        "href": "/solution/LeetCode-insert-interval",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> result;\n        int index = 0;\n        // Add all intervals that end before the newInterval starts\n        while (index < intervals.size() && intervals[index][1] < newInterval[0]) {\n            result.push_back(intervals[index]);\n            index++;\n        }\n        // Merge all overlapping intervals with the newInterval\n        while (index < intervals.size() && intervals[index][0] <= newInterval[1]) {\n            newInterval[0] = min(newInterval[0], intervals[index][0]);\n            newInterval[1] = max(newInterval[1], intervals[index][1]);\n            index++;\n        }\n        result.push_back(newInterval);\n        // Add all intervals that start after the newInterval ends\n        while (index < intervals.size()) {\n            result.push_back(intervals[index]);\n            index++;\n        }\n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n        // Add all intervals that end before newInterval starts\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n        // Merge intervals that overlap with newInterval\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\n            i++;\n        }\n        result.add(newInterval);\n        // Add all remaining intervals\n        while (i < intervals.length) {\n            result.add(intervals[i]);\n            i++;\n        }\n        return result.toArray(new int[result.size()][]);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        \n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n            i += 1\n        \n        result.append(newInterval)\n        \n        while i < len(intervals):\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new List<int[]>();\n        int i = 0;\n        \n        // Add all intervals that come before the newInterval\n        while (i < intervals.Length && intervals[i][1] < newInterval[0]) {\n            result.Add(intervals[i]);\n            i++;\n        }\n        \n        // Merge overlapping intervals\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        \n        result.Add(newInterval);\n        \n        // Add all intervals that come after the newInterval\n        while (i < intervals.Length) {\n            result.Add(intervals[i]);\n            i++;\n        }\n        \n        return result.ToArray();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    let result = [];\n    let i = 0;\n\n    // Add all intervals that come before newInterval\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    // Merge intervals that overlap with newInterval\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n\n    result.push(newInterval);\n\n    // Add remaining intervals\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n    const result: number[][] = [];\n    let i = 0;\n\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n\n    result.push(newInterval);\n\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $intervals\n     * @param Integer[] $newInterval\n     * @return Integer[][]\n     */\n    function insert($intervals, $newInterval) {\n        $result = [];\n        $inserted = false;\n        \n        foreach ($intervals as $interval) {\n            if ($interval[1] < $newInterval[0]) {\n                $result[] = $interval;\n            } elseif ($interval[0] > $newInterval[1]) {\n                if (!$inserted) {\n                    $result[] = $newInterval;\n                    $inserted = true;\n                }\n                $result[] = $interval;\n            } else {\n                $newInterval[0] = min($newInterval[0], $interval[0]);\n                $newInterval[1] = max($newInterval[1], $interval[1]);\n            }\n        }\n        \n        if (!$inserted) {\n            $result[] = $newInterval;\n        }\n        \n        return $result;\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\n        val result = mutableListOf<IntArray>()\n        var i = 0\n\n        // Add all intervals that come before newInterval\n        while (i < intervals.size && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i])\n            i++\n        }\n\n        // Merge overlapping intervals\n        while (i < intervals.size && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = minOf(newInterval[0], intervals[i][0])\n            newInterval[1] = maxOf(newInterval[1], intervals[i][1])\n            i++\n        }\n        result.add(newInterval)\n\n        // Add all intervals that come after newInterval\n        while (i < intervals.size) {\n            result.add(intervals[i])\n            i++\n        }\n\n        return result.toTypedArray()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> insert(List<List<int>> intervals, List<int> newInterval) {\n    List<List<int>> result = [];\n    int i = 0;\n    \n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n      result.add(intervals[i]);\n      i++;\n    }\n    \n    List<int> toAdd = newInterval;\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n      toAdd = [min(toAdd[0], intervals[i][0]), max(toAdd[1], intervals[i][1])];\n      i++;\n    }\n    result.add(toAdd);\n    \n    while (i < intervals.length) {\n      result.add(intervals[i]);\n      i++;\n    }\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func insert(intervals [][]int, newInterval []int) [][]int {\n    result := make([][]int, 0)\n    var i int\n    for i < len(intervals) && intervals[i][1] < newInterval[0] {\n        result = append(result, intervals[i])\n        i++\n    }\n    for i < len(intervals) && intervals[i][0] <= newInterval[1] {\n        if intervals[i][0] < newInterval[0] {\n            newInterval[0] = intervals[i][0]\n        }\n        if intervals[i][1] > newInterval[1] {\n            newInterval[1] = intervals[i][1]\n        }\n        i++\n    }\n    result = append(result, newInterval)\n    for i < len(intervals) {\n        result = append(result, intervals[i])\n        i++\n    }\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} intervals\n# @param {Integer[]} new_interval\n# @return {Integer[][]}\ndef insert(intervals, new_interval)\n    result = []\n    i = 0\n\n    while i < intervals.length && intervals[i][1] < new_interval[0]\n        result << intervals[i]\n        i += 1\n    end\n\n    while i < intervals.length && intervals[i][0] <= new_interval[1]\n        new_interval[0] = [new_interval[0], intervals[i][0]].min\n        new_interval[1] = [new_interval[1], intervals[i][1]].max\n        i += 1\n    end\n\n    result << new_interval\n\n    while i < intervals.length\n        result << intervals[i]\n        i += 1\n    end\n\n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {\n        var result = List[Array[Int]]()\n        \n        var i = 0\n        while (i < intervals.length && intervals(i)(1) < newInterval(0)) {\n            result = result :+ intervals(i)\n            i += 1\n        }\n        \n        var mergedInterval = newInterval\n        while (i < intervals.length && intervals(i)(0) <= newInterval(1)) {\n            mergedInterval(0) = Math.min(mergedInterval(0), intervals(i)(0))\n            mergedInterval(1) = Math.max(mergedInterval(1), intervals(i)(1))\n            i += 1\n        }\n        result = result :+ mergedInterval\n        \n        while (i < intervals.length) {\n            result = result :+ intervals(i)\n            i += 1\n        }\n        \n        result.toArray\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut result = vec![];\n        let mut new_interval = new_interval;\n        let mut i = 0;\n\n        while i < intervals.len() && intervals[i][1] < new_interval[0] {\n            result.push(intervals[i].clone());\n            i += 1;\n        }\n\n        while i < intervals.len() && intervals[i][0] <= new_interval[1] {\n            new_interval[0] = new_interval[0].min(intervals[i][0]);\n            new_interval[1] = new_interval[1].max(intervals[i][1]);\n            i += 1;\n        }\n\n        result.push(new_interval.clone());\n\n        while i < intervals.len() {\n            result.push(intervals[i].clone());\n            i += 1;\n        }\n\n        result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to insert a new interval into an existing list of non-overlapping sorted intervals while ensuring the merged intervals remain sorted and non-overlapping.\n\n# Explanation\n\n1. **Initialization**:\n   - Prepare an empty list `result` to store the final merged intervals.\n   - Initialize an index `i` to track the current position in the `intervals` list.\n\n2. **Add Non-Overlapping Intervals Before New Interval**:\n   - Iterate through the `intervals` list and add intervals to the `result` list that end before the start of the `newInterval`.\n\n3. **Merge Overlapping Intervals**:\n   - Continue iterating through the `intervals` list to merge all overlapping intervals with the `newInterval`. Adjust the `newInterval` to the smallest start and largest end value among the overlapping intervals.\n\n4. **Add the Merged Interval**:\n   - Add the merged `newInterval` to the `result` list.\n\n5. **Add Remaining Intervals**:\n   - Append any remaining intervals to the `result` list that start after the end of the `newInterval`.\n\n6. **Return the Result**:\n   - Return the `result` list containing the merged intervals.\n\n# Pseudocode\n\n```text\nFUNCTION insert_intervals(intervals: List of List of Integers, new_interval: List of Integers) -> List of List of Integers\n    DEFINE result AS an empty List of List of Integers\n    DEFINE i AS Integer, initialized to 0\n    \n    # Add all intervals that end before the new interval starts\n    WHILE i < LENGTH(intervals) AND intervals[i][1] < new_interval[0]\n        APPEND intervals[i] TO result\n        i = i + 1\n    \n    # Merge all overlapping intervals into new_interval\n    WHILE i < LENGTH(intervals) AND intervals[i][0] <= new_interval[1]\n        new_interval[0] = MIN(new_interval[0], intervals[i][0])\n        new_interval[1] = MAX(new_interval[1], intervals[i][1])\n        i = i + 1\n    \n    # Add the merged interval to the result\n    APPEND new_interval TO result\n    \n    # Add remaining intervals to the result\n    WHILE i < LENGTH(intervals)\n        APPEND intervals[i] TO result\n        i = i + 1\n    \n    RETURN result\n```\n\nThis pseudocode provides a clear and structured approach to solving the challenge of inserting and merging intervals.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-insert-interval"
    },
    {
        "name": "Length Of Last Word",
        "site": "LeetCode",
        "href": "/solution/LeetCode-length-of-last-word",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int length = 0;\n        int i = s.length() - 1;\n        \n        while (i >= 0 && s[i] == ' ') {\n            i--;\n        }\n        \n        while (i >= 0 && s[i] != ' ') {\n            length++;\n            i--;\n        }\n        \n        return length;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        String[] words = s.trim().split(\" \");\n        return words[words.length - 1].length();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        words = s.strip().split()\n        return len(words[-1]) if words else 0"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int lengthOfLastWord(char* s) {\n    int length = 0;\n    int i = strlen(s) - 1;\n    \n    while (i >= 0 && s[i] == ' ') {\n        i--;\n    }\n    \n    while (i >= 0 && s[i] != ' ') {\n        length++;\n        i--;\n    }\n    \n    return length;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LengthOfLastWord(string s) {\n        s = s.Trim();\n        int length = 0;\n        for (int i = s.Length - 1; i >= 0; i--) {\n            if (s[i] == ' ') {\n                break;\n            }\n            length++;\n        }\n        return length;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    const words = s.trim().split(\" \");\n    return words[words.length - 1].length;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function lengthOfLastWord(s: string): number {\n    const words = s.trim().split(' ');\n    return words[words.length - 1].length;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function lengthOfLastWord($s) {\n        $words = explode(\" \", trim($s));\n        return strlen(end($words));\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func lengthOfLastWord(_ s: String) -> Int {\n        let trimmedString = s.trimmingCharacters(in: .whitespaces)\n        guard let lastWord = trimmedString.components(separatedBy: \" \").last else { return 0 }\n        return lastWord.count\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun lengthOfLastWord(s: String): Int {\n        var length = 0\n        var i = s.length - 1\n        \n        while (i >= 0 && s[i] == ' ') {\n            i--\n        }\n        \n        while (i >= 0 && s[i] != ' ') {\n            length++\n            i--\n        }\n        \n        return length\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int lengthOfLastWord(String s) {\n    List<String> words = s.trim().split(\" \");\n    return words.last.length;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func lengthOfLastWord(s string) int {\n    length := 0\n    foundWord := false\n\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] != ' ' {\n            foundWord = true\n            length++\n        } else if foundWord {\n            break\n        }\n    }\n\n    return length\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef length_of_last_word(s)\n    words = s.split\n    words.empty? ? 0 : words.last.length\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def lengthOfLastWord(s: String): Int = {\n        s.trim.split(\" \").last.length\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn length_of_last_word(s: String) -> i32 {\n        let mut result = 0;\n        \n        for c in s.trim().chars().rev() {\n            if c == ' ' {\n                break;\n            }\n            result += 1;\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (length-of-last-word s)\n  (-> string? exact-integer?)\n  (let* ((words (regexp-match* #rx\"[a-zA-Z]+\" s))\n         (last-word (last-pair words)))\n    (if last-word\n        (string-length (car last-word))\n        0)))"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec length_of_last_word(s :: String.t) :: integer\n  def length_of_last_word(s) do\n    s\n    |> String.trim()\n    |> String.split(\" \")\n    |> Enum.reverse()\n    |> Enum.find(&(&1 != \"\"))\n    |> String.length()\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the length of the last word in a given string. We can accomplish this task by first removing any leading or trailing spaces from the string, and then dividing the string into individual words based on spaces. The last word from this list of words will give us the desired result.\n\n# Explanation\nThe steps to solve the problem are as follows:\n1. **Trim the String**: Use the `strip()` method to remove any leading and trailing spaces from the string.\n2. **Split the String**: Use the `split()` method to divide the string into a list of words where each word is a contiguous sequence of non-space characters.\n3. **Identify the Last Word**: The last element in the list of words will be the last word of the string.\n4. **Compute the Length**: Use the `len()` function to find the length of the last word, which is the desired output.\n\n# Pseudocode\nHere\u2019s the pseudocode to illustrate the solution:\n\n```\nfunction lengthOfLastWord(s):\n    # Step 1: Trim the input string to remove leading/trailing spaces\n    trimmed_string = s.strip()\n    \n    # Step 2: Split the trimmed string into a list of words\n    words = trimmed_string.split()\n    \n    # Step 3: Check if the list of words is not empty\n    if words is not empty:\n        # Get the last word from the list\n        last_word = words[-1]\n        \n        # Step 4: Return the length of the last word\n        return length(last_word)\n    else:\n        # If there are no words, return 0\n        return 0\n```\n\nThis method ensures we handle cases with multiple spaces appropriately and retrieves the last word\u2019s length efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-length-of-last-word"
    },
    {
        "name": "Spiral Matrix Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-spiral-matrix-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\n        int top = 0, bottom = n - 1, left = 0, right = n - 1;\n        int num = 1;\n\n        while (num <= n * n) {\n            for (int i = left; i <= right; i++) {\n                matrix[top][i] = num++;\n            }\n            top++;\n\n            for (int i = top; i <= bottom; i++) {\n                matrix[i][right] = num++;\n            }\n            right--;\n\n            for (int i = right; i >= left; i--) {\n                matrix[bottom][i] = num++;\n            }\n            bottom--;\n\n            for (int i = bottom; i >= top; i--) {\n                matrix[i][left] = num++;\n            }\n            left++;\n        }\n\n        return matrix;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] matrix = new int[n][n];\n        int num = 1;\n        int top = 0, bottom = n - 1, left = 0, right = n - 1;\n        \n        while(num <= n*n) {\n            for(int i = left; i <= right; i++) {\n                matrix[top][i] = num++;\n            }\n            top++;\n            \n            for(int i = top; i <= bottom; i++) {\n                matrix[i][right] = num++;\n            }\n            right--;\n            \n            for(int i = right; i >= left; i--) {\n                matrix[bottom][i] = num++;\n            }\n            bottom--;\n            \n            for(int i = bottom; i >= top; i--) {\n                matrix[i][left] = num++;\n            }\n            left++;\n        }\n        \n        return matrix;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def generateMatrix(self, n):\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        top, bottom, left, right = 0, n - 1, 0, n - 1\n        num = 1\n        \n        while num <= n * n:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, \nassume caller calls free().\n */\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {\n    int i, k = 1;\n    int **matrix = (int**)malloc(sizeof(int*) * n);\n    for (i = 0; i < n; i++) {\n        matrix[i] = (int*)malloc(sizeof(int) * n);\n    }\n\n    int top = 0, bottom = n - 1, left = 0, right = n - 1;\n    \n    while (k <= n * n) {\n        for (i = left; i <= right; i++) {\n            matrix[top][i] = k++;\n        }\n        top++;\n        \n        for (i = top; i <= bottom; i++) {\n            matrix[i][right] = k++;\n        }\n        right--;\n        \n        for (i = right; i >= left; i--) {\n            matrix[bottom][i] = k++;\n        }\n        bottom--;\n        \n        for (i = bottom; i >= top; i--) {\n            matrix[i][left] = k++;\n        }\n        left++;\n    }\n    \n    *returnSize = n;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++) {\n        (*returnColumnSizes)[i] = n;\n    }\n    \n    return matrix;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[][] GenerateMatrix(int n) {\n        int[][] matrix = new int[n][];\n        for (int i = 0; i < n; i++) {\n            matrix[i] = new int[n];\n        }\n        \n        int top = 0, bottom = n - 1, left = 0, right = n - 1;\n        int num = 1;\n        \n        while (num <= n * n) {\n            for (int i = left; i <= right; i++) {\n                matrix[top][i] = num++;\n            }\n            top++;\n            \n            for (int i = top; i <= bottom; i++) {\n                matrix[i][right] = num++;\n            }\n            right--;\n            \n            for (int i = right; i >= left; i--) {\n                matrix[bottom][i] = num++;\n            }\n            bottom--;\n            \n            for (int i = bottom; i >= top; i--) {\n                matrix[i][left] = num++;\n            }\n            left++;\n        }\n        \n        return matrix;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function generateMatrix(n: number): number[][] {\n    const matrix: number[][] = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    \n    let num = 1;\n    let top = 0, bottom = n - 1, left = 0, right = n - 1;\n    \n    while(num <= n * n) {\n        for(let i = left; i <= right; i++) {\n            matrix[top][i] = num++;\n        }\n        top++;\n        \n        for(let i = top; i <= bottom; i++) {\n            matrix[i][right] = num++;\n        }\n        right--;\n        \n        for(let i = right; i >= left; i--) {\n            matrix[bottom][i] = num++;\n        }\n        bottom--;\n        \n        for(let i = bottom; i >= top; i--) {\n            matrix[i][left] = num++;\n        }\n        left++;\n    }\n    \n    return matrix;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function generateMatrix($n) {\n        $matrix = array_fill(0, $n, array_fill(0, $n, 0));\n        $top = 0;\n        $bottom = $n - 1;\n        $left = 0;\n        $right = $n - 1;\n        $num = 1;\n        \n        while ($num <= $n * $n) {\n            for ($i = $left; $i <= $right; $i++) {\n                $matrix[$top][$i] = $num++;\n            }\n            $top++;\n            \n            for ($i = $top; $i <= $bottom; $i++) {\n                $matrix[$i][$right] = $num++;\n            }\n            $right--;\n            \n            for ($i = $right; $i >= $left; $i--) {\n                $matrix[$bottom][$i] = $num++;\n            }\n            $bottom--;\n            \n            for ($i = $bottom; $i >= $top; $i--) {\n                $matrix[$i][$left] = $num++;\n            }\n            $left++;\n        }\n        \n        return $matrix;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func generateMatrix(_ n: Int) -> [[Int]] {\n        var result = Array(repeating: Array(repeating: 0, count: n), count: n)\n        var top = 0, bottom = n - 1, left = 0, right = n - 1\n        var num = 1\n\n        while num <= n * n {\n            for i in stride(from: left, through: right, by: 1) {\n                result[top][i] = num\n                num += 1\n            }\n            top += 1\n\n            for i in stride(from: top, through: bottom, by: 1) {\n                result[i][right] = num\n                num += 1\n            }\n            right -= 1\n\n            for i in stride(from: right, through: left, by: -1) {\n                result[bottom][i] = num\n                num += 1\n            }\n            bottom -= 1\n\n            for i in stride(from: bottom, through: top, by: -1) {\n                result[i][left] = num\n                num += 1\n            }\n            left += 1\n        }\n\n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun generateMatrix(n: Int): Array<IntArray> {\n        val matrix = Array(n) { IntArray(n) }\n        var num = 1\n        var top = 0\n        var bottom = n - 1\n        var left = 0\n        var right = n - 1\n\n        while (num <= n * n) {\n            for (i in left..right) {\n                matrix[top][i] = num++\n            }\n            top++\n            for (i in top..bottom) {\n                matrix[i][right] = num++\n            }\n            right--\n            for (i in right downTo left) {\n                matrix[bottom][i] = num++\n            }\n            bottom--\n            for (i in bottom downTo top) {\n                matrix[i][left] = num++\n            }\n            left++\n        }\n\n        return matrix\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> generateMatrix(int n) {\n    List<List<int>> matrix = List.generate(n, (_) => List.filled(n, 0));\n    \n    int top = 0, bottom = n - 1, left = 0, right = n - 1;\n    int num = 1;\n    \n    while (num <= n * n) {\n      for (int i = left; i <= right; i++) {\n        matrix[top][i] = num++;\n      }\n      top++;\n      \n      for (int i = top; i <= bottom; i++) {\n        matrix[i][right] = num++;\n      }\n      right--;\n      \n      for (int i = right; i >= left; i--) {\n        matrix[bottom][i] = num++;\n      }\n      bottom--;\n      \n      for (int i = bottom; i >= top; i--) {\n        matrix[i][left] = num++;\n      }\n      left++;\n    }\n    \n    return matrix;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func generateMatrix(n int) [][]int {\n    matrix := make([][]int, n)\n    for i := range matrix {\n        matrix[i] = make([]int, n)\n    }\n\n    num := 1\n    top, bottom, left, right := 0, n-1, 0, n-1\n\n    for num <= n*n {\n        for i := left; i <= right; i++ {\n            matrix[top][i] = num\n            num++\n        }\n        top++\n\n        for i := top; i <= bottom; i++ {\n            matrix[i][right] = num\n            num++\n        }\n        right--\n\n        for i := right; i >= left; i-- {\n            matrix[bottom][i] = num\n            num++\n        }\n        bottom--\n\n        for i := bottom; i >= top; i-- {\n            matrix[i][left] = num\n            num++\n        }\n        left++\n    }\n\n    return matrix\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer[][]}\ndef generate_matrix(n)\n    matrix = Array.new(n) { Array.new(n, 0) }\n    top = 0\n    bottom = n - 1\n    left = 0\n    right = n - 1\n    num = 1\n\n    while top <= bottom && left <= right\n        left.upto(right) do |i|\n            matrix[top][i] = num\n            num += 1\n        end\n        top += 1\n\n        top.upto(bottom) do |i|\n            matrix[i][right] = num\n            num += 1\n        end\n        right -= 1\n\n        if top <= bottom\n            right.downto(left) do |i|\n                matrix[bottom][i] = num\n                num += 1\n            end\n            bottom -= 1\n        end\n\n        if left <= right\n            bottom.downto(top) do |i|\n                matrix[i][left] = num\n                num += 1\n            end\n            left += 1\n        end\n    end\n\n    matrix\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def generateMatrix(n: Int): Array[Array[Int]] = {\n        val matrix = Array.ofDim[Int](n, n)\n        var top = 0\n        var bottom = n - 1\n        var left = 0\n        var right = n - 1\n        var num = 1\n\n        while (num <= n * n) {\n            for (i <- left to right) {\n                matrix(top)(i) = num\n                num += 1\n            }\n            top += 1\n\n            for (i <- top to bottom) {\n                matrix(i)(right) = num\n                num += 1\n            }\n            right -= 1\n\n            for (i <- right to left by -1) {\n                matrix(bottom)(i) = num\n                num += 1\n            }\n            bottom -= 1\n\n            for (i <- bottom to top by -1) {\n                matrix(i)(left) = num\n                num += 1\n            }\n            left += 1\n        }\n\n        matrix\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {\n        let mut matrix = vec![vec![0; n as usize]; n as usize];\n        let (mut top, mut bottom, mut left, mut right) = (0, n as usize - 1, 0, n as usize - 1);\n        let mut num = 1;\n\n        while num <= n * n {\n            for i in left..=right {\n                matrix[top][i] = num;\n                num += 1;\n            }\n            top += 1;\n\n            for i in top..=bottom {\n                matrix[i][right] = num;\n                num += 1;\n            }\n            right -= 1;\n\n            if top <= bottom {\n                for i in (left..=right).rev() {\n                    matrix[bottom][i] = num;\n                    num += 1;\n                }\n                bottom -= 1;\n            }\n\n            if left <= right {\n                for i in (top..=bottom).rev() {\n                    matrix[i][left] = num;\n                    num += 1;\n                }\n                left += 1;\n            }\n        }\n\n        matrix\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate an \\( n \\times n \\) matrix filled with integers from 1 to \\( n^2 \\) in a spiral order. The challenge involves filling the matrix layer by layer, starting from the outermost layer and moving inward.\n\n# Explanation\n1. Initialize the matrix with zeros.\n2. Define the boundaries for the spiral traversal: `top`, `bottom`, `left`, and `right`.\n3. Use a while loop to fill the matrix until the value `num` exceeds \\( n^2 \\).\n4. Traverse the matrix in the following order:\n   - From left to right in the top row, then move the `top` boundary down.\n   - From top to bottom in the right column, then move the `right` boundary left.\n   - From right to left in the bottom row, then move the `bottom` boundary up.\n   - From bottom to top in the left column, then move the `left` boundary right.\n5. Continue this process until all elements are filled.\n\n# Pseudocode\n```\nfunction generateSpiralMatrix(n):\n    # Step 1: Initialize the matrix with zeros\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Step 2: Define initial boundaries\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    num = 1\n    \n    # Step 3: Fill the matrix in spiral order\n    while num <= n * n:\n        # Traverse from left to right in the top row\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        \n        # Traverse from top to bottom in the right column\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        # Traverse from right to left in the bottom row\n        for i in range(right, left - 1, -1):\n            matrix[bottom][i] = num\n            num += 1\n        bottom -= 1\n        \n        # Traverse from bottom to top in the left column\n        for i in range(bottom, top - 1, -1):\n            matrix[i][left] = num\n            num += 1\n        left += 1\n    \n    return matrix\n```\n\nThis pseudocode outlines how to fill the matrix in a spiral order by adjusting the boundaries and incrementing the value at each step. It methodically spirals inward until the entire matrix is filled.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-spiral-matrix-ii"
    },
    {
        "name": "Permutation Sequence",
        "site": "LeetCode",
        "href": "/solution/LeetCode-permutation-sequence",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector<int> nums;\n        for(int i = 1; i <= n; i++) {\n            nums.push_back(i);\n        }\n        \n        string result;\n        int fac = 1;\n        for(int i = 2; i < n; i++) {\n            fac *= i;\n        }\n        k--;\n        \n        while(n > 0) {\n            int index = k / fac;\n            result += to_string(nums[index]);\n            nums.erase(nums.begin() + index);\n            k %= fac;\n            if(n > 1) {\n                fac /= (n-1);\n            }\n            n--;\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        List<Integer> numbers = new ArrayList<>();\n        int[] factorial = new int[n + 1];\n        StringBuilder sb = new StringBuilder();\n        \n        int sum = 1;\n        factorial[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            sum *= i;\n            factorial[i] = sum;\n            numbers.add(i);\n        }\n        \n        k--;\n        \n        for (int i = 1; i <= n; i++) {\n            int index = k / factorial[n - i];\n            sb.append(numbers.get(index));\n            numbers.remove(index);\n            k -= index * factorial[n - i];\n        }\n        \n        return sb.toString();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def getPermutation(self, n, k):\n        def getFactorial(num):\n            result = 1\n            for i in range(1, num+1):\n                result *= i\n            return result\n        \n        nums = [str(i) for i in range(1, n+1)]\n        factorial = getFactorial(n)\n        k -= 1\n        result = \"\"\n        \n        while n > 0:\n            factorial //= n\n            index = k // factorial\n            result += nums.pop(index)\n            k %= factorial\n            n -= 1\n        \n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string GetPermutation(int n, int k) {\n        List<int> numbers = new List<int>();\n        for (int i = 1; i <= n; i++) {\n            numbers.Add(i);\n        }\n        \n        int[] factorial = new int[n + 1];\n        factorial[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        \n        k--;\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 1; i <= n; i++) {\n            int index = k / factorial[n - i];\n            sb.Append(numbers[index]);\n            numbers.RemoveAt(index);\n            k -= index * factorial[n - i];\n        }\n        \n        return sb.ToString();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n    const nums = Array.from({ length: n }, (_, index) => index + 1);\n    let result = '';\n    k--;\n    \n    while (n > 0) {\n        const factorial = factorialize(n - 1);\n        const index = Math.floor(k / factorial);\n        result += nums[index];\n        nums.splice(index, 1);\n        k %= factorial;\n        n--;\n    }\n    \n    return result;\n    \n    function factorialize(num) {\n        if (num <= 1) {\n            return 1;\n        }\n        return num * factorialize(num - 1);\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function getPermutation(n: number, k: number): string {\n    const nums = Array.from({ length: n }, (_, index) => index + 1);\n    let result = '';\n    \n    const factorial = (num: number): number => {\n        let res = 1;\n        for (let i = 1; i <= num; i++) {\n            res *= i;\n        }\n        return res;\n    };\n    \n    k--;\n    while (nums.length > 0) {\n        const fact = factorial(nums.length - 1);\n        const index = Math.floor(k / fact);\n        result += String(nums[index]);\n        nums.splice(index, 1);\n        k %= fact;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    function getPermutation($n, $k) {\n        $fact = 1;\n        $nums = [];\n        for ($i = 1; $i <= $n; $i++) {\n            $fact *= $i;\n            $nums[] = $i;\n        }\n        $k--;\n        $result = \"\";\n        \n        while ($n > 0) {\n            $fact = $fact / $n;\n            $index = (int)($k / $fact);\n            $result .= strval($nums[$index]);\n            array_splice($nums, $index, 1);\n            $k %= $fact;\n            $n--;\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return String\n     */\n    func getPermutation(_ n: Int, _ k: Int) -> String {\n        var fact = 1\n        for i in 1...n {\n            fact *= i\n        }\n        \n        var nums = [Int](1...n)\n        var k = k - 1\n        \n        var result = \"\"\n        for i in 0..<n {\n            fact = fact / (n - i)\n            let index = k / fact\n            k = k % fact\n            \n            result += String(nums.remove(at: index))\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String getPermutation(int n, int k) {\n    List<int> numbers = List.generate(n, (index) => index + 1);\n\n    List<int> factorials = [1];\n    for (int i = 1; i <= n; i++) {\n      factorials.add(factorials[i - 1] * i);\n    }\n\n    k--;\n\n    String result = '';\n    for (int i = n - 1; i >= 0; i--) {\n      int index = k ~/ factorials[i];\n      k %= factorials[i];\n      result += numbers[index].toString();\n      numbers.removeAt(index);\n    }\n\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func getPermutation(n int, k int) string {\n    factorial := make([]int, n+1)\n    factorial[0] = 1\n    nums := make([]int, n)\n    for i := 1; i <= n; i++ {\n        factorial[i] = factorial[i-1] * i\n        nums[i-1] = i\n    }\n    \n    k-- \n    var result strings.Builder\n    for i := 1; i <= n; i++ {\n        index := k / factorial[n-i]\n        result.WriteString(strconv.Itoa(nums[index]))\n        nums = append(nums[:index], nums[index+1:]...)\n        k -= index * factorial[n-i]\n    }\n    \n    return result.String()\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {String}\ndef get_permutation(n, k)\n    nums = (1..n).to_a\n    result = \"\"\n    k -= 1\n    \n    while n > 0\n        n -= 1\n        index = k / factorial(n)\n        k %= factorial(n)\n        result += nums.delete_at(index).to_s\n    end\n    \n    result\nend\n\ndef factorial(n)\n    n <= 1 ? 1 : n * factorial(n - 1)\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn get_permutation(n: i32, k: i32) -> String {\n        let mut nums: Vec<i32> = (1..=n).collect();\n        let mut factorial: Vec<i32> = vec![1; n as usize];\n\n        for i in 1..n as usize {\n            factorial[i] = factorial[i - 1] * i as i32;\n        }\n\n        let mut k = k - 1;\n        let mut result = String::new();\n\n        for i in (0..n as usize).rev() {\n            let index = (k / factorial[i]) as usize;\n            k %= factorial[i];\n            result.push_str(&nums[index].to_string());\n            nums.remove(index);\n        }\n\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the kth permutation sequence of numbers from 1 to n. The algorithm we use leverages some mathematical concepts about permutations and factorials to efficiently find the permutation without generating all the permutations.\n\n# Explanation\n\n1. **Factorials:** We need to understand that the total number of permutations of n elements is n!. This means if `n = 3`, we have 3! = 6 permutations.\n2. **Understanding K:** Given a k, we need to determine which digits should appear in each position of the permutation sequence. This can be done by utilizing the properties of factorial.\n3. **Reduce the Problem Scope:** By breaking down the problem step by step, we can reduce the size of `n` and adjust `k` iteratively.\n4. **List Management:** Start with a list of numbers from 1 to n. Use the index obtained by dividing `k` by factorial to determine which number goes to the current position and then remove it from the list.\n\n# Pseudocode\n\n```plaintext\nfunction getPermutation(n, k):\n    # Helper function to calculate factorial\n    function getFactorial(num):\n        result = 1\n        for i from 1 to num inclusive:\n            result *= i\n        return result\n    \n    # Generate the initial list of numbers\n    nums = list of strings [\"1\", \"2\", ..., str(n)]\n    \n    # Calculate factorial of n\n    factorial = getFactorial(n)\n    \n    # Adjust k to be zero-indexed\n    k = k - 1\n    \n    # Initialize an empty result string\n    result = \"\"\n    \n    while n > 0:\n        # Update factorial to be the factorial of (n-1)\n        factorial = factorial // n\n        \n        # Determine the index of the current number\n        index = k // factorial\n        \n        # Append the chosen number to the result\n        result += nums[index]\n        \n        # Remove the chosen number from the list\n        nums.remove(nums[index])\n        \n        # Update k for the next iteration\n        k = k % factorial\n        \n        # Decrease n as we have considered one number\n        n = n - 1\n    \n    return result\n```\n\nThis pseudocode outlines the logical steps needed to construct the required permutation sequence directly without generating all possibilities. Each loop iteration narrows down the choices based on factorial division, directly finding the k-th permutation sequence.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-permutation-sequence"
    },
    {
        "name": "Rotate List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-rotate-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next || k == 0) return head;\n        \n        int len = 1;\n        ListNode *tail = head;\n        while (tail->next) {\n            len++;\n            tail = tail->next;\n        }\n        \n        k = k % len;\n        if (k == 0) return head;\n        \n        ListNode *newTail = head;\n        for (int i = 0; i < len - k - 1; i++) {\n            newTail = newTail->next;\n        }\n        \n        ListNode *newHead = newTail->next;\n        newTail->next = nullptr;\n        tail->next = head;\n        \n        return newHead;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        \n        int length = 1;\n        ListNode curr = head;\n        while (curr.next != null) {\n            length++;\n            curr = curr.next;\n        }\n        curr.next = head;\n        \n        k = k % length;\n        for (int i = 0; i < length - k; i++) {\n            curr = curr.next;\n        }\n        \n        ListNode newHead = curr.next;\n        curr.next = null;\n        \n        return newHead;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def rotateRight(self, head, k):\n        if not head or not head.next or k == 0:\n            return head\n        \n        # calculate the length of the linked list\n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        # connect the last node with the head to make it a circular linked list\n        curr.next = head\n        \n        # find kth node from the end (length - k % length) and set it as the new head\n        new_head_index = length - k % length - 1\n        new_head = head\n        for _ in range(new_head_index):\n            new_head = new_head.next\n        \n        # update the new head and break the circular linked list\n        head = new_head.next\n        new_head.next = None\n        \n        return head"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* rotateRight(struct ListNode* head, int k) {\n    if (head == NULL || head->next == NULL || k == 0) {\n        return head;\n    }\n    \n    int length = 1;\n    struct ListNode* current = head;\n    while (current->next != NULL) {\n        current = current->next;\n        length++;\n    }\n    \n    current->next = head;\n    k = k % length;\n    \n    for (int i = 0; i < length - k; i++) {\n        current = current->next;\n    }\n    \n    head = current->next;\n    current->next = NULL;\n    \n    return head;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        \n        // Get the length of the list\n        int length = 1;\n        ListNode temp = head;\n        while (temp.next != null) {\n            temp = temp.next;\n            length++;\n        }\n        \n        k = k % length;\n        if (k == 0) {\n            return head;\n        }\n        \n        // Connect the last node to the head to create a loop\n        temp.next = head;\n        \n        // Find the new head and break the loop\n        k = length - k;\n        for (int i = 0; i < k; i++) {\n            temp = temp.next;\n        }\n        ListNode newHead = temp.next;\n        temp.next = null;\n        \n        return newHead;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || k === 0) {\n        return head;\n    }\n    \n    let current = head;\n    let length = 1;\n    while (current.next) {\n        current = current.next;\n        length++;\n    }\n    \n    current.next = head;\n    \n    let newTail = head;\n    for (let i = 0; i < length - k % length - 1; i++) {\n        newTail = newTail.next;\n    }\n    \n    let newHead = newTail.next;\n    newTail.next = null;\n    \n    return newHead;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n */\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if (!head || !head.next || k === 0) {\n        return head;\n    }\n    \n    let length = 1;\n    let tail = head;\n    while (tail.next) {\n        tail = tail.next;\n        length++;\n    }\n    \n    k = k % length;\n    if (k === 0) {\n        return head;\n    }\n    \n    let newTail = head;\n    for (let i = 1; i < length - k; i++) {\n        newTail = newTail.next;\n    }\n    \n    const newHead = newTail.next;\n    newTail.next = null;\n    tail.next = head;\n    \n    return newHead;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n */\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function rotateRight($head, $k) {\n        if (!$head || !$head->next || $k === 0) return $head;\n        \n        $length = 1;\n        $tail = $head;\n        while ($tail->next) {\n            $tail = $tail->next;\n            $length++;\n        }\n        \n        $k = $k % $length;\n        if ($k === 0) return $head;\n        \n        $newTail = $head;\n        for ($i = 0; $i < $length - $k - 1; $i++) {\n            $newTail = $newTail->next;\n        }\n        \n        $newHead = $newTail->next;\n        $newTail->next = null;\n        $tail->next = $head;\n        \n        return $newHead;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val;\n *         self.next = next;\n *     }\n * }\n */\n \nclass Solution {\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\n        if head == nil || k == 0 {\n            return head\n        }\n        \n        var length = 1\n        var tail = head\n        \n        while tail?.next != nil {\n            length += 1\n            tail = tail?.next\n        }\n        \n        let steps = length - k % length\n        tail?.next = head\n        \n        var newTail = tail\n        var newHead = head\n        \n        for _ in 0..<steps {\n            newTail = newHead\n            newHead = newHead?.next\n        }\n        \n        newTail?.next = nil\n        \n        return newHead\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if head == nil || head.Next == nil || k == 0 {\n        return head\n    }\n    \n    cur := head\n    length := 1\n    for cur.Next != nil {\n        cur = cur.Next\n        length++\n    }\n    cur.Next = head\n    \n    k = k % length\n    for i := 0; i < length-k; i++ {\n        cur = cur.Next\n    }\n    \n    newHead := cur.Next\n    cur.Next = nil\n    \n    return newHead\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n\ndef rotate_right(head, k)\n    return head if head.nil? || head.next.nil? || k == 0\n    dummy = ListNode.new(0)\n    dummy.next = head\n    current = head\n    length = 1\n    \n    while current.next\n        current = current.next\n        length += 1\n    end\n    \n    k = k % length\n    return head if k == 0\n    \n    fast = slow = head\n    (1..k).each do\n        fast = fast.next\n    end\n    \n    while fast.next\n        slow = slow.next\n        fast = fast.next\n    end\n    \n    new_head = slow.next\n    slow.next = nil\n    fast.next = head\n    new_head\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def rotateRight(head: ListNode, k: Int): ListNode = {\n        if (head == null || head.next == null || k == 0) return head\n        \n        var length = 1\n        var tail = head\n        while (tail.next != null) {\n            tail = tail.next\n            length += 1\n        }\n        \n        var newK = k % length\n        if (newK == 0) return head\n        \n        var fast = head\n        var slow = head\n        for (_ <- 0 until newK) {\n            fast = fast.next\n        }\n        \n        while (fast.next != null) {\n            fast = fast.next\n            slow = slow.next\n        }\n        \n        val newHead = slow.next\n        slow.next = null\n        fast.next = head\n        \n        newHead\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to rotate the linked list to the right by a given number of positions, k. Here\u2019s a step-by-step approach:\n\n# Explanation\n1. **Handle Edge Cases**:\n   - If the linked list is empty (`head` is `None`).\n   - If the linked list has only one node (`head.next` is `None`).\n   - If `k` is zero.\n\n2. **Calculate the Length of the Linked List**:\n   - Traverse the linked list to find its length.\n   - While traversing, keep a note of the last node to facilitate making the list circular.\n\n3. **Make the List Circular**:\n   - Connect the last node's `next` to the `head`, thus forming a circular linked list.\n\n4. **Find the New Tail and Break the Circular Link**:\n   - Calculate the effective number of rotations needed by taking `k % length`.\n   - Find the node that should become the new tail, which is at the position `length - k % length - 1` from the beginning.\n   - Set the node next to the new tail as the new head.\n   - Break the circular link by setting the new tail's `next` to `None`.\n\n# Pseudocode\n```text\nfunction rotateRight(head, k):\n    if head is null or head.next is null or k == 0:\n        return head\n\n    # Calculate the length of the linked list\n    length = 1\n    curr = head\n    while curr.next is not null:\n        curr = curr.next\n        length += 1\n\n    # Connect the last node with the head to make it a circular linked list\n    curr.next = head\n    \n    # Find the new head and new tail\n    new_tail_index = length - k % length - 1\n    new_tail = head\n    for i from 0 to new_tail_index - 1:\n        new_tail = new_tail.next\n\n    new_head = new_tail.next\n    \n    # Update the new tail's next to None to break the circular link\n    new_tail.next = None\n\n    return new_head\n```\n\nThis pseudocode outlines the steps required to rotate the linked list and handles different scenarios appropriately. Ensure the algorithm efficiently handles large values of `k` by reducing the number of required rotations through the modulus operation.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-rotate-list"
    },
    {
        "name": "Unique Paths",
        "site": "LeetCode",
        "href": "/solution/LeetCode-unique-paths",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        \n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1;\n        }\n        \n        for (int j = 0; j < n; j++) {\n            dp[0][j] = 1;\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def uniquePaths(self, m, n):\n        dp = [[1] * n for _ in range(m)]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[-1][-1]\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int uniquePaths(int m, int n) {\n    int dp[m][n];\n    \n    for(int i = 0; i < m; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for(int j = 0; j < n; j++) {\n        dp[0][j] = 1;\n    }\n    \n    for(int i = 1; i < m; i++) {\n        for(int j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int UniquePaths(int m, int n) {\n        int[,] dp = new int[m,n];\n        \n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(i == 0 || j == 0){\n                    dp[i,j] = 1;\n                } else{\n                    dp[i,j] = dp[i-1,j] + dp[i,j-1];\n                }\n            }\n        }\n        \n        return dp[m-1,n-1];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    const dp = new Array(m).fill(1).map(() => new Array(n).fill(1));\n    \n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    \n    return dp[m - 1][n - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function uniquePaths(m: number, n: number): number {\n    const dp: number[][] = new Array(m).fill(0).map(() => new Array(n).fill(1));\n\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @return Integer\n     */\n    function uniquePaths($m, $n) {\n        $dp = array_fill(0, $m, array_fill(0, $n, 1));\n\n        for ($i = 1; $i < $m; $i++) {\n            for ($j = 1; $j < $n; $j++) {\n                $dp[$i][$j] = $dp[$i - 1][$j] + $dp[$i][$j - 1];\n            }\n        }\n\n        return $dp[$m - 1][$n - 1];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func uniquePaths(_ m: Int, _ n: Int) -> Int {\n        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                if i == 0 || j == 0 {\n                    dp[i][j] = 1\n                } else {\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                }\n            }\n        }\n        \n        return dp[m-1][n-1]\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun uniquePaths(m: Int, n: Int): Int {\n        val dp = Array(m) { IntArray(n) { 1 } }\n        \n        for (i in 1 until m) {\n            for (j in 1 until n) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            }\n        }\n        \n        return dp[m - 1][n - 1]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int uniquePaths(int m, int n) {\n    List<List<int>> dp = List.generate(m, (_) => List.filled(n, 1));\n    \n    for (int i = 1; i < m; i++) {\n      for (int j = 1; j < n; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n    \n    return dp[m - 1][n - 1];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func uniquePaths(m int, n int) int {\n    dp := make([][]int, m)\n    for i := range dp {\n        dp[i] = make([]int, n)\n        dp[i][0] = 1\n    }\n    for j := 0; j < n; j++ {\n        dp[0][j] = 1\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        }\n    }\n    return dp[m-1][n-1]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} m\n# @param {Integer} n\n# @return {Integer}\ndef unique_paths(m, n)\n    dp = Array.new(m) { Array.new(n, 1) }\n    \n    (1...m).each do |i|\n        (1...n).each do |j|\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        end\n    end\n    \n    dp[m - 1][n - 1]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def uniquePaths(m: Int, n: Int): Int = {\n        val dp = Array.ofDim[Int](m, n)\n        \n        for (i <- 0 until m) {\n            dp(i)(0) = 1\n        }\n        \n        for (j <- 0 until n) {\n            dp(0)(j) = 1\n        }\n        \n        for (i <- 1 until m) {\n            for (j <- 1 until n) {\n                dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)\n            }\n        }\n        \n        dp(m - 1)(n - 1)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\n        let mut dp = vec![vec![0; n as usize]; m as usize];\n        \n        for i in 0..m as usize {\n            for j in 0..n as usize {\n                if i == 0 || j == 0 {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                }\n            }\n        }\n        \n        dp[m as usize - 1][n as usize - 1]\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (unique-paths m n)\n  (-> exact-integer? exact-integer? exact-integer?)\n  (if (or (= m 1) (= n 1))\n      1\n      (+ (unique-paths (- m 1) n) (unique-paths m (- n 1)))\n      )\n  )"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you can use dynamic programming to compute the number of unique paths that the robot can take to reach from the top-left to the bottom-right corner of the grid.\n\n# Explanation\n1. **Problem Understanding**:\n   - The robot is initially at the top-left corner (0,0).\n   - It can only move either right or down.\n   - It needs to reach the bottom-right corner (m-1, n-1).\n   - The task is to determine the number of unique paths to get there.\n\n2. **Dynamic Programming Approach**:\n   - We'll maintain a 2D list `dp` where `dp[i][j]` will store the number of unique paths to reach cell (i, j).\n   - Initialize the first row and first column with 1s because there's only one way to reach any cell in the first row (all rights) or the first column (all downs).\n   - For each cell `dp[i][j]`, the number of ways to get to that cell is the sum of the ways to get to the cell directly above it (`dp[i-1][j]`) and the ways to get to the cell directly to its left (`dp[i][j-1]`).\n\n3. **Time and Space Complexity**:\n   - The time complexity is O(m*n) because we are using nested loops to fill the array.\n   - The space complexity is also O(m*n) because we maintain a 2D list to store the paths count.\n\n# Pseudocode\n```\n# Function to calculate unique paths\ndef uniquePaths(m, n):\n    # Create a 2D list dp with size m x n, initialized to 1\n    dp = [[1] * n for _ in range(m)]\n    \n    # Iterate over the grid starting from (1,1) to (m-1, n-1)\n    for i in range(1, m):\n        for j in range(1, n):\n            # The number of ways to reach dp[i][j] is the sum of ways to reach dp[i-1][j] and dp[i][j-1]\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    # The bottom-right corner will have the number of unique paths\n    return dp[m-1][n-1]\n\n# Example usage\nm = 3\nn = 7\nprint(uniquePaths(m, n))  # Output: 28\n```\n\nIn this pseudocode:\n- We initialize the `dp` array with ones because there is only one way to traverse the first row and the first column.\n- We iterate through the array starting from the second row and second column, updating each cell with the sum of the value from the cell above and the cell to the left, effectively computing the number of unique paths to that cell.\n- Finally, we return the value at `dp[m-1][n-1]`, which contains the total number of unique paths to the bottom-right corner.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-unique-paths"
    },
    {
        "name": "Unique Paths Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-unique-paths-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        \n        vector<vector<long long>> dp(m, vector<long long>(n, 0));\n        \n        dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;\n        \n        for (int i = 1; i < m; i++) {\n            dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i - 1][0] : 0;\n        }\n        \n        for (int j = 1; j < n; j++) {\n            dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j - 1] : 0;\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (obstacleGrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        \n        return dp[m - 1][n - 1];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) {\n            return 0;\n        }\n\n        int[][] dp = new int[m][n];\n        dp[0][0] = 1;\n\n        for (int i = 1; i < m; i++) {\n            dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0];\n        }\n\n        for (int j = 1; j < n; j++) {\n            dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j-1];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1];\n            }\n        }\n\n        return dp[m-1][n-1];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i - 1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j - 1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[-1][-1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize) {\n    int m = obstacleGridSize;\n    int n = obstacleGridColSize[0];\n    \n    int dp[m][n];\n    memset(dp, 0, sizeof(dp));\n    \n    for(int i = 0; i < m; i++){\n        if(obstacleGrid[i][0] == 1) break;\n        dp[i][0] = 1;\n    }\n    \n    for(int i = 0; i < n; i++){\n        if(obstacleGrid[0][i] == 1) break;\n        dp[0][i] = 1;\n    }\n    \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            if(obstacleGrid[i][j] == 1) continue;\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    \n    return dp[m-1][n-1];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.Length;\n        int n = obstacleGrid[0].Length;\n        \n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) {\n            return 0;\n        }\n        \n        int[,] dp = new int[m, n];\n        dp[0, 0] = 1;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[i, j] = 0;\n                } else {\n                    if (i > 0) {\n                        dp[i, j] += dp[i-1, j];\n                    }\n                    if (j > 0) {\n                        dp[i, j] += dp[i, j-1];\n                    }\n                }\n            }\n        }\n        \n        return dp[m-1, n-1];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;\n    \n    if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) {\n        return 0;\n    }\n    \n    obstacleGrid[0][0] = 1;\n    \n    for (let i = 1; i < m; i++) {\n        obstacleGrid[i][0] = (obstacleGrid[i][0] === 0 && obstacleGrid[i - 1][0] === 1) ? 1 : 0;\n    }\n    \n    for (let j = 1; j < n; j++) {\n        obstacleGrid[0][j] = (obstacleGrid[0][j] === 0 && obstacleGrid[0][j - 1] === 1) ? 1 : 0;\n    }\n    \n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            if (obstacleGrid[i][j] === 0) {\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\n            } else {\n                obstacleGrid[i][j] = 0;\n            }\n        }\n    }\n    \n    return obstacleGrid[m - 1][n - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;\n    \n    if (obstacleGrid[0][0] === 1) {\n        return 0;\n    }\n    \n    obstacleGrid[0][0] = 1;\n    \n    for (let i = 1; i < m; i++) {\n        obstacleGrid[i][0] = obstacleGrid[i][0] === 0 && obstacleGrid[i - 1][0] === 1 ? 1 : 0;\n    }\n    \n    for (let j = 1; j < n; j++) {\n        obstacleGrid[0][j] = obstacleGrid[0][j] === 0 && obstacleGrid[0][j - 1] === 1 ? 1 : 0;\n    }\n    \n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            if (obstacleGrid[i][j] === 0) {\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\n            } else {\n                obstacleGrid[i][j] = 0;\n            }\n        }\n    }\n    \n    return obstacleGrid[m - 1][n - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $obstacleGrid\n     * @return Integer\n     */\n    function uniquePathsWithObstacles($obstacleGrid) {\n        $m = count($obstacleGrid);\n        $n = count($obstacleGrid[0]);\n        \n        $dp = array_fill(0, $m, array_fill(0, $n, 0));\n        \n        for ($i = 0; $i < $m; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($obstacleGrid[$i][$j] == 1) {\n                    $dp[$i][$j] = 0;\n                } else {\n                    if ($i == 0 && $j == 0) {\n                        $dp[$i][$j] = 1;\n                    } else {\n                        $fromLeft = $j - 1 >= 0 ? $dp[$i][$j - 1] : 0;\n                        $fromUp = $i - 1 >= 0 ? $dp[$i - 1][$j] : 0;\n                        $dp[$i][$j] = $fromLeft + $fromUp;\n                    }\n                }\n            }\n        }\n        \n        return $dp[$m - 1][$n - 1];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\n        let m = obstacleGrid.count\n        let n = obstacleGrid[0].count\n        \n        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                if obstacleGrid[i][j] == 1 {\n                    dp[i][j] = 0\n                } else if i == 0 && j == 0 {\n                    dp[i][j] = 1\n                } else if i == 0 {\n                    dp[i][j] = dp[i][j - 1]\n                } else if j == 0 {\n                    dp[i][j] = dp[i - 1][j]\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                }\n            }\n        }\n        \n        return dp[m - 1][n - 1]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        val m = obstacleGrid.size\n        val n = obstacleGrid[0].size\n        val dp = Array(m) { IntArray(n) }\n\n        if (obstacleGrid[0][0] == 1) {\n            return 0\n        }\n\n        dp[0][0] = 1\n\n        for (i in 1 until m) {\n            dp[i][0] = if (obstacleGrid[i][0] == 1) 0 else dp[i - 1][0]\n        }\n\n        for (j in 1 until n) {\n            dp[0][j] = if (obstacleGrid[0][j] == 1) 0 else dp[0][j - 1]\n        }\n\n        for (i in 1 until m) {\n            for (j in 1 until n) {\n                dp[i][j] = if (obstacleGrid[i][j] == 1) 0 else dp[i - 1][j] + dp[i][j - 1]\n            }\n        }\n\n        return dp[m - 1][n - 1]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int uniquePathsWithObstacles(List<List<int>> obstacleGrid) {\n    int m = obstacleGrid.length;\n    int n = obstacleGrid[0].length;\n    \n    List<List<int>> dp = List.generate(m, (index) => List.filled(n, 0));\n    \n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (obstacleGrid[i][j] == 1) {\n          dp[i][j] = 0;\n        } else if (i == 0 && j == 0) {\n          dp[i][j] = 1;\n        } else if (i == 0) {\n          dp[i][j] = dp[i][j - 1];\n        } else if (j == 0) {\n          dp[i][j] = dp[i - 1][j];\n        } else {\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n      }\n    }\n    \n    return dp[m - 1][n - 1];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func uniquePathsWithObstacles(obstacleGrid [][]int) int {\n    m := len(obstacleGrid)\n    n := len(obstacleGrid[0])\n\n    dp := make([][]int, m)\n    for i := range dp {\n        dp[i] = make([]int, n)\n    }\n\n    for i := 0; i < m && obstacleGrid[i][0] == 0; i++ {\n        dp[i][0] = 1\n    }\n\n    for j := 0; j < n && obstacleGrid[0][j] == 0; j++ {\n        dp[0][j] = 1\n    }\n\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            if obstacleGrid[i][j] == 0 {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n    }\n\n    return dp[m-1][n-1]\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} obstacle_grid\n# @return {Integer}\ndef unique_paths_with_obstacles(obstacle_grid)\n    m = obstacle_grid.length\n    n = obstacle_grid[0].length\n    \n    dp = Array.new(m) { Array.new(n, 0) }\n    \n    (0...m).each do |i|\n        break if obstacle_grid[i][0] == 1\n        dp[i][0] = 1\n    end\n    \n    (0...n).each do |j|\n        break if obstacle_grid[0][j] == 1\n        dp[0][j] = 1\n    end\n    \n    (1...m).each do |i|\n        (1...n).each do |j|\n            dp[i][j] = obstacle_grid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1]\n        end\n    end\n    \n    return dp[m - 1][n - 1]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def uniquePathsWithObstacles(obstacleGrid: Array[Array[Int]]): Int = {\n        val m = obstacleGrid.length\n        val n = obstacleGrid(0).length\n        val dp = Array.ofDim[Int](m, n)\n        \n        if (obstacleGrid(0)(0) == 1) return 0\n        \n        dp(0)(0) = 1\n        \n        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n                if (obstacleGrid(i)(j) == 1) {\n                    dp(i)(j) = 0\n                } else {\n                    if (i > 0) dp(i)(j) += dp(i - 1)(j)\n                    if (j > 0) dp(i)(j) += dp(i)(j - 1)\n                }\n            }\n        }\n        \n        dp(m - 1)(n - 1)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        let m = obstacle_grid.len();\n        let n = obstacle_grid[0].len();\n        \n        let mut dp = vec![vec![0; n]; m];\n        \n        for i in 0..m {\n            if obstacle_grid[i][0] == 1 {\n                break;\n            } else {\n                dp[i][0] = 1;\n            }\n        }\n        \n        for j in 0..n {\n            if obstacle_grid[0][j] == 1 {\n                break;\n            } else {\n                dp[0][j] = 1;\n            }\n        }\n        \n        for i in 1..m {\n            for j in 1..n {\n                if obstacle_grid[i][j] == 0 {\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                }\n            }\n        }\n        \n        dp[m-1][n-1]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the number of unique paths a robot can take from the top-left corner to the bottom-right corner of a grid, avoiding obstacles along the way. The obstacles are indicated by `1`s, while open spaces are indicated by `0`s.\n\nHere is the step-by-step approach to solve this problem using dynamic programming:\n\n## Explanation\n\n1. **Initialization**: Check the initial position. If it is an obstacle, then there's no way to start, and we should return 0.\n2. **First Row and Column**: Initialize the first row and first column. If there is an obstacle, the number of paths to that cell is `0`.\n3. **Dynamic Programming Table Filling**:\n   - For each cell, calculate the number of ways to reach there by summing the number of ways to reach the cell above and the cell to the left, provided the cell is not an obstacle.\n   - If the current cell is an obstacle, the number of ways to reach this cell is `0`.\n4. **Result Extraction**: The value in the bottom-right cell will be the result, i.e., the number of unique paths to that cell.\n\n## Pseudocode\n\n```plaintext\nfunction uniquePathsWithObstacles(obstacleGrid):\n    m = number of rows in obstacleGrid\n    n = number of columns in obstacleGrid\n    \n    // If starting cell has an obstacle, return 0\n    if obstacleGrid[0][0] == 1:\n        return 0\n    \n    // Initialize the starting point\n    obstacleGrid[0][0] = 1\n    \n    // Initialize first column\n    for i from 1 to m-1:\n        if obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1:\n            obstacleGrid[i][0] = 1\n        else:\n            obstacleGrid[i][0] = 0\n    \n    // Initialize first row\n    for j from 1 to n-1:\n        if obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1:\n            obstacleGrid[0][j] = 1\n        else:\n            obstacleGrid[0][j] = 0\n    \n    // Fill the rest of the obstacleGrid array\n    for i from 1 to m-1:\n        for j from 1 to n-1:\n            if obstacleGrid[i][j] == 0:\n                obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n            else:\n                obstacleGrid[i][j] = 0\n    \n    // The value in the bottom-right cell is the number of unique paths\n    return obstacleGrid[m-1][n-1]\n```\n\nThis approach ensures that we consider only valid paths that do not pass through obstacles, maintaining the efficiency with a time complexity of \\(O(m \\times n)\\).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-unique-paths-ii"
    },
    {
        "name": "Minimum Path Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-path-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        \n        dp[0][0] = grid[0][0];\n        \n        for (int i = 1; i < m; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        \n        for (int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        \n        int[][] dp = new int[m][n];\n        dp[0][0] = grid[0][0];\n        \n        for (int i = 1; i < m; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        \n        for (int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int minPathSum(int** grid, int gridSize, int* gridColSize) {\n    int m = gridSize;\n    int n = *gridColSize;\n    \n    for (int i = 1; i < m; i++) {\n        grid[i][0] += grid[i - 1][0];\n    }\n    \n    for (int j = 1; j < n; j++) {\n        grid[0][j] += grid[0][j - 1];\n    }\n    \n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            grid[i][j] += fmin(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    \n    return grid[m - 1][n - 1];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinPathSum(int[][] grid) {\n        int m = grid.Length;\n        int n = grid[0].Length;\n        \n        int[][] dp = new int[m][];\n        for (int i = 0; i < m; i++) {\n            dp[i] = new int[n];\n        }\n        \n        dp[0][0] = grid[0][0];\n        \n        for (int i = 1; i < m; i++) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        \n        for (int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = grid[i][j] + Math.Min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        \n        return dp[m - 1][n - 1];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    \n    for (let i = 1; i < m; i++) {\n        grid[i][0] += grid[i - 1][0];\n    }\n    \n    for (let j = 1; j < n; j++) {\n        grid[0][j] += grid[0][j - 1];\n    }\n    \n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    \n    return grid[m - 1][n - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minPathSum(grid: number[][]): number {\n    const m = grid.length;\n    const n = grid[0].length;\n\n    for (let i = 1; i < m; i++) {\n        grid[i][0] += grid[i - 1][0];\n    }\n\n    for (let j = 1; j < n; j++) {\n        grid[0][j] += grid[0][j - 1];\n    }\n\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n\n    return grid[m - 1][n - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function minPathSum($grid) {\n        $m = count($grid);\n        $n = count($grid[0]);\n        \n        for ($i = 1; $i < $m; $i++) {\n            $grid[$i][0] += $grid[$i - 1][0];\n        }\n        \n        for ($j = 1; $j < $n; $j++) {\n            $grid[0][$j] += $grid[0][$j - 1];\n        }\n        \n        for ($i = 1; $i < $m; $i++) {\n            for ($j = 1; $j < $n; $j++) {\n                $grid[$i][$j] += min($grid[$i - 1][$j], $grid[$i][$j - 1]);\n            }\n        }\n        \n        return $grid[$m - 1][$n - 1];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minPathSum(_ grid: [[Int]]) -> Int {\n        var dp = grid\n        \n        for i in 0..<grid.count {\n            for j in 0..<grid[0].count {\n                if i > 0 && j > 0 {\n                    dp[i][j] += min(dp[i-1][j], dp[i][j-1])\n                } else if i > 0 {\n                    dp[i][j] += dp[i-1][j]\n                } else if j > 0 {\n                    dp[i][j] += dp[i][j-1]\n                }\n            }\n        }\n        \n        return dp[grid.count-1][grid[0].count-1]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minPathSum(grid: Array<IntArray>): Int {\n        val m = grid.size\n        val n = grid[0].size\n        \n        for (i in 1 until m) {\n            grid[i][0] += grid[i - 1][0]\n        }\n        \n        for (j in 1 until n) {\n            grid[0][j] += grid[0][j - 1]\n        }\n        \n        for (i in 1 until m) {\n            for (j in 1 until n) {\n                grid[i][j] += minOf(grid[i - 1][j], grid[i][j - 1])\n            }\n        }\n        \n        return grid[m - 1][n - 1]\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int minPathSum(List<List<int>> grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    \n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (i == 0 && j == 0) continue;\n        else if (i == 0) grid[i][j] += grid[i][j - 1];\n        else if (j == 0) grid[i][j] += grid[i - 1][j];\n        else grid[i][j] += grid[i - 1][j] < grid[i][j - 1] ? grid[i - 1][j] : grid[i][j - 1];\n      }\n    }\n    \n    return grid[m - 1][n - 1];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minPathSum(grid [][]int) int {\n    m := len(grid)\n    n := len(grid[0])\n    \n    dp := make([][]int, m)\n    for i := range dp {\n        dp[i] = make([]int, n)\n    }\n    \n    dp[0][0] = grid[0][0]\n    \n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    }\n    \n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    }\n    \n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    \n    return dp[m-1][n-1]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef min_path_sum(grid)\n    m = grid.length\n    n = grid[0].length\n    \n    (1...n).each { |j| grid[0][j] += grid[0][j-1] }\n    (1...m).each { |i| grid[i][0] += grid[i-1][0] }\n    \n    (1...m).each do |i|\n        (1...n).each do |j|\n            grid[i][j] += [grid[i-1][j], grid[i][j-1]].min\n        end\n    end\n    \n    return grid[m-1][n-1]\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minPathSum(grid: Array[Array[Int]]): Int = {\n        val m = grid.length\n        val n = grid(0).length\n        \n        for (i <- 0 until m; j <- 0 until n) {\n            if (i == 0 && j == 0) {\n                grid(i)(j) = grid(i)(j)\n            } else if (i == 0) {\n                grid(i)(j) += grid(i)(j - 1)\n            } else if (j == 0) {\n                grid(i)(j) += grid(i - 1)(j)\n            } else {\n                grid(i)(j) += math.min(grid(i - 1)(j), grid(i)(j - 1))\n            }\n        }\n        \n        grid(m - 1)(n - 1)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {\n        let m = grid.len();\n        let n = grid[0].len();\n        \n        let mut dp = vec![vec![0; n]; m];\n        dp[0][0] = grid[0][0];\n        \n        for i in 1..m {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        \n        for j in 1..n {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        \n        for i in 1..m {\n            for j in 1..n {\n                dp[i][j] = grid[i][j] + std::cmp::min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        \n        dp[m - 1][n - 1]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the minimum path sum from the top-left to the bottom-right corner of a given grid while only allowing moves either down or right.\n\n# Explanation\n1. **Initialize the Grid**: We start by capturing the dimensions of the grid `m` (rows) and `n` (columns).\n2. **Dynamic Programming Table**: We'll use a 2D list `dp` to store the minimum path sums for each cell from the top-left moving only right or down.\n3. **Fill the DP Table**:\n   - **Top-Left Corner**: Set `dp[0][0]` equal to `grid[0][0]`, as there's no other path to this start point.\n   - **First Column**: Populate the first column of the `dp` table by summing the values from `grid`'s first column, since only downward moves are allowed.\n   - **First Row**: Populate the first row similarly by summing the values from `grid`\u2019s first row, since only rightward moves are allowed.\n   - **Remaining Cells**: For each cell `(i, j)`, the minimum path sum is the current cell value (`grid[i][j]`) plus the minimum of the path sums from the cell directly above (`dp[i-1][j]`) and the cell directly to the left (`dp[i][j-1]`).\n4. **Result**: The value in the bottom-right cell `dp[m-1][n-1]` will be our answer, representing the minimum path sum from the top-left to the bottom-right.\n\n# Pseudocode\n```\nfunction minPathSum(grid):\n    m = number of rows in grid\n    n = number of columns in grid\n    \n    # Initialize a DP table with the same dimensions as grid\n    dp = 2D array with dimensions m x n\n    \n    # Set the starting point\n    dp[0][0] = grid[0][0]\n    \n    # Fill the first column\n    for i from 1 to m-1:\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    # Fill the first row\n    for j from 1 to n-1:\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill the rest of the DP table\n    for i from 1 to m-1:\n        for j from 1 to n-1:\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # The bottom-right cell contains the minimum path sum\n    return dp[m-1][n-1]\n```\n\nThis method ensures that we efficiently compute the minimum path sum using a dynamic programming approach, with a time complexity of `O(m*n)` and a space complexity of `O(m*n)` for storing intermediate results.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-path-sum"
    },
    {
        "name": "Valid Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-valid-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        if(s.empty()) return false;\n        \n        int i = 0;\n        while(i < s.size() && isspace(s[i])) {\n            i++;\n        }\n        \n        if(s[i] == '+' || s[i] == '-') {\n            i++;\n        }\n        \n        bool isNumeric = false;\n        while(i < s.size() && isdigit(s[i])) {\n            i++;\n            isNumeric = true;\n        }\n        \n        if(i < s.size() && s[i] == '.') {\n            i++;\n            while(i < s.size() && isdigit(s[i])) {\n                i++;\n                isNumeric = true;\n            }\n        }\n        \n        if(isNumeric && i < s.size() && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n            isNumeric = false;\n            if(s[i] == '+' || s[i] == '-') {\n                i++;\n            }\n            while(i < s.size() && isdigit(s[i])) {\n                i++;\n                isNumeric = true;\n            }\n        }\n        \n        while(i < s.size() && isspace(s[i])) {\n            i++;\n        }\n        \n        return isNumeric && i == s.size();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        if (s == null || s.length() == 0) {\n            return false;\n        }\n        \n        s = s.trim();\n        boolean seenNum = false;\n        boolean seenDot = false;\n        boolean seenE = false;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (Character.isDigit(c)) {\n                seenNum = true;\n            } else if (c == '.') {\n                if (seenDot || seenE) {\n                    return false;\n                }\n                seenDot = true;\n            } else if (c == 'e' || c == 'E') {\n                if (seenE || !seenNum) {\n                    return false;\n                }\n                seenE = true;\n                seenNum = false;\n            } else if (c == '+' || c == '-') {\n                if (i != 0 && s.charAt(i - 1) != 'e' && s.charAt(i - 1) != 'E') {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        \n        return seenNum;\n    }\n}"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "#include <stdbool.h>\n\nbool isNumber(char* s) {\n    bool seenNum = false;\n    bool seenDot = false;\n    bool seenE = false;\n    bool seenSign = false;\n    int n = strlen(s);\n    \n    for (int i = 0; i < n; i++) {\n        if (isdigit(s[i])) {\n            seenNum = true;\n        } else if (s[i] == '+' || s[i] == '-') {\n            if (i > 0 && s[i-1] != 'e' && s[i-1] != 'E') {\n                return false;\n            }\n            seenSign = true;\n        } else if (s[i] == '.') {\n            if (seenDot || seenE) {\n                return false;\n            }\n            seenDot = true;\n        } else if (s[i] == 'e' || s[i] == 'E') {\n            if (seenE || !seenNum) {\n                return false;\n            }\n            seenE = true;\n            seenNum = false;\n            seenSign = false;\n        } else {\n            return false;\n        }\n    }\n    \n    return seenNum;\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function(s) {\n    const regex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n    return regex.test(s.trim());\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isNumber(s: string): boolean {\n    const regex = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$/;\n    return regex.test(s.trim());\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isNumber($s) {\n        return preg_match('/^\\s*[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?\\s*$/', $s) === 1;\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isNumber(s: String): Boolean {\n        val regex = Regex(\"^[-+]?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([eE][-+]?[0-9]+)?$\")\n        return regex.matches(s)\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isNumber(String s) {\n    s = s.trim();\n    \n    bool seenNum = false;\n    bool seenDot = false;\n    bool seenE = false;\n    bool seenNumAfterE = false;\n    \n    for (int i = 0; i < s.length; i++) {\n      if ('0'.codeUnitAt(0) <= s[i].codeUnitAt(0) && s[i].codeUnitAt(0) <= '9'.codeUnitAt(0)) {\n        seenNum = true;\n        seenNumAfterE = true;\n      } else if (s[i] == '.') {\n        if (seenDot || seenE) {\n          return false;\n        }\n        seenDot = true;\n      } else if (s[i] == 'e' || s[i] == 'E') {\n        if (seenE || !seenNum) {\n          return false;\n        }\n        seenE = true;\n        seenNumAfterE = false;\n      } else if (s[i] == '-' || s[i] == '+') {\n        if (i != 0 && s[i - 1] != 'e' && s[i - 1] != 'E') {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    \n    return seenNum && seenNumAfterE;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "import \"regexp\"\n\nfunc isNumber(s string) bool {\n    pattern := `^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$`\n    matched, _ := regexp.MatchString(pattern, s)\n    return matched\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Boolean}\ndef is_number(s)\n    /\\A[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?\\z/ === s.strip\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isNumber(s: String): Boolean = {\n        s.matches(\"\"\"[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?\"\"\")\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_number(s: String) -> bool {\n        let s = s.trim(); // Remove leading and trailing whitespaces\n        let mut has_dot = false;\n        let mut has_digit = false;\n        let mut has_exp = false;\n        \n        for (i, c) in s.chars().enumerate() {\n            match c {\n                '+' | '-' => {\n                    if i > 0 && s.chars().nth(i - 1).unwrap() != 'e' {\n                        return false; // Sign can only appear at the beginning or after 'e'\n                    }\n                }\n                'e' | 'E' => {\n                    if has_exp || !has_digit {\n                        return false; // Exponent can only appear once and should have at least one digit before it\n                    }\n                    has_exp = true;\n                    has_digit = false; // Reset after encountering exponent\n                }\n                '.' => {\n                    if has_dot || has_exp {\n                        return false; // Decimal point can only appear once and before exponent\n                    }\n                    has_dot = true;\n                }\n                '0'..='9' => {\n                    has_digit = true;\n                }\n                _ => {\n                    return false; // Invalid character\n                }\n            }\n        }\n        \n        has_digit\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec is_number(s :: String.t) :: boolean\n  def is_number(s) do\n    Regex.match?(~r/\\A[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?\\z/, s)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given string is a valid number based on specific definitions provided. We can achieve this using regular expressions to match the patterns described in the problem statement.\n\n# Explanation\n\n1. **Define the Integer Number Pattern:** An integer number can optionally start with '+' or '-' followed by digits.\n2. **Define the Decimal Number Pattern:** A decimal number can have:\n    - Digits followed by a dot ('.').\n    - Digits followed by a dot ('.') followed by more digits.\n    - A dot ('.') followed by digits.\n3. **Include the Exponent:** The exponent notation 'e' or 'E' must be followed by an integer, which can also be defined with an optional sign followed by digits.\n4. **Combine Patterns:** Combine the integer and decimal patterns, and optionally allow an exponent part.\n\n# Pseudocode\n\n```pseudo\nFUNCTION isNumber(s: STRING) -> BOOLEAN\n    # Define the regular expression for a valid number\n    SET regex TO \"^\\\\s*[+-]?(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][+-]?\\\\d+)?\\\\s*$\"\n    \n    # Trim the input string to remove leading and trailing whitespaces\n    SET trimmed_s TO TRIM(s)\n    \n    # Check if the trimmed string matches the regular expression\n    RETURN MATCHES_REGEX(trimmed_s, regex)\n\n# MATCHES_REGEX is a helper function that checks if a string matches a given regex pattern\nFUNCTION MATCHES_REGEX(str: STRING, pattern: STRING) -> BOOLEAN\n    # Use a regex matching function available in the programming language\n    RETURN REGEX_MATCHES(str, pattern)\n```\n\nThis pseudocode utilizes regular expressions to validate the input string against the defined patterns for integers, decimal numbers, and optional exponents. The `MATCHES_REGEX` function is a placeholder for the actual implementation of regex matching in the chosen programming language (e.g., Python, JavaScript, etc.).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-valid-number"
    },
    {
        "name": "Partition List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-partition-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode less_head(0);\n        ListNode greater_head(0);\n        ListNode *less_ptr = &less_head;\n        ListNode *greater_ptr = &greater_head;\n        \n        while (head != nullptr) {\n            if (head->val < x) {\n                less_ptr->next = head;\n                less_ptr = less_ptr->next;\n            } else {\n                greater_ptr->next = head;\n                greater_ptr = greater_ptr->next;\n            }\n            head = head->next;\n        }\n        \n        greater_ptr->next = nullptr;\n        less_ptr->next = greater_head.next;\n        \n        return less_head.next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int val) { this.val = val; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode smallerHead = new ListNode(0);\n        ListNode greaterHead = new ListNode(0);\n        ListNode smaller = smallerHead;\n        ListNode greater = greaterHead;\n        \n        while (head != null) {\n            if(head.val < x) {\n                smaller.next = head;\n                smaller = smaller.next;\n            } else {\n                greater.next = head;\n                greater = greater.next;\n            }\n            head = head.next;\n        }\n        \n        greater.next = null;\n        smaller.next = greaterHead.next;\n        \n        return smallerHead.next;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* partition(struct ListNode* head, int x) {\n    struct ListNode less_head, greater_head;\n    struct ListNode *less_ptr = &less_head;\n    struct ListNode *greater_ptr = &greater_head;\n    \n    struct ListNode *curr = head;\n    while (curr != NULL) {\n        if (curr->val < x) {\n            less_ptr->next = curr;\n            less_ptr = less_ptr->next;\n        } else {\n            greater_ptr->next = curr;\n            greater_ptr = greater_ptr->next;\n        }\n        curr = curr->next;\n    }\n    \n    less_ptr->next = greater_head.next;\n    greater_ptr->next = NULL;\n    \n    return less_head.next;\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will break down the logic and convert it from C++ to pseudocode that can be implemented in any programming language. The algorithm should divide the linked list into two separate lists: one for nodes with values less than the given integer `x` and another for nodes with values greater than or equal to `x`. We then combine these two lists to get the desired result.\n\nHere\u2019s the structured approach:\n\n# Explanation\n\n1. **Initialize Two Dummy Nodes**: \n   - `less_head` to store values less than `x`.\n   - `greater_head` to store values greater than or equal to `x`.\n\n2. **Traversing the List**:\n   - Traverse the original list, comparing each node\u2019s value with `x`.\n   - If a node's value is less than `x`, append it to the `less_head` list.\n   - Otherwise, append it to the `greater_head` list.\n\n3. **Combine the Two Lists**:\n   - Ensure the end of the `greater_head` list points to `nullptr` (or equivalent).\n   - Append the `greater_head` list to the end of the `less_head` list.\n\n4. **Return the New List**: \n   - The new combined list should start at the node following the dummy `less_head` node.\n\n# Pseudocode\n\nHere\u2019s a step-by-step pseudocode representation of the solution:\n\n```\nfunction partition(head, x):\n    # Create two dummy nodes\n    less_head = ListNode(0)\n    greater_head = ListNode(0)\n    \n    # Pointers to build the two lists\n    less_ptr = less_head\n    greater_ptr = greater_head\n    \n    # Traverse the list\n    while head is not NULL:\n        if head.val < x:\n            less_ptr.next = head\n            less_ptr = less_ptr.next\n        else:\n            greater_ptr.next = head\n            greater_ptr = greater_ptr.next\n        head = head.next\n    \n    # Ensure the last node of greater list points to NULL\n    greater_ptr.next = NULL\n    \n    # Connect the less list to the greater list\n    less_ptr.next = greater_head.next\n    \n    # Return the combined list starting from the node following dummy node\n    return less_head.next\n```\n\nThis pseudocode represents the logical steps necessary to partition a linked list around a value `x`, ensuring nodes less than `x` come before nodes greater than or equal to `x`, while maintaining their relative order in the initial list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-partition-list"
    },
    {
        "name": "Add Binary",
        "site": "LeetCode",
        "href": "/solution/LeetCode-add-binary",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string result = \"\";\n        int carry = 0;\n        int i = a.size() - 1;\n        int j = b.size() - 1;\n        \n        while (i >= 0 || j >= 0 || carry) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += a[i] - '0';\n                i--;\n            }\n            if (j >= 0) {\n                sum += b[j] - '0';\n                j--;\n            }\n            carry = sum / 2;\n            result = to_string(sum % 2) + result;\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder sb = new StringBuilder();\n        int carry = 0;\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n\n        while (i >= 0 || j >= 0 || carry == 1) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += a.charAt(i--) - '0';\n            }\n            if (j >= 0) {\n                sum += b.charAt(j--) - '0';\n            }\n            sb.insert(0, sum % 2);\n            carry = sum / 2;\n        }\n\n        return sb.toString();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def addBinary(self, a, b):\n        return bin(int(a, 2) + int(b, 2))[2:]"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nconst addBinary = (a, b) => {\n    let i = a.length - 1;\n    let j = b.length - 1;\n    let carry = 0;\n    let result = '';\n    \n    while (i >= 0 || j >= 0 || carry > 0) {\n        const sum = (+a[i] || 0) + (+b[j] || 0) + carry;\n        result = (sum % 2) + result;\n        carry = sum > 1 ? 1 : 0;\n        i--;\n        j--;\n    }\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function addBinary(a: string, b: string): string {\n    let result = '';\n    let carry = 0;\n    let i = a.length - 1;\n    let j = b.length - 1;\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n        const sum = (+a[i] || 0) + (+b[j] || 0) + carry;\n        result = (sum % 2) + result;\n        carry = sum > 1 ? 1 : 0;\n        i--;\n        j--;\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $a\n     * @param String $b\n     * @return String\n     */\n    function addBinary($a, $b) {\n        $i = strlen($a) - 1;\n        $j = strlen($b) - 1;\n        $carry = 0;\n        $result = \"\";\n\n        while ($i >= 0 || $j >= 0 || $carry > 0) {\n            $sum = $carry;\n            if ($i >= 0) {\n                $sum += $a[$i--] == '1' ? 1 : 0;\n            }\n            if ($j >= 0) {\n                $sum += $b[$j--] == '1' ? 1 : 0;\n            }\n            $result = ($sum % 2) . $result;\n            $carry = (int) ($sum / 2);\n        }\n\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func addBinary(_ a: String, _ b: String) -> String {\n        var result = \"\"\n        var carry = 0\n        var i = a.count - 1\n        var j = b.count - 1\n        \n        while i >= 0 || j >= 0 || carry > 0 {\n            let digitA = i >= 0 ? Int(String(a[a.index(a.startIndex, offsetBy: i)]))! : 0\n            let digitB = j >= 0 ? Int(String(b[b.index(b.startIndex, offsetBy: j)]))! : 0\n            let sum = digitA + digitB + carry\n            result = String(sum % 2) + result\n            carry = sum / 2\n            i -= 1\n            j -= 1\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun addBinary(a: String, b: String): String {\n        var result = StringBuilder()\n        var carry = 0\n        var i = a.length - 1\n        var j = b.length - 1\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            if (i >= 0) {\n                carry += a[i] - '0'\n                i--\n            }\n            if (j >= 0) {\n                carry += b[j] - '0'\n                j--\n            }\n            result.insert(0, (carry % 2).toString())\n            carry /= 2\n        }\n\n        return result.toString()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String addBinary(String a, String b) {\n    int i = a.length - 1;\n    int j = b.length - 1;\n    int carry = 0;\n    String result = '';\n    \n    while (i >= 0 || j >= 0 || carry > 0) {\n      int sum = carry;\n      if (i >= 0) sum += a.codeUnitAt(i--) - '0'.codeUnitAt(0);\n      if (j >= 0) sum += b.codeUnitAt(j--) - '0'.codeUnitAt(0);\n      carry = sum ~/ 2;\n      result = '${sum % 2}$result';\n    }\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func addBinary(a string, b string) string {\n    carry := 0\n    result := \"\"\n    \n    i, j := len(a)-1, len(b)-1\n    \n    for i >= 0 || j >= 0 || carry > 0 {\n        sum := carry\n        \n        if i >= 0 {\n            sum += int(a[i] - '0')\n            i--\n        }\n        \n        if j >= 0 {\n            sum += int(b[j] - '0')\n            j--\n        }\n        \n        result = string(sum%2+'0') + result\n        carry = sum / 2\n    }\n    \n    return result\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": " # @param {String} a\n# @param {String} b\n# @return {String}\ndef add_binary(a, b)\n    (a.to_i(2) + b.to_i(2)).to_s(2)\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def addBinary(a: String, b: String): String = {\n        var (carry, result) = (0, \"\")\n        var (i, j) = (a.length - 1, b.length - 1)\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            val sum = carry + (if (i >= 0) a(i) - '0' else 0) + (if (j >= 0) b(j) - '0' else 0)\n            result = (sum % 2).toString + result\n            carry = sum / 2\n            i -= 1\n            j -= 1\n        }\n\n        result\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (add-binary a b)\n  (-> string? string? string?)\n  (number->string (+ (string->number a 2) (string->number b 2)) 2)\n)"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to add two binary strings and return their sum as a binary string.\n\n# Explanation\n\n1. **Convert Binary Strings to Integers**:\n   - We start by converting each binary string to its integer representation. This can be done using the `int` function with base 2.\n\n2. **Add Integers**:\n   - We then add the two integer values.\n\n3. **Convert the Sum Back to Binary**:\n   - Finally, we convert the sum back to a binary string. The Python `bin` function can be used for this, which returns a string starting with '0b'. We need to remove this '0b' prefix to obtain the final binary representation.\n\n4. **Return the Result**:\n   - The resultant string is then returned.\n\n# Pseudocode\n\nThe pseudocode for the solution is as follows:\n\n```\nFUNCTION add_binary(a, b):\n    # Convert binary strings to integers\n    integer_a = convert a to an integer with base 2\n    integer_b = convert b to an integer with base 2\n    \n    # Add the two integers\n    sum_integer = integer_a + integer_b\n    \n    # Convert the sum back to a binary string and remove the '0b' prefix\n    result_binary = convert sum_integer to binary string\n    result_binary = result_binary without the first two characters\n    \n    RETURN result_binary\n```\n\nThis pseudocode outlines the steps required to implement the solution. By following these steps, you can write a function to add two binary strings and return the resultant binary string.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-add-binary"
    },
    {
        "name": "Text Justification",
        "site": "LeetCode",
        "href": "/solution/LeetCode-text-justification",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> result;\n        int n = words.size();\n        int i = 0;\n        while (i < n) {\n            int j = i, len = 0;\n            while (j < n && len + words[j].size() + j - i <= maxWidth) {\n                len += words[j].size();\n                j++;\n            }\n            string line = \"\";\n            int diff = maxWidth - len;\n            int numGaps = j - i - 1;\n            if (j == n || numGaps == 0) {\n                for (int k = i; k < j; k++) {\n                    line += words[k];\n                    if (k < j - 1) line += \" \";\n                }\n                line += string(maxWidth - line.size(), ' ');\n            } else {\n                int spaces = diff / numGaps;\n                int extraSpaces = diff % numGaps;\n                for (int k = i; k < j - 1; k++) {\n                    line += words[k];\n                    line += string(spaces, ' ');\n                    if (k - i < extraSpaces) line += \" \";\n                }\n                line += words[j - 1];\n            }\n            result.push_back(line);\n            i = j;\n        }\n        return result;\n    }\n};\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        line = []\n        line_length = 0\n        for word in words:\n            if line_length + len(word) + len(line) > maxWidth:\n                for i in range(maxWidth - line_length):\n                    line[i % (len(line) - 1 or 1)] += ' '\n                result.append(''.join(line))\n                line = []\n                line_length = 0\n            line.append(word)\n            line_length += len(word)\n        result.append(' '.join(line).ljust(maxWidth))\n        return result"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[] $words\n     * @param Integer $maxWidth\n     * @return String[]\n     */\n    function fullJustify($words, $maxWidth) {\n        $result = [];\n        $line = [];\n        $lineLength = 0;\n        \n        foreach ($words as $word) {\n            if ($lineLength + count($line) + strlen($word) > $maxWidth) {\n                foreach ($line as $i => &$w) {\n                    if (count($line) == 1) {\n                        $line[$i] .= str_repeat(' ', $maxWidth - $lineLength);\n                    } elseif ($i != count($line) - 1) {\n                        $spaces = $maxWidth - $lineLength;\n                        $line[$i] .= str_repeat(' ', intval($spaces / (count($line) - 1) + ($i < $spaces % (count($line) - 1))));\n                    }\n                }\n                $result[] = implode('', $line);\n                $line = [];\n                $lineLength = 0;\n            }\n            \n            $line[] = $word;\n            $lineLength += strlen($word);\n        }\n        \n        $result[] = implode(' ', $line) . str_repeat(' ', $maxWidth - $lineLength - count($line) + 1);\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\n        var result: [String] = []\n        var index = 0\n        \n        while index < words.count {\n            var lineWords: [String] = []\n            var lineLength = 0\n            \n            while index < words.count && lineLength + words[index].count + lineWords.count <= maxWidth {\n                lineWords.append(words[index])\n                lineLength += words[index].count\n                index += 1\n            }\n            \n            var line = \"\"\n            \n            if index == words.count || lineWords.count == 1 {\n                line = lineWords.joined(separator: \" \")\n                line += String(repeating: \" \", count: maxWidth - line.count)\n            } else {\n                let totalSpaces = maxWidth - lineLength\n                let spaceCount = lineWords.count - 1\n                var spaces = Array(repeating: totalSpaces / spaceCount, count: spaceCount)\n                for i in 0..<totalSpaces % spaceCount {\n                    spaces[i] += 1\n                }\n                \n                for (i, word) in lineWords.enumerated() {\n                    line += word\n                    if i < spaces.count {\n                        line += String(repeating: \" \", count: spaces[i])\n                    }\n                }\n            }\n            \n            result.append(line)\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\n        val result = mutableListOf<String>()\n        var index = 0\n        \n        while (index < words.size) {\n            var line = \"\"\n            var count = 0\n            var lineWords = mutableListOf<String>()\n            \n            while (index < words.size && count + words[index].length + lineWords.size <= maxWidth) {\n                lineWords.add(words[index])\n                count += words[index].length\n                index++\n            }\n            \n            if (index == words.size || lineWords.size == 1) {\n                // Left justify for last line or single word line\n                line = lineWords.joinToString(\" \")\n                line += \"\".padEnd(maxWidth - line.length)\n            } else {\n                val totalSpaces = maxWidth - count\n                val spacesBetweenWords = totalSpaces / (lineWords.size - 1)\n                val extraSpaces = totalSpaces % (lineWords.size - 1)\n                \n                for (i in lineWords.indices) {\n                    line += lineWords[i]\n                    if (i < lineWords.size - 1) {\n                        line += \" \".repeat(spacesBetweenWords)\n                        if (i < extraSpaces) {\n                            line += \" \"\n                        }\n                    }\n                }\n            }\n            \n            result.add(line)\n        }\n        \n        return result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create a function that formats a given array of words into fully justified text. Each line must contain exactly `maxWidth` characters and be both left and right justified, except for the last line, which should be left-justified.\n\n### # Explanation:\n1. **Initialization**: We initialize an empty result list to store the final lines, a temporary list to hold words for the current line, and a length counter to track the current line's total length.\n2. **Word Processing**: We iterate through the words array and check if adding the current word would exceed `maxWidth`. If it does, we need to justify the current line and reset it.\n3. **Justification**:\n    - **Full Justification**: When a line is ready to be added to the result, we distribute extra spaces evenly between the words.\n    - **Edge Case**: If there's only one word in the line, we justify it by padding spaces at the end.\n4. **Last Line Justification**: Left justify the last line and pad the right side with spaces if needed.\n5. **Final Output**: Return the list of justified lines.\n\n### # Pseudocode:\n``` \n# Pseudocode\n\nfunction fullJustify(words, maxWidth):\n    initialize result as an empty list\n    initialize line as an empty list\n    initialize line_length as 0\n\n    for each word in words:\n        # Check if adding the word exceeds maxWidth\n        if line_length + length(word) + length(line) > maxWidth:\n            # Distribute spaces in the current line\n            for i from 0 to (maxWidth - line_length) exclusive:\n                line[i % (length(line) - 1 or 1)] += \" \"\n            # Add the fully justified line to the result\n            result.append(\"\".join(line))\n            # Reset line and line_length for new line\n            line = []\n            line_length = 0\n        \n        # Add word to the current line\n        line.append(word)\n        line_length += length(word)\n        \n    # Handle the last line (left-justified)\n    result.append(\" \".join(line).ljust(maxWidth))\n    \n    return result\n\n# Example Usage:\n# words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n# maxWidth = 16\n# Output should be: \n# [\n#    \"This    is    an\",\n#    \"example  of text\",\n#    \"justification.  \"\n# ]\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-text-justification"
    },
    {
        "name": "Sqrtx",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sqrtx",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0 || x == 1) {\n            return x;\n        }\n        \n        long left = 1;\n        long right = x;\n        while (left < right) {\n            long mid = left + (right - left) / 2;\n            if (mid * mid == x) {\n                return mid;\n            } else if (mid * mid < x) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return left - 1;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int mySqrt(int x) {\n        if (x == 0) return 0;\n        long left = 1, right = x;\n        while (left < right) {\n            long mid = left + (right - left + 1) / 2;\n            if (mid * mid > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return (int)left;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif x < mid * mid:\n                right = mid\n            else:\n                left = mid + 1"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int mySqrt(int x) {\n    if (x == 0) {\n        return 0;\n    }\n    \n    long left = 1;\n    long right = x;\n    long ans = 0;\n\n    while (left <= right) {\n        long mid = left + (right - left) / 2;\n        long square = mid * mid;\n        \n        if (square == x) {\n            return mid;\n        } else if (square < x) {\n            ans = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return ans;\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    if (x < 2) {\n        return x;\n    }\n    \n    let left = 1;\n    let right = x;\n    \n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        \n        if (mid * mid === x) {\n            return mid;\n        } else if (mid * mid < x) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return right - 1;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $x\n     *\n     * @return Integer\n     */\n    function mySqrt($x) {\n        $left = 0;\n        $right = $x;\n        \n        while ($left <= $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            if ($mid * $mid == $x) {\n                return $mid;\n            } elseif ($mid * $mid < $x) {\n                $left = $mid + 1;\n            } else {\n                $right = $mid - 1;\n            }\n        }\n        \n        return $right;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func mySqrt(_ x: Int) -> Int {\n        if x == 0 {\n            return 0\n        }\n        \n        var left = 1\n        var right = x\n        \n        while left < right {\n            let mid = left + (right - left + 1) / 2\n            if mid * mid > x {\n                right = mid - 1\n            } else {\n                left = mid\n            }\n        }\n        \n        return left\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun mySqrt(x: Int): Int {\n        if (x == 0) return 0\n        var left = 1\n        var right = x\n        while (left < right) {\n            val mid = left + (right - left) / 2\n            if (mid <= x / mid && (mid + 1) > x / (mid + 1)) {\n                return mid\n            } else if (mid > x / mid) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        return left\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int mySqrt(int x) {\n    if (x == 0) return 0;\n    \n    int left = 1;\n    int right = x;\n    int result = 0;\n    \n    while (left <= right) {\n      int mid = left + ((right - left) ~/ 2);\n      if (mid <= x ~/ mid) {\n        result = mid;\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func mySqrt(x int) int {\n    if x == 0 {\n        return 0\n    }\n    \n    left, right := 1, x\n    for left <= right {\n        mid := left + (right - left) / 2\n        if mid == x / mid {\n            return mid\n        } else if mid < x / mid {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return right\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} x\n# @return {Integer}\ndef my_sqrt(x)\n    return Math.sqrt(x).to_i\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def mySqrt(x: Int): Int = {\n        if (x == 0) return 0\n        var left = 1\n        var right = x\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            if (mid * mid == x) return mid\n            else if (mid * mid < x) left = mid + 1\n            else right = mid - 1\n        }\n        right\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn my_sqrt(x: i32) -> i32 {\n        if x == 0 {\n            return 0;\n        }\n        \n        let mut left = 1;\n        let mut right = x;\n        \n        while left < right {\n            let mid = left + (right - left) / 2;\n            if mid > x / mid {\n                right = mid;\n            } else {\n                if mid + 1 > x / (mid + 1) {\n                    return mid;\n                }\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n}"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec my_sqrt(x :: integer) :: integer\n  def my_sqrt(x) do\n    if x == 0, do: 0, else: :math.sqrt(x) |> trunc\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a binary search approach to find the square root of a given non-negative integer \\( x \\). Let's break it down into the # Explanation and # Pseudocode sections.\n\n# Explanation\n1. **Initial Check**: If \\( x \\) is 0, the function should return 0 since the square root of 0 is 0.\n2. **Binary Search Setup**: We establish two pointers, `left` and `right`, to represent the search space. Initially, `left` is set to 1 and `right` is set to \\( x \\).\n3. **Binary Search Loop**:\n   - Compute the midpoint `mid` of the current search space.\n   - Check if `mid * mid` is less than or equal to \\( x \\) and `(mid + 1) * (mid + 1)` is greater than \\( x \\). If true, return `mid`.\n   - If `mid * mid` is greater than \\( x \\), we need to discard the right half of the search space by setting `right` to `mid`.\n   - If `mid * mid` is less than \\( x \\), discard the left half by setting `left` to `mid + 1`.\n4. **Termination**: The loop continues until the search space is exhausted, at which point the correct integer value of the square root is returned.\n\n# Pseudocode\n```\nfunction mySqrt(x):\n    if x == 0:\n        return 0\n    \n    left = 1\n    right = x\n    \n    while left <= right:\n        mid = (left + right) // 2\n        mid_squared = mid * mid\n        mid_plus_one_squared = (mid + 1) * (mid + 1)\n        \n        if mid_squared <= x < mid_plus_one_squared:\n            return mid\n        elif x < mid_squared:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return left # or return right based on preference\n```\n\nThis pseudocode clearly outlines the steps required to implement the solution using binary search without utilizing any built-in exponentiation functions or operators.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sqrtx"
    },
    {
        "name": "Climbing Stairs",
        "site": "LeetCode",
        "href": "/solution/LeetCode-climbing-stairs",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        int first = 1;\n        int second = 2;\n        for (int i = 3; i <= n; i++) {\n            int third = first + second;\n            first = second;\n            second = third;\n        }\n        return second;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int climbStairs(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def climbStairs(self, n):\n        if n == 1:\n            return 1\n        first, second = 1, 2\n        for i in range(3, n+1):\n            third = first + second\n            first = second\n            second = third\n        return second"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int climbStairs(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    \n    int first = 1;\n    int second = 2;\n    \n    for (int i = 3; i <= n; i++) {\n        int third = first + second;\n        first = second;\n        second = third;\n    }\n    \n    return second;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int ClimbStairs(int n) {\n        if (n == 1) return 1;\n        \n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        \n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        \n        return dp[n];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    if (n === 1) return 1;\n    let dp = new Array(n + 1).fill(0);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function climbStairs(n: number): number {\n    if (n === 1) {\n        return 1;\n    }\n    \n    let first = 1;\n    let second = 2;\n    \n    for (let i = 3; i <= n; i++) {\n        let third = first + second;\n        first = second;\n        second = third;\n    }\n    \n    return second;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function climbStairs($n) {\n        if ($n == 1) {\n            return 1;\n        }\n        $dp = array_fill(0, $n+1, 0);\n        $dp[1] = 1;\n        $dp[2] = 2;\n        for ($i = 3; $i <= $n; $i++) {\n            $dp[$i] = $dp[$i-1] + $dp[$i-2];\n        }\n        return $dp[$n];\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun climbStairs(n: Int): Int {\n        if (n == 1) return 1\n        if (n == 2) return 2\n        \n        var first = 1\n        var second = 2\n        var third = 0\n        \n        for (i in 3..n) {\n            third = first + second\n            first = second\n            second = third\n        }\n        \n        return third\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int climbStairs(int n) {\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n    \n    int first = 1;\n    int second = 2;\n    for (int i = 3; i <= n; i++) {\n      int third = first + second;\n      first = second;\n      second = third;\n    }\n    \n    return second;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func climbStairs(n int) int {\n    if n == 1 {\n        return 1\n    }\n    \n    first, second := 1, 2\n    for i := 3; i <= n; i++ {\n        third := first + second\n        first = second\n        second = third\n    }\n    \n    return second\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef climb_stairs(n)\n    return 1 if n == 1\n    first = 1\n    second = 2\n    for i in 3..n\n        third = first + second\n        first = second\n        second = third\n    end\n    return second\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def climbStairs(n: Int): Int = {\n        if (n == 1) return 1\n        if (n == 2) return 2\n\n        var dp = Array.ofDim[Int](n + 1)\n        dp(1) = 1\n        dp(2) = 2\n\n        for (i <- 3 to n) {\n            dp(i) = dp(i - 1) + dp(i - 2)\n        }\n\n        dp(n)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        if n <= 2 {\n            return n;\n        }\n\n        let mut dp = vec![0; n as usize + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        \n        for i in 3..=n {\n            dp[i as usize] = dp[i as usize - 1] + dp[i as usize - 2];\n        }\n        \n        dp[n as usize]\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (climb-stairs n)\n  (-> exact-integer? exact-integer?)\n  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [else (+ (climb-stairs (- n 1)) (climb-stairs (- n 2)))]\n  )\n)"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the number of distinct ways to climb a staircase of `n` steps, where each time you can either climb 1 or 2 steps.\n\n# Explanation\nThe problem can be broken down using dynamic programming principles. Here's the main idea:\n\n1. **Base Cases**:\n   - If there is only 1 step (`n = 1`), there's only one way to climb it: a single 1-step.\n   - If there are 2 steps (`n = 2`), there are two ways to climb it: either two 1-steps or one 2-step.\n\n2. **Recurrence Relation**:\n   - If `n > 2`, the number of ways to get to the `n`-th step is the sum of ways to get to the `(n-1)`-th step and the `(n-2)`-th step, because you could have reached step `n` by either:\n     - Taking a 1-step from step `n-1`, or\n     - Taking a 2-step from step `n-2`.\n\n3. **Iteration**:\n   - This relation is similar to the Fibonacci sequence where the first two numbers are 1 and 2, and each subsequent number is the sum of the two preceding numbers.\n\n# Pseudocode\n1. Initialize two variables, `first` and `second` to represent the number of ways to climb 1 step and 2 steps respectively.\n2. Loop from 3 to `n`:\n   - Calculate the number of ways to reach the current step as the sum of ways to reach the previous two steps.\n   - Update the `first` and `second` variables to move to the next step in the sequence.\n3. Return the value stored in `second`, because for `n` steps, the number of ways will be stored in `second` after the loop completes.\n\n```pseudo\nFunction climbStairs(n):\n    If n == 1:\n        Return 1\n    Initialize first to 1\n    Initialize second to 2\n    For i from 3 to n (inclusive):\n        third = first + second\n        first = second\n        second = third\n    Return second\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-climbing-stairs"
    },
    {
        "name": "Simplify Path",
        "site": "LeetCode",
        "href": "/solution/LeetCode-simplify-path",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        stack<string> st;\n        string res, dir;\n        \n        stringstream ss(path);\n        \n        while(getline(ss, dir, '/')) {\n            if (dir == \"\" || dir == \".\") {\n                continue;\n            } else if (dir == \"..\" && !st.empty()) {\n                st.pop();\n            } else if (dir != \"..\") {\n                st.push(dir);\n            }\n        }\n        \n        while (!st.empty()) {\n            res = \"/\" + st.top() + res;\n            st.pop();\n        }\n        \n        return res.empty() ? \"/\" : res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stack = new ArrayDeque<>();\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\n        \n        for (String dir : path.split(\"/\")) {\n            if (dir.equals(\"..\") && !stack.isEmpty()) {\n                stack.pop();\n            } else if (!skip.contains(dir)) {\n                stack.push(dir);\n            }\n        }\n        \n        String result = \"\";\n        for (String dir : stack) {\n            result = \"/\" + dir + result;\n        }\n        \n        return result.isEmpty() ? \"/\" : result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def simplifyPath(self, path):\n        stack = []\n        components = path.split('/')\n        \n        for component in components:\n            if component == '..':\n                if stack:\n                    stack.pop()\n            elif component and component != '.':\n                stack.append(component)\n        \n        return '/' + '/'.join(stack)"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string SimplifyPath(string path) {\n        Stack<string> stack = new Stack<string>();\n        \n        string[] components = path.Split('/');\n        \n        foreach(string component in components) {\n            if(component.Equals(\"..\")) {\n                if(stack.Count > 0) {\n                    stack.Pop();\n                }\n            } else if(!component.Equals(\".\") && !string.IsNullOrEmpty(component)) {\n                stack.Push(component);\n            }\n        }\n        \n        string[] resultComponents = stack.ToArray();\n        Array.Reverse(resultComponents);\n        \n        return \"/\" + string.Join(\"/\", resultComponents);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} path\n * @return {string}\n */\nconst simplifyPath = (path) => {\n    const stack = [];\n    \n    for (let dir of path.split('/')) {\n        if (dir === '' || dir === '.') {\n            continue;\n        } else if (dir === '..') {\n            stack.pop();\n        } else {\n            stack.push(dir);\n        }\n    }\n    \n    return '/' + stack.join('/');\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function simplifyPath(path: string): string {\n    const stack = [];\n    const parts = path.split('/');\n\n    for (let part of parts) {\n        if (part === '' || part === '.') {\n            continue;\n        } else if (part === '..') {\n            stack.pop();\n        } else {\n            stack.push(part);\n        }\n    }\n\n    return '/' + stack.join('/');\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $path\n     * @return String\n     */\n    function simplifyPath($path) {\n        $parts = explode('/', $path);\n        $stack = [];\n        \n        foreach ($parts as $part) {\n            if ($part == '' || $part == '.') {\n                continue;\n            } elseif ($part == '..') {\n                array_pop($stack);\n            } else {\n                array_push($stack, $part);\n            }\n        }\n        \n        return '/' . implode('/', $stack);\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func simplifyPath(_ path: String) -> String {\n        var stack = [String]()\n\n        let components = path.components(separatedBy: \"/\")\n\n        for component in components {\n            if component == \"\" || component == \".\" {\n                continue\n            } else if component == \"..\" {\n                if !stack.isEmpty {\n                    stack.removeLast()\n                }\n            } else {\n                stack.append(component)\n            }\n        }\n\n        return \"/\" + stack.joined(separator: \"/\")\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun simplifyPath(path: String): String {\n        val stack = mutableListOf<String>()\n        val components = path.split(\"/\")\n\n        for (component in components) {\n            when (component) {\n                \"\", \".\" -> { }\n                \"..\" -> if (stack.isNotEmpty()) stack.removeAt(stack.size - 1)\n                else -> stack.add(component)\n            }\n        }\n\n        return \"/\" + stack.joinToString(\"/\")\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String simplifyPath(String path) {\n    List<String> stack = [];\n\n    for (String dir in path.split('/')) {\n      if (dir == '..') {\n        if (stack.isNotEmpty) stack.removeLast();\n      } else if (dir != '' && dir != '.') {\n        stack.add(dir);\n      }\n    }\n\n    return '/' + stack.join('/');\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func simplifyPath(path string) string {\n    stack := []string{}\n    dirs := strings.Split(path, \"/\")\n    \n    for _, dir := range dirs {\n        if dir == \"\" || dir == \".\" {\n            continue\n        } else if dir == \"..\" {\n            if len(stack) > 0 {\n                stack = stack[:len(stack)-1]\n            }\n        } else {\n            stack = append(stack, dir)\n        }\n    }\n    \n    result := \"/\" + strings.Join(stack, \"/\")\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} path\n# @return {String}\ndef simplify_path(path)\n    stack = []\n    \n    path.split('/').each do |dir|\n        next if dir.empty? || dir == '.'\n        \n        if dir == '..'\n            stack.pop\n        else\n            stack.push(dir)\n        end\n    end\n    \n    '/' + stack.join('/')\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn simplify_path(path: String) -> String {\n        let mut stack: Vec<&str> = Vec::new();\n        \n        for dir in path.split(\"/\") {\n            match dir {\n                \"\" | \".\" => continue,\n                \"..\" => { stack.pop(); },\n                _ => stack.push(dir),\n            }\n        }\n        \n        \"/\".to_string() + &stack.join(\"/\")\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to handle and simplify an absolute Unix-style path by removing redundant elements such as multiple slashes, current directory indicators ('.'), and navigating up one directory where indicated by '..'. We will return the simplified canonical path.\n\n# Explanation\n\n1. **Input Handling**: The absolute path is provided as a string starting with '/'.\n2. **Splitting the Path**: We will split the path using '/' as the delimiter to handle each component individually.\n3. **Using a Stack**: We utilize a stack to manage the components:\n   - If the component is '..', pop an element from the stack if the stack is not empty (to go up a directory level).\n   - If the component is '.' or an empty string (from multiple slashes), we do nothing.\n   - Otherwise, we add the component to the stack.\n4. **Reconstructing the Path**: Join the stack components with '/' and ensure the path starts with a '/'.\n5. **Returning the Output**: Ensure the final output adheres to the canonical path rules.\n\n# Pseudocode\n\n```text\nfunction simplifyPath(path):\n    initialize stack as an empty list\n    split path by '/' to get components\n\n    for each component in components:\n        if component is '..':\n            if stack is not empty:\n                pop the last element from stack\n        else if component is non-empty and not '.':\n            push component to stack\n    \n    return '/' + join stack components with '/'\n```\n\nThis pseudocode outlines the method of simplifying a Unix-style path by processing its components in a loop and using a stack to manage directory levels appropriately.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-simplify-path"
    },
    {
        "name": "Set Matrix Zeroes",
        "site": "LeetCode",
        "href": "/solution/LeetCode-set-matrix-zeroes",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        bool firstRowZero = false;\n        bool firstColZero = false;\n        \n        // Check if first row has zero\n        for(int j=0; j<n; j++){\n            if(matrix[0][j] == 0){\n                firstRowZero = true;\n                break;\n            }\n        }\n        \n        // Check if first column has zero\n        for(int i=0; i<m; i++){\n            if(matrix[i][0] == 0){\n                firstColZero = true;\n                break;\n            }\n        }\n        \n        // Mark zeros on first row and column\n        for(int i=1; i<m; i++){\n            for(int j=1; j<n; j++){\n                if(matrix[i][j] == 0){\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        // Set elements to zero based on first row and column\n        for(int i=1; i<m; i++){\n            for(int j=1; j<n; j++){\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        // Set first row to zero\n        if(firstRowZero){\n            for(int j=0; j<n; j++){\n                matrix[0][j] = 0;\n            }\n        }\n        \n        // Set first column to zero\n        if(firstColZero){\n            for(int i=0; i<m; i++){\n                matrix[i][0] = 0;\n            }\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        boolean firstRowZero = false;\n        boolean firstColZero = false;\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    if (i == 0) firstRowZero = true;\n                    if (j == 0) firstColZero = true;\n                    matrix[0][j] = 0;\n                    matrix[i][0] = 0;\n                }\n            }\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[0][j] == 0 || matrix[i][0] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        if (firstRowZero) {\n            for (int j = 0; j < n; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n        \n        if (firstColZero) {\n            for (int i = 0; i < m; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        row_zero, col_zero = False, False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        row_zero = True\n                    if j == 0:\n                        col_zero = True\n                    matrix[0][j] = 0\n                    matrix[i][0] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        if col_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {\n    int m = matrixSize;\n    int n = *matrixColSize;\n    bool firstRowZero = false;\n    bool firstColZero = false;\n\n    // Check if the first row contains zero\n    for (int j = 0; j < n; j++) {\n        if (matrix[0][j] == 0) {\n            firstRowZero = true;\n            break;\n        }\n    }\n\n    // Check if the first column contains zero\n    for (int i = 0; i < m; i++) {\n        if (matrix[i][0] == 0) {\n            firstColZero = true;\n            break;\n        }\n    }\n\n    // Mark zeros on first row and first column\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    // Set zeros based on marks in first row and first column\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    // Set zeros for the first row if needed\n    if (firstRowZero) {\n        for (int j = 0; j < n; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n\n    // Set zeros for the first column if needed\n    if (firstColZero) {\n        for (int i = 0; i < m; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void SetZeroes(int[][] matrix) {\n        bool firstRowHasZero = false;\n        bool firstColHasZero = false;\n\n        // Check if the first row has zero\n        for (int j = 0; j < matrix[0].Length; j++) {\n            if (matrix[0][j] == 0) {\n                firstRowHasZero = true;\n                break;\n            }\n        }\n\n        // Check if the first column has zero\n        for (int i = 0; i < matrix.Length; i++) {\n            if (matrix[i][0] == 0) {\n                firstColHasZero = true;\n                break;\n            }\n        }\n\n        // Mark zeros on first row and column\n        for (int i = 1; i < matrix.Length; i++) {\n            for (int j = 1; j < matrix[0].Length; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n\n        // Set zeros based on first row and column markers\n        for (int i = 1; i < matrix.Length; i++) {\n            for (int j = 1; j < matrix[0].Length; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n\n        // Set zeros for the first row if needed\n        if (firstRowHasZero) {\n            for (int j = 0; j < matrix[0].Length; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n\n        // Set zeros for the first column if needed\n        if (firstColHasZero) {\n            for (int i = 0; i < matrix.Length; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function(matrix) {\n    let rows = matrix.length;\n    let cols = matrix[0].length;\n    \n    let firstRowZero = false;\n    let firstColZero = false;\n    \n    for(let i = 0; i < rows; i++) {\n        for(let j = 0; j < cols; j++) {\n            if(matrix[i][j] === 0) {\n                if(i === 0) firstRowZero = true;\n                if(j === 0) firstColZero = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    \n    for(let i = 1; i < rows; i++) {\n        for(let j = 1; j < cols; j++) {\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    \n    if(firstRowZero) {\n        for(let j = 0; j < cols; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n    \n    if(firstColZero) {\n        for(let i = 0; i < rows; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function setZeroes(matrix: number[][]): void {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    let firstRowHasZero = false;\n    let firstColHasZero = false;\n    \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (matrix[i][j] === 0) {\n                if (i === 0) firstRowHasZero = true;\n                if (j === 0) firstColHasZero = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    \n    for (let i = 1; i < rows; i++) {\n        for (let j = 1; j < cols; j++) {\n            if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    \n    if (firstRowHasZero) {\n        for (let j = 0; j < cols; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n    \n    if (firstColHasZero) {\n        for (let i = 0; i < rows; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $matrix\n     */\n    function setZeroes(&$matrix) {\n        $row = count($matrix);\n        $col = count($matrix[0]);\n        \n        $col0 = false;\n        \n        for ($i = 0; $i < $row; $i++) {\n            if ($matrix[$i][0] == 0) {\n                $col0 = true;\n            }\n            for ($j = 1; $j < $col; $j++) {\n                if ($matrix[$i][$j] == 0) {\n                    $matrix[$i][0] = 0;\n                    $matrix[0][$j] = 0;\n                }\n            }\n        }\n        \n        for ($i = $row - 1; $i >= 0; $i--) {\n            for ($j = $col - 1; $j >= 1; $j--) {\n                if ($matrix[$i][0] == 0 || $matrix[0][$j] == 0) {\n                    $matrix[$i][$j] = 0;\n                }\n            }\n            if ($col0) {\n                $matrix[$i][0] = 0;\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var firstRowHasZero = false\n        var firstColHasZero = false\n        \n        for i in 0..<matrix.count {\n            for j in 0..<matrix[0].count {\n                if matrix[i][j] == 0 {\n                    if i == 0 {\n                        firstRowHasZero = true\n                    }\n                    if j == 0 {\n                        firstColHasZero = true\n                    }\n                    matrix[0][j] = 0\n                    matrix[i][0] = 0\n                }\n            }\n        }\n        \n        for i in 1..<matrix.count {\n            for j in 1..<matrix[0].count {\n                if matrix[0][j] == 0 || matrix[i][0] == 0 {\n                    matrix[i][j] = 0\n                }\n            }\n        }\n        \n        if firstRowHasZero {\n            for j in 0..<matrix[0].count {\n                matrix[0][j] = 0\n            }\n        }\n        \n        if firstColHasZero {\n            for i in 0..<matrix.count {\n                matrix[i][0] = 0\n            }\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun setZeroes(matrix: Array<IntArray>): Unit {\n        val rows = matrix.size\n        val cols = matrix[0].size\n        var isCol = false\n\n        for (i in 0 until rows) {\n            if (matrix[i][0] == 0) {\n                isCol = true\n            }\n\n            for (j in 1 until cols) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n                }\n            }\n        }\n\n        for (i in 1 until rows) {\n            for (j in 1 until cols) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0\n                }\n            }\n        }\n\n        if (matrix[0][0] == 0) {\n            for (j in 0 until cols) {\n                matrix[0][j] = 0\n            }\n        }\n\n        if (isCol) {\n            for (i in 0 until rows) {\n                matrix[i][0] = 0\n            }\n        }\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void setZeroes(List<List<int>> matrix) {\n    bool firstRowHasZero = false;\n    bool firstColHasZero = false;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (matrix[i][j] == 0) {\n          if (i == 0) {\n            firstRowHasZero = true;\n          }\n          if (j == 0) {\n            firstColHasZero = true;\n          }\n          matrix[0][j] = 0;\n          matrix[i][0] = 0;\n        }\n      }\n    }\n\n    for (int i = 1; i < m; i++) {\n      for (int j = 1; j < n; j++) {\n        if (matrix[0][j] == 0 || matrix[i][0] == 0) {\n          matrix[i][j] = 0;\n        }\n      }\n    }\n\n    if (firstRowHasZero) {\n      for (int j = 0; j < n; j++) {\n        matrix[0][j] = 0;\n      }\n    }\n\n    if (firstColHasZero) {\n      for (int i = 0; i < m; i++) {\n        matrix[i][0] = 0;\n      }\n    }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func setZeroes(matrix [][]int)  {\n    rows := len(matrix)\n    cols := len(matrix[0])\n    zeroFirstCol := false\n\n    for i := 0; i < rows; i++ {\n        if matrix[i][0] == 0 {\n            zeroFirstCol = true\n        }\n        for j := 1; j < cols; j++ {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n\n    for i := 1; i < rows; i++ {\n        for j := 1; j < cols; j++ {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n\n    if matrix[0][0] == 0 {\n        for j := 0; j < cols; j++ {\n            matrix[0][j] = 0\n        }\n    }\n\n    if zeroFirstCol {\n        for i := 0; i < rows; i++ {\n            matrix[i][0] = 0\n        }\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @return {Void} Do not return anything, modify matrix in-place instead.\ndef set_zeroes(matrix)\n    rows = matrix.length\n    cols = matrix[0].length\n    zero_rows = []\n    zero_cols = []\n    \n    (0...rows).each do |i|\n        (0...cols).each do |j|\n            if matrix[i][j] == 0\n                zero_rows << i\n                zero_cols << j\n            end\n        end\n    end\n    \n    zero_rows.each { |row| matrix[row] = [0] * cols }\n    (0...rows).each { |i| zero_cols.each { |col| matrix[i][col] = 0 } }\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def setZeroes(matrix: Array[Array[Int]]): Unit = {\n        var firstRowZero = false\n        var firstColZero = false\n        \n        for (i <- 0 until matrix.length) {\n            for (j <- 0 until matrix(0).length) {\n                if (matrix(i)(j) == 0) {\n                    if (i == 0) firstRowZero = true\n                    if (j == 0) firstColZero = true\n                    matrix(0)(j) = 0\n                    matrix(i)(0) = 0\n                }\n            }\n        }\n        \n        for (i <- 1 until matrix.length) {\n            for (j <- 1 until matrix(0).length) {\n                if (matrix(0)(j) == 0 || matrix(i)(0) == 0) {\n                    matrix(i)(j) = 0\n                }\n            }\n        }\n        \n        if (firstRowZero) {\n            for (j <- 0 until matrix(0).length) {\n                matrix(0)(j) = 0\n            }\n        }\n        \n        if (firstColZero) {\n            for (i <- 0 until matrix.length) {\n                matrix(i)(0) = 0\n            }\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        let mut first_col_zero = false;\n        \n        // Mark the rows and columns to be zeroed out\n        for i in 0..matrix.len() {\n            if matrix[i][0] == 0 {\n                first_col_zero = true;\n            }\n            for j in 1..matrix[0].len() {\n                if matrix[i][j] == 0 {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        // Zero out based on the marks\n        for i in (1..matrix.len()).rev() {\n            for j in (1..matrix[0].len()).rev() {\n                if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        // Zero out the first row if needed\n        if matrix[0][0] == 0 {\n            for j in 0..matrix[0].len() {\n                matrix[0][j] = 0;\n            }\n        }\n        \n        // Zero out the first column if needed\n        if first_col_zero {\n            for i in 0..matrix.len() {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of setting entire rows and columns to zero in a matrix when an element is zero, we need to do it in place with a space complexity of O(1). Performing the operation in place means we cannot use additional data structures to store the positions of zero elements directly.\n\n## # Explanation\n1. **Initial Pass to Mark Rows and Columns:** Start by iterating through the matrix to find all the zero elements. Use the first row and first column as markers to indicate which rows and columns should be set to zero. Additionally, use two variables to keep track of whether the first row and the first column themselves should be zeroed out.\n\n2. **Zeroing Rows and Columns:** Iterate again to set the matrix elements to zero based on the markers in the first row and column.\n\n3. **Final Adjustments:** Finally, zero out the first row and first column if necessary based on the variables tracked in the first pass.\n\n## # Pseudocode\n```pseudocode\nfunction setZeroes(matrix)\n    m = number of rows in matrix\n    n = number of columns in matrix\n    row_zero = false\n    col_zero = false\n\n    # Step 1: determine which row and column need to be zero\n    for i from 0 to m-1 do\n        for j from 0 to n-1 do\n            if matrix[i][j] == 0 then\n                if i == 0 then\n                    row_zero = true\n                if j == 0 then\n                    col_zero = true\n                # mark the corresponding row and column in the first row and column\n                matrix[0][j] = 0\n                matrix[i][0] = 0\n\n    # Step 2: use the first row and column to set elements to zero\n    for i from 1 to m-1 do\n        for j from 1 to n-1 do\n            if matrix[i][0] == 0 or matrix[0][j] == 0 then\n                matrix[i][j] = 0\n\n    # Step 3: zero out the first row if needed\n    if row_zero then\n        for j from 0 to n-1 do\n            matrix[0][j] = 0\n\n    # Step 4: zero out the first column if needed\n    if col_zero then\n        for i from 0 to m-1 do\n            matrix[i][0] = 0\n```\n\nThis approach efficiently modifies the matrix in place by leveraging the first row and column as auxiliary storage, ensuring that the space complexity remains constant at O(1).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-set-matrix-zeroes"
    },
    {
        "name": "Search A 2D Matrix",
        "site": "LeetCode",
        "href": "/solution/LeetCode-search-a-2d-matrix",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        int left = 0;\n        int right = m * n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midElement = matrix[mid / n][mid % n];\n            \n            if (midElement == target) {\n                return true;\n            } else if (midElement < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return false;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        \n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        int left = 0;\n        int right = rows * cols - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midElement = matrix[mid / cols][mid % cols];\n            \n            if (midElement == target) {\n                return true;\n            } else if (midElement < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if mid_element == target:\n                return True\n            elif mid_element < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\n    int m = matrixSize;\n    int n = *matrixColSize;\n    \n    int low = 0;\n    int high = m * n - 1;\n    \n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int midElement = matrix[mid / n][mid % n];\n        \n        if (midElement == target) {\n            return true;\n        } else if (midElement < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool SearchMatrix(int[][] matrix, int target) {\n        int m = matrix.Length;\n        int n = matrix[0].Length;\n\n        int left = 0;\n        int right = m * n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midElement = matrix[mid / n][mid % n];\n            \n            if (midElement == target) {\n                return true;\n            } else if (midElement < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nconst searchMatrix = (matrix, target) => {\n    if (matrix.length === 0) {\n        return false;\n    }\n    \n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    let left = 0;\n    let right = rows * cols - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        const midVal = matrix[Math.floor(mid / cols)][mid % cols];\n        \n        if (midVal === target) {\n            return true;\n        } else if (midVal < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function searchMatrix(matrix: number[][], target: number): boolean {\n    let rows = matrix.length;\n    let cols = matrix[0].length;\n    \n    let left = 0;\n    let right = rows * cols - 1;\n    \n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        let midVal = matrix[Math.floor(mid / cols)][mid % cols];\n        \n        if (midVal === target) {\n            return true;\n        } else if (midVal < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return false;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $matrix\n     */\n    function searchMatrix($matrix, $target) {\n        $m = count($matrix);\n        $n = count($matrix[0]);\n        \n        $left = 0;\n        $right = $m * $n - 1;\n        \n        while ($left <= $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            $row = intval($mid / $n);\n            $col = $mid % $n;\n            \n            if ($matrix[$row][$col] == $target) {\n                return true;\n            } else if ($matrix[$row][$col] < $target) {\n                $left = $mid + 1;\n            } else {\n                $right = $mid - 1;\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n        guard !matrix.isEmpty, !matrix[0].isEmpty else {\n            return false\n        }\n        \n        let row = matrix.count\n        let col = matrix[0].count\n        var left = 0\n        var right = row * col - 1\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            let midElement = matrix[mid / col][mid % col]\n            \n            if midElement == target {\n                return true\n            } else if midElement < target {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\n        if (matrix.isEmpty() || matrix[0].isEmpty()) {\n            return false\n        }\n        \n        val rows = matrix.size\n        val cols = matrix[0].size\n        \n        var left = 0\n        var right = rows * cols - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            val midElement = matrix[mid / cols][mid % cols]\n            \n            if (midElement == target) {\n                return true\n            } else if (midElement < target) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        return false\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool searchMatrix(List<List<int>> matrix, int target) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    \n    int left = 0;\n    int right = m * n - 1;\n    \n    while (left <= right) {\n      int mid = left + ((right - left) ~/ 2);\n      int midElement = matrix[mid ~/ n][mid % n];\n      \n      if (midElement == target) {\n        return true;\n      } else if (midElement < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func searchMatrix(matrix [][]int, target int) bool {\n    m := len(matrix)\n    if m == 0 {\n        return false\n    }\n    n := len(matrix[0])\n    low, high := 0, m*n-1\n\n    for low <= high {\n        mid := low + (high-low)/2\n        midVal := matrix[mid/n][mid%n]\n\n        if midVal == target {\n            return true\n        } else if midVal < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n\n    return false\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @param {Integer} target\n# @return {Boolean}\ndef search_matrix(matrix, target)\n    m = matrix.length\n    n = matrix[0].length\n    left = 0\n    right = m * n - 1\n    \n    while left <= right\n        mid = left + (right - left) / 2\n        mid_val = matrix[mid / n][mid % n]\n        \n        if mid_val == target\n            return true\n        elsif mid_val < target\n            left = mid + 1\n        else\n            right = mid - 1\n        end\n    end\n    \n    return false\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def searchMatrix(matrix: Array[Array[Int]], target: Int): Boolean = {\n        if (matrix.isEmpty || matrix(0).isEmpty) {\n            return false\n        }\n        \n        val m = matrix.length\n        val n = matrix(0).length\n        \n        var left = 0\n        var right = m * n - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            val midElement = matrix(mid / n)(mid % n)\n            \n            if (midElement == target) {\n                return true\n            } else if (midElement < target) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        false\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        if matrix.is_empty() || matrix[0].is_empty() {\n            return false;\n        }\n        \n        let rows = matrix.len();\n        let cols = matrix[0].len();\n        \n        let mut left = 0;\n        let mut right = (rows * cols) as i32 - 1;\n        \n        while left <= right {\n            let mid = left + (right - left) / 2;\n            let mid_element = matrix[mid as usize / cols][mid as usize % cols];\n            \n            if mid_element == target {\n                return true;\n            } else if mid_element < target {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        false\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec search_matrix(Matrix :: [[integer()]], Target \n:: integer()) -> boolean().\nsearch_matrix(Matrix, Target) ->\n    Rows = lists:flatten(Matrix),\n    lists:member(Target, Rows)."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, an effective approach is to use a binary search algorithm on the matrix by treating it as a one-dimensional array. This approach is viable due to the sorted nature of each row and the entire matrix's order properties.\n\n# Explanation\n1. **Understanding the Matrix**: The matrix has `m` rows and `n` columns, and crucially:\n   - Each row is independently sorted.\n   - The first element of each row is larger than the last element of the previous row.\n   Hence, the matrix can logically be 'flattened' into a sorted list.\n\n2. **Binary Search Logic**: Instead of iterating through each element (which would be inefficient), use a binary search:\n   - Consider the matrix as a single list of length `m*n`.\n   - Calculate the `mid` index. Use integer division and modulus operations to map this index back to the original 2D matrix coordinates.\n   - Use standard binary search logic to adjust the `left` and `right` bounds.\n\n3. **Time Complexity**: Binary search operates in O(log(m*n)), meeting the challenge's constraints.\n\n# Pseudocode\n```plaintext\nfunction searchMatrix(matrix, target):\n    m = number of rows in matrix\n    n = number of columns in matrix\n    \n    left = 0\n    right = m * n - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        mid_element = matrix[mid // n][mid % n]\n        \n        if mid_element == target:\n            return True\n        else if mid_element < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False\n```\n\nThis pseudocode ensures that the matrix is searched efficiently using binary search, maintaining the O(log(m*n)) time complexity requirement.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-search-a-2d-matrix"
    },
    {
        "name": "Sort Colors",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sort-colors",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int low = 0, high = nums.size() - 1, i = 0;\n        \n        while (i <= high) {\n            if (nums[i] == 0) {\n                swap(nums[i], nums[low]);\n                i++;\n                low++;\n            } else if (nums[i] == 2) {\n                swap(nums[i], nums[high]);\n                high--;\n            } else {\n                i++;\n            }\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void sortColors(int[] nums) {\n        int start = 0;\n        int end = nums.length - 1;\n        int index = 0;\n\n        while (index <= end) {\n            if (nums[index] == 0) {\n                int temp = nums[start];\n                nums[start] = nums[index];\n                nums[index] = temp;\n                start++;\n                index++;\n            } else if (nums[index] == 2) {\n                int temp = nums[end];\n                nums[end] = nums[index];\n                nums[index] = temp;\n                end--;\n            } else {\n                index++;\n            }\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        left, right, i = 0, len(nums) - 1, 0\n        \n        while i <= right:\n            if nums[i] == 0:\n                nums[left], nums[i] = nums[i], nums[left]\n                left += 1\n                i += 1\n            elif nums[i] == 2:\n                nums[right], nums[i] = nums[i], nums[right]\n                right -= 1\n            else:\n                i += 1"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void sortColors(int* nums, int numsSize) {\n    int low = 0, high = numsSize - 1, i = 0;\n    \n    while (i <= high) {\n        if (nums[i] == 0) {\n            int temp = nums[low];\n            nums[low] = nums[i];\n            nums[i] = temp;\n            low++;\n            i++;\n        } else if (nums[i] == 2) {\n            int temp = nums[high];\n            nums[high] = nums[i];\n            nums[i] = temp;\n            high--;\n        } else {\n            i++;\n        }\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void SortColors(int[] nums) {\n        int low = 0;\n        int high = nums.Length - 1;\n        int i = 0;\n\n        while (i <= high) {\n            if (nums[i] == 0) {\n                Swap(nums, i, low);\n                i++;\n                low++;\n            } else if (nums[i] == 2) {\n                Swap(nums, i, high);\n                high--;\n            } else {\n                i++;\n            }\n        }\n    }\n\n    private void Swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify \n * nums in-place instead.\n */\nvar sortColors = function(nums) {\n    let low = 0;\n    let high = nums.length - 1;\n    let i = 0;\n\n    while (i <= high) {\n        if (nums[i] === 0) {\n            [nums[i], nums[low]] = [nums[low], nums[i]];\n            low++;\n            i++;\n        } else if (nums[i] === 2) {\n            [nums[i], nums[high]] = [nums[high], nums[i]];\n            high--;\n        } else {\n            i++;\n        }\n    }\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify nums in-place \ninstead.\n */\nfunction sortColors(nums: number[]): void {\n    let left = 0;\n    let right = nums.length - 1;\n    let i = 0;\n\n    while (i <= right) {\n        if (nums[i] === 0) {\n            [nums[i], nums[left]] = [nums[left], nums[i]];\n            left++;\n            i++;\n        } else if (nums[i] === 2) {\n            [nums[i], nums[right]] = [nums[right], nums[i]];\n            right--;\n        } else {\n            i++;\n        }\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     */\n    function sortColors(&$nums) {\n        $red = 0;\n        $white = 0;\n        $blue = count($nums) - 1;\n        \n        while ($white <= $blue) {\n            if ($nums[$white] == 0) {\n                $this->swap($nums, $white, $red);\n                $white++;\n                $red++;\n            } elseif ($nums[$white] == 1) {\n                $white++;\n            } else {\n                $this->swap($nums, $white, $blue);\n                $blue--;\n            }\n        }\n    }\n    \n    function swap(&$nums, $i, $j) {\n        $temp = $nums[$i];\n        $nums[$i] = $nums[$j];\n        $nums[$j] = $temp;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func sortColors(_ nums: inout [Int]) {\n        var low = 0\n        var high = nums.count - 1\n        var i = 0\n        \n        while i <= high {\n            if nums[i] == 0 {\n                nums.swapAt(i, low)\n                low += 1\n                i += 1\n            } else if nums[i] == 2 {\n                nums.swapAt(i, high)\n                high -= 1\n            } else {\n                i += 1\n            }\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun sortColors(nums: IntArray): Unit {\n        var low = 0\n        var high = nums.size - 1\n        var i = 0\n        \n        while (i <= high) {\n            when {\n                nums[i] == 0 -> {\n                    nums[i] = nums[low]\n                    nums[low] = 0\n                    low++\n                    i++\n                }\n                nums[i] == 1 -> {\n                    i++\n                }\n                nums[i] == 2 -> {\n                    nums[i] = nums[high]\n                    nums[high] = 2\n                    high--\n                }\n            }\n        }\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void sortColors(List<int> nums) {\n    int low = 0;\n    int high = nums.length - 1;\n    int i = 0;\n    \n    while (i <= high) {\n      if (nums[i] == 0) {\n        int temp = nums[i];\n        nums[i] = nums[low];\n        nums[low] = temp;\n        low++;\n        i++;\n      } else if (nums[i] == 2) {\n        int temp = nums[i];\n        nums[i] = nums[high];\n        nums[high] = temp;\n        high--;\n      } else {\n        i++;\n      }\n    }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func sortColors(nums []int)  {\n    low, high := 0, len(nums)-1\n    i := 0\n    for i <= high {\n        if nums[i] == 0 {\n            nums[i], nums[low] = nums[low], nums[i]\n            low++\n            i++\n        } else if nums[i] == 2 {\n            nums[i], nums[high] = nums[high], nums[i]\n            high--\n        } else {\n            i++\n        }\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Void} Do not return anything, modify nums in-place instead.\ndef sort_colors(nums)\n    left = 0\n    right = nums.length - 1\n    i = 0\n    \n    while i <= right\n        if nums[i] == 0\n            nums[i], nums[left] = nums[left], nums[i]\n            left += 1\n            i += 1\n        elsif nums[i] == 2\n            nums[i], nums[right] = nums[right], nums[i]\n            right -= 1\n        else\n            i += 1\n        end\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def sortColors(nums: Array[Int]): Unit = {\n        var low = 0\n        var high = nums.length - 1\n        var i = 0\n\n        while (i <= high) {\n            nums(i) match {\n                case 0 =>\n                    val temp = nums(i)\n                    nums(i) = nums(low)\n                    nums(low) = temp\n                    i += 1\n                    low += 1\n                case 1 =>\n                    i += 1\n                case 2 =>\n                    val temp = nums(i)\n                    nums(i) = nums(high)\n                    nums(high) = temp\n                    high -= 1\n            }\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn sort_colors(nums: &mut Vec<i32>) {\n        let (mut left, mut right, mut current) = (0, nums.len() - 1, 0);\n        \n        while current <= right {\n            if nums[current] == 0 {\n                nums.swap(current, left);\n                left += 1;\n                current += 1;\n            } else if nums[current] == 2 {\n                nums.swap(current, right);\n                if right == 0 {\n                    break;\n                }\n                right -= 1;\n            } else {\n                current += 1;\n            }\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a method known as the Dutch National Flag problem algorithm by Edsger W. Dijkstra. This technique sorts an array containing three distinct values efficiently in a single pass with constant extra space.\n\n### # Explanation\nThe algorithm maintains three pointers:\n1. `left` \u2013 Points to the next position to place `0`.\n2. `right` \u2013 Points to the next position to place `2`.\n3. `i` \u2013 Current index being evaluated.\n\nHere\u2019s a high-level step-by-step explanation:\n1. Start with `left` at the beginning (0), `right` at the end (n-1), and `i` at the beginning (0).\n2. Traverse the array with the pointer `i` until it surpasses `right`.\n3. If `nums[i]` is `0`, swap `nums[i]` with `nums[left]`, and increment both `left` and `i`.\n4. If `nums[i]` is `2`, swap `nums[i]` with `nums[right]`, and decrement `right`.\n5. If `nums[i]` is `1`, just increment `i`.\n\nThis ensures all `0`s are positioned before all `1`s, and all `2`s are positioned after all `1`s.\n\n### # Pseudocode\n```pseudocode\nfunction sortColors(nums):\n    left = 0\n    right = length(nums) - 1\n    i = 0\n    \n    while i <= right:\n        if nums[i] == 0:\n            swap(nums[left], nums[i])\n            left += 1\n            i += 1\n        else if nums[i] == 2:\n            swap(nums[right], nums[i])\n            right -= 1\n        else:\n            i += 1\n```\nIn the pseudocode, `swap(a, b)` denotes exchanging the values of `a` and `b`.\n\n1. Start with the `left` pointer at index `0` (beginning of the array).\n2. Start with the `right` pointer at index `n-1` (end of the array).\n3. Iterate with `i` from `0` to `right`.\n4. If the element at `i` is `0`, swap with `left`, increment both `left` and `i`.\n5. If the element at `i` is `2`, swap with `right`, decrement `right`.\n6. If the element at `i` is `1`, just move to the next element by incrementing `i`.\n\nThis efficiently rearranges the elements such that all `0`s come before `1`s and all `1`s come before `2`s, completing the sorting in a single pass with constant extra space.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sort-colors"
    },
    {
        "name": "Minimum Window Substring",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-window-substring",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        string result = \"\";\n        if (s.empty() || t.empty()) {\n            return result;\n        }\n\n        unordered_map<char, int> target;\n        for (char c : t) {\n            target[c]++;\n        }\n\n        int required = target.size();\n        int left = 0, right = 0;\n        int formed = 0;\n\n        unordered_map<char, int> window;\n\n        int minLen = INT_MAX;\n        int minLeft = 0;\n\n        while (right < s.length()) {\n            char c = s[right];\n            window[c]++;\n            if (target.find(c) != target.end() && window[c] == target[c]) {\n                formed++;\n            }\n            while (formed == required && left <= right) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    minLeft = left;\n                }\n                char leftChar = s[left];\n                window[leftChar]--;\n                if (target.find(leftChar) != target.end() && window[leftChar] < target[leftChar]) {\n                    formed--;\n                }\n                left++;\n            }\n            right++;\n        }\n\n        if (minLen == INT_MAX) {\n            return result;\n        }\n\n        return s.substr(minLeft, minLen);\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String minWindow(String s, String t) {\n        int[] targetCharFreq = new int[128];\n        for(char c : t.toCharArray()) {\n            targetCharFreq[c]++;\n        }\n        \n        int left = 0;\n        int right = 0;\n        int minLen = Integer.MAX_VALUE;\n        int minStart = 0;\n        int count = t.length();\n        \n        while(right < s.length()) {\n            if(targetCharFreq[s.charAt(right++)]-- > 0) {\n                count--;\n            }\n            \n            while(count == 0) {\n                if(right - left < minLen) {\n                    minLen = right - left;\n                    minStart = left;\n                }\n                \n                if(targetCharFreq[s.charAt(left++)]++ == 0) {\n                    count++;\n                }\n            }\n        }\n        \n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if not s or not t:\n            return \"\"\n        \n        char_count = {}\n        for char in t:\n            char_count[char] = char_count.get(char, 0) + 1\n        \n        left, min_left, min_len, count = 0, 0, float('inf'), len(t)\n        \n        for right in range(len(s)):\n            if s[right] in char_count:\n                char_count[s[right]] -= 1\n                if char_count[s[right]] >= 0:\n                    count -= 1\n            \n            while count == 0:\n                if right - left + 1 < min_len:\n                    min_left = left\n                    min_len = right - left + 1\n                \n                if s[left] in char_count:\n                    char_count[s[left]] += 1\n                    if char_count[s[left]] > 0:\n                        count += 1\n                left += 1\n        \n        return \"\" if min_len == float('inf') else s[min_left:min_left+min_len]"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string MinWindow(string s, string t) {\n        if (s == null || s.Length == 0 || t == null || t.Length == 0) {\n            return \"\";\n        }\n        \n        Dictionary<char, int> targetFreq = new Dictionary<char, int>();\n        foreach (char c in t) {\n            if (!targetFreq.ContainsKey(c)) {\n                targetFreq[c] = 0;\n            }\n            targetFreq[c]++;\n        }\n        \n        int required = targetFreq.Count;\n        int left = 0;\n        int right = 0;\n        int formed = 0;\n        \n        Dictionary<char, int> windowFreq = new Dictionary<char, int>();\n        int[] ans = {-1, 0, 0};\n        \n        while (right < s.Length) {\n            char c = s[right];\n            if (!windowFreq.ContainsKey(c)) {\n                windowFreq[c] = 0;\n            }\n            windowFreq[c]++;\n            \n            if (targetFreq.ContainsKey(c) && windowFreq[c] == targetFreq[c]) {\n                formed++;\n            }\n            \n            while (left <= right && formed == required) {\n                c = s[left];\n                if (ans[0] == -1 || right - left + 1 < ans[0]) {\n                    ans[0] = right - left + 1;\n                    ans[1] = left;\n                    ans[2] = right + 1;\n                }\n                \n                windowFreq[c]--;\n                if (targetFreq.ContainsKey(c) && windowFreq[c] < targetFreq[c]) {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return ans[0] == -1 ? \"\" : s.Substring(ans[1], ans[2] - ans[1]);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    const need = {};\n    const window = {};\n    let left = 0;\n    let right = 0;\n    let valid = 0;\n    let start = 0;\n    let len = Infinity;\n\n    for (let char of t) {\n        need[char] = need[char] ? need[char] + 1 : 1;\n    }\n\n    while (right < s.length) {\n        const curr = s[right];\n        right++;\n\n        if (need[curr]) {\n            window[curr] = window[curr] ? window[curr] + 1 : 1;\n            if (window[curr] === need[curr]) {\n                valid++;\n            }\n        }\n\n        while (valid === Object.keys(need).length) {\n            if (right - left < len) {\n                start = left;\n                len = right - left;\n            }\n\n            const removeChar = s[left];\n            left++;\n\n            if (need[removeChar]) {\n                if (window[removeChar] === need[removeChar]) {\n                    valid--;\n                }\n                window[removeChar]--;\n            }\n        }\n    }\n\n    return len === Infinity ? \"\" : s.substr(start, len);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minWindow(s: string, t: string): string {\n    let left = 0;\n    let right = 0;\n    let charCount = new Map();\n    let required = t.length;\n    let minLen = Infinity;\n    let minStart = 0;\n    \n    for (let char of t) {\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n    \n    while (right < s.length) {\n        if (charCount.has(s[right]) && charCount.get(s[right]) > 0) {\n            required--;\n        }\n        charCount.set(s[right], (charCount.get(s[right]) || 0) - 1);\n        right++;\n        \n        while (required === 0) {\n            if (right - left < minLen) {\n                minLen = right - left;\n                minStart = left;\n            }\n            charCount.set(s[left], (charCount.get(s[left]) || 0) + 1);\n            if (charCount.get(s[left]) > 0) {\n                required++;\n            }\n            left++;\n        }\n    }\n    \n    return minLen === Infinity ? \"\" : s.substring(minStart, minStart + minLen);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     *\n     * @param String $t\n     *\n     * @return String\n     */\n    function minWindow($s, $t) {\n        $start = 0;\n        $len = PHP_INT_MAX;\n        $left = $right = 0;\n        $missing = strlen($t);\n        $map = [];\n        $result = '';\n        \n        for ($i = 0; $i < strlen($t); $i++) {\n            $map[$t[$i]]++;\n        }\n        \n        while ($right < strlen($s)) {\n            if (isset($map[$s[$right]]) && $map[$s[$right]] > 0 ) {\n                $missing--;\n            }\n            \n            if (isset($map[$s[$right]])) {\n                $map[$s[$right]]--;\n            }\n            $right++;\n            \n            while ($missing == 0) {\n                if ($right - $left < $len) {\n                    $start = $left;\n                    $len = $right - $left;\n                }\n                if (isset($map[$s[$left]])) {\n                    $map[$s[$left]]++;\n                }\n                if (isset($map[$s[$left]]) && $map[$s[$left]] > 0) {\n                    $missing++;\n                }\n                $left++;\n            }\n        }\n        \n        if ($len != PHP_INT_MAX) {\n            $result = substr($s, $start, $len);\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        var dictT = [Character: Int]()\n        var dictS = [Character: Int]()\n        var required = 0\n        var l = 0\n        var r = 0\n        var formed = 0\n        var ans = (Int.max, -1, -1)\n        \n        for char in t {\n            dictT[char, default: 0] += 1\n        }\n        \n        required = dictT.count\n        \n        while r < s.count {\n            let char = s[s.index(s.startIndex, offsetBy: r)]\n            dictS[char, default: 0] += 1\n            if let countInDictS = dictS[char], let countInDictT = dictT[char] {\n                if countInDictS == countInDictT {\n                    formed += 1\n                }\n            }\n            \n            while formed == required && l <= r {\n                let currentLength = r - l + 1\n                if currentLength < ans.0 {\n                    ans = (currentLength, l, r)\n                }\n                \n                let leftChar = s[s.index(s.startIndex, offsetBy: l)]\n                dictS[leftChar]! -= 1\n                if let leftCharCount = dictS[leftChar], let countT = dictT[leftChar] {\n                    if leftCharCount < countT {\n                        formed -= 1\n                    }\n                }\n                \n                l += 1\n            }\n            \n            r += 1\n        }\n        \n        if ans.1 == -1 {\n            return \"\"\n        } else {\n            let start = s.index(s.startIndex, offsetBy: ans.1)\n            let end = s.index(s.startIndex, offsetBy: ans.2)\n            return String(s[start...end])\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minWindow(s: String, t: String): String {\n        val tMap = mutableMapOf<Char, Int>()\n        t.forEach { tMap[it] = tMap.getOrDefault(it, 0) + 1 }\n\n        var left = 0\n        var minLen = Int.MAX_VALUE\n        var minStart = 0\n        var remainingChars = t.length\n\n        s.forEachIndexed { index, char ->\n            if (tMap.containsKey(char)) {\n                if (tMap[char]!! > 0) {\n                    remainingChars--\n                }\n                tMap[char] = tMap[char]!! - 1\n            }\n\n            while (remainingChars == 0) {\n                if (index - left + 1 < minLen) {\n                    minLen = index - left + 1\n                    minStart = left\n                }\n\n                val leftChar = s[left]\n                if (tMap.containsKey(leftChar)) {\n                    if (tMap[leftChar] == 0) {\n                        remainingChars++\n                    }\n                    tMap[leftChar] = tMap[leftChar]!! + 1\n                }\n\n                left++\n            }\n        }\n\n        return if (minLen == Int.MAX_VALUE) \"\" else s.substring(minStart, minStart + minLen)\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minWindow(s string, t string) string {\n    if len(s) < len(t) {\n        return \"\"\n    }\n\n    tMap := make(map[byte]int)\n    for i := 0; i < len(t); i++ {\n        tMap[t[i]]++\n    }\n\n    required, formed := len(tMap), 0\n    windowCounts := make(map[byte]int)\n    ans := []int{-1, 0, 0}\n    l, r := 0, 0\n\n    for r < len(s) {\n        char := s[r]\n        windowCounts[char]++\n\n        if count, found := tMap[char]; found && windowCounts[char] == count {\n            formed++\n        }\n\n        for l <= r && formed == required {\n            char = s[l]\n            if ans[0] == -1 || r-l+1 < ans[0] {\n                ans[0] = r - l + 1\n                ans[1] = l\n                ans[2] = r\n            }\n\n            windowCounts[char]--\n            if count, found := tMap[char]; found && windowCounts[char] < count {\n                formed--\n            }\n\n            l++\n        }\n\n        r++\n    }\n\n    if ans[0] == -1 {\n        return \"\"\n    }\n    return s[ans[1] : ans[2]+1]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def min_window(s, t)\n    left = 0\n    right = 0\n    window_counts = Hash.new(0)\n    t_counts = Hash.new(0)\n    required_chars = t.length\n    min_len = Float::INFINITY\n    min_start = 0\n\n    t.each_char do |char|\n        t_counts[char] += 1\n    end\n\n    while right < s.length\n        char = s[right]\n        window_counts[char] += 1\n\n        if t_counts[char] > 0 && window_counts[char] <= t_counts[char]\n            required_chars -= 1\n        end\n\n        while required_chars.zero?\n            if right - left + 1 < min_len\n                min_len = right - left + 1\n                min_start = left\n            end\n\n            window_counts[s[left]] -= 1\n            if t_counts[s[left]] > 0 && window_counts[s[left]] < t_counts[s[left]]\n                required_chars += 1\n            end\n\n            left += 1\n        end\n\n        right += 1\n    end\n\n    min_len == Float::INFINITY ? \"\" : s[min_start, min_len]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minWindow(s: String, t: String): String = {\n        val need = scala.collection.mutable.Map[Char, Int]()\n        val window = scala.collection.mutable.Map[Char, Int]()\n\n        t.foreach(char => need(char) = need.getOrElse(char, 0) + 1)\n\n        var left = 0\n        var right = 0\n        var valid = 0\n        var start = 0\n        var len = Int.MaxValue\n\n        while (right < s.length) {\n            val c = s(right)\n            right += 1\n            if (need.contains(c)) {\n                window(c) = window.getOrElse(c, 0) + 1\n                if (window(c) == need(c)) valid += 1\n            }\n\n            while (valid == need.size) {\n                if (right - left < len) {\n                    start = left\n                    len = right - left\n                }\n\n                val d = s(left)\n                left += 1\n                if (need.contains(d)) {\n                    if (window(d) == need(d)) valid -= 1\n                    window(d) = window(d) - 1\n                }\n            }\n        }\n\n        if (len == Int.MaxValue) \"\"\n        else s.substring(start, start + len)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        let (s_chars, t_chars) = (s.chars().collect::<Vec<char>>(), t.chars().collect::<Vec<char>>());\n        let mut t_map: HashMap<char, i32> = HashMap::new();\n        for &c in &t_chars {\n            *t_map.entry(c).or_insert(0) += 1;\n        }\n        let (mut left, mut right, mut required, mut formed) = (0, 0, t_map.len(), 0);\n        let mut window_counts: HashMap<char, i32> = HashMap::new();\n        let mut ans: (i32, i32) = (-1, 0);\n        let mut min_len = std::i32::MAX;\n        \n        while right < s_chars.len() {\n            let char_right = s_chars[right];\n            *window_counts.entry(char_right).or_insert(0) += 1;\n            if let Some(&t_req) = t_map.get(&char_right) {\n                if window_counts[&char_right] == t_req {\n                    formed += 1;\n                }\n            }\n            while left <= right && formed == required {\n                if right as i32 - left as i32 + 1 < min_len {\n                    min_len = right as i32 - left as i32 + 1;\n                    ans = (left as i32, (right + 1) as i32);\n                }\n                let char_left = s_chars[left];\n                *window_counts.get_mut(&char_left).unwrap() -= 1;\n                if let Some(&t_req) = t_map.get(&char_left) {\n                    if window_counts[&char_left] < t_req {\n                        formed -= 1;\n                    }\n                }\n                left += 1;\n            }\n            right += 1;\n        }\n        \n        if ans.0 == -1 {\n            return String::new();\n        } else {\n            return s_chars[ans.0 as usize..ans.1 as usize].iter().collect();\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will utilize the sliding window technique that efficiently finds the minimum window in string `s` that contains all characters from string `t`. This approach ensures an optimal time complexity of O(m + n).\n\n# Explanation\n\n1. **Edge Cases**: First, we handle any cases where `s` or `t` is empty by returning an empty string immediately.\n2. **Character Counting**: Use a hash map to count the frequency of each character in `t`.\n3. **Sliding Window Initialization**: Track the left and right indices of the window, the minimum length of the substring found so far, and the count of required characters matched within the window.\n4. **Expand and Contract the Window**: \n   - Expand the window by moving the right pointer to include characters from `s` in the current window.\n   - Once the window contains all characters of `t` (i.e., `count` hits zero), check if it's the smallest such window found so far. If so, update the minimum length and starting index of the window.\n   - Contract the window by moving the left pointer to potentially find a smaller window.\n\n# Pseudocode\n\n```pseudocode\nfunction minWindow(s, t):\n    if s is empty or t is empty:\n        return \"\"\n\n    # Create a frequency count for characters in t\n    char_count = dictionary with default value 0\n    for char in t:\n        char_count[char] += 1\n\n    left = 0\n    count = length of t\n    min_left = 0\n    min_len = infinity\n\n    for right in range(length of s):\n        if s[right] in char_count:\n            char_count[s[right]] -= 1\n            if char_count[s[right]] >= 0:\n                count -= 1\n\n        while count == 0:\n            if right - left + 1 < min_len:\n                min_left = left\n                min_len = right - left + 1\n\n            if s[left] in char_count:\n                char_count[s[left]] += 1\n                if char_count[s[left]] > 0:\n                    count += 1\n            left += 1\n\n    return \"\" if min_len == infinity else substring of s from min_left to min_left + min_len\n```\n\nThis pseudocode breaks down the sliding window approach for identifying the minimum window substring efficiently, aligning with the challenge's constraints and requirement for optimal performance.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-window-substring"
    },
    {
        "name": "Combinations",
        "site": "LeetCode",
        "href": "/solution/LeetCode-combinations",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> res;\n        vector<int> temp;\n        backtrack(res, temp, n, k, 1);\n        return res;\n    }\n    \n    void backtrack(vector<vector<int>>& res, vector<int>& temp, int n, int k, int start) {\n        if (temp.size() == k) {\n            res.push_back(temp);\n            return;\n        }\n        \n        for (int i = start; i <= n; i++) {\n            temp.push_back(i);\n            backtrack(res, temp, n, k, i + 1);\n            temp.pop_back();\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> current = new ArrayList<>();\n        backtrack(result, current, 1, n, k);\n        return result;\n    }\n    \n    private void backtrack(List<List<Integer>> result, List<Integer> current, int start, int n, int k) {\n        if (current.size() == k) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int i = start; i <= n; i++) {\n            current.add(i);\n            backtrack(result, current, i + 1, n, k);\n            current.remove(current.size() - 1);\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, path):\n            if len(path) == k:\n                output.append(path)\n                return\n            for i in range(start, n+1):\n                backtrack(i+1, path + [i])\n\n        output = []\n        backtrack(1, [])\n        return output"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> Combine(int n, int k) {\n        IList<IList<int>> result = new List<IList<int>>();\n        List<int> current = new List<int>();\n        Backtrack(result, current, 1, n, k);\n        return result;\n    }\n\n    private void Backtrack(IList<IList<int>> result, List<int> current, int start, int n, int k) {\n        if (k == 0) {\n            result.Add(new List<int>(current));\n            return;\n        }\n\n        for (int i = start; i <= n; i++) {\n            current.Add(i);\n            Backtrack(result, current, i + 1, n, k - 1);\n            current.RemoveAt(current.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    const result = [];\n    \n    const backtrack = (curr, start) => {\n        if (curr.length === k) {\n            result.push(curr.slice());\n            return;\n        }\n        \n        for (let i = start; i <= n; i++) {\n            curr.push(i);\n            backtrack(curr, i + 1);\n            curr.pop();\n        }\n    }\n    \n    backtrack([], 1);\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function combine(n: number, k: number): number[][] {\n    const result: number[][] = [];\n    \n    const backtrack = (start: number, curr: number[]) => {\n        if (curr.length === k) {\n            result.push([...curr]);\n            return;\n        }\n        \n        for (let i = start; i <= n; i++) {\n            curr.push(i);\n            backtrack(i + 1, curr);\n            curr.pop();\n        }\n    };\n    \n    backtrack(1, []);\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     */\n    function combine($n, $k) {\n        $answer = [];\n        $this->backtrack($n, $k, 1, [], $answer);\n        return $answer;\n    }\n    \n    function backtrack($n, $k, $start, $path, &$answer) {\n        if ($k === 0) {\n            $answer[] = $path;\n            return;\n        }\n        \n        for ($i = $start; $i <= $n; $i++) {\n            $path[] = $i;\n            $this->backtrack($n, $k - 1, $i + 1, $path, $answer);\n            array_pop($path);\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun combine(n: Int, k: Int): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        val tempList = mutableListOf<Int>()\n\n        fun backtrack(start: Int, tempList: MutableList<Int>) {\n            if (tempList.size == k) {\n                result.add(tempList.toList())\n                return\n            }\n\n            for (i in start..n) {\n                tempList.add(i)\n                backtrack(i + 1, tempList)\n                tempList.removeAt(tempList.size - 1)\n            }\n        }\n\n        backtrack(1, tempList)\n        return result\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> combine(int n, int k) {\n    List<List<int>> result = [];\n    \n    void backtrack(int start, List<int> curr) {\n      if (curr.length == k) {\n        result.add(List.from(curr));\n        return;\n      }\n      \n      for (int i = start; i <= n; i++) {\n        curr.add(i);\n        backtrack(i + 1, curr);\n        curr.removeLast();\n      }\n    }\n    \n    backtrack(1, []);\n    \n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func combine(n int, k int) [][]int {\n    res := [][]int{}\n    \n    var backtrack func(start int, path []int)\n    backtrack = func(start int, path []int) {\n        if len(path) == k {\n            temp := make([]int, k)\n            copy(temp, path)\n            res = append(res, temp)\n            return\n        }\n        \n        for i := start; i <= n; i++ {\n            backtrack(i+1, append(path, i))\n        }\n    }\n    \n    backtrack(1, []int{})\n    \n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer[][]}\ndef combine(n, k)\n    result = []\n    current = []\n    \n    backtrack(1, n, k, current, result)\n    \n    result\nend\n\ndef backtrack(start, n, k, current, result)\n    if current.length == k\n        result << current.dup\n        return\n    end\n    \n    (start..n).each do |num|\n        current << num\n        backtrack(num + 1, n, k, current, result)\n        current.pop\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def combine(n: Int, k: Int): List[List[Int]] = {\n        if (k == 0) {\n            List(List())\n        } else if (k == n) {\n            (1 to n).toList  :: Nil\n        } else {\n            combine(n - 1, k) ++ combine(n - 1, k - 1).map(_ :+ n)\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut path = Vec::new();\n        \n        fn backtrack(start: i32, n: i32, k: i32, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {\n            if path.len() == k as usize {\n                result.push(path.clone());\n                return;\n            }\n            \n            for i in start..=n {\n                path.push(i);\n                backtrack(i + 1, n, k, path, result);\n                path.pop();\n            }\n        }\n        \n        backtrack(1, n, k, &mut path, &mut result);\n        \n        result\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec combine(N :: integer(), K :: integer()) -> \n[[integer()]].\ncombine(N, K) ->\n    combine(N, K, lists:seq(1, N)).\n\ncombine(_, 0, _) ->\n    [[]];\ncombine(N, K, [H|T]) ->\n    [[H|X] || X <- combine(N, K-1, T)] ++ combine(N, K, T);\ncombine(_, _, []) ->\n    []."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate all possible combinations of `k` numbers chosen from the range `[1, n]` using backtracking. Here is a detailed explanation along with the pseudocode to achieve that.\n\n# Explanation\n1. **Backtracking**: This technique helps explore different combinations by building them incrementally and abandoning them as soon as we know they cannot result in a valid solution.\n2. **Base Case**: When the length of the current combination (path) equals `k`, we add this combination to the output list.\n3. **Recursive Case**: Start from the current index, and recursively add each number to the current path, ensuring that the next number to be added is greater than the last added number to avoid duplicate combinations.\n4. **Termination**: Once every combination of length `k` has been explored, return the output list containing all the valid combinations.\n\n# Pseudocode\n```\nFunction combine(n, k):\n    Initialize output as an empty list\n    \n    Function backtrack(start, path):\n        If length of path equals k:\n            Add path to output\n            Return\n        \n        For i from start to n:\n            Add i to the current path\n            Recursively call backtrack with i + 1 and the updated path\n    \n    Call backtrack with start = 1 and an empty path\n    Return output\n```\nThis pseudocode outlines the approach of exploring all possible combinations recursively and ensures that each valid combination of `k` numbers is included in the result.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-combinations"
    },
    {
        "name": "Subsets",
        "site": "LeetCode",
        "href": "/solution/LeetCode-subsets",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> res;\n        vector<int> subset;\n        backtrack(nums, res, subset, 0);\n        return res;\n    }\n    \n    void backtrack(vector<int>& nums, vector<vector<int>>& res, vector<int>& subset, int start) {\n        res.push_back(subset);\n        for (int i = start; i < nums.size(); ++i) {\n            subset.push_back(nums[i]);\n            backtrack(nums, res, subset, i + 1);\n            subset.pop_back();\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        generateSubsets(nums, 0, new ArrayList<>(), result);\n        return result;\n    }\n    \n    private void generateSubsets(int[] nums, int index, List<Integer> current, List<List<Integer>> result) {\n        result.add(new ArrayList<>(current));\n        \n        for (int i = index; i < nums.length; i++) {\n            current.add(nums[i]);\n            generateSubsets(nums, i + 1, current, result);\n            current.remove(current.size() - 1);\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, path, result):\n            result.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path, result)\n                path.pop()\n        \n        result = []\n        backtrack(0, [], result)\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n */\nint **subsets(int *nums, int numsSize, int *returnSize, int **returnColumnSizes) {\n    // Calculate the number of subsets\n    int numSubsets = pow(2, numsSize);\n    \n    // Allocate memory for the result arrays\n    int **result = (int **)malloc(sizeof(int *) * numSubsets);\n    *returnColumnSizes = (int *)malloc(sizeof(int) * numSubsets);\n    *returnSize = numSubsets;\n    \n    // Generate the subsets\n    for (int i = 0; i < numSubsets; i++) {\n        int subsetSize = 0;\n        result[i] = (int *)malloc(sizeof(int) * numsSize);\n        \n        for (int j = 0; j < numsSize; j++) {\n            if (i & (1 << j)) {\n                result[i][subsetSize] = nums[j];\n                subsetSize++;\n            }\n        }\n        \n        (*returnColumnSizes)[i] = subsetSize;\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> Subsets(int[] nums) {\n        IList<IList<int>> result = new List<IList<int>>();\n        List<int> current = new List<int>();\n        GenerateSubsets(nums, 0, current, result);\n        return result;\n    }\n\n    private void GenerateSubsets(int[] nums, int index, List<int> current, IList<IList<int>> result)\n    {\n        result.Add(new List<int>(current));\n        for (int i = index; i < nums.Length; i++)\n        {\n            current.Add(nums[i]);\n            GenerateSubsets(nums, i + 1, current, result);\n            current.RemoveAt(current.Count - 1);\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    const result = [[]];\n    \n    for (let num of nums) {\n        const n = result.length;\n        for (let i = 0; i < n; i++) {\n            const subset = result[i].slice();\n            subset.push(num);\n            result.push(subset);\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function subsets(nums: number[]): number[][] {\n    const result: number[][] = [];\n    const backtrack = (start: number, curr: number[]) => {\n        result.push(curr.slice());\n        for (let i = start; i < nums.length; i++) {\n            curr.push(nums[i]);\n            backtrack(i + 1, curr);\n            curr.pop();\n        }\n    };\n    backtrack(0, []);\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsets($nums) {\n        $output = [[]];\n        foreach ($nums as $num) {\n            foreach ($output as $curr) {\n                $output[] = array_merge($curr, [$num]);\n            }\n        }\n        return $output;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func subsets(_ nums: [Int]) -> [[Int]] {\n        var result: [[Int]] = []\n        var subset: [Int] = []\n\n        backtrack(&result, &subset, nums, 0)\n\n        return result\n    }\n\n    func backtrack(_ result: inout [[Int]], _ subset: inout [Int], _ nums: [Int], _ index: Int) {\n        result.append(subset)\n\n        for i in index..<nums.count {\n            subset.append(nums[i])\n            backtrack(&result, &subset, nums, i + 1)\n            subset.removeLast()\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun subsets(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        backtrack(result, ArrayList(), nums, 0)\n        return result\n    }\n\n    private fun backtrack(result: MutableList<List<Int>>, tempList: ArrayList<Int>, nums: IntArray, start: Int) {\n        result.add(ArrayList(tempList))\n        for (i in start until nums.size) {\n            tempList.add(nums[i])\n            backtrack(result, tempList, nums, i + 1)\n            tempList.removeAt(tempList.size - 1)\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> subsets(List<int> nums) {\n    List<List<int>> result = [];\n    \n    void backtrack(int start, List<int> path) {\n      result.add(List.from(path));\n      \n      for (int i = start; i < nums.length; i++) {\n        path.add(nums[i]);\n        backtrack(i + 1, path);\n        path.removeLast();\n      }\n    }\n    \n    backtrack(0, []);\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func subsets(nums []int) [][]int {\n    result := make([][]int, 0)\n    subset := make([]int, 0)\n\n    var backtrack func(start int)\n    backtrack = func(start int) {\n        temp := make([]int, len(subset))\n        copy(temp, subset)\n        result = append(result, temp)\n\n        for i := start; i < len(nums); i++ {\n            subset = append(subset, nums[i])\n            backtrack(i + 1)\n            subset = subset[:len(subset)-1]\n        }\n    }\n\n    backtrack(0)\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[][]}\ndef subsets(nums)\n    result = []\n    \n    (0..nums.length).each do |i|\n        nums.combination(i).each do |subset|\n            result << subset\n        end\n    end\n    \n    result\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def subsets(nums: Array[Int]): List[List[Int]] = {\n        def backtrack(start: Int, path: List[Int]): List[List[Int]] = {\n            if (start == nums.length) {\n                List(path)\n            } else {\n                backtrack(start + 1, path) ++ backtrack(start + 1, nums(start) :: path)\n            }\n        }\n        \n        backtrack(0, List())\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut res = Vec::new();\n        let n = nums.len();\n        \n        for i in 0..1 << n {\n            let mut subset = Vec::new();\n            for j in 0..n {\n                if (i >> j) & 1 == 1 {\n                    subset.push(nums[j]);\n                }\n            }\n            res.push(subset);\n        }\n        \n        res\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec subsets(Nums :: [integer()]) -> [[integer()]].\nsubsets(Nums) ->\n    Results = [[]],\n    lists:foldl(\n        fun(X, Acc) -> \n            lists:append(lists:map(fun(Y) -> [X | Y] end, Acc), Acc)\n        end,\n        Results,\n        Nums\n    ).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate all possible subsets of a given list of unique integers. The approach to solve this problem involves backtracking.\n\n# Explanation\n1. **Input Specification**: We are given a list `nums` of unique integers.\n2. **Output Specification**: We need to return a list of all possible subsets of `nums`.\n3. **Constraints**: The length of `nums` is between 1 and 10, inclusive, and all elements are unique_integer between -10 and 10.\n\n## Approach\nWe use backtracking to generate the power set. The idea is to iterate through each element in the input list, decide whether to include it in the current subset or not, and recursively build all possible subsets.\n\nSteps:\n1. Initialize an empty list `result` to store all subsets.\n2. Define a helper function `backtrack(start, path)` where:\n   - `start` is the current index in `nums` to consider.\n   - `path` is the current subset being constructed.\n3. In each call to `backtrack`:\n   - Add the current `path` to `result`.\n   - Iterate through the elements of `nums` starting from the `start` index.\n   - For each element, add it to `path`, and recursively call `backtrack` with the next index.\n   - After the recursive call, remove the last element from `path` to backtrack and consider other subsets.\n\nFinally, return the `result` which contains all possible subsets.\n\n# Pseudocode\n\n```\ndef subsets(nums):\n    def backtrack(start, path, result):\n        # Add the current subset (path) to the result list\n        result.append(path[:])\n        # Iterate through the elements starting from 'start' index\n        for i in range(start, len(nums)):\n            # Include nums[i] in the current subset\n            path.append(nums[i])\n            # Move to the next element\n            backtrack(i + 1, path, result)\n            # Remove nums[i] from path (backtrack)\n            path.pop()\n    \n    # Initialize result to store all subsets\n    result = []\n    # Start backtracking from index 0 with an empty subset\n    backtrack(0, [], result)\n    # Return the result containing all subsets\n    return result\n```\n\nThis pseudocode provides a structured approach to solving the problem by using backtracking to explore all possible subsets of the input list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-subsets"
    },
    {
        "name": "Word Search",
        "site": "LeetCode",
        "href": "/solution/LeetCode-word-search",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        int n = board[0].size();\n\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dfs(board, word, visited, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n    \n    bool dfs(vector<vector<char>>& board, string& word, vector<vector<bool>>& visited, int i, int j, int index) {\n        if (index == word.size()) {\n            return true;\n        }\n        \n        if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]) {\n            return false;\n        }\n        \n        visited[i][j] = true;\n        \n        bool found = dfs(board, word, visited, i + 1, j, index + 1) ||\n                     dfs(board, word, visited, i - 1, j, index + 1) ||\n                     dfs(board, word, visited, i, j + 1, index + 1) ||\n                     dfs(board, word, visited, i, j - 1, index + 1);\n        \n        visited[i][j] = false;\n        \n        return found;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        if (board == null || board.length == 0 || word == null || word.length() == 0) {\n            return false;\n        }\n        \n        int m = board.length;\n        int n = board[0].length;\n        boolean[][] visited = new boolean[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dfs(board, word, visited, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfs(char[][] board, String word, boolean[][] visited, int i, int j, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n        \n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n            return false;\n        }\n        \n        visited[i][j] = true;\n        \n        boolean result = dfs(board, word, visited, i + 1, j, index + 1) ||\n                        dfs(board, word, visited, i - 1, j, index + 1) ||\n                        dfs(board, word, visited, i, j + 1, index + 1) ||\n                        dfs(board, word, visited, i, j - 1, index + 1);\n        \n        visited[i][j] = false;\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def backtrack(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or board[i][j] != word[k]:\n                return False\n            tmp, board[i][j] = board[i][j], '/'\n            res = backtrack(i+1, j, k+1) or backtrack(i-1, j, k+1) or backtrack(i, j+1, k+1) or backtrack(i, j-1, k+1)\n            board[i][j] = tmp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if backtrack(i, j, 0):\n                    return True\n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool dfs(char** board, int rows, int cols, int i, int j, int index, int wordLen, char* word, bool visited[rows][cols]);\n\nbool exist(char** board, int boardSize, int* boardColSize, char* word) {\n    if (board == NULL || boardSize == 0 || boardColSize == NULL || word == NULL) {\n        return false;\n    }\n\n    int rows = boardSize;\n    int cols = *boardColSize;\n    int wordLen = strlen(word);\n\n    bool visited[rows][cols];\n    memset(visited, false, sizeof(visited));\n\n    bool found = false;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (dfs(board, rows, cols, i, j, 0, wordLen, word, visited)) {\n                found = true;\n                break;\n            }\n        }\n        if(found) {\n            break;\n        }\n    }\n\n    return found;\n}\n\nbool dfs(char** board, int rows, int cols, int i, int j, int index, int wordLen, char* word, bool visited[rows][cols]) {\n    if (index == wordLen) {\n        return true;\n    }\n\n    if (i < 0 || i >= rows || j < 0 || j >= cols || visited[i][j] || board[i][j] != word[index]) {\n        return false;\n    }\n\n    visited[i][j] = true;\n\n    if (dfs(board, rows, cols, i + 1, j, index + 1, wordLen, word, visited) ||\n        dfs(board, rows, cols, i - 1, j, index + 1, wordLen, word, visited) ||\n        dfs(board, rows, cols, i, j + 1, index + 1, wordLen, word, visited) ||\n        dfs(board, rows, cols, i, j - 1, index + 1, wordLen, word, visited)) {\n        return true;\n    }\n\n    visited[i][j] = false;\n\n    return false;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool Exist(char[][] board, string word) {\n        int m = board.Length;\n        int n = board[0].Length;\n\n        bool[,] visited = new bool[m, n];\n\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (SearchWord(board, visited, i, j, word, 0))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private bool SearchWord(char[][] board, bool[,] visited, int i, int j, string word, int index)\n    {\n        if (index == word.Length)\n        {\n            return true;\n        }\n\n        if (i < 0 || i >= board.Length || j < 0 || j >= board[0].Length || visited[i, j] || board[i][j] != word[index])\n        {\n            return false;\n        }\n\n        visited[i, j] = true;\n\n        bool result = SearchWord(board, visited, i + 1, j, word, index + 1) ||\n                      SearchWord(board, visited, i - 1, j, word, index + 1) ||\n                      SearchWord(board, visited, i, j + 1, word, index + 1) ||\n                      SearchWord(board, visited, i, j - 1, word, index + 1);\n\n        visited[i, j] = false;\n\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nconst exist = (board, word) => {\n    const dfs = (i, j, k) => {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== word[k]) {\n            return false;\n        }\n        if (k === word.length - 1) {\n            return true;\n        }\n        \n        const temp = board[i][j];\n        board[i][j] = '#';\n        const found = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return found;\n    };\n    \n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[0].length; j++) {\n            if (board[i][j] === word[0] && dfs(i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n};\n  "
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function exist(board: string[][], word: string): boolean {\n    const dfs = (i: number, j: number, index: number): boolean => {\n        if (index === word.length) return true;\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] !== word[index]) return false;\n\n        const temp = board[i][j];\n        board[i][j] = '#';\n        const found = dfs(i + 1, j, index + 1) || dfs(i - 1, j, index + 1) || dfs(i, j + 1, index + 1) || dfs(i, j - 1, index + 1);\n        board[i][j] = temp;\n\n        return found;\n    };\n\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[0].length; j++) {\n            if (dfs(i, j, 0)) return true;\n        }\n    }\n\n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $board\n     */\n    function exist($board, $word) {\n        $rows = count($board);\n        $cols = count($board[0]);\n        \n        for ($i = 0; $i < $rows; $i++) {\n            for ($j = 0; $j < $cols; $j++) {\n                if ($this->dfs($board, $i, $j, $word, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    function dfs(&$board, $i, $j, $word, $index) {\n        if ($index == strlen($word)) {\n            return true;\n        }\n        \n        if ($i < 0 || $i >= count($board) || $j < 0 || $j >= count($board[0]) || $board[$i][$j] != $word[$index]) {\n            return false;\n        }\n        \n        $tmp = $board[$i][$j];\n        $board[$i][$j] = \"#\";\n        \n        $found = $this->dfs($board, $i + 1, $j, $word, $index + 1) || \n                 $this->dfs($board, $i - 1, $j, $word, $index + 1) || \n                 $this->dfs($board, $i, $j + 1, $word, $index + 1) || \n                 $this->dfs($board, $i, $j - 1, $word, $index + 1);\n        \n        $board[$i][$j] = $tmp;\n        \n        return $found;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func exist(_ board: [[Character]], _ word: String) -> Bool {\n        var board = board\n        let m = board.count\n        let n = board[0].count\n        \n        func dfs(_ i: Int, _ j: Int, _ index: Int) -> Bool {\n            if index == word.count {\n                return true\n            }\n            \n            if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[word.index(word.startIndex, offsetBy: index)] {\n                return false\n            }\n            \n            let temp = board[i][j]\n            board[i][j] = \" \"\n            \n            let found = dfs(i + 1, j, index + 1) || dfs(i - 1, j, index + 1) || dfs(i, j + 1, index + 1) || dfs(i, j - 1, index + 1)\n            \n            board[i][j] = temp\n            \n            return found\n        }\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                if dfs(i, j, 0) {\n                    return true\n                }\n            }\n        }\n        \n        return false\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun exist(board: Array<CharArray>, word: String): Boolean {\n        fun dfs(board: Array<CharArray>, word: String, i: Int, j: Int, k: Int): Boolean {\n            if (i !in board.indices || j !in board[i].indices || board[i][j] != word[k]) return false\n            if (k == word.length - 1) return true\n\n            val temp = board[i][j]\n            board[i][j] = '#'\n\n            val result = dfs(board, word, i + 1, j, k + 1) ||\n                    dfs(board, word, i - 1, j, k + 1) ||\n                    dfs(board, word, i, j + 1, k + 1) ||\n                    dfs(board, word, i, j - 1, k + 1)\n\n            board[i][j] = temp\n            return result\n        }\n\n        for (i in board.indices) {\n            for (j in board[i].indices) {\n                if (dfs(board, word, i, j, 0)) {\n                    return true\n                }\n            }\n        }\n\n        return false\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool exist(List<List<String>> board, String word) {\n      int m = board.length;\n      int n = board[0].length;\n      \n      bool dfs(int i, int j, int k) {\n        if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] != word[k]) {\n          return false;\n        }\n        if (k == word.length - 1) {\n          return true;\n        }\n        String tmp = board[i][j];\n        board[i][j] = '';\n        bool found = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = tmp;\n        return found;\n      }\n      \n      for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n          if (dfs(i, j, 0)) {\n            return true;\n          }\n        }\n      }\n      \n      return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func exist(board [][]byte, word string) bool {\n    var dfs func(i, j, k int) bool\n    dfs = func(i, j, k int) bool {\n        if i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) || board[i][j] != word[k] {\n            return false\n        }\n        if k == len(word)-1 {\n            return true\n        }\n        tmp := board[i][j]\n        board[i][j] = ' '\n        if dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1) {\n            return true\n        }\n        board[i][j] = tmp\n        return false\n    }\n    \n    for i := 0; i < len(board); i++ {\n        for j := 0; j < len(board[0]); j++ {\n            if dfs(i, j, 0) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to use a recursive backtracking approach to explore the possible paths in the grid that form the given word. \n\nHere's a detailed explanation and the corresponding pseudocode:\n\n# Explanation:\n1. **Initialization**: Define the main function `exist` that takes the board and the word as inputs. This function will iterate through each cell of the board to start the search.\n2. **Backtracking Function**: Define a helper function `backtrack` that will perform the depth-first search (DFS) from a given cell (i, j) and checks if the current path can form the word from the k-th character onward.\n3. **Base Cases**:\n    - If `k` is equal to the length of the word, it indicates the entire word has been found, so return `True`.\n    - If the current cell (i, j) is out of bounds or does not match the k-th character of the word, return `False`.\n4. **Marking Visited Cells**: Temporarily mark the current cell as visited by replacing its character with a special marker (e.g., '/').\n5. **Recursive Calls**: Recursively call `backtrack` for all four possible directions (right, left, down, up).\n6. **Restore State**: Restore the current cell's original value after exploring all possible paths.\n7. **Check All Starting Points**: Iterate through each cell of the board and call the `backtrack` function.\n\n# Pseudocode:\n```plaintext\nfunction exist(board, word):\n    # Check if the word exists in the board\n    function backtrack(i, j, k):\n        # If we have found the entire word, return True\n        if k == len(word):\n            return True\n        # Check for out-of-bounds or character mismatch\n        if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or board[i][j] != word[k]:\n            return False\n        # Temporarily mark the current cell as visited\n        tmp, board[i][j] = board[i][j], '/'\n        # Explore all four possible directions\n        res = (backtrack(i + 1, j, k + 1) or\n               backtrack(i - 1, j, k + 1) or\n               backtrack(i, j + 1, k + 1) or\n               backtrack(i, j - 1, k + 1))\n        # Restore the original character in the current cell\n        board[i][j] = tmp\n        return res\n    \n    # Iterate through each cell in the board\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            # Start backtracking from the cell if it matches the first character of the word\n            if backtrack(i, j, 0):\n                return True\n    return False\n```\n\nThis pseudocode provides a clear structure for implementing the given problem's solution using a backtracking approach to search for the word in the grid.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-word-search"
    },
    {
        "name": "Remove Duplicates From Sorted Array Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-duplicates-from-sorted-array-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if (n <= 2) {\n            return n;\n        }\n        \n        int index = 2;\n        for (int i = 2; i < n; i++) {\n            if (nums[i] != nums[index - 2]) {\n                nums[index++] = nums[i];\n            }\n        }\n        \n        return index;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length <= 2) {\n            return nums.length;\n        }\n        \n        int index = 2;\n        for (int i = 2; i < nums.length; i++) {\n            if (nums[i] != nums[index - 2]) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def removeDuplicates(self, nums):\n        if len(nums) <= 2:\n            return len(nums)\n        \n        count = 2\n        for i in range(2, len(nums)):\n            if nums[i] != nums[count - 2]:\n                nums[count] = nums[i]\n                count += 1\n        \n        return count"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int removeDuplicates(int* nums, int numsSize) {\n    if (numsSize <= 2) {\n        return numsSize;\n    }\n    \n    int index = 2;\n    for (int i = 2; i < numsSize; i++) {\n        if (nums[i] != nums[index - 2]) {\n            nums[index] = nums[i];\n            index++;\n        }\n    }\n    \n    return index;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int RemoveDuplicates(int[] nums) {\n        if (nums.Length <= 2) {\n            return nums.Length;\n        }\n        \n        int index = 2;\n        for (int i = 2; i < nums.Length; i++) {\n            if (nums[i] != nums[index - 2]) {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    let count = 1;\n    let duplicateCount = 1;\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[i - 1]) {\n            nums[count] = nums[i];\n            count++;\n            duplicateCount = 1;\n        } else {\n            duplicateCount++;\n            if (duplicateCount <= 2) {\n                nums[count] = nums[i];\n                count++;\n            }\n        }\n    }\n    \n    return count;\n};\n\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function removeDuplicates(nums: number[]): number {\n    let count = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (count < 2 || nums[i] !== nums[count - 2]) {\n            nums[count] = nums[i];\n            count++;\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function removeDuplicates(&$nums) {\n        $n = count($nums);\n        if ($n <= 2) {\n            return $n;\n        }\n        \n        $index = 2;\n        for ($i = 2; $i < $n; $i++) {\n            if ($nums[$i] != $nums[$index - 2]) {\n                $nums[$index] = $nums[$i];\n                $index++;\n            }\n        }\n        \n        return $index;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        if nums.isEmpty {\n            return 0\n        }\n        \n        var count = 1\n        var isDuplicate = false\n        \n        for i in 1..<nums.count {\n            if nums[i] == nums[i - 1] {\n                if !isDuplicate {\n                    isDuplicate = true\n                    nums[count] = nums[i]\n                    count += 1\n                }\n            } else {\n                isDuplicate = false\n                nums[count] = nums[i]\n                count += 1\n            }\n        }\n        \n        return count\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun removeDuplicates(nums: IntArray): Int {\n        if (nums.size <= 2) return nums.size\n        \n        var index = 2\n        \n        for (i in 2 until nums.size) {\n            if (nums[i] != nums[index - 2]) {\n                nums[index] = nums[i]\n                index++\n            }\n        }\n        \n        return index\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int removeDuplicates(List<int> nums) {\n    if (nums.length <= 2) {\n      return nums.length;\n    }\n    \n    int index = 2;\n\n    for (int i = 2; i < nums.length; i++) {\n      if (nums[i] != nums[index - 2]) {\n        nums[index] = nums[i];\n        index++;\n      }\n    }\n\n    return index;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func removeDuplicates(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    k := 2\n    for i := 2; i < len(nums); i++ {\n        if nums[i] != nums[k-2] {\n            nums[k] = nums[i]\n            k++\n        }\n    }\n    \n    return k\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef remove_duplicates(nums)\n    return 0 if nums.empty?\n    \n    index = 0\n    count = 1\n    \n    (1..nums.length - 1).each do |i|\n        if nums[i] == nums[index]\n            count += 1\n        else\n            count = 1\n        end\n        \n        if count <= 2\n            index += 1\n            nums[index] = nums[i]\n        end\n    end\n    \n    return index + 1\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def removeDuplicates(nums: Array[Int]): Int = {\n        if(nums.length <= 2) return nums.length\n        var slow = 2\n        for(fast <- 2 until nums.length) {\n            if(nums(fast) != nums(slow - 2)) {\n                nums(slow) = nums(fast)\n                slow += 1\n            }\n        }\n        slow\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let mut i = 0;\n        for j in 0..nums.len() {\n            if i < 2 || nums[j] != nums[i - 2] {\n                nums[i] = nums[j];\n                i += 1;\n            }\n        }\n        i as i32\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to remove some duplicates in the given sorted array such that each unique element appears at most twice. The algorithm should modify the array in place and not use any extra space beyond a constant amount.\n\n# Explanation\nThe approach to this problem involves iterating through the array while maintaining a count of the position in the new array where the next unique element should be placed. Specifically:\n1. If the length of the array is 2 or less, we can return the length of the array directly since it already satisfies the requirement.\n2. Initialize a `count` variable to 2 since the first two elements can remain unchanged.\n3. Iterate through the array starting from the third element.\n4. For each element, compare it with the element at position `count - 2`. If they are different, place the current element at position `count` and increment `count`.\n5. Return the value of `count` which represents the length of the modified array with at most two occurrences of each element.\n\n# Pseudocode\nHere is the pseudocode for the solution:\n\n```\nfunction removeDuplicates(nums):\n    // If array length is 2 or less, return the length of the array\n    if length of nums <= 2:\n        return length of nums\n    \n    // Initialize count to 2\n    count = 2\n    \n    // Iterate over the array starting from the third element\n    for i from 2 to length of nums - 1:\n        // If current element is not equal to the element at position count-2\n        if nums[i] \u2260 nums[count - 2]:\n            // Move current element to position count\n            nums[count] = nums[i]\n            // Increment count\n            count += 1\n   \n    // Return the modified array length\n    return count\n```\n\nThis pseudocode captures the logic necessary to implement the solution in any programming language while ensuring the modifications are made in-place and only a constant extra space is used.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-duplicates-from-sorted-array-ii"
    },
    {
        "name": "Search In Rotated Sorted Array Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-search-in-rotated-sorted-array-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return true;\n            }\n            \n            if (nums[mid] == nums[left] && nums[mid] == nums[right]) {\n                left++;\n                right--;\n            } else if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean search(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return true;\n            }\n            \n            if (nums[mid] == nums[left] && nums[mid] == nums[right]) {\n                left++;\n                right--;\n            } else if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            \n            while left < mid and nums[left] == nums[mid]:\n                left += 1\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool search(int* nums, int numsSize, int target) {\n    int left = 0, right = numsSize - 1;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if(nums[mid] == target) {\n            return true;\n        }\n        \n        if(nums[left] == nums[mid] && nums[right] == nums[mid]) {\n            left++;\n            right--;\n        } else if(nums[left] <= nums[mid]) {\n            if(nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if(nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool Search(int[] nums, int target) {\n        int left = 0, right = nums.Length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return true;\n            }\n            \n            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {\n                left++;\n                right--;\n            } else if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nvar search = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    \n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        \n        if (nums[mid] === target) {\n            return true;\n        }\n        \n        if (nums[left] === nums[mid] && nums[right] === nums[mid]) {\n            left++;\n            right--;\n        } else if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return false;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function search(nums: number[], target: number): boolean {\n    let left = 0;\n    let right = nums.length - 1;\n    \n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        \n        if (nums[mid] === target) {\n            return true;\n        }\n        \n        if (nums[left] === nums[mid] && nums[right] === nums[mid]) {\n            left++;\n            right--;\n        } else if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Boolean\n     */\n    function search($nums, $target) {\n        $left = 0;\n        $right = count($nums) - 1;\n        \n        while ($left <= $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            \n            if ($nums[$mid] == $target) {\n                return true;\n            }\n            \n            if ($nums[$left] == $nums[$mid] && $nums[$right] == $nums[$mid]) {\n                $left++;\n                $right--;\n            } elseif ($nums[$left] <= $nums[$mid]) {\n                if ($nums[$left] <= $target && $target < $nums[$mid]) {\n                    $right = $mid - 1;\n                } else {\n                    $left = $mid + 1;\n                }\n            } else {\n                if ($nums[$mid] < $target && $target <= $nums[$right]) {\n                    $left = $mid + 1;\n                } else {\n                    $right = $mid - 1;\n                }\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Bool {\n        var left = 0\n        var right = nums.count - 1\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            \n            if nums[mid] == target {\n                return true\n            }\n            \n            if nums[left] == nums[mid] && nums[right] == nums[mid] {\n                left += 1\n                right -= 1\n            } else if nums[left] <= nums[mid] {\n                if nums[left] <= target && target < nums[mid] {\n                    right = mid - 1\n                } else {\n                    left = mid + 1\n                }\n            } else {\n                if nums[mid] < target && target <= nums[right] {\n                    left = mid + 1\n                } else {\n                    right = mid - 1\n                }\n            }\n        }\n        \n        return false\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun search(nums: IntArray, target: Int): Boolean {\n        var left = 0\n        var right = nums.size - 1\n\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n\n            if (nums[mid] == target) {\n                return true\n            }\n\n            if (nums[left] == nums[mid] && nums[right] == nums[mid]) {\n                left++\n                right--\n            } else if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1\n                } else {\n                    left = mid + 1\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1\n                } else {\n                    right = mid - 1\n                }\n            }\n        }\n\n        return false\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool search(List<int> nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n      int mid = left + ((right - left) ~/ 2);\n\n      if (nums[mid] == target) {\n        return true;\n      }\n\n      if (nums[left] == nums[mid]) {\n        left++;\n      } else if (nums[left] < nums[mid]) {\n        if (nums[left] <= target && target < nums[mid]) {\n          right = mid - 1;\n        } else {\n          left = mid + 1;\n        }\n      } else {\n        if (nums[mid] < target && target <= nums[right]) {\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func search(nums []int, target int) bool {\n    left, right := 0, len(nums)-1\n\n    for left <= right {\n        mid := left + (right-left)/2\n\n        if nums[mid] == target {\n            return true\n        }\n\n        // Skip duplicates\n        if nums[left] == nums[mid] {\n            left++\n            continue\n        }\n\n        if nums[left] < nums[mid] {\n            if nums[left] <= target && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        } else {\n            if nums[mid] < target && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n\n    return false\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Boolean}\ndef search(nums, target)\n    left = 0\n    right = nums.length - 1\n    \n    while left <= right\n        mid = left + (right - left) / 2\n        \n        return true if nums[mid] == target\n        \n        if nums[left] == nums[mid] && nums[right] == nums[mid]\n            left += 1\n            right -= 1\n        elsif nums[left] <= nums[mid]\n            if nums[left] <= target && target < nums[mid]\n                right = mid - 1\n            else\n                left = mid + 1\n            end\n        else\n            if nums[mid] < target && target <= nums[right]\n                left = mid + 1\n            else\n                right = mid - 1\n            end\n        end\n    end\n    \n    false\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def search(nums: Array[Int], target: Int): Boolean = {\n        if (nums.isEmpty) return false\n        \n        var left = 0\n        var right = nums.length - 1\n        \n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            \n            if (nums(mid) == target) return true\n            \n            if (nums(left) == nums(mid) && nums(right) == nums(mid)) {\n                left += 1\n                right -= 1\n            } else if (nums(left) <= nums(mid)) {\n                if (nums(left) <= target && target < nums(mid)) right = mid - 1\n                else left = mid + 1\n            } else {\n                if (nums(mid) < target && target <= nums(right)) left = mid + 1\n                else right = mid - 1\n            }\n        }\n        \n        false\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> bool {\n        let (mut left, mut right) = (0, nums.len() - 1);\n\n        while left <= right {\n            let mid = left + (right - left) / 2;\n\n            if nums[mid] == target {\n                return true;\n            }\n\n            if nums[left] == nums[mid] {\n                left += 1;\n            } else if nums[left] < nums[mid] {\n                if nums[left] <= target && target < nums[mid] {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if nums[mid] < target && target <= nums[right] {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n\n        false\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec search(Nums :: [integer()], Target :: integer()) -> boolean().\nsearch(Nums, Target) ->\n    case lists:member(Target, Nums) of\n        true -> true;\n        false -> false\n    end."
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) \n  :: boolean\n  def search(nums, target) do\n    Enum.any?(nums, &(&1 == target))\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to efficiently determine if a given integer (`target`) exists within a rotated sorted array (`nums`) that may contain duplicate values, while minimizing the number of operations. The key is to apply a modified binary search that handles the rotation and duplicates.\n\nHere's how you can approach this:\n\n# Explanation\n1. **Initialize Pointers**: Start by initializing two pointers, `left` and `right`, which represent the current range within the array.\n2. **Binary Search Loop**: While `left` is less than or equal to `right`, calculate the mid-point of the current range.\n3. **Target Found**: If the element at the mid-point is equal to the target, return `True`.\n4. **Handle Duplicates**: In case of duplicates, move the `left` pointer closer to the `mid` to skip duplicates.\n5. **Determine Sorted Segment**: Determine which segment (`left to mid` or `mid to right`) is sorted:\n   - If the `left` sub-array (`nums[left]` to `nums[mid]`) is sorted:\n     - Check if the `target` lies within this sub-array.\n     - If so, adjust the `right` pointer; otherwise, adjust the `left` pointer.\n   - Else if the `right` sub-array (`nums[mid]` to `nums[right]`) is sorted:\n     - Check if the `target` lies within this sub-array.\n     - If so, adjust the `left` pointer; otherwise, adjust the `right` pointer.\n6. **Return Result**: If the loop ends without finding the target, return `False`.\n\n# Pseudocode\n``` \n# Pseudocode\nfunction search(nums, target):\n    left = 0\n    right = length(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n      \n        // Check if mid is the target\n        if nums[mid] == target:\n            return True\n\n        // Handle duplicates\n        while left < mid and nums[left] == nums[mid]:\n            left += 1\n      \n        // Determine the sorted sub-array\n        if nums[left] <= nums[mid]:\n            // Left part is sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            // Right part is sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return False\n```\nThis pseudocode outlines the necessary steps to find the target in a rotated sorted array with duplicates using a modified binary search, ensuring efficiency by minimizing unnecessary checks and handling duplicates appropriately.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-search-in-rotated-sorted-array-ii"
    },
    {
        "name": "Remove Duplicates From Sorted List Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-duplicates-from-sorted-list-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode* next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* prev = dummy;\n        while (head) {\n            if (head->next && head->val == head->next->val) {\n                while (head->next && head->val == head->next->val) {\n                    head = head->next;\n                }\n                prev->next = head->next;\n            } else {\n                prev = prev->next;\n            }\n            head = head->next;\n        }\n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = dummy;\n        while (head != null) {\n            if (head.next != null && head.val == head.next.val) {\n                while (head.next != null && head.val == head.next.val) {\n                    head = head.next;\n                }\n                prev.next = head.next;\n            } else {\n                prev = prev.next;\n            }\n            head = head.next;\n        }\n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* deleteDuplicates(struct ListNode* head){\n    if (!head || !head->next) return head;\n    \n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->val = -101;\n    dummy->next = head;\n    struct ListNode* prev = dummy;\n    struct ListNode* curr = head;\n    \n    while (curr) {\n        if (curr->next && curr->val == curr->next->val) {\n            while (curr->next && curr->val == curr->next->val) curr = curr->next;\n            prev->next = curr->next;\n        } else {\n            prev = prev->next;\n        }\n        curr = curr->next;\n    }\n    \n    return dummy->next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n \npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        \n        while (head != null) {\n            if (head.next != null && head.val == head.next.val) {\n                while (head.next != null && head.val == head.next.val) {\n                    head = head.next;\n                }\n                prev.next = head.next;\n            } else {\n                prev = prev.next;\n            }\n            head = head.next;\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\nvar deleteDuplicates = function(head) {\n    if (head === null || head.next === null) return head;\n\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n\n    while (head !== null) {\n        if (head.next !== null && head.val === head.next.val) {\n            while (head.next !== null && head.val === head.next.val) {\n                head = head.next;\n            }\n            prev.next = head.next;\n        } else {\n            prev = prev.next;\n        }\n        head = head.next;\n    }\n\n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return head;\n    }\n    \n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    \n    while (head && head.next) {\n        if (head.val === head.next.val) {\n            while (head && head.next && head.val === head.next.val) {\n                head = head.next;\n            }\n            prev.next = head.next;\n        } else {\n            prev = prev.next;\n        }\n        head = head.next;\n    }\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public ListNode $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function deleteDuplicates($head) {\n        $dummy = new ListNode(0);\n        $dummy->next = $head;\n        $prev = $dummy;\n        while ($head != null) {\n            if ($head->next != null && $head->val == $head->next->val) {\n                while ($head->next != null && $head->val == $head->next->val) {\n                    $head = $head->next;\n                }\n                $prev->next = $head->next;\n            } else {\n                $prev = $prev->next;\n            }\n            $head = $head->next;\n        }\n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\n\nclass Solution {\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\n        var dummy = ListNode(0)\n        dummy.next = head\n        var current: ListNode? = dummy\n        \n        while current?.next != nil && current?.next?.next != nil {\n            if current!.next!.val == current!.next!.next!.val {\n                let duplicateValue = current!.next!.val\n                while current?.next != nil && current!.next!.val == duplicateValue {\n                    current!.next = current!.next!.next\n                }\n            } else {\n                current = current?.next\n            }\n        }\n        \n        return dummy.next\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    dummy := &ListNode{Val: 0, Next: head}\n    prev := dummy\n    for head != nil {\n        if head.Next != nil && head.Val == head.Next.Val {\n            for head.Next != nil && head.Val == head.Next.Val {\n                head = head.Next\n            }\n            prev.Next = head.Next\n        } else {\n            prev = prev.Next\n        }\n        head = head.Next\n    }\n    return dummy.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#     end\n# end\n\ndef delete_duplicates(head)\n    dummy = ListNode.new(0)\n    dummy.next = head\n    current = dummy\n\n    while current.next && current.next.next\n        if current.next.val == current.next.next.val\n            value = current.next.val\n            while current.next && current.next.val == value\n                current.next = current.next.next\n            end\n        else\n            current = current.next\n        end\n    end\n\n    return dummy.next\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *     var x: Int = _x\n *     var next: ListNode = _next\n * }\n */\nobject Solution {\n    def deleteDuplicates(head: ListNode): ListNode = {\n        if (head == null || head.next == null) return head\n        if (head.x != head.next.x) {\n            head.next = deleteDuplicates(head.next)\n            return head\n        } else {\n            var curr: ListNode = head\n            while (curr != null && curr.x == head.x) {\n                curr = curr.next\n            }\n            return deleteDuplicates(curr)\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of removing duplicates from a sorted linked list, we can follow a strategy where we traverse the linked list and use additional pointers to manage the removal of duplicate nodes.\n\n# Explanation:\n1. **Initialization**:\n    - Create a dummy node that points to the head of the list. The dummy node helps in handling edge cases where the head itself might be removed.\n    - Use two pointers, `prev` (to keep track of the last node before the sequence of duplicates) and `head` (to traverse the list).\n\n2. **Traversal and Duplicate Detection**:\n    - Traverse the list using the `head` pointer.\n    - For each node, check if it has a duplicate (`head.next` and `head.val == head.next.val`).\n    - If a duplicate is found, continue moving `head` forward until all duplicates are skipped. Then, link `prev.next` to `head.next` (skipping all duplicates).\n\n3. **Move Pointers**:\n    - If no duplicate is found at `head`, simply move `prev` to `prev.next`.\n\n4. **Return**:\n    - Return `dummy.next` which points to the new head of the modified list.\n\n# Pseudocode:\n```\nfunction deleteDuplicates(head):\n    if head is null or head.next is null:\n        return head\n\n    dummy = new ListNode(0)\n    dummy.next = head\n    prev = dummy\n    \n    while head is not null:\n        if head.next is not null and head.val == head.next.val:\n            while head.next is not null and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    \n    return dummy.next\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-duplicates-from-sorted-list-ii"
    },
    {
        "name": "Remove Duplicates From Sorted List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-duplicates-from-sorted-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        \n        ListNode* current = head;\n        \n        while (current->next != nullptr) {\n            if (current->val == current->next->val) {\n                ListNode* temp = current->next;\n                current->next = current->next->next;\n                delete temp;\n            } else {\n                current = current->next;\n            }\n        }\n        \n        return head;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n \nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode current = head;\n        while (current != null && current.next != null) {\n            if (current.val == current.next.val) {\n                current.next = current.next.next;\n            } else {\n                current = current.next;\n            }\n        }\n        \n        return head;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def deleteDuplicates(self, head):\n        current = head\n        while current and current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        return head"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    struct ListNode* current = head;\n    while(current != NULL && current->next != NULL){\n        if(current->val == current->next->val){\n            struct ListNode* temp = current->next;\n            current->next = current->next->next;\n            free(temp);\n        } else {\n            current = current->next;\n        }\n    }\n    return head;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode current = head;\n        while (current != null && current.next != null) {\n            if (current.val == current.next.val) {\n                current.next = current.next.next;\n            } else {\n                current = current.next;\n            }\n        }\n        \n        return head;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\nvar deleteDuplicates = function(head) {\n    let current = head;\n    while (current !== null && current.next !== null) {\n        if (current.val === current.next.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\n    let current = head;\n    while (current !== null && current.next !== null) {\n        if (current.val === current.next.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * Definition for a singly-linked list.\n     * class ListNode {\n     *     public $val = 0;\n     *     public $next = null;\n     *     function __construct($val = 0, $next = null) {\n     *         $this->val = $val;\n     *         $this->next = $next;\n     *     }\n     * }\n     */\n    \n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function deleteDuplicates($head) {\n        $current = $head;\n        \n        while ($current != null && $current->next != null) {\n            if ($current->val == $current->next->val) {\n                $current->next = $current->next->next;\n            } else {\n                $current = $current->next;\n            }\n        }\n        \n        return $head;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\n\nclass Solution {\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\n        var current = head\n\n        while current != nil && current?.next != nil {\n            if current?.val == current?.next?.val {\n                current?.next = current?.next?.next\n            } else {\n                current = current?.next\n            }\n        }\n\n        return head\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\nfunc deleteDuplicates(head *ListNode) *ListNode {\n    current := head\n    for current != nil && current.Next != nil {\n        if current.Val == current.Next.Val {\n            current.Next = current.Next.Next\n        } else {\n            current = current.Next\n        }\n    }\n    return head\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n **/\n \nobject Solution {\n    def deleteDuplicates(head: ListNode): ListNode = {\n        var current = head\n        while (current != null && current.next != null) {\n            if (current.x == current.next.x) {\n                current.next = current.next.next\n            } else {\n                current = current.next\n            }\n        }\n        head\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::collections::HashSet;\n\n// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n\nimpl Solution {\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut current = head;\n        let mut unique_values = HashSet::new();\n        let mut new_head = None;\n        \n        while let Some(mut node) = current {\n            let val = node.val;\n            \n            if !unique_values.contains(&val) {\n                unique_values.insert(val);\n                if new_head.is_none() {\n                    new_head = Some(Box::new(ListNode { val, next: None }));\n                } else {\n                    let mut tail = new_head.as_mut().unwrap();\n                    while tail.next.is_some() {\n                        tail = tail.next.as_mut().unwrap();\n                    }\n                    tail.next = Some(Box::new(ListNode { val, next: None }));\n                }\n            }\n            \n            current = node.next.take();\n        }\n        \n        new_head\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE{\n#     val: integer,\n#     next: %__MODULE.t | nil\n#   }\n# end\n\ndefmodule Solution do\n  def delete_duplicates(head) do\n    case head do\n      nil -> nil\n      %ListNode{val: val, next: nil} -> %ListNode{val: val, next: nil}\n      %ListNode{val: val, next: %ListNode{val: val, next: next}} ->\n        delete_duplicates(%ListNode{val: val, next: next})\n      %ListNode{val: val, next: next} ->\n        %ListNode{val: val, next: delete_duplicates(next)}\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse a sorted linked list and remove any duplicate nodes while ensuring the list remains sorted. Here is the explanation and the pseudocode for achieving this:\n\n# Explanation\n1. **Initialization**: Start with the head node of the linked list.\n2. **Traversal**: Use a loop to traverse through the linked list until you reach the end (i.e., until the current node is not `None`).\n3. **Duplicate Check**: For each node, check if its value is equal to the value of the next node.\n    - If they are equal, skip the next node by pointing the current node's `next` to the node after the next node.\n    - If they are not equal, move to the next node.\n4. **End of List**: Once the loop completes, return the modified list which should now have all duplicate nodes removed.\n\n# Pseudocode\n```\nfunction deleteDuplicates(head)\n    current = head\n    \n    while current is not None and current.next is not None\n        if current.val equals current.next.val\n            current.next = current.next.next  // Skip the duplicate node\n        else\n            current = current.next  // Move to the next node\n    end while\n    \n    return head  // Return the modified list\n```\n\nThis pseudocode outlines the main steps required to remove duplicates from a sorted linked list and ensures that each element appears only once.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-duplicates-from-sorted-list"
    },
    {
        "name": "Largest Rectangle In Histogram",
        "site": "LeetCode",
        "href": "/solution/LeetCode-largest-rectangle-in-histogram",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack<int> st;\n        int maxArea = 0;\n        heights.push_back(0);\n        for (int i = 0; i < heights.size(); ++i) {\n            while (!st.empty() && heights[i] < heights[st.top()]) {\n                int h = heights[st.top()];\n                st.pop();\n                int w = st.empty() ? i : i - st.top() - 1;\n                maxArea = max(maxArea, h * w);\n            }\n            st.push(i);\n        }\n        return maxArea;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int i = 0;\n        while (i < heights.length) {\n            if (stack.isEmpty() || heights[i] >= heights[stack.peek()]) {\n                stack.push(i);\n                i++;\n            } else {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n        }\n        \n        while (!stack.isEmpty()) {\n            int height = heights[stack.pop()];\n            int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        \n        return maxArea;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        \"\"\"\n        stack = []\n        max_area = 0\n        heights.append(0)\n        for i in range(len(heights)):\n            while stack and heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        return max_area"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int largestRectangleArea(int* heights, int heightsSize) {\n    int maxArea = 0;\n    int stack[heightsSize + 1];\n    int top = -1;\n    for (int i = 0; i <= heightsSize; i++) {\n        while (top != -1 && (i == heightsSize || heights[i] < heights[stack[top]])) {\n            int height = heights[stack[top--]];\n            int width = top == -1 ? i : i - stack[top] - 1;\n            maxArea = fmax(maxArea, height * width);\n        }\n        stack[++top] = i;\n    }\n    return maxArea;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LargestRectangleArea(int[] heights) {\n        if (heights == null || heights.Length == 0) {\n            return 0;\n        }\n        \n        int maxArea = 0;\n        Stack<int> stack = new Stack<int>();\n        \n        for (int i = 0; i <= heights.Length; i++) {\n            int h = (i == heights.Length) ? 0 : heights[i];\n            if (stack.Count == 0 || h >= heights[stack.Peek()]) {\n                stack.Push(i);\n            } else {\n                int top = stack.Pop();\n                int width = stack.Count == 0 ? i : i - 1 - stack.Peek();\n                maxArea = Math.Max(maxArea, heights[top] * width);\n                i--;\n            }\n        }\n        \n        return maxArea;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} heights\n * @return {number}\n */\nconst largestRectangleArea = (heights) => {\n    let maxArea = 0;\n    const stack = [];\n    heights.push(0);\n\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length > 0 && heights[i] < heights[stack[stack.length - 1]]) {\n            const height = heights[stack.pop()];\n            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        stack.push(i);\n    }\n\n    return maxArea;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function largestRectangleArea(heights: number[]): number {\n    let maxArea = 0;\n    const stack: number[] = [];\n    heights.push(0);\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\n            const height = heights[stack.pop() as number];\n            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        stack.push(i);\n    }\n    return maxArea;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $heights\n     */\n    function largestRectangleArea($heights) {\n        $heights[] = 0;\n        $stack = [];\n        $maxArea = 0;\n        for ($i = 0; $i < count($heights); $i++) {\n            while (!empty($stack) && $heights[$i] < $heights[end($stack)]) {\n                $height = $heights[array_pop($stack)];\n                $width = empty($stack) ? $i : $i - end($stack) - 1;\n                $maxArea = max($maxArea, $height * $width);\n            }\n            $stack[] = $i;\n        }\n        return $maxArea;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func largestRectangleArea(_ heights: [Int]) -> Int {\n        \n        var stack: [Int] = []\n        var maxArea = 0\n        var current = 0\n        \n        while current < heights.count {\n            if stack.isEmpty || heights[current] >= heights[stack.last ?? 0] {\n                stack.append(current)\n                current += 1\n            } else {\n                let height = heights[stack.removeLast()]\n                let width = stack.isEmpty ? current : current - stack.last! - 1\n                maxArea = max(maxArea, height * width)\n            }\n        }\n        \n        while !stack.isEmpty {\n            let height = heights[stack.removeLast()]\n            let width = stack.isEmpty ? current : current - stack.last! - 1\n            maxArea = max(maxArea, height * width)\n        }\n        \n        return maxArea\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun largestRectangleArea(heights: IntArray): Int {\n        var maxArea = 0\n        val stack = Stack<Int>()\n        val updatedHeights = IntArray(heights.size + 2)\n        \n        for (i in 0 until heights.size) {\n            updatedHeights[i + 1] = heights[i]\n        }\n        \n        stack.push(0)\n        \n        for (i in 1 until updatedHeights.size) {\n            while (updatedHeights[i] < updatedHeights[stack.peek()]) {\n                val height = updatedHeights[stack.pop()]\n                val width = i - stack.peek() - 1\n                maxArea = maxOf(maxArea, height * width)\n            }\n            stack.push(i)\n        }\n        \n        return maxArea\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int largestRectangleArea(List<int> heights) {\n    int maxArea = 0;\n    List<int> stack = [];\n    heights.insert(0, 0);\n    heights.add(0);\n\n    for (int i = 0; i < heights.length; i++) {\n      while (stack.isNotEmpty && heights[i] < heights[stack.last]) {\n        int height = heights[stack.removeLast()];\n        int width = i - stack.last - 1;\n        maxArea = max(maxArea, height * width);\n      }\n      stack.add(i);\n    }\n\n    return maxArea;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func largestRectangleArea(heights []int) int {\n    if len(heights) == 0 {\n        return 0\n    }\n    \n    stack := []int{}\n    maxArea := 0\n    \n    for i := 0; i <= len(heights); i++ {\n        var h int\n        if i == len(heights) {\n            h = 0\n        } else {\n            h = heights[i]\n        }\n        \n        for len(stack) > 0 && h < heights[stack[len(stack)-1]] {\n            height := heights[stack[len(stack)-1]]\n            stack = stack[:len(stack)-1]\n            width := i\n            if len(stack) > 0 {\n                width = i - stack[len(stack)-1] - 1\n            }\n            area := height * width\n            if area > maxArea {\n                maxArea = area\n            }\n        }\n        \n        stack = append(stack, i)\n    }\n    \n    return maxArea\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def largest_rectangle_area(heights)\n    stack = []\n    max_area = 0\n    heights.push(0)\n    \n    heights.each_with_index do |height, i|\n        while !stack.empty? && heights[stack.last] > height\n            h = heights[stack.pop]\n            w = stack.empty? ? i : i - stack.last - 1\n            max_area = [max_area, h * w].max\n        end\n        stack.push(i)\n    end\n    \n    return max_area\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def largestRectangleArea(heights: Array[Int]): Int = {\n        var maxArea = 0\n        val stack = scala.collection.mutable.Stack[Int]()\n\n        for (i <- heights.indices) {\n            while (stack.nonEmpty && heights(i) < heights(stack.top)) {\n                val height = heights(stack.pop())\n                val width = if (stack.isEmpty) i else i - stack.top - 1\n                maxArea = maxArea.max(height * width)\n            }\n            stack.push(i)\n        }\n\n        while (stack.nonEmpty) {\n            val height = heights(stack.pop())\n            val width = if (stack.isEmpty) heights.length else heights.length - stack.top - 1\n            maxArea = maxArea.max(height * width)\n        }\n\n        maxArea\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {\n        let mut stack = vec![];\n        let mut max_area = 0;\n        let mut i = 0;\n\n        while i < heights.len() {\n            if stack.is_empty() || heights[i] >= heights[*stack.last().unwrap()] {\n                stack.push(i);\n                i += 1;\n            } else {\n                let top = stack.pop().unwrap();\n                let width = if stack.is_empty() {\n                    i as i32\n                } else {\n                    (i - stack.last().unwrap() - 1) as i32\n                };\n                max_area = max_area.max(heights[top] * width);\n            }\n        }\n\n        while !stack.is_empty() {\n            let top = stack.pop().unwrap();\n            let width = if stack.is_empty() {\n                i as i32\n            } else {\n                (i - stack.last().unwrap() - 1) as i32\n            };\n            max_area = max_area.max(heights[top] * width);\n        }\n\n        max_area\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can utilize a stack to keep track of the indices of the heights in the histogram bars. The main idea is to maintain a stack where we store the indices of the histogram bars and ensure that these heights are in ascending order. When we encounter a height that is less than the most recent height in the stack, we calculate the area of the rectangle with the height of the bar at the index stored at the top of the stack.\n\nHere\u2019s the structured explanation and pseudocode for the solution:\n\n### # Explanation\n1. **Initialize Variables**:\n   - A stack to keep track of the indices of the histogram bars.\n   - A variable `max_area` to store the maximum rectangle area found so far.\n   \n2. **Append a Zero at the End**:\n   - This helps in ensuring that all bars in the stack are processed, i.e., it acts as a sentinel.\n\n3. **Iterate Through the Heights**:\n   - For each `heights[i]`, if it is less than the height of the bar at the index stored at the top of the stack, calculate the area for the rectangle with the height of the bar at the stack\u2019s top index.\n   - Pop the stack and calculate the width of the rectangle.\n   - The width is determined by the current index `i` if the stack is empty, else by the difference `i - stack[-1] - 1`.\n\n4. **Calculate and Update**:\n   - Calculate the area of the rectangle using the height popped from the stack and the width determined.\n   - Update `max_area` if the current area is larger.\n\n5. **Push Current Index to Stack**:\n   - After processing any smaller heights, push the current index `i` to the stack.\n\n6. **Return the Maximum Area**:\n   - Once all heights are processed, return `max_area`.\n\n### # Pseudocode\n```pseudo\nfunction largestRectangleArea(heights):\n    # Step 1: Initialize variables\n    stack = []\n    max_area = 0\n    heights.append(0)  # Append a zero to ensure all bars are processed\n\n    # Step 2: Iterate through the heights\n    for i in range(0, len(heights)):\n        # Step 3: While the current height is less than the height at the top of the stack\n        while stack is not empty and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # The height of the rectangle\n            if stack is empty:\n                w = i  # The width is the current index when stack is empty\n            else:\n                w = i - stack[-1] - 1  # Width is the difference between current index and index at new top of stack\n            max_area = max(max_area, h * w)  # Update the max_area\n\n        # Step 5: Push the current index to the stack\n        stack.append(i)\n\n    # Step 6: Return the maximum area\n    return max_area\n```\n\nFollowing this methodology ensures that we process all histogram bars efficiently, making sure we consider all possible rectangular areas and find the largest one.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-largest-rectangle-in-histogram"
    },
    {
        "name": "Maximal Rectangle",
        "site": "LeetCode",
        "href": "/solution/LeetCode-maximal-rectangle",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        if (matrix.empty()) {\n            return 0;\n        }\n        \n        int rows = matrix.size();\n        int cols = matrix[0].size();\n        vector<vector<int>> heights(rows, vector<int>(cols, 0));\n        int maxArea = 0;\n        \n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (matrix[i][j] == '1') {\n                    heights[i][j] = (i == 0) ? 1 : heights[i - 1][j] + 1;\n                }\n            }\n            maxArea = max(maxArea, largestRectangleArea(heights[i]));\n        }\n        \n        return maxArea;\n    }\n    \n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        stack<int> st;\n        int maxArea = 0;\n        \n        for (int i = 0; i <= n; ++i) {\n            while (!st.empty() && (i == n || heights[i] < heights[st.top()])) {\n                int height = heights[st.top()];\n                st.pop();\n                int width = st.empty() ? i : i - st.top() - 1;\n                maxArea = max(maxArea, height * width);\n            }\n            st.push(i);\n        }\n        \n        return maxArea;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if(matrix == null || matrix.length == 0) {\n            return 0;\n        }\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int[] heights = new int[n];\n        int maxArea = 0;\n        \n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0;\n            }\n            maxArea = Math.max(maxArea, largestRectangleArea(heights));\n        }\n        \n        return maxArea;\n    }\n    \n    private int largestRectangleArea(int[] heights) {\n        if(heights == null || heights.length == 0) {\n            return 0;\n        }\n        \n        int n = heights.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Stack<Integer> stack = new Stack<>();\n        \n        for(int i = 0; i < n; i++) {\n            while(!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        \n        stack.clear();\n        \n        for(int i = n - 1; i >= 0; i--) {\n            while(!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        \n        int maxArea = 0;\n        for(int i = 0; i < n; i++) {\n            maxArea = Math.max(maxArea, heights[i] * (right[i] - left[i] - 1));\n        }\n        \n        return maxArea;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        if not matrix or not matrix[0]:\n            return 0\n        \n        def largestRectangleArea(heights):        \n            stack = [-1]\n            max_area = 0\n            heights.append(0)\n            \n            for i in range(len(heights)):\n                while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                    h = heights[stack.pop()]\n                    w = i - stack[-1] - 1\n                    max_area = max(max_area, h * w)\n                stack.append(i)\n            \n            return max_area\n        \n        cols = len(matrix[0])\n        heights = [0] * cols\n        max_area = 0\n        \n        for row in matrix:\n            for i in range(cols):\n                heights[i] = heights[i] + 1 if row[i] == '1' else 0\n            max_area = max(max_area, largestRectangleArea(heights))\n            \n        return max_area\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maximalRectangle(char** matrix, int matrixSize, int* matrixColSize) {\n    if (matrixSize == 0 || *matrixColSize == 0) {\n        return 0;\n    }\n\n    int maxArea = 0;\n    int rows = matrixSize;\n    int cols = *matrixColSize;\n    int heights[cols];\n\n    for (int i = 0; i < cols; i++) {\n        heights[i] = 0;\n    }\n\n    for (int row = 0; row < rows; row++) {\n        for (int col = 0; col < cols; col++) {\n            if (matrix[row][col] == '1') {\n                heights[col]++;\n            } else {\n                heights[col] = 0;\n            }\n        }\n\n        int stack[cols + 1];\n        int top = -1;\n\n        for (int i = 0; i <= cols; i++) {\n            while (top >= 0 && (i == cols || heights[i] < heights[stack[top]])) {\n                int height = heights[stack[top--]];\n                int width = top == -1 ? i : i - stack[top] - 1;\n                maxArea = fmax(maxArea, height * width);\n            }\n            stack[++top] = i;\n        }\n    }\n\n    return maxArea;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaximalRectangle(char[][] matrix) {\n        if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0) {\n            return 0;\n        }\n        \n        int rows = matrix.Length;\n        int cols = matrix[0].Length;\n        int[] heights = new int[cols];\n        int maxArea = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0;\n            }\n            maxArea = Math.Max(maxArea, LargestRectangleArea(heights));\n        }\n        \n        return maxArea;\n    }\n    \n    private int LargestRectangleArea(int[] heights) {\n        int maxArea = 0;\n        Stack<int> stack = new Stack<int>();\n        \n        for (int i = 0; i <= heights.Length; i++) {\n            int height = i == heights.Length ? 0 : heights[i];\n            while (stack.Count > 0 && height < heights[stack.Peek()]) {\n                int h = heights[stack.Pop()];\n                int w = stack.Count == 0 ? i : i - stack.Peek() - 1;\n                maxArea = Math.Max(maxArea, h * w);\n            }\n            stack.Push(i);\n        }\n        \n        return maxArea;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalRectangle = function(matrix) {\n    if (matrix === null || matrix.length === 0) {\n        return 0;\n    }\n\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const heights = new Array(cols).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            heights[j] = matrix[i][j] === '1' ? heights[j] + 1 : 0;\n        }\n        maxArea = Math.max(maxArea, calculateMaxArea(heights));\n    }\n\n    return maxArea;\n};\n\nconst calculateMaxArea = (heights) => {\n    const stack = [];\n    let maxArea = 0;\n\n    for (let i = 0; i <= heights.length; i++) {\n        while (stack.length !== 0 && (i === heights.length || heights[i] < heights[stack[stack.length - 1]])) {\n            const height = heights[stack.pop()];\n            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        stack.push(i);\n    }\n\n    return maxArea;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maximalRectangle(matrix: string[][]) {\n    if (matrix.length === 0) {\n        return 0;\n    }\n\n    let maxArea = 0;\n    const heights = Array(matrix[0].length).fill(0);\n    \n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            heights[j] = matrix[i][j] === '1' ? heights[j] + 1 : 0;\n        }\n        maxArea = Math.max(maxArea, calculateMaxArea(heights));\n    }\n    \n    return maxArea;\n};\n\nfunction calculateMaxArea(heights: number[]) {\n    const stack = [];\n    let maxArea = 0;\n    \n    for (let i = 0; i <= heights.length; i++) {\n        while (stack.length !== 0 && (i === heights.length || heights[i] < heights[stack[stack.length - 1]])) {\n            const height = heights[stack.pop()];\n            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n        stack.push(i);\n    }\n    \n    return maxArea;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $matrix\n     * @return Integer\n     */\n    function maximalRectangle($matrix) {\n        $maxArea = 0;\n        if (empty($matrix)) {\n            return $maxArea;\n        }\n        \n        $rows = count($matrix);\n        $cols = count($matrix[0]);\n        $heights = array_fill(0, $cols, 0);\n        \n        for ($i = 0; $i < $rows; $i++) {\n            for ($j = 0; $j < $cols; $j++) {\n                $heights[$j] = $matrix[$i][$j] == '1' ? $heights[$j] + 1 : 0;\n            }\n            $maxArea = max($maxArea, $this->largestRectangleArea($heights));\n        }\n        \n        return $maxArea;\n    }\n    \n    function largestRectangleArea($heights) {\n        $heights[] = 0;\n        $stack = [];\n        $maxArea = 0;\n        \n        for ($i = 0; $i < count($heights); $i++) {\n            while (!empty($stack) && $heights[$i] < $heights[end($stack)]) {\n                $height = array_pop($stack);\n                $width = empty($stack) ? $i : $i - end($stack) - 1;\n                $maxArea = max($maxArea, $heights[$height] * $width);\n            }\n            $stack[] = $i;\n        }\n        \n        return $maxArea;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maximalRectangle(_ matrix: [[Character]]) -> Int {\n        guard matrix.count > 0 && matrix[0].count > 0 else {\n            return 0\n        }\n        \n        let rows = matrix.count\n        let cols = matrix[0].count\n        var heights = Array(repeating: 0, count: cols)\n        var maxArea = 0\n        \n        for i in 0..<rows {\n            for j in 0..<cols {\n                if matrix[i][j] == \"1\" {\n                    heights[j] += 1\n                } else {\n                    heights[j] = 0\n                }\n            }\n            maxArea = max(maxArea, largestRectangleArea(heights))\n        }\n        \n        return maxArea\n    }\n    \n    func largestRectangleArea(_ heights: [Int]) -> Int {\n        var stack = [Int]()\n        var maxArea = 0\n        var i = 0\n        \n        while i < heights.count {\n            if stack.isEmpty || heights[i] >= heights[stack.last!] {\n                stack.append(i)\n                i += 1\n            } else {\n                let height = heights[stack.removeLast()]\n                let width = stack.isEmpty ? i : i - stack.last! - 1\n                maxArea = max(maxArea, height * width)\n            }\n        }\n        \n        while !stack.isEmpty {\n            let height = heights[stack.removeLast()]\n            let width = stack.isEmpty ? i : i - stack.last! - 1\n            maxArea = max(maxArea, height * width)\n        }\n        \n        return maxArea\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maximalRectangle(matrix: Array<CharArray>): Int {\n        if(matrix.isEmpty()) return 0\n        \n        val n = matrix.size\n        val m = matrix[0].size\n        val heights = IntArray(m)\n        var maxArea = 0\n        \n        for (i in 0 until n) {\n            for (j in 0 until m) {\n                heights[j] = if (matrix[i][j] == '1') heights[j] + 1 else 0\n            }\n            maxArea = maxOf(maxArea, largestRectangleArea(heights))\n        }\n        \n        return maxArea\n    }\n    \n    private fun largestRectangleArea(heights: IntArray): Int {\n        val stack = LinkedList<Int>()\n        var maxArea = 0\n        var i = 0\n        \n        while (i <= heights.size) {\n            val h = if (i == heights.size) 0 else heights[i]\n            if (stack.isEmpty() || h >= heights[stack.peek()]) {\n                stack.push(i)\n                i++\n            } else {\n                val height = heights[stack.pop()]\n                val width = if (stack.isEmpty()) i else i - stack.peek() - 1\n                maxArea = maxOf(maxArea, height * width)\n            }\n        }\n        \n        return maxArea\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "import 'dart:math';\n\nclass Solution {\n  int maximalRectangle(List<List<String>> matrix) {\n    if (matrix.isEmpty) return 0;\n    \n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    \n    List<List<int>> heights = List.generate(rows, (_) => List.filled(cols, 0));\n    \n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        if (matrix[i][j] == '1') {\n          heights[i][j] = i == 0 ? 1 : heights[i - 1][j] + 1;\n        }\n      }\n    }\n    \n    int maxArea = 0;\n    for (int i = 0; i < rows; i++) {\n      maxArea = max(maxArea, largestRectangleArea(heights[i]));\n    }\n    \n    return maxArea;\n  }\n  \n  int largestRectangleArea(List<int> heights) {\n    List<int> stack = [];\n    heights = List.from(heights)..add(0);\n    int maxArea = 0;\n    \n    for (int i = 0; i < heights.length; i++) {\n      while (stack.isNotEmpty && heights[i] < heights[stack.last]) {\n        int h = heights[stack.removeLast()];\n        int w = stack.isEmpty ? i : i - stack.last - 1;\n        maxArea = max(maxArea, h * w);\n      }\n      stack.add(i);\n    }\n    \n    return maxArea;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maximalRectangle(matrix [][]byte) int {\n    if len(matrix) == 0 {\n        return 0\n    }\n    rows, cols := len(matrix), len(matrix[0])\n    heights := make([]int, cols)\n    maxArea := 0\n\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            if matrix[i][j] == '0' {\n                heights[j] = 0\n            } else {\n                heights[j]++\n            }\n        }\n        maxArea = max(maxArea, largestRectangleArea(heights))\n    }\n\n    return maxArea\n}\n\nfunc largestRectangleArea(heights []int) int {\n    if len(heights) == 0 {\n        return 0\n    }\n\n    stack := make([]int, 0)\n    heights = append(heights, 0)\n    maxArea := 0\n\n    for i := 0; i < len(heights); i++ {\n        for len(stack) > 0 && heights[i] < heights[stack[len(stack)-1]] {\n            h := heights[stack[len(stack)-1]]\n            stack = stack[:len(stack)-1]\n            width := i\n            if len(stack) > 0 {\n                width = i - stack[len(stack)-1] - 1\n            }\n            maxArea = max(maxArea, h*width)\n        }\n        stack = append(stack, i)\n    }\n\n    return maxArea\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[][]} matrix\n# @return {Integer}\ndef maximal_rectangle(matrix)\n    return 0 if matrix.empty?\n\n    rows = matrix.size\n    cols = matrix[0].size\n    max_area = 0\n    heights = Array.new(cols, 0)\n    left = Array.new(cols, 0)\n    right = Array.new(cols, cols)\n\n    (0...rows).each do |i|\n        cur_left = 0\n        cur_right = cols\n\n        (0...cols).each do |j|\n            heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0\n        end\n\n        (0...cols).each do |j|\n            if matrix[i][j] == '1'\n                left[j] = [left[j], cur_left].max\n            else\n                left[j] = 0\n                cur_left = j + 1\n            end\n        end\n\n        (cols-1).downto(0).each do |j|\n            if matrix[i][j] == '1'\n                right[j] = [right[j], cur_right].min\n            else\n                right[j] = cols\n                cur_right = j\n            end\n        end\n\n        (0...cols).each do |j|\n            max_area = [max_area, (right[j] - left[j]) * heights[j]].max\n        end\n    end\n\n    return max_area\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maximalRectangle(matrix: Array[Array[Char]]): Int = {\n        if (matrix.isEmpty) return 0\n        val rows = matrix.length\n        val cols = matrix(0).length\n        val heights = Array.fill(cols)(0)\n        var maxArea = 0\n        \n        def largestRectangleArea(heights: Array[Int]): Int = {\n            var stack = List.empty[Int]\n            var maxArea = 0\n            \n            for (i <- 0 to heights.length) {\n                while (stack.nonEmpty && (i == heights.length || heights(i) < heights(stack.head))) {\n                    val h = heights(stack.head)\n                    stack = stack.tail\n                    val w = if (stack.isEmpty) i else i - stack.head - 1\n                    maxArea = math.max(maxArea, h * w)\n                }\n                stack = i :: stack\n            }\n            maxArea\n        }\n        \n        for (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n                heights(j) = if (matrix(i)(j) == '1') heights(j) + 1 else 0\n            }\n            maxArea = math.max(maxArea, largestRectangleArea(heights))\n        }\n        \n        maxArea\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\n        let rows = matrix.len();\n        if rows == 0 {\n            return 0;\n        }\n        let cols = matrix[0].len();\n        \n        let mut left = vec![0; cols];\n        let mut right = vec![cols; cols];\n        let mut height = vec![0; cols];\n        \n        let mut max_area = 0;\n        \n        for i in 0..rows {\n            let mut cur_left = 0;\n            let mut cur_right = cols;\n            \n            for j in 0..cols {\n                if matrix[i][j] == '1' {\n                    height[j] += 1;\n                } else {\n                    height[j] = 0;\n                }\n            }\n            \n            for j in 0..cols {\n                if matrix[i][j] == '1' {\n                    left[j] = left[j].max(cur_left);\n                } else {\n                    left[j] = 0;\n                    cur_left = j + 1;\n                }\n            }\n            \n            for j in (0..cols).rev() {\n                if matrix[i][j] == '1' {\n                    right[j] = right[j].min(cur_right);\n                } else {\n                    right[j] = cols;\n                    cur_right = j;\n                }\n            }\n            \n            for j in 0..cols {\n                max_area = max_area.max(height[j] * (right[j] - left[j]));\n            }\n        }\n        \n        max_area as i32\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to find the largest rectangle containing only '1's in a given binary matrix and return its area.\n\n# Explanation:\n1. **Initial Checks**: If the matrix is empty or the first row is empty, return 0.\n2. **Helper Function**: Implement a helper function `largestRectangleArea` to compute the maximum area of a histogram, which uses a stack to keep track of the indices.\n3. **Height Array**: Iterate over each row of the matrix, update a height array where each element denotes the height of the column up to that row.\n4. **Calculate Max Area**: For each row, use the height array with the `largestRectangleArea` function to determine the maximal rectangle in that row.\n5. **Final Result**: Return the maximum area found during the process.\n\nThe overall complexity is kept efficient by reusing the histogram method for each row of the matrix.\n\n# Pseudocode:\n```pseudocode\nfunction maximalRectangle(matrix):\n    if matrix is empty or matrix[0] is empty:\n        return 0\n\n    function largestRectangleArea(heights):\n        stack = [-1]\n        max_area = 0\n        append 0 to heights  // Sentinel to force calculation at the end\n        \n        for i from 0 to length of heights:\n            while stack top is not -1 and heights[stack top] >= heights[i]:\n                h = heights[stack pop()]\n                w = i - stack top - 1\n                max_area = max(max_area, h * w)\n            stack append i\n            \n        return max_area\n\n    cols = length of matrix[0]\n    heights = array of zeros with length cols\n    max_area = 0\n\n    for row in matrix:\n        for i from 0 to cols - 1:\n            if row[i] == '1':\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        max_area = max(max_area, largestRectangleArea(heights))\n\n    return max_area\n```\n\nThis pseudocode provides a step-by-step guide on how to approach the problem. It iteratively updates the heights of columns and uses the helper function to compute the maximum possible rectangle area for each row.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-maximal-rectangle"
    },
    {
        "name": "Symmetric Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-symmetric-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if(!root) return true;\n        return isSymmetric(root->left, root->right);\n    }\n    \n    bool isSymmetric(TreeNode* left, TreeNode* right) {\n        if(!left && !right) return true;\n        if(!left || !right) return false;\n        \n        return (left->val == right->val) && isSymmetric(left->left, right->right) && isSymmetric(left->right, right->left);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return isSymmetric(root.left, root.right);\n    }\n    \n    private boolean isSymmetric(TreeNode left, TreeNode right) {\n        if (left == null && right == null) {\n            return true;\n        }\n        if (left == null || right == null) {\n            return false;\n        }\n        if (left.val != right.val) {\n            return false;\n        }\n        return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nbool isMirror(struct TreeNode* left, struct TreeNode* right) {\n    if (left == NULL && right == NULL) {\n        return true;\n    }\n    if (left == NULL || right == NULL) {\n        return false;\n    }\n    if (left->val != right->val) {\n        return false;\n    }\n    \n    return isMirror(left->left, right->right) && isMirror(left->right, right->left);\n}\n\nbool isSymmetric(struct TreeNode* root){\n    if (root == NULL) {\n        return true;\n    }\n    return isMirror(root->left, root->right);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return IsMirror(root.left, root.right);\n    }\n    \n    private bool IsMirror(TreeNode left, TreeNode right) {\n        if (left == null && right == null) {\n            return true;\n        }\n        \n        if (left == null || right == null) {\n            return false;\n        }\n        \n        if (left.val != right.val) {\n            return false;\n        }\n        \n        return IsMirror(left.left, right.right) && IsMirror(left.right, right.left);\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\nvar isSymmetric = function(root) {\n    const compare = (left, right) => {\n        if (!left && !right) return true;\n        if (!left || !right) return false;\n        if (left.val !== right.val) return false;\n        return compare(left.left, right.right) && compare(left.right, right.left);\n    }\n    \n    if (!root) return true;\n    return compare(root.left, root.right);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction isSymmetric(root: TreeNode | null): boolean {\n    if (!root) {\n        return true;\n    }\n    \n    const isMirror = (left: TreeNode | null, right: TreeNode | null): boolean => {\n        if (!left && !right) {\n            return true;\n        }\n        if (!left || !right || left.val !== right.val) {\n            return false;\n        }\n        return isMirror(left.left, right.right) && isMirror(left.right, right.left);\n    };\n    \n    return isMirror(root.left, root.right);\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isSymmetric(_ root: TreeNode?) -> Bool {\n        func isMirror(_ left: TreeNode?, _ right: TreeNode?) -> Bool {\n            if left == nil && right == nil {\n                return true\n            }\n            if left == nil || right == nil {\n                return false\n            }\n            return left!.val == right!.val &&\n                isMirror(left!.left, right!.right) &&\n                isMirror(left!.right, right!.left)\n        }\n        \n        return isMirror(root, root)\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left, Right *TreeNode\n * }\n */\n\nfunc isSymmetric(root *TreeNode) bool {\n    if root == nil {\n        return true\n    }\n    return isMirror(root.Left, root.Right)\n}\n\nfunc isMirror(left, right *TreeNode) bool {\n    if left == nil && right == nil {\n        return true\n    }\n    if left == nil || right == nil {\n        return false\n    }\n    return (left.Val == right.Val) && isMirror(left.Left, right.Right) && isMirror(left.Right, right.Left)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef is_symmetric(root)\n    return is_mirror(root, root)\nend\n\ndef is_mirror(t1, t2)\n    if t1.nil? && t2.nil?\n        return true\n    end\n    if t1.nil? || t2.nil?\n        return false\n    end\n    return (t1.val == t2.val) && is_mirror(t1.right, t2.left) && is_mirror(t1.left, t2.right)\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to determine whether a binary tree is symmetric around its center. This means that the left subtree is a mirror reflection of the right subtree.\n\n# Explanation\n\nGiven a binary tree, we need to check if the tree is symmetric by comparing elements of the left and right subtrees recursively. In essence, two trees are a mirror of each other if:\n1. Their two roots have the same value.\n2. The right subtree of each tree is a mirror reflection of the left subtree of the other tree.\n\nThis problem can be approached both recursively and iteratively. Below, I'll provide a pseudocode for the recursive approach:\n\n# Pseudocode\n\nHere is the pseudocode for resolving the symmetric tree problem using a recursive approach:\n\n1. Define a helper function `isMirror(left, right)`:\n   - If both `left` and `right` are null, return true.\n   - If only one of them is null, return false.\n   - Check if the values of `left` and `right` are equal.\n   - Recursively check:\n     - if `left.left` is a mirror of `right.right`\n     - if `left.right` is a mirror of `right.left`\n\n2. Define the main function `isSymmetric(root)`:\n   - If `root` is null, return true.\n   - Call `isMirror(root.left, root.right)` and return its result.\n\nHere is the organized pseudocode:\n\n```\nfunction isMirror(left, right):\n    if left is null and right is null:\n        return true\n    if left is null or right is null:\n        return false\n    if left.val is not equal to right.val:\n        return false\n    return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n\nfunction isSymmetric(root):\n    if root is null:\n        return true\n    return isMirror(root.left, root.right)\n```\n\nThis pseudocode will help in implementing the solution for the problem of determining if a binary tree is symmetric, utilizing a recursive approach.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-symmetric-tree"
    },
    {
        "name": "Scramble String",
        "site": "LeetCode",
        "href": "/solution/LeetCode-scramble-string",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        int n = s1.length();\n        if (n != s2.length()) {\n            return false;\n        }\n        \n        boolean[][][] dp = new boolean[n][n][n + 1];\n        \n        for (int len = 1; len <= n; len++) {\n            for (int i = 0; i + len <= n; i++) {\n                for (int j = 0; j + len <= n; j++) {\n                    if (len == 1) {\n                        dp[i][j][len] = s1.charAt(i) == s2.charAt(j);\n                    } else {\n                        for (int k = 1; k < len && !dp[i][j][len]; k++) {\n                            dp[i][j][len] = (dp[i][j][k] && dp[i + k][j + k][len - k]) || (dp[i][j + len - k][k] && dp[i + k][j][len - k]);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[0][0][n];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        def is_scramble(s1, s2):\n            if s1 == s2:\n                return True\n            if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n                return False\n            n = len(s1)\n            dp = [[[False] * n for _ in range(n)] for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    dp[0][i][j] = s1[i] == s2[j]\n            for l in range(2, n + 1):\n                for i in range(n - l, -1, -1):\n                    for j in range(n - l, -1, -1):\n                        for k in range(1, l):\n                            if (dp[k - 1][i][j] and dp[l - k - 1][i + k][j + k]) or (dp[k - 1][i][j + l - k] and dp[l - k - 1][i + k][j]):\n                                dp[l - 1][i][j] = True\n                                break\n            return dp[n - 1][0][0]\n        \n        return is_scramble(s1, s2)"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsScramble(string s1, string s2) {\n        if (s1 == s2) {\n            return true;\n        }\n        \n        if (s1.Length != s2.Length) {\n            return false;\n        }\n        \n        int n = s1.Length;\n        bool[,,] dp = new bool[n, n, n + 1];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i, j, 1] = s1[i] == s2[j];\n            }\n        }\n        \n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                for (int j = 0; j <= n - len; j++) {\n                    for (int k = 1; k < len; k++) {\n                        if ((dp[i, j, k] && dp[i + k, j + k, len - k]) || (dp[i, j + len - k, k] && dp[i + k, j, len - k])) {\n                            dp[i, j, len] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[0, 0, n];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var isScramble = function(s1, s2) {\n    if (s1 === s2) {\n        return true;\n    }\n    if (s1.length !== s2.length || s1.split('').sort().join('') !== s2.split('').sort().join('')) {\n        return false;\n    }\n    \n    const n = s1.length;\n    const dp = Array.from({ length: n }, () => Array.from({ length: n }, () => Array(n + 1).fill(false)));\n    \n    for (let len = 1; len <= n; len++) {\n        for (let i = 0; i + len <= n; i++) {\n            for (let j = 0; j + len <= n; j++) {\n                if (len === 1) {\n                    dp[i][j][len] = s1[i] === s2[j];\n                } else {\n                    for (let k = 1; k < len; k++) {\n                        if ((dp[i][j][k] && dp[i + k][j + k][len - k]) || (dp[i][j + len - k][k] && dp[i + k][j][len - k])) {\n                            dp[i][j][len] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[0][0][n];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isScramble(s1: string, s2: string): boolean {\n    const n = s1.length;\n    if (s1 === s2) {\n        return true;\n    }\n    if (s1.length !== s2.length || !isAnagram(s1, s2)) {\n        return false;\n    }\n    \n    const dp: boolean[][][] = Array.from({ length: n }, () =>\n        Array.from({ length: n }, () => new Array(n + 1).fill(false))\n    );\n    \n    for (let len = 1; len <= n; len++) {\n        for (let i = 0; i <= n - len; i++) {\n            for (let j = 0; j <= n - len; j++) {\n                if (len === 1) {\n                    dp[i][j][len] = s1[i] === s2[j];\n                } else {\n                    for (let k = 1; k < len && !dp[i][j][len]; k++) {\n                        dp[i][j][len] = (dp[i][j][k] && dp[i + k][j + k][len - k]) ||\n                            (dp[i][j + len - k][k] && dp[i + k][j][len - k]);\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[0][0][n];\n};\n\nfunction isAnagram(s1: string, s2: string): boolean {\n    const map = new Map<string, number>();\n    for (let char of s1) {\n        map.set(char, (map.get(char) || 0) + 1);\n    }\n    for (let char of s2) {\n        if (!map.has(char)) {\n            return false;\n        }\n        map.set(char, map.get(char)! - 1);\n        if (map.get(char)! === 0) {\n            map.delete(char);\n        }\n    }\n    return map.size === 0;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @return Boolean\n     */\n    function isScramble($s1, $s2) {\n        if ($s1 == $s2) {\n            return true;\n        }\n        if (strlen($s1) != strlen($s2) || count_chars($s1) != count_chars($s2)) {\n            return false;\n        }\n        $length = strlen($s1);\n        $dp = [];\n        for ($i = 0; $i < $length; $i++) {\n            for ($j = 0; $j < $length; $j++) {\n                $dp[$i][$j][1] = ($s1[$i] == $s2[$j]);\n            }\n        }\n        for ($len = 2; $len <= $length; $len++) {\n            for ($i = 0; $i <= $length - $len; $i++) {\n                for ($j = 0; $j <= $length - $len; $j++) {\n                    $dp[$i][$j][$len] = false;\n                    for ($k = 1; $k < $len && !$dp[$i][$j][$len]; $k++) {\n                        $dp[$i][$j][$len] = ($dp[$i][$j][$k] && $dp[$i+$k][$j+$k][$len-$k]) ||\n                            ($dp[$i][$j+$len-$k][$k] && $dp[$i+$k][$j][$len-$k]);\n                    }\n                }\n            }\n        }\n        return $dp[0][0][$length];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\n        if s1 == s2 {\n            return true\n        }\n        \n        if s1.count != s2.count || s1.sorted() != s2.sorted() {\n            return false\n        }\n        \n        let n = s1.count\n        var dp = Array(repeating: Array(repeating: Array(repeating: false, count: n), count: n), count: n + 1)\n        \n        for len in 1...n {\n            for i in 0...(n - len) {\n                for j in 0...(n - len) {\n                    if len == 1 {\n                        dp[len][i][j] = s1[s1.index(s1.startIndex, offsetBy: i)] == s2[s2.index(s2.startIndex, offsetBy: j)]\n                    } else {\n                        for k in 1..<len {\n                            if (dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j]) {\n                                dp[len][i][j] = true\n                                break\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return dp[n][0][0]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isScramble(s1: String, s2: String): Boolean {\n        val n = s1.length\n        if (n != s2.length) return false\n        if (s1 == s2) return true\n        if (s1.toCharArray().sorted() != s2.toCharArray().sorted()) return false\n        \n        val dp = Array(n) { Array(n) { BooleanArray(n + 1) } }\n        for (i in 0 until n) {\n            for (j in 0 until n) {\n                dp[i][j][1] = s1[i] == s2[j]\n            }\n        }\n        \n        for (len in 2..n) {\n            for (i in 0 until n - len + 1) {\n                for (j in 0 until n - len + 1) {\n                    for (k in 1 until len) {\n                        dp[i][j][len] = dp[i][j][len] || (dp[i][j][k] && dp[i + k][j + k][len - k]) ||\n                            (dp[i][j + len - k][k] && dp[i + k][j][len - k])\n                    }\n                }\n            }\n        }\n        \n        return dp[0][0][n]\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isScramble(String s1, String s2) {\n    if (s1 == s2) {\n      return true;\n    }\n    \n    if (s1.length != s2.length) {\n      return false;\n    }\n    \n    int n = s1.length;\n    List<List<List<bool>>> dp = List.generate(\n        n,\n        (index) => List.generate(\n            n,\n            (index) => List.generate(\n                n + 1, (index) => false,\n                growable: false),\n            growable: false),\n        growable: false);\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        dp[i][j][1] = s1[i] == s2[j];\n      }\n    }\n    \n    for (int len = 2; len <= n; len++) {\n      for (int i = 0; i <= n - len; i++) {\n        for (int j = 0; j <= n - len; j++) {\n          for (int k = 1; k < len; k++) {\n            if ((dp[i][j][k] && dp[i + k][j + k][len - k]) ||\n                (dp[i][j + len - k][k] && dp[i + k][j][len - k])) {\n              dp[i][j][len] = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n    \n    return dp[0][0][n];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isScramble(s1 string, s2 string) bool {\n    if s1 == s2 {\n        return true\n    }\n    \n    if len(s1) != len(s2) {\n        return false\n    }\n    \n    n := len(s1)\n    dp := make([][][]bool, n)\n    \n    for i := 0; i < n; i++ {\n        dp[i] = make([][]bool, n)\n        for j := 0; j < n; j++ {\n            dp[i][j] = make([]bool, n+1)\n            dp[i][j][1] = s1[i] == s2[j]\n        }\n    }\n    \n    for l := 2; l <= n; l++ {\n        for i := 0; i <= n - l; i++ {\n            for j := 0; j <= n - l; j++ {\n                for k := 1; k < l; k++ {\n                    if (dp[i][j][k] && dp[i+k][j+k][l-k]) || (dp[i][j+l-k][k] && dp[i+k][j][l-k]) {\n                        dp[i][j][l] = true\n                        break\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[0][0][n]\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isScramble(s1: String, s2: String): Boolean = {\n        val n = s1.length\n        val dp = Array.fill(n, n, n + 1)(false)\n\n        for (i <- 0 until n; \n             j <- 0 until n) {\n            dp(i)(j)(1) = s1(i) == s2(j)\n        }\n\n        for (len <- 2 to n; \n             i <- 0 to n - len; \n             j <- 0 to n - len) {\n            for (k <- 1 until len; \n                 if !dp(i)(j)(len)) {\n                dp(i)(j)(len) = \n                  (dp(i)(j)(k) && dp(i + k)(j + k)(len - k)) || \n                  (dp(i)(j + len - k)(k) && dp(i + k)(j)(len - k))\n            }\n        }\n\n        dp(0)(0)(n)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_scramble(s1: String, s2: String) -> bool {\n        if s1 == s2 {\n            return true;\n        }\n\n        if s1.len() != s2.len() {\n            return false;\n        }\n\n        let n = s1.len();\n        let mut dp = vec![vec![vec![false; n]; n]; n + 1];\n\n        let s1_chars: Vec<char> = s1.chars().collect();\n        let s2_chars: Vec<char> = s2.chars().collect();\n\n        for len in 1..=n {\n            for i in 0..=n - len {\n                for j in 0..=n - len {\n                    if len == 1 {\n                        dp[len][i][j] = s1_chars[i] == s2_chars[j];\n                    } else {\n                        for k in 1..len {\n                            if dp[k][i][j] && dp[len - k][i + k][j + k]\n                                || dp[k][i][j + len - k] && dp[len - k][i + k][j]\n                            {\n                                dp[len][i][j] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        dp[n][0][0]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if one string is a scrambled version of another string using recursive string operations. Below, we'll break down the methodology and present the pseudocode.\n\n## Explanation\n\n1. **Base Condition**:\n   - If the two strings `s1` and `s2` are identical, then `s2` is trivially a scrambled version of `s1`.\n   - If the lengths of `s1` and `s2` differ, or if they don\u2019t have the same characters (even if possibly in different orders), then `s2` cannot be a scrambled version of `s1`.\n\n2. **Recursive Check**:\n   - We'll recursively split both strings into substrings.\n   - For each potential split point, there are two recursive scenarios to consider:\n     - Both parts of the split in `s1` directly map to corresponding parts in `s2`.\n     - The parts of the split in `s1` map to swapped parts in `s2`.\n\n3. **Dynamic Programming (DP)**:\n   - We'll use a 3D DP table to store solutions to subproblems.\n   - `dp[l][i][j]` will be `True` if the substring of length `l` starting at `i` in `s1` is a scrambled version of the substring of length `l` starting at `j` in `s2`.\n\n4. **DP Initialization**:\n   - Initialize the DP table for substrings of length 1 by comparing individual characters of `s1` and `s2`.\n\n5. **DP Transition**:\n   - Use nested loops to build up the solution for increasing substring lengths, checking both the direct and swapped mapping scenarios for each potential split point.\n\n## Pseudocode\n\n```plaintext\n# Pseudocode\n\nfunction isScramble(s1, s2):\n    # Base condition 1: If the strings are identical\n    if s1 == s2:\n        return true\n    \n    # Base condition 2: If strings are of different lengths or contain different characters\n    if length(s1) != length(s2) or sorted(s1) != sorted(s2):\n        return false\n    \n    n = length(s1)\n    \n    # Initialize a 3D DP table with dimensions n x n x n\n    dp = 3D list of False with dimensions [n][n][n]\n    \n    # Initialize DP for substrings of length 1\n    for i from 0 to n-1:\n        for j from 0 to n-1:\n            dp[1][i][j] = (s1[i] == s2[j])\n    \n    # Build the DP table for substrings of increasing lengths\n    for l from 2 to n:\n        for i from 0 to n-l:\n            for j from 0 to n-l:\n                for k from 1 to l-1:\n                    if (dp[k][i][j] and dp[l-k][i+k][j+k]) or (dp[k][i][j+l-k] and dp[l-k][i+k][j]):\n                        dp[l][i][j] = true\n                        break\n    \n    # The result for the entire strings is in dp[n][0][0]\n    return dp[n][0][0]\n\n# Function call example\nresult = isScramble(\"great\", \"rgeat\")\nprint(result)  # Should output true\n```\n\nThis pseudocode captures the essence of solving the problem using a dynamic programming approach with recursive subproblem checks and memoization to avoid redundant calculations.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-scramble-string"
    },
    {
        "name": "Merge Sorted Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-merge-sorted-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n - 1;\n        int p = m + n - 1;\n        \n        while (p1 >= 0 && p2 >= 0) {\n            if (nums1[p1] > nums2[p2]) {\n                nums1[p] = nums1[p1];\n                p1--;\n            } else {\n                nums1[p] = nums2[p2];\n                p2--;\n            }\n            p--;\n        }\n        \n        while (p2 >= 0) {\n            nums1[p] = nums2[p2];\n            p2--;\n            p--;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None\n        \"\"\"\n        p1 = m - 1\n        p2 = n - 1\n        p = m + n - 1\n        \n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n        \n        if p2 >= 0:\n            nums1[:p2+1] = nums2[:p2+1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {\n    // Start merging from the end of the arrays\n    int index1 = m - 1;\n    int index2 = n - 1;\n    int index_merged = m + n - 1;\n    \n    while (index1 >= 0 && index2 >= 0) {\n        if (nums1[index1] > nums2[index2]) {\n            nums1[index_merged] = nums1[index1];\n            index1--;\n        } else {\n            nums1[index_merged] = nums2[index2];\n            index2--;\n        }\n        index_merged--;\n    }\n    \n    while (index2 >= 0) {\n        nums1[index_merged] = nums2[index2];\n        index2--;\n        index_merged--;\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void Merge(int[] nums1, int m, int[] nums2, int n) {\n        int pointer1 = m - 1;\n        int pointer2 = n - 1;\n        int index = m + n - 1;\n\n        while (pointer1 >= 0 && pointer2 >= 0) {\n            if (nums1[pointer1] > nums2[pointer2]) {\n                nums1[index] = nums1[pointer1];\n                pointer1--;\n            } else {\n                nums1[index] = nums2[pointer2];\n                pointer2--;\n            }\n            index--;\n        }\n\n        while (pointer2 >= 0) {\n            nums1[index] = nums2[pointer2];\n            pointer2--;\n            index--;\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n */\nconst merge = (nums1, m, nums2) => {\n    let p1 = m - 1;\n    let p2 = nums2.length - 1;\n    let p = nums1.length - 1;\n\n    while (p2 >= 0) {\n        if (nums1[p1] > nums2[p2]) {\n            nums1[p] = nums1[p1];\n            p1--;\n        } else {\n            nums1[p] = nums2[p2];\n            p2--;\n        }\n        p--;\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify nums1 in-place \ninstead.\n */\nfunction merge(nums1: number[], m: number, nums2: number[], n: number): void {\n    let i = m - 1;\n    let j = n - 1;\n    let k = m + n - 1;\n\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j]) {\n            nums1[k] = nums1[i];\n            i--;\n        } else {\n            nums1[k] = nums2[j];\n            j--;\n        }\n        k--;\n    }\n\n    while (j >= 0) {\n        nums1[k] = nums2[j];\n        j--;\n        k--;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums1\n     * @param Integer $m\n     * @param Integer[] $nums2\n     * @param Integer $n\n     * @return NULL\n     */\n    function merge(&$nums1, $m, $nums2, $n) {\n        $p1 = $m - 1;\n        $p2 = $n - 1;\n        $p = $m + $n - 1;\n        \n        while ($p1 >= 0 && $p2 >= 0) {\n            if ($nums1[$p1] > $nums2[$p2]) {\n                $nums1[$p] = $nums1[$p1];\n                $p1--;\n            } else {\n                $nums1[$p] = $nums2[$p2];\n                $p2--;\n            }\n            $p--;\n        }\n        \n        while ($p2 >= 0) {\n            $nums1[$p] = $nums2[$p2];\n            $p2--;\n            $p--;\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {\n        var index1 = m - 1\n        var index2 = n - 1\n        var currentIndex = m + n - 1\n        \n        while index1 >= 0 && index2 >= 0 {\n            if nums1[index1] > nums2[index2] {\n                nums1[currentIndex] = nums1[index1]\n                index1 -= 1\n            } else {\n                nums1[currentIndex] = nums2[index2]\n                index2 -= 1\n            }\n            currentIndex -= 1\n        }\n        \n        while index2 >= 0 {\n            nums1[currentIndex] = nums2[index2]\n            index2 -= 1\n            currentIndex -= 1\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun merge(nums1: IntArray, m: Int, nums2: IntArray, n: Int): Unit {\n        var i = m - 1\n        var j = n - 1\n        var k = m + n - 1\n        \n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k] = nums1[i]\n                i--\n            } else {\n                nums1[k] = nums2[j]\n                j--\n            }\n            k--\n        }\n        \n        while (j >= 0) {\n            nums1[k] = nums2[j]\n            j--\n            k--\n        }\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void merge(List<int> nums1, int m, List<int> nums2, int n) {\n    int index1 = m - 1;\n    int index2 = n - 1;\n    int currentIndex = m + n - 1;\n\n    while (index1 >= 0 && index2 >= 0) {\n      if (nums1[index1] > nums2[index2]) {\n        nums1[currentIndex] = nums1[index1];\n        index1--;\n      } else {\n        nums1[currentIndex] = nums2[index2];\n        index2--;\n      }\n      currentIndex--;\n    }\n\n    while (index2 >= 0) {\n      nums1[currentIndex] = nums2[index2];\n      index2--;\n      currentIndex--;\n    }\n  }\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums1\n# @param {Integer} m\n# @param {Integer[]} nums2\n# @param {Integer} n\ndef merge(nums1, m, nums2, n)\n    p1 = m - 1\n    p2 = n - 1\n    p = m + n - 1\n\n    while p1 >= 0 && p2 >= 0\n        if nums1[p1] > nums2[p2]\n            nums1[p] = nums1[p1]\n            p1 -= 1\n        else\n            nums1[p] = nums2[p2]\n            p2 -= 1\n        end\n        p -= 1\n    end\n\n    nums1[0...p2+1] = nums2[0..p2] if p2 >= 0\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {\n        var i = m - 1\n        var j = n - 1\n        var k = m + n - 1\n\n        while (i >= 0 && j >= 0) {\n            if (nums1(i) > nums2(j)) {\n                nums1(k) = nums1(i)\n                i -= 1\n            } else {\n                nums1(k) = nums2(j)\n                j -= 1\n            }\n            k -= 1\n        }\n\n        while (j >= 0) {\n            nums1(k) = nums2(j)\n            j -= 1\n            k -= 1\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        let (mut m, mut n) = (m as usize, n as usize);\n        let (mut p1, mut p2) = (m as i32 - 1, n as i32 - 1);\n        \n        for i in ((0..(m + n) as usize).rev()) {\n            if p2 < 0 {\n                break;\n            }\n            \n            if p1 >= 0 && nums1[p1 as usize] > nums2[p2 as usize] {\n                nums1[i] = nums1[p1 as usize];\n                p1 -= 1;\n            } else {\n                nums1[i] = nums2[p2 as usize];\n                p2 -= 1;\n            }\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we must merge two sorted arrays, `nums1` and `nums2`, into a single sorted array within `nums1`. The given values `m` and `n` indicate the number of valid elements in `nums1` and `nums2` respectively, while the last `n` elements of `nums1` are placeholders (set to 0) that should be ignored initially.\n\n# Explanation\n\n1. We start by initializing three pointers:\n   - `p1` pointing to the last valid element in `nums1`.\n   - `p2` pointing to the last element in `nums2`.\n   - `p` pointing to the last position in `nums1` where the merged element should be placed.\n\n2. We then iterate from the end of both arrays towards the beginning:\n   - Compare elements from the end of `nums1` and `nums2`.\n   - Place the greater element at position `p` in `nums1`.\n   - Decrement the pointers accordingly.\n\n3. If there are remaining elements in `nums2` that were not merged, copy them to the beginning of `nums1`.\n\nThis ensures the `nums1` array retains all original and merged elements in a non-decreasing order.\n\n# Pseudocode\n\n```text\nfunction merge(nums1, m, nums2, n):\n    p1 = m - 1  # Pointer to last valid element of nums1\n    p2 = n - 1  # Pointer to last element of nums2\n    p = m + n - 1  # Pointer to last element in nums1 (including \"0\" placeholders)\n    \n    # While there are elements to be compared in both arrays\n    while p1 >= 0 and p2 >= 0:\n        if nums1[p1] > nums2[p2]:\n            nums1[p] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[p] = nums2[p2]\n            p2 -= 1\n        p -= 1\n    \n    # If there are remaining elements in nums2, copy them over to nums1\n    # Only needed if p2 has remaining elements since p1's are already in place\n    if p2 >= 0:\n        nums1[:p2 + 1] = nums2[:p2 + 1]\n\n# Example input\nnums1 = [1,2,3,0,0,0]\nm = 3\nnums2 = [2,5,6]\nn = 3\n\nmerge(nums1, m, nums2, n)\n# Output: nums1 will be [1, 2, 2, 3, 5, 6]\n```\n\nBy following this logic, we ensure that the final merged array is stored in `nums1` in non-decreasing order, using an optimal linear time approach considering the constraints and requirements given.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-merge-sorted-array"
    },
    {
        "name": "Gray Code",
        "site": "LeetCode",
        "href": "/solution/LeetCode-gray-code",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> result;\n        for (int i = 0; i < 1 << n; ++i) {\n            result.push_back(i ^ i >> 1);\n        }\n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.*;\n\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < (1 << n); i++) {\n            result.add(i ^ (i >> 1));\n        }\n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        for i in range(2**n):\n            result.append((i >> 1) ^ i)\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume \ncaller calls free().\n */\nint* grayCode(int n, int* returnSize){\n    *returnSize = 1 << n;\n    int* result = (int*)malloc(*returnSize * sizeof(int));\n    for (int i = 0; i < *returnSize; i++) {\n        result[i] = i ^ (i >> 1);\n    }\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> GrayCode(int n) {\n        IList<int> result = new List<int>();\n        \n        for (int i = 0; i < 1 << n; i++) {\n            result.Add(i ^ i >> 1);\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function(n) {\n    let result = [];\n    for (let i = 0; i < Math.pow(2, n); i++) {\n        result.push(i ^ (i >> 1));\n    }\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function grayCode(n: number): number[] {\n    const result: number[] = [0];\n    for (let i = 0; i < n; i++) {\n        const len = result.length;\n        for (let j = len - 1; j >= 0; j--) {\n            result.push(result[j] | 1 << i);\n        }\n    }\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     */\n    function grayCode($n) {\n        $result = [];\n        for ($i = 0; $i < 1 << $n; $i++) {\n            $result[] = $i ^ $i >> 1;\n        }\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func grayCode(_ n: Int) -> [Int] {\n        var result: [Int] = []\n        for i in 0..<(1 << n) {\n            result.append(i ^ (i >> 1))\n        }\n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun grayCode(n: Int): List<Int> {\n        val result = mutableListOf<Int>()\n        for (i in 0 until (1 shl n)) {\n            result.add(i xor (i shr 1))\n        }\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> grayCode(int n) {\n    List<int> result = [];\n    for (int i = 0; i < (1 << n); i++) {\n      result.add(i ^ (i >> 1));\n    }\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func grayCode(n int) []int {\n    res := make([]int, 1<<uint(n))\n    for i := 0; i < 1<<uint(n); i++ {\n        res[i] = i ^ i>>1\n    }\n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer[]}\ndef gray_code(n)\n    result = [0]\n    (0...n).each do |i|\n        result += result.reverse.map { |x| x | 1 << i }\n    end\n    return result\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def grayCode(n: Int): List[Int] = {\n        if (n == 0) {\n            List(0)\n        } else {\n            val half = grayCode(n - 1)\n            half ++ half.reverse.map(_ | 1 << (n - 1))\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn gray_code(n: i32) -> Vec<i32> {\n        let mut result = Vec::new();\n        for i in 0..1 << n {\n            result.push(i ^ (i >> 1));\n        }\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate a sequence of Gray codes for a given integer \\( n \\). A Gray code sequence is a list of \\( 2^n \\) integers where every pair of adjacent integers differs by exactly one bit and the entire sequence forms a circular loop.\n\n# Explanation\n\n1. **Understanding Gray Code**:\n   - Gray code is a binary numeral system where two successive values differ in only one bit.\n   - For \\( n \\)-bit Gray code, we need to generate a sequence of \\( 2^n \\) integers.\n\n2. **Properties of Gray Code**:\n   - Each integer appears exactly once.\n   - The binary representation of each pair of adjacent integers differs by exactly one bit.\n   - The binary representation of the first and last integers also differs by exactly one bit.\n\n3. **Steps to Generate Gray Code**:\n   - Iterate through the range from \\( 0 \\) to \\( 2^n - 1 \\).\n   - For each integer \\( i \\), calculate its Gray code using the formula: \\( \\text{GrayCode}(i) = (i >> 1) \\oplus i \\).\n     - '\\(\\oplus\\)' represents the XOR operation.\n     - '>> 1' represents a right bit-shift by one position.\n\n# Pseudocode\n\n```\nfunction grayCode(n):\n    # Initialize an empty list to store the Gray code sequence\n    result = []\n\n    # Iterate over the range from 0 to 2^n - 1\n    for i from 0 to 2^n - 1:\n        # Calculate the Gray code for the integer i\n        gray = (i >> 1) ^ i\n        # Append the calculated Gray code to the result list\n        result.append(gray)\n    \n    # Return the Gray code sequence\n    return result\n\n# Example Usage\n# n = 2\n# Output should be [0, 1, 3, 2]\n```\n\nHere, the function `grayCode(n)` generates the required Gray code sequence for a given \\( n \\). The binary representation of each adjacent pair will differ by exactly one bit, satisfying the conditions of the problem statement.\n",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-gray-code"
    },
    {
        "name": "Subsets Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-subsets-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        vector<vector<int>> res;\n        vector<int> subset;\n        sort(nums.begin(), nums.end());\n        backtrack(nums, 0, subset, res);\n        return res;\n    }\n    \n    void backtrack(vector<int>& nums, int start, vector<int>& subset, vector<vector<int>>& res) {\n        res.push_back(subset);\n        for (int i = start; i < nums.size(); i++) {\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            subset.push_back(nums[i]);\n            backtrack(nums, i + 1, subset, res);\n            subset.pop_back();\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(result, new ArrayList<>(), nums, 0);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int start) {\n        result.add(new ArrayList<>(tempList));\n        for (int i = start; i < nums.length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, i + 1);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        \n        def backtrack(start, path):\n            res.append(path[:]) # Add a copy of the current path to the result\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]: # Skip duplicates\n                    continue\n                path.append(nums[i]) # Choose\n                backtrack(i + 1, path) # Explore\n                path.pop() # Unchoose\n            \n        nums.sort() # Sort the input array\n        backtrack(0, []) # Call the backtrack function starting from index 0 with an empty path\n        return res"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n */\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid backtrack(int* nums, int numsSize, int start, int* subset, int subsetSize, int** result, int* returnSize, int* returnColumnSizes) {\n    result[*returnSize] = (int*)malloc(sizeof(int) * subsetSize);\n    memcpy(result[*returnSize], subset, sizeof(int) * subsetSize);\n    returnColumnSizes[*returnSize] = subsetSize;\n    (*returnSize)++;\n    \n    for (int i = start; i < numsSize; i++) {\n        if (i > start && nums[i] == nums[i-1]) continue;\n        subset[subsetSize] = nums[i];\n        backtrack(nums, numsSize, i + 1, subset, subsetSize + 1, result, returnSize, returnColumnSizes);\n    }\n}\n\nint** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    // Sort the array to handle duplicates\n    qsort(nums, numsSize, sizeof(int), compare);\n    \n    int** result = (int**)malloc(sizeof(int*) * 2000);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 2000);\n    *returnSize = 0;\n    \n    int subset[2000];\n    backtrack(nums, numsSize, 0, subset, 0, result, returnSize, *returnColumnSizes);\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> SubsetsWithDup(int[] nums) {\n        Array.Sort(nums);\n        List<IList<int>> result = new List<IList<int>>();\n        Backtrack(result, new List<int>(), nums, 0);\n        return result;\n    }\n    \n    private void Backtrack(List<IList<int>> result, List<int> tempList, int[] nums, int start) {\n        result.Add(new List<int>(tempList));\n        for (int i = start; i < nums.Length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) continue;\n            tempList.Add(nums[i]);\n            Backtrack(result, tempList, nums, i + 1);\n            tempList.RemoveAt(tempList.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    let res = [];\n    \n    nums.sort((a, b) => a - b);\n\n    const backtrack = (start, path) => {\n        res.push([...path]);\n        \n        for (let i = start; i < nums.length; i++) {\n            if (i > start && nums[i] === nums[i - 1]) continue;\n            path.push(nums[i]);\n            backtrack(i + 1, path);\n            path.pop();\n        }\n    };\n    \n    backtrack(0, []);\n    \n    return res;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function subsetsWithDup(nums: number[]): number[][] {\n    nums.sort((a, b) => a - b);\n    \n    const result: number[][] = [];\n    \n    function backtrack(start: number, path: number[]) {\n        result.push([...path]);\n        \n        for (let i = start; i < nums.length; i++) {\n            if (i > start && nums[i] === nums[i - 1]) {\n                continue;\n            }\n            path.push(nums[i]);\n            backtrack(i + 1, path);\n            path.pop();\n        }\n    }\n    \n    backtrack(0, []);\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[][]\n     */\n    function subsetsWithDup($nums) {\n        sort($nums);\n        $result = [];\n        $this->backtrack($nums, $result, [], 0);\n        return $result;\n    }\n    \n    function backtrack($nums, &$result, $current, $start) {\n        $result[] = $current;\n        \n        for ($i = $start; $i < count($nums); $i++) {\n            if ($i > $start && $nums[$i] == $nums[$i - 1]) {\n                continue;\n            }\n            $current[] = $nums[$i];\n            $this->backtrack($nums, $result, $current, $i + 1);\n            array_pop($current);\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun subsetsWithDup(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        nums.sort()\n        backtrack(result, ArrayList(), nums, 0)\n        return result\n    }\n\n    private fun backtrack(result: MutableList<List<Int>>, tempList: ArrayList<Int>, nums: IntArray, start: Int) {\n        result.add(ArrayList(tempList))\n        for (i in start until nums.size) {\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue\n            }\n            tempList.add(nums[i])\n            backtrack(result, tempList, nums, i + 1)\n            tempList.removeAt(tempList.size - 1)\n        }\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> subsetsWithDup(List<int> nums) {\n    List<List<int>> result = [];\n    List<int> current = [];\n    nums.sort();\n    \n    void backtrack(int index) {\n      result.add(List.from(current));\n      \n      for (int i = index; i < nums.length; i++) {\n        if (i > index && nums[i] == nums[i - 1]) {\n          continue;\n        }\n        current.add(nums[i]);\n        backtrack(i + 1);\n        current.removeLast();\n      }\n    }\n    \n    backtrack(0);\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func subsetsWithDup(nums []int) [][]int {\n    var res [][]int\n    var path []int\n    var backtrack func(start int)\n\n    sort.Ints(nums)\n\n    backtrack = func(start int) {\n        temp := make([]int, len(path))\n        copy(temp, path)\n        res = append(res, temp)\n\n        for i := start; i < len(nums); i++ {\n            if i > start && nums[i] == nums[i-1] {\n                continue\n            }\n            path = append(path, nums[i])\n            backtrack(i + 1)\n            path = path[:len(path)-1]\n        }\n    }\n\n    backtrack(0)\n\n    return res\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn subsets_with_dup(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut result = vec![vec![]];\n        let mut nums = nums;\n        nums.sort_unstable();\n        \n        Self::backtrack(&mut result, &mut vec![], &nums, 0);\n        \n        result\n    }\n    \n    fn backtrack(result: &mut Vec<Vec<i32>>, current: &mut Vec<i32>, nums: &Vec<i32>, start: usize) {\n        for i in start..nums.len() {\n            if i > start && nums[i] == nums[i-1] {\n                continue;\n            }\n            current.push(nums[i]);\n            result.push(current.clone());\n            Self::backtrack(result, current, nums, i+1);\n            current.pop();\n        }\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec subsets_with_dup(Nums :: [integer()]) -> \n[[integer()]].\nsubsets_with_dup(Nums) ->\n    lists:foldl(\n        fun(X, Acc) ->\n            lists:usort(Acc ++ lists:map(fun(Set) -> lists:sort([X|Set]) end, Acc))\n        end, [[]], lists:sort(Nums)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to generate all possible subsets of a given list of integers, ensuring no duplicate subsets are included in the result. The strategy typically involves backtracking, allowing us to construct subsets incrementally and handle duplicates effectively.\n\n# Explanation\n1. **Sort Input Array:** First, sort the input array to facilitate the identification and avoidance of duplicate subsets.\n2. **Backtracking:** Use a backtracking approach where we build subsets by including one element at a time.\n3. **Avoid Duplicates:** While backtracking, at each step, skip the duplicate elements to ensure each subset is unique.\n\nHere's the breakdown of the pseudocode:\n\n# Pseudocode\n```\nFUNCTION subsetsWithDup(nums):\n    SORT nums\n    CREATE result list to hold all subsets\n    DEFINE backtrack function(start, path):\n        ADD path copy to result\n        FOR i from start to length of nums:\n            IF i > start AND nums[i] == nums[i-1]:\n                CONTINUE\n            APPEND nums[i] to path\n            CALL backtrack(i + 1, path)\n            REMOVE last element from path\n    \n    CALL backtrack(0, [])\n    RETURN result\n```\n\n- The **`backtrack`** function is a recursive function that builds subsets by including each element one-by-one.\n- The **sorted array** ensures that duplicates are adjacent, making them easier to skip.\n- **Base Case and Recursive Calls:** The path is added to the result at every step, and recursive calls are made to explore further elements.\n- **Avoiding Duplicates:** If the current element is the same as the previous element (and it's not the first element we're considering), we skip processing to avoid duplicate subsets.\n\nThis approach ensures we systematically explore all subsets while skipping duplicates effectively by leveraging the sorted properties of the input array and controlled recursion.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-subsets-ii"
    },
    {
        "name": "Decode Ways",
        "site": "LeetCode",
        "href": "/solution/LeetCode-decode-ways",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        if (s.empty() || s[0] == '0') return 0;\n        \n        int n = s.size();\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; ++i) {\n            if (s[i - 1] != '0') {\n                dp[i] += dp[i - 1];\n            }\n            \n            int twoDigit = stoi(s.substr(i - 2, 2));\n            if (twoDigit >= 10 && twoDigit <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        \n        return dp[n];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0 || s.charAt(0) == '0') {\n            return 0;\n        }\n        \n        int n = s.length();\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int oneDigit = Integer.parseInt(s.substring(i-1, i));\n            int twoDigits = Integer.parseInt(s.substring(i-2, i));\n            \n            if (oneDigit >= 1) {\n                dp[i] += dp[i-1];\n            }\n            \n            if (twoDigits >= 10 && twoDigits <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        \n        return dp[n];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s or s[0] == \"0\":\n            return 0\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 1\n        \n        for i in range(2, n + 1):\n            if s[i - 1] != \"0\":\n                dp[i] += dp[i - 1]\n            \n            if s[i - 2] == \"1\" or (s[i - 2] == \"2\" and s[i - 1] <= \"6\"):\n                dp[i] += dp[i - 2]\n        \n        return dp[n]"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumDecodings(string s) {\n        if (string.IsNullOrEmpty(s) || s[0] == '0') {\n            return 0;\n        }\n\n        int n = s.Length;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            int first = int.Parse(s.Substring(i - 1, 1));\n            int second = int.Parse(s.Substring(i - 2, 2));\n\n            if (first >= 1 && first <= 9) {\n                dp[i] += dp[i - 1];\n            }\n\n            if (second >= 10 && second <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n\n        return dp[n];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nconst numDecodings = (s) => {\n    const n = s.length;\n    let dp = new Array(n + 1).fill(0);\n    \n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n    \n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.substring(i - 1, i));\n        const twoDigits = parseInt(s.substring(i - 2, i));\n        \n        if (oneDigit >= 1) {\n            dp[i] += dp[i - 1];\n        }\n        \n        if (twoDigits >= 10 && twoDigits <= 26) {\n            dp[i] += dp[i - 2];\n        }\n    }\n    \n    return dp[n];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numDecodings(s: string): number {\n    if (s.length === 0 || s[0] === \"0\") {\n        return 0;\n    }\n    \n    let dp = new Array(s.length + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for (let i = 2; i <= s.length; i++) {\n        if (s[i - 1] !== \"0\") {\n            dp[i] += dp[i - 1];\n        }\n        \n        let twoDigit = Number(s.substring(i - 2, i));\n        if (twoDigit >= 10 && twoDigit <= 26) {\n            dp[i] += dp[i - 2];\n        }\n    }\n    \n    return dp[s.length];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     */\n    function numDecodings($s) {\n        $n = strlen($s);\n        $dp = array_fill(0, $n + 1, 0);\n        $dp[0] = 1;\n        \n        $dp[1] = $s[0] == '0' ? 0 : 1;\n        \n        for ($i = 2; $i <= $n; $i++) {\n            $oneDigit = intval(substr($s, $i - 1, 1));\n            $twoDigits = intval(substr($s, $i - 2, 2));\n            \n            if ($oneDigit >= 1) {\n                $dp[$i] += $dp[$i - 1];\n            }\n            \n            if ($twoDigits >= 10 && $twoDigits <= 26) {\n                $dp[$i] += $dp[$i - 2];\n            }\n        }\n        \n        return $dp[$n];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func numDecodings(_ s: String) -> Int {\n        if s.isEmpty || s.first == \"0\" {\n            return 0\n        }\n        \n        let n = s.count\n        var dp = [Int](repeating: 0, count: n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in 2...n {\n            let firstDigit = Int(String(s[s.index(s.startIndex, offsetBy: i - 1)])) ?? 0\n            let twoDigits = Int(s[s.index(s.startIndex, offsetBy: i - 2)...s.index(s.startIndex, offsetBy: i - 1)]) ?? 0\n            \n            if firstDigit > 0 {\n                dp[i] += dp[i - 1]\n            }\n            \n            if twoDigits >= 10 && twoDigits <= 26 {\n                dp[i] += dp[i - 2]\n            }\n        }\n        \n        return dp[n]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numDecodings(s: String): Int {\n        if (s.isEmpty() || s[0] == '0') return 0\n        if (s.length == 1) return 1\n\n        var dp = IntArray(s.length + 1)\n        dp[0] = 1\n        dp[1] = if (s[1] == '0') 0 else 1\n\n        for (i in 2..s.length) {\n            val oneDigit = s.substring(i - 1, i).toInt()\n            val twoDigits = s.substring(i - 2, i).toInt()\n\n            if (oneDigit in 1..9) {\n                dp[i] += dp[i - 1]\n            }\n            if (twoDigits in 10..26) {\n                dp[i] += dp[i - 2]\n            }\n        }\n\n        return dp[s.length]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numDecodings(String s) {\n    if (s.isEmpty) return 0;\n    \n    int n = s.length;\n    List<int> dp = List.filled(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] == '0' ? 0 : 1;\n    \n    for (int i = 2; i <= n; i++) {\n      int oneDigit = int.parse(s.substring(i - 1, i));\n      int twoDigits = int.parse(s.substring(i - 2, i));\n      \n      if (oneDigit >= 1) {\n        dp[i] += dp[i - 1];\n      }\n      \n      if (twoDigits >= 10 && twoDigits <= 26) {\n        dp[i] += dp[i - 2];\n      }\n    }\n    \n    return dp[n];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numDecodings(s string) int {\n    if s[0] == '0' {\n        return 0\n    }\n    \n    n := len(s)\n    dp := make([]int, n+1)\n    dp[0], dp[1] = 1, 1\n    \n    for i := 2; i <= n; i++ {\n        if s[i-1] != '0' {\n            dp[i] += dp[i-1]\n        }\n        if s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6') {\n            dp[i] += dp[i-2]\n        }\n    }\n    \n    return dp[n]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef num_decodings(s)\n    return 0 if s.empty? || s[0] == \"0\"\n    \n    n = s.length\n    dp = Array.new(n+1, 0)\n    dp[0] = 1\n    dp[1] = 1\n    \n    (2..n).each do |i|\n        one_digit = s[i-1].to_i\n        two_digits = s[i-2..i-1].to_i\n        \n        dp[i] += dp[i-1] if one_digit >= 1 && one_digit <= 9\n        dp[i] += dp[i-2] if two_digits >= 10 && two_digits <= 26\n    end\n    \n    return dp[n]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def numDecodings(s: String): Int = {\n        if (s.isEmpty()) return 0\n\n        val n = s.length\n        val dp = new Array[Int](n + 1)\n        dp(0) = 1\n        dp(1) = if (s(0) != '0') 1 else 0\n\n        for (i <- 2 to n) {\n            val first = s.substring(i - 1, i).toInt\n            val second = s.substring(i - 2, i).toInt\n\n            if (first >= 1 && first <= 9) {\n                dp(i) += dp(i - 1)\n            }\n\n            if (second >= 10 && second <= 26) {\n                dp(i) += dp(i - 2)\n            }\n        }\n\n        dp(n)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn num_decodings(s: String) -> i32 {\n        let s = s.as_bytes();\n        let n = s.len();\n        if n == 0 || s[0] == b'0' {\n            return 0;\n        }\n\n        let mut dp = vec![0; n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for i in 2..=n {\n            if s[i-1] != b'0' {\n                dp[i] += dp[i-1];\n            }\n            if s[i-2] == b'1' || (s[i-2] == b'2' && s[i-1] <= b'6') {\n                dp[i] += dp[i-2];\n            }\n        }\n        \n        dp[n]\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use dynamic programming. We'll maintain a list `dp` where `dp[i]` represents the number of ways to decode the substring `s[:i]`. This helps in breaking down the problem into smaller subproblems.\n\n# Explanation\n1. **Base Cases**:\n   - If the input string `s` is empty or starts with a '0', there are `0` ways to decode it.\n   - Initialize `dp[0]` and `dp[1]` to `1`. `dp[0]` corresponds to the empty substring, which has exactly one way to decode (doing nothing), and `dp[1]` is `1` if the first character is not '0'.\n\n2. **Dynamic Programming Transition**:\n   - Iterate through the string from the second character to the end.\n   - If the current character `s[i-1]` is not '0', then it contributes to the number of ways as `dp[i] += dp[i-1]`.\n   - Additionally, if the two-character substring `s[i-2:i]` forms a valid encoding from '10' to '26', it contributes as `dp[i] += dp[i-2]`.\n\n3. **Final Result**:\n   - The result will be stored in `dp[n]`, where `n` is the length of the string `s`.\n\n# Pseudocode\n``` \nfunction numDecodings(s):\n    if s is empty or s starts with \"0\":\n        return 0\n\n    n = length of s\n    dp = array of size n+1 initialized to 0\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i from 2 to n:\n        if s[i-1] is not \"0\":\n            dp[i] += dp[i-1]\n        \n        if s[i-2] == \"1\" or (s[i-2] == \"2\" and s[i-1] <= \"6\"):\n            dp[i] += dp[i-2]\n\n    return dp[n]\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-decode-ways"
    },
    {
        "name": "Reverse Linked List Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reverse-linked-list-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* pre = dummy;\n        for (int i = 0; i < left - 1; i++) {\n            pre = pre->next;\n        }\n        ListNode* curr = pre->next;\n        for (int i = 0; i < right - left; i++) {\n            ListNode* temp = pre->next;\n            pre->next = curr->next;\n            curr->next = curr->next->next;\n            pre->next->next = temp;\n        }\n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        \n        for (int i = 0; i < left - 1; i++) {\n            pre = pre.next;\n        }\n        \n        ListNode curr = pre.next;\n        for (int i = left; i < right; i++) {\n            ListNode temp = curr.next;\n            curr.next = temp.next;\n            temp.next = pre.next;\n            pre.next = temp;\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\n    if(left == right) return head;\n    \n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\n    dummy->val = -1;\n    dummy->next = head;\n    \n    struct ListNode* prev = dummy;\n    \n    for(int i = 0; i < left - 1; i++) {\n        prev = prev->next;\n    }\n    \n    struct ListNode* curr = prev->next;\n    struct ListNode* next;\n    \n    for(int i = 0; i < right - left; i++) {\n        next = curr->next;\n        curr->next = next->next;\n        next->next = prev->next;\n        prev->next = next;\n    }\n    \n    return dummy->next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n */\npublic class Solution {\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\n        ListNode prev = null;\n        ListNode curr = head;\n        int count = 1;\n\n        while (count < left) {\n            prev = curr;\n            curr = curr.next;\n            count++;\n        }\n\n        ListNode con = prev;\n        ListNode tail = curr;\n\n        while (count <= right) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n            count++;\n        }\n\n        if (con != null) {\n            con.next = prev;\n        } else {\n            head = prev;\n        }\n\n        tail.next = curr;\n\n        return head;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n */\nvar reverseBetween = function(head, left, right) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let prev = dummy;\n    \n    for(let i = 0; i < left - 1; i++) {\n        prev = prev.next;\n    }\n    \n    let current = prev.next;\n    for(let i = 0; i < right - left; i++) {\n        let temp = prev.next;\n        prev.next = current.next;\n        current.next = current.next.next;\n        prev.next.next = temp;\n    }\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {\n    if (!head) {\n        return null;\n    }\n    \n    let dummy = new ListNode();\n    dummy.next = head;\n    let prev = dummy;\n\n    for (let i = 0; i < left - 1; i++) {\n        prev = prev.next!;\n    }\n\n    let curr = prev.next;\n    for (let i = 0; i < right - left; i++) {\n        let next = curr!.next;\n        curr!.next = next!.next;\n        next!.next = prev.next;\n        prev.next = next;\n    }\n\n    return dummy.next;\n};\n  "
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n\n    /**\n     * Definition for a singly-linked list.\n     * class ListNode {\n     *     public $val = 0;\n     *     public $next = null;\n     *     function __construct($val = 0, $next = null) {\n     *         $this->val = $val;\n     *         $this->next = $next;\n     *     }\n     * }\n     */\n\n    function reverseBetween($head, $left, $right) {\n        $dummy = new ListNode(0);\n        $dummy->next = $head;\n        $prev = $dummy;\n\n        for ($i = 0; $i < $left - 1; $i++) {\n            $prev = $prev->next;\n        }\n\n        $current = $prev->next;\n        for ($i = 0; $i < $right - $left; $i++) {\n            $temp = $prev->next;\n            $prev->next = $current->next;\n            $current->next = $current->next->next;\n            $prev->next->next = $temp;\n        }\n\n        return $dummy->next;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\n\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        var prev: ListNode? = nil\n        var curr: ListNode? = head\n        var start: ListNode? = head\n        var position = 1\n        \n        while position < left {\n            prev = curr\n            curr = curr?.next\n            start = start?.next\n            position += 1\n        }\n        \n        var end: ListNode? = curr\n        while position < right {\n            let next = end?.next\n            end?.next = next?.next\n            if let n = next {\n                next?.next = start\n                start = next\n            }\n            position += 1\n        }\n        \n        if prev == nil {\n            return start\n        } else {\n            prev?.next = start\n            return head\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? {\n        if (head == null) return null\n        \n        var dummy = ListNode(0)\n        dummy.next = head\n        var pre = dummy\n        \n        for (i in 1 until left) {\n            pre = pre.next\n        }\n        \n        var start = pre.next\n        var then = start?.next\n        \n        for (i in left until right) {\n            start?.next = then?.next\n            then?.next = pre?.next\n            pre?.next = then\n            then = start?.next\n        }\n        \n        return dummy.next\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n \nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\n    dummy := &ListNode{Val: 0, Next: head}\n    prev := dummy\n    for i := 0; i < left-1; i++ {\n        prev = prev.Next\n    }\n    curr := prev.Next\n    for i := 0; i < right-left; i++ {\n        next := curr.Next\n        curr.Next = next.Next\n        next.Next = prev.Next\n        prev.Next = next\n    }\n    return dummy.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class ListNode\n    attr_accessor :val, :next\n    def initialize(val = 0, _next = nil)\n        @val = val\n        @next = _next\n    end\nend\n\ndef reverse_between(head, left, right)\n    dummy = ListNode.new(0)\n    dummy.next = head\n    prev_left = dummy\n    \n    (left - 1).times do\n        prev_left = prev_left.next\n    end\n    \n    current = prev_left.next\n    (right - left).times do\n        temp = current.next\n        current.next = temp.next\n        temp.next = prev_left.next\n        prev_left.next = temp\n    end\n    \n    return dummy.next\nend"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to reverse the nodes of a singly linked list from position `left` to position `right` inclusive. Below, I provide an explanation and a pseudocode to achieve this.\n\n# Explanation\n\n1. **Input and Output**: \n    - The function takes in the head of a singly linked list and two integers, `left` and `right`.\n    - The output should be the head of the modified list where the nodes between `left` and `right` (inclusive) are reversed.\n\n2. **Approach**:\n    - Initialize a dummy node to handle edge cases more easily.\n    - Traverse the list to reach the node just before the `left` position (`prev` node).\n    - Repeatedly adjust the `next` pointers to reverse the nodes between `left` and `right`.\n    - Return the new head of the list.\n\n3. **Steps**:\n    - Create a dummy node and set its `next` to the head of the list.\n    - Iterate to the node just before the `left` position.\n    - Starting from that node, reverse the pointers between `left` and `right` nodes.\n    - Return the `next` of the dummy node.\n\n# Pseudocode\n\n```\nPseudocode:\n1. Define function reverseBetween(head, left, right)\n    1.1 If head is None, return None\n    \n    2. Create a dummy node with value 0, let dummy.next be head\n    3. Initialize a pointer 'prev' and set it to dummy\n    \n    4. Move 'prev' to the node just before the 'left' position\n        4.1 Loop from 0 to left - 2\n            4.1.1 prev = prev.next\n    \n    5. Initialize a pointer 'current' and set it to prev.next\n    \n    6. Reverse the sublist from 'left' to 'right'\n        6.1 Loop from 0 to right - left\n            6.1.1 Let 'temp' be prev.next\n            6.1.2 prev.next = current.next\n            6.1.3 current.next = current.next.next\n            6.1.4 prev.next.next = temp\n    \n    7. Return dummy.next as the new head\n```\n\nBy following the above pseudocode, we can efficiently reverse the linked list segment between the given positions `left` and `right`. This process ensures only one pass through the specified segment, meeting the problem's constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reverse-linked-list-ii"
    },
    {
        "name": "Restore Ip Addresses",
        "site": "LeetCode",
        "href": "/solution/LeetCode-restore-ip-addresses",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        vector<string> result;\n        string ip;\n        backtrack(s, result, ip, 0, 0);\n        return result;\n    }\n    \n    void backtrack(string s, vector<string>& result, string& ip, int start, int count) {\n        if (count == 4 && start == s.length()) {\n            result.push_back(ip);\n            return;\n        }\n        \n        for (int i = 1; i < 4; i++) {\n            if (start + i > s.length()) break;\n            string part = s.substr(start, i);\n            if ((part[0] == '0' && part.length() > 1) || (i == 3 && stoi(part) >= 256)) continue;\n            \n            string tmp = ip;\n            ip += part + (count == 3 ? \"\" : \".\");\n            backtrack(s, result, ip, start + i, count + 1);\n            ip = tmp;\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.*;\n\nclass Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> result = new ArrayList<>();\n        dfs(s, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void dfs(String s, int start, List<String> path, List<String> result) {\n        if (path.size() == 4) {\n            if (start == s.length()) {\n                result.add(String.join(\".\", path));\n            }\n            return;\n        }\n\n        for (int i = 1; i <= 3; i++) {\n            if (start + i > s.length()) {\n                break;\n            }\n\n            String part = s.substring(start, start + i);\n            if ((part.startsWith(\"0\") && part.length() > 1) || (i == 3 && Integer.parseInt(part) > 255)) {\n                continue;\n            }\n\n            path.add(part);\n            dfs(s, start + i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def backtrack(start, path, s, res):\n            if start == len(s) and len(path) == 4:\n                res.append(\".\".join(path))\n                return\n            if len(path) >= 4:\n                return\n            for i in range(1, 4):\n                if start + i > len(s):\n                    break\n                if s[start] == \"0\" and i > 1:\n                    break\n                num = int(s[start:start+i])\n                if num <= 255:\n                    backtrack(start + i, path + [s[start:start+i]], s, res)\n        \n        res = []\n        backtrack(0, [], s, res)\n        return res"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> RestoreIpAddresses(string s) {\n        List<string> result = new List<string>();\n        DFS(s, 0, 0, new List<string>(), result);\n        return result;\n    }\n    \n    private void DFS(string s, int index, int segment, List<string> current, List<string> result) {\n        if (segment == 4) {\n            if (index == s.Length) {\n                result.Add(string.Join(\".\", current));\n            }\n            return;\n        }\n        \n        for (int i = 1; i <= 3; i++) {\n            if (index + i > s.Length) break;\n            \n            string segmentStr = s.Substring(index, i);\n            if ((segmentStr[0] == '0' && segmentStr.Length > 1) || (i == 3 && int.Parse(segmentStr) > 255)) {\n                continue;\n            }\n            \n            current.Add(segmentStr);\n            DFS(s, index + i, segment + 1, current, result);\n            current.RemoveAt(current.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    let result = [];\n    \n    const backtrack = (current, start, parts) => {\n        if (parts === 4) {\n            if (start === s.length) {\n                result.push(current.join('.'));\n            }\n            return;\n        }\n        \n        for (let i = 1; i <= 3; i++) {\n            if (start + i > s.length) break;\n            \n            let part = s.substring(start, start + i);\n            if ((part[0] === '0' && part.length > 1) || parseInt(part) > 255) continue;\n            \n            current.push(part);\n            backtrack(current, start + i, parts + 1);\n            current.pop();\n        }\n    };\n    \n    backtrack([], 0, 0);\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function restoreIpAddresses(s: string): string[] {\n    const result: string[] = [];\n    \n    const backtrack = (curr: string, idx: number, dots: number) => {\n        if (idx >= s.length) {\n            if (dots === 0) {\n                result.push(curr);\n            }\n            return;\n        }\n\n        const remaining = s.length - idx;\n        \n        if (dots * 3 < remaining || dots > remaining) {\n            return;\n        }\n        \n        if (curr !== \"\") {\n            curr += \".\";\n        }\n\n        for (let i = 1; i <= 3 && idx + i <= s.length; i++) {\n            const part = s.slice(idx, idx + i);\n            if ((part[0] === \"0\" && part.length > 1) || parseInt(part) > 255) {\n                continue;\n            }\n            backtrack(curr + part, idx + i, dots - 1);\n        }\n    };\n\n    backtrack(\"\", 0, 4);\n\n    return result;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func restoreIpAddresses(_ s: String) -> [String] {\n        var result = [String]()\n        backtrack(s, &result, \"\", 0, 0)\n        return result\n    }\n    \n    func backtrack(_ s: String, _ result: inout [String], _ current: String, _ index: Int, _ dots: Int) {\n        if dots == 4 {\n            if index == s.count {\n                result.append(current)\n            }\n            return\n        }\n        \n        for i in 1...3 {\n            if index + i > s.count {\n                break\n            }\n            let str = String(s[s.index(s.startIndex, offsetBy: index)..<s.index(s.startIndex, offsetBy: index+i)])\n            if let num = Int(str), String(num) == str, num >= 0, num <= 255 {\n                if i > 1 && s[s.index(s.startIndex, offsetBy: index)] == \"0\" {\n                    continue\n                }\n                let newStr = current.isEmpty ? str : current + \".\" + str\n                backtrack(s, &result, newStr, index+i, dots+1)\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun restoreIpAddresses(s: String): List<String> {\n        val result = mutableListOf<String>()\n        backtrack(s, result, \"\", 0, 0)\n        return result\n    }\n\n    private fun backtrack(s: String, result: MutableList<String>, current: String, index: Int, segment: Int) {\n        if (segment == 4) {\n            if (index == s.length) result.add(current)\n            return\n        }\n\n        for (i in 1..3) {\n            if (index + i > s.length) break\n            val str = s.substring(index, index + i)\n            if ((str.length > 1 && str.startsWith('0')) || (i == 3 && str.toInt() > 255)) continue\n            backtrack(s, result, if (segment == 0) str else \"$current.$str\", index + i, segment + 1)\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> restoreIpAddresses(String s) {\n      List<String> result = [];\n      dfs(s, 0, \"\", 0, result);\n      return result;\n  }\n  \n  void dfs(String s, int index, String path, int count, List<String> result) {\n      if (index == s.length && count == 4) {\n          result.add(path);\n          return;\n      }\n      \n      if (count > 4) {\n          return;\n      }\n      \n      for (int i = 1; i <= 3; i++) {\n          if (index + i > s.length) {\n              break;\n          }\n          \n          String segment = s.substring(index, index + i);\n          \n          if (segment.startsWith('0') && segment.length > 1 || int.parse(segment) > 255) {\n              continue;\n          }\n          \n          String newPath = path.isEmpty ? segment : path + \".\" + segment;\n          \n          dfs(s, index + i, newPath, count + 1, result);\n      }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func restoreIpAddresses(s string) []string {\n    var res []string\n    backtrack(s, &res, []string{}, 0)\n    return res\n}\n\nfunc backtrack(s string, res *[]string, path []string, start int) {\n    if len(path) == 4 && start == len(s) {\n        *res = append(*res, strings.Join(path, \".\"))\n        return\n    }\n    \n    if len(path) == 4 || start == len(s) {\n        return\n    }\n    \n    for i := 1; i <= 3 && start+i <= len(s); i++ {\n        if isValid(s[start:start+i]) {\n            path = append(path, s[start:start+i])\n            backtrack(s, res, path, start+i)\n            path = path[:len(path)-1]\n        }\n    }\n}\n\nfunc isValid(s string) bool {\n    if s[0] == '0' && len(s) > 1 {\n        return false\n    }\n    num, _ := strconv.Atoi(s)\n    return num >= 0 && num <= 255\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {String[]}\ndef restore_ip_addresses(s)\n    result = []\n    \n    backtrack(s, \"\", result, 0, 0)\n    \n    return result\nend\n\ndef backtrack(s, current, result, index, count)\n    return if count > 4\n    \n    if count == 4 && index == s.length\n        result << current\n        return\n    end\n    \n    (1..3).each do |i|\n        next if index + i > s.length\n        \n        segment = s[index, i].to_i\n        \n        if i > 1 && s[index] == '0'\n            next\n        end\n        \n        if segment >= 0 && segment <= 255\n            new_current = current.empty? ? segment.to_s : \"#{current}.#{segment}\"\n            backtrack(s, new_current, result, index + i, count + 1)\n        end\n    end\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn restore_ip_addresses(s: String) -> Vec<String> {\n        let mut res: Vec<String> = Vec::new();\n        let n = s.len();\n        for i in 1..=3 {\n            for j in 1..=3 {\n                for k in 1..=3 {\n                    let l = n - i - j - k;\n                    if l > 0 && l <= 3 {\n                        let a: i32 = s[..i].parse().unwrap_or(-1);\n                        let b: i32 = s[i..i + j].parse().unwrap_or(-1);\n                        let c: i32 = s[i + j..i + j + k].parse().unwrap_or(-1);\n                        let d: i32 = s[i + j + k..].parse().unwrap_or(-1);\n                        if a >= 0 && a <= 255 && b >= 0 && b <= 255 && c >= 0 && c <= 255 && d >= 0 && d <= 255 {\n                            let ip = format!(\"{}.{}.{}.{}\", a, b, c, d);\n                            if ip.len() == n + 3 {\n                                res.push(ip);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        res\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a Depth-First Search (DFS) approach with backtracking to explore all possible combinations of placing dots in the given string to form valid IP addresses. The main idea is to build the valid IP address segments while backtracking when the current segment does not lead to a solution. \n\nHere's how you can approach this problem:\n\n# Explanation\n\n1. **Initialization**: Start with an empty list `res` to store the valid IP addresses.\n2. **Backtracking Function**: Define a helper function `backtrack` that takes four parameters: the current start index in the string `s`, the current path (an array representing segments of the IP address), the string `s` itself, and the result list `res`.\n\n    - **Base Case**:\n        - If the start index is equal to the length of the string `s` and the path contains exactly 4 segments, the current path can form a valid IP address. Join the segments by dots and add the result to `res`.\n        - If the length of the path exceeds 4 segments, return as it is invalid.\n\n    - **Recursive Case**:\n        - Loop through possible segment lengths (1 to 3 characters).\n        - Ensure segment does not start with '0' unless it is exactly '0'.\n        - Convert the segment to an integer and check if it is within the range 0 to 255.\n        - Call the `backtrack` function recursively with the next start index and the current segment added to the path.\n\n3. **Termination**: After the backtracking is complete, return the list `res` containing all valid IP addresses.\n\n# Pseudocode\n\n```\n# Function to restore IP addresses\nfunction restoreIpAddresses(s):\n    # Initialize result list to store the valid IP addresses\n    res = []\n\n    # Helper function for backtracking\n    function backtrack(start, path, s, res):\n        # If start index equals length of s and path has 4 segments, it is a valid IP address\n        if start == len(s) and len(path) == 4:\n            res.append(join(path, \".\"))\n            return\n        \n        # If the path already has 4 segments, stop further exploration\n        if len(path) >= 4:\n            return\n\n        # Try segments of length 1, 2, and 3\n        for i in range(1, 4):\n            # If start + i is out of bounds, break\n            if start + i > len(s):\n                break\n            \n            # Extract the segment\n            segment = s[start:start+i]\n            \n            # Ensure segment does not have leading zeros unless it is exactly \"0\"\n            if segment[0] == '0' and len(segment) > 1:\n                break\n            \n            # Convert the segment to an integer\n            num = int(segment)\n            \n            # Segment must be in the range 0 to 255\n            if num <= 255:\n                # Recursive call with the next starting index and current segment in the path\n                backtrack(start + i, path + [segment], s, res)\n\n    # Initial call to the backtracking function\n    backtrack(0, [], s, res)\n    \n    # Return the result list\n    return res\n```\nThe pseudocode above outlines the process clearly. It ensures that every step to build a valid IP address is accounted for by placing and validating each segment recursively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-restore-ip-addresses"
    },
    {
        "name": "Binary Tree Inorder Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-inorder-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> res;\n        stack<TreeNode*> st;\n        TreeNode* curr = root;\n        \n        while (curr != NULL || !st.empty()) {\n            while (curr != NULL) {\n                st.push(curr);\n                curr = curr->left;\n            }\n            \n            curr = st.top();\n            st.pop();\n            res.push_back(curr->val);\n            \n            curr = curr->right;\n        }\n        \n        return res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        \n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            result.add(curr.val);\n            curr = curr.right;\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n \nint* inorderTraversal(struct TreeNode* root, int* returnSize){\n    if (root == NULL) {\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    int* result = (int*)malloc(100 * sizeof(int));\n    int index = 0;\n    \n    struct TreeNode* stack[100];\n    int top = -1;\n    \n    while (root != NULL || top != -1) {\n        while (root != NULL) {\n            stack[++top] = root;\n            root = root->left;\n        }\n        root = stack[top--];\n        result[index++] = root->val;\n        root = root->right;\n    }\n    \n    *returnSize = index;\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> InorderTraversal(TreeNode root) {\n        List<int> result = new List<int>();\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n\n        while (root != null || stack.Count > 0) {\n            while (root != null) {\n                stack.Push(root);\n                root = root.left;\n            }\n\n            root = stack.Pop();\n            result.Add(root.val);\n            root = root.right;\n        }\n\n        return result;\n    }\n}\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n */\n\nvar inorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n    let current = root;\n    \n    while (current !== null || stack.length > 0) {\n        while (current !== null) {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        result.push(current.val);\n        current = current.right;\n    }\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction inorderTraversal(root: TreeNode | null): number[] {\n    const result: number[] = [];\n    const stack: TreeNode[] = [];\n    let current: TreeNode | null = root;\n    \n    while (current || stack.length > 0) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n        current = stack.pop();\n        if (current) {\n            result.push(current.val);\n            current = current.right;\n        }\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function inorderTraversal($root) {\n        $result = [];\n        $stack = [];\n        $current = $root;\n        \n        while ($current !== null || !empty($stack)) {\n            while ($current !== null) {\n                array_push($stack, $current);\n                $current = $current->left;\n            }\n            $current = array_pop($stack);\n            $result[] = $current->val;\n            $current = $current->right;\n        }\n        \n        return $result;\n    }\n}\n\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Solution {\n    fun inorderTraversal(root: TreeNode?): List<Int> {\n        val res = mutableListOf<Int>()\n        val stack = Stack<TreeNode>()\n        var curr = root\n\n        while (curr != null || stack.isNotEmpty()) {\n            while (curr != null) {\n                stack.push(curr)\n                curr = curr.left\n            }\n            curr = stack.pop()\n            res.add(curr.`val`)\n            curr = curr.right\n        }\n        \n        return res\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc inorderTraversal(root *TreeNode) []int {\n    var res []int\n    var stack []*TreeNode\n    curr := root\n    for curr != nil || len(stack) > 0 {\n        for curr != nil {\n            stack = append(stack, curr)\n            curr = curr.Left\n        }\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res, node.Val)\n        curr = node.Right\n    }\n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#     end\n# end\n\ndef inorder_traversal(root)\n    result = []\n    stack = []\n    current = root\n    \n    while current || !stack.empty?\n        while current\n            stack.push(current)\n            current = current.left\n        end\n        \n        current = stack.pop\n        result.push(current.val)\n        current = current.right\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *     var value: Int = _value\n *     var left: TreeNode = _left\n *     var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def inorderTraversal(root: TreeNode): List[Int] = {\n        var res = List[Int]()\n        def inorder(node: TreeNode): Unit = {\n            if (node == null) return\n            inorder(node.left)\n            res = res :+ node.value\n            inorder(node.right)\n        }\n        inorder(root)\n        res\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | \ninorder_traversal(null) ->\n    [];\ninorder_traversal(#tree_node{left = Left, val = Val, right = Right}) ->\n    inorder_traversal(Left) ++ [Val] ++ inorder_traversal(Right).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform an inorder traversal of a binary tree. Inorder traversal means visiting the nodes in the following order: left subtree, root node, and then the right subtree. This should be done iteratively, not recursively.\n\n# Explanation\n\n1. **Initialize Data Structures:**\n   - Use an array `result` to store the values of nodes in inorder sequence.\n   - Use a stack to keep track of nodes as we traverse the tree.\n\n2. **Traversal Logic:**\n   - Start from the root node.\n   - Iterate until there are no nodes left to visit or the stack is empty.\n   - Traverse the leftmost node first (push all left nodes to the stack).\n   - Once the leftmost node is reached (current node is null), pop from the stack (this gives us the current node to process).\n   - Add the node's value to the result list.\n   - Move to the right node of the current node.\n   \nThis process ensures that we visit the tree nodes in the correct inorder sequence.\n\n# Pseudocode\n\n```\ndefine function inorderTraversal(root):\n    initialize result as an empty list\n    initialize stack as an empty list\n    set current to root\n    \n    while current is not null or stack is not empty:\n        while current is not null:\n            push current to stack\n            set current to current.left\n        \n        set current to pop from stack\n        append current.val to result\n        set current to current.right\n    \n    return result\n```\n\nIn summary, we use an iterative approach with a stack to manage the traversal, ensuring all nodes are visited in the correct inorder sequence.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-inorder-traversal"
    },
    {
        "name": "Unique Binary Search Trees Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-unique-binary-search-trees-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        if (n == 0) {\n            return {};\n        }\n        return generateTrees(1, n);\n    }\n    \n    vector<TreeNode*> generateTrees(int start, int end) {\n        vector<TreeNode*> trees;\n        if (start > end) {\n            trees.push_back(nullptr);\n            return trees;\n        }\n        \n        for (int i = start; i <= end; ++i) {\n            vector<TreeNode*> leftSubtrees = generateTrees(start, i - 1);\n            vector<TreeNode*> rightSubtrees = generateTrees(i + 1, end);\n            \n            for (TreeNode* left : leftSubtrees) {\n                for (TreeNode* right : rightSubtrees) {\n                    TreeNode* root = new TreeNode(i);\n                    root->left = left;\n                    root->right = right;\n                    trees.push_back(root);\n                }\n            }\n        }\n        \n        return trees;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<TreeNode> generateTrees(int n) {\n        if (n == 0) {\n            return new ArrayList<TreeNode>();\n        }\n        return generateTrees(1, n);\n    }\n    \n    private List<TreeNode> generateTrees(int start, int end) {\n        List<TreeNode> result = new ArrayList<TreeNode>();\n        if (start > end) {\n            result.add(null);\n            return result;\n        }\n        \n        for (int i = start; i <= end; i++) {\n            List<TreeNode> leftSubtrees = generateTrees(start, i - 1);\n            List<TreeNode> rightSubtrees = generateTrees(i + 1, end);\n            \n            for (TreeNode left : leftSubtrees) {\n                for (TreeNode right : rightSubtrees) {\n                    TreeNode root = new TreeNode(i);\n                    root.left = left;\n                    root.right = right;\n                    result.add(root);\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<TreeNode> GenerateTrees(int n) {\n        if (n == 0) return new List<TreeNode>();\n        return GenerateTrees(1, n);\n    }\n    \n    public IList<TreeNode> GenerateTrees(int start, int end) {\n        IList<TreeNode> res = new List<TreeNode>();\n        \n        if (start > end) {\n            res.Add(null);\n            return res;\n        }\n        \n        for (int i = start; i <= end; i++) {\n            IList<TreeNode> leftTree = GenerateTrees(start, i - 1);\n            IList<TreeNode> rightTree = GenerateTrees(i + 1, end);\n            \n            foreach (var left in leftTree) {\n                foreach (var right in rightTree) {\n                    TreeNode root = new TreeNode(i);\n                    root.left = left;\n                    root.right = right;\n                    res.Add(root);\n                }\n            }\n        }\n        \n        return res;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n * @param {number} n\n * @return {TreeNode[]}\n */\nvar generateTrees = function(n) {\n    const generate = (start, end) => {\n        if (start > end) return [null];\n        \n        const result = [];\n        \n        for (let i = start; i <= end; i++) {\n            const leftTrees = generate(start, i - 1);\n            const rightTrees = generate(i + 1, end);\n            \n            for (let left of leftTrees) {\n                for (let right of rightTrees) {\n                    const root = new TreeNode(i);\n                    root.left = left;\n                    root.right = right;\n                    result.push(root);\n                }\n            }\n        }\n        \n        return result;\n    };\n    \n    if (n === 0) return [];\n    return generate(1, n);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number;\n *     left: TreeNode | null;\n *     right: TreeNode | null;\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val);\n *         this.left = (left===undefined ? null : left);\n *         this.right = (right===undefined ? null : right);\n *     }\n * }\n */\nfunction generateTrees(n: number): Array<TreeNode | null> {\n    function generateTreesRecursive(start: number, end: number): Array<TreeNode | null> {\n        const result: Array<TreeNode | null> = [];\n        if (start > end) {\n            result.push(null);\n            return result;\n        }\n        \n        for (let i = start; i <= end; i++) {\n            const leftSubtrees = generateTreesRecursive(start, i - 1);\n            const rightSubtrees = generateTreesRecursive(i + 1, end);\n            \n            for (let left of leftSubtrees) {\n                for (let right of rightSubtrees) {\n                    const root = new TreeNode(i);\n                    root.left = left;\n                    root.right = right;\n                    result.push(root);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    if (n === 0) {\n        return [];\n    }\n    \n    return generateTreesRecursive(1, n);\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun generateTrees(n: Int): List<TreeNode?> {\n        if (n == 0) return emptyList()\n        return generateTrees(1, n)\n    }\n    \n    fun generateTrees(start: Int, end: Int): List<TreeNode?> {\n        val res = mutableListOf<TreeNode?>()\n        if (start > end) {\n            res.add(null)\n            return res\n        }\n        for (i in start..end) {\n            val leftSubtrees = generateTrees(start, i - 1)\n            val rightSubtrees = generateTrees(i + 1, end)\n            for (left in leftSubtrees) {\n                for (right in rightSubtrees) {\n                    val root = TreeNode(i)\n                    root.left = left\n                    root.right = right\n                    res.add(root)\n                }\n            }\n        }\n        return res\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc generateTrees(n int) []*TreeNode {\n    if n == 0 {\n        return []*TreeNode{}\n    }\n    return generateTreesDFS(1, n)\n}\n\nfunc generateTreesDFS(start, end int) []*TreeNode {\n    var res []*TreeNode\n    if start > end {\n        res = append(res, nil)\n        return res\n    }\n\n    for i := start; i <= end; i++ {\n        leftTrees := generateTreesDFS(start, i-1)\n        rightTrees := generateTreesDFS(i+1, end)\n        for _, left := range leftTrees {\n            for _, right := range rightTrees {\n                root := &TreeNode{Val: i}\n                root.Left = left\n                root.Right = right\n                res = append(res, root)\n            }\n        }\n    }\n\n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef generate_trees(n)\n    def generate_trees_helper(start, last)\n        return [nil] if start > last\n        \n        result = []\n        (start..last).each do |i|\n            left_trees = generate_trees_helper(start, i - 1)\n            right_trees = generate_trees_helper(i + 1, last)\n            \n            left_trees.each do |left|\n                right_trees.each do |right|\n                    root = TreeNode.new(i)\n                    root.left = left\n                    root.right = right\n                    result << root\n                end\n            end\n        end\n        result\n    end\n    \n    generate_trees_helper(1, n)\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of generating all structurally unique BSTs that have exactly `n` nodes with unique values from 1 to `n`, we can use a recursive approach. The main idea is to consider each number from 1 to `n` as the root node and recursively generate all possible left and right subtrees. \n\nThe recursive function will:\n1. Generate all possible left subtrees using the numbers less than the root.\n2. Generate all possible right subtrees using the numbers greater than the root.\n3. Combine each left subtree with each right subtree to form the complete tree and add it to the result.\n\n# Explanation\n1. **Recursive Tree Generation**: We can define a recursive function `generate(start, end)` that generates all unique BSTs for numbers in the range from `start` to `end`.\n2. **Base Case**: If `start` is greater than `end`, return a list containing `null`, indicating an empty subtree.\n3. **Iterate over possible root values**: For each value `i` from `start` to `end`, consider `i` as the root.\n4. **Generate subtrees**: Recursively generate all possible left subtrees for values `start` to `i-1` and all possible right subtrees for `i+1` to `end`.\n5. **Combine subtrees**: For each combination of left and right subtrees, create a new tree with `i` as the root, and add it to the result list.\n6. **Edge Case**: If `n` is 0, return an empty list.\n\n# Pseudocode\n```pseudocode\n# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generateTrees(n):\n    def generate(start, end):\n        # If the start index is greater than the end index, return list with None\n        if start > end:\n            return [None]\n        \n        # List to store all unique BSTs for this range\n        result = []\n        \n        # Iterate over all values as potential root\n        for i in range(start, end + 1):\n            # Generate all left subtrees for values less than i\n            leftTrees = generate(start, i - 1)\n            # Generate all right subtrees for values greater than i\n            rightTrees = generate(i + 1, end)\n            \n            # Combine each left and right subtree with the current root (i)\n            for left in leftTrees:\n                for right in rightTrees:\n                    # Create a new root node\n                    root = TreeNode(i)\n                    root.left = left\n                    root.right = right\n                    # Add this tree to the result list\n                    result.append(root)\n        \n        return result\n\n    # If n is 0, return an empty list\n    if n == 0:\n        return []\n    \n    # Generate all unique BSTs for values from 1 to n\n    return generate(1, n)\n```\n\nThis pseudocode outlines the approach used to generate all structurally unique binary search trees for a given `n` using recursion and tree node creation. The function `generateTrees` handles the main generation logic by utilizing the helper function `generate`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-unique-binary-search-trees-ii"
    },
    {
        "name": "Unique Binary Search Trees",
        "site": "LeetCode",
        "href": "/solution/LeetCode-unique-binary-search-trees",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        \n        return dp[n];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numTrees(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        \n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n        \n        return dp[n];\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[n]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int numTrees(int n) {\n    int dp[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for(int i = 2; i <= n; i++) {\n        dp[i] = 0;\n        for(int j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    \n    return dp[n];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumTrees(int n) {\n        if (n <= 1) {\n            return 1;\n        }\n        \n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n        \n        return dp[n];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar numTrees = function(n) {\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        for (let j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n    \n    return dp[n];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numTrees(n: number): number {\n    const dp: number[] = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++) {\n        for (let j = 1; j <= i; j++) {\n            dp[i] += dp[j - 1] * dp[i - j];\n        }\n    }\n\n    return dp[n];\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function numTrees($n) {\n        $dp = array_fill(0, $n + 1, 0);\n        $dp[0] = 1;\n        $dp[1] = 1;\n\n        for ($i = 2; $i <= $n; $i++) {\n            for ($j = 1; $j <= $i; $j++) {\n                $dp[$i] += $dp[$j - 1] * $dp[$i - $j];\n            }\n        }\n\n        return $dp[$n];\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numTrees(n: Int): Int {\n        val dp = IntArray(n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for (i in 2..n) {\n            for (j in 1..i) {\n                dp[i] += dp[j - 1] * dp[i - j]\n            }\n        }\n        \n        return dp[n]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numTrees(int n) {\n    List<int> dp = List.filled(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n      for (int j = 1; j <= i; j++) {\n        dp[i] += dp[j - 1] * dp[i - j];\n      }\n    }\n\n    return dp[n];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numTrees(n int) int {\n    if n == 1 {\n        return 1\n    }\n    \n    dp := make([]int, n+1)\n    dp[0], dp[1] = 1, 1\n    \n    for i := 2; i <= n; i++ {\n        for j := 1; j <= i; j++ {\n            dp[i] += dp[j-1] * dp[i-j]\n        }\n    }\n    \n    return dp[n]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef num_trees(n)\n    dp = Array.new(n+1, 0)\n    dp[0] = 1\n    dp[1] = 1\n\n    (2..n).each do |i|\n        (1..i).each do |j|\n            dp[i] += dp[j - 1] * dp[i - j]\n        end\n    end\n\n    return dp[n]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def numTrees(n: Int): Int = {\n        if (n <= 1) {\n            return 1\n        }\n        \n        val dp = new Array[Int](n + 1)\n        dp(0) = 1\n        dp(1) = 1\n        \n        for (i <- 2 to n) {\n            for (j <- 0 until i) {\n                dp(i) += dp(j) * dp(i - j - 1)\n            }\n        }\n        \n        dp(n)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn num_trees(n: i32) -> i32 {\n        let mut dp = vec![0; n as usize + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n\n        for i in 2..=n as usize {\n            for j in 1..=i {\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n\n        dp[n as usize]\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec num_trees(N :: integer()) -> integer().\nnum_trees(N) ->\n    NumTrees = fun(0) -> 1;\n                   (1) -> 1;\n                   (N) when N > 1 ->\n                       lists:sum([num_trees(I-1) * num_trees(N-I) || I <- lists:seq(1, N)])\n                end,\n    NumTrees(N).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the number of unique binary search trees (BSTs) that can be formed using exactly \\( n \\) distinct nodes. This can be achieved using dynamic programming.\n\n# Explanation\n\n1. **Concept**: \n   - The problem requires us to count the number of structurally unique Binary Search Trees (BSTs) that can be formed with nodes valued from 1 to \\( n \\).\n   - Let \\( G(n) \\) represent the number of unique BSTs that can be made with \\( n \\) nodes.\n   \n2. **Dynamic Programming Basis**:\n   - The number of unique BSTs for \\( n \\) nodes can be derived from smaller subproblems.\n   - If a node \\( i \\) is chosen as the root, the number of unique BSTs that can be formed is the product of the number of unique BSTs that can be formed with the left subtree (nodes 1 to \\( i-1 \\)) and the right subtree (nodes \\( i+1 \\) to \\( n \\)).\n   - Mathematically, the relationship can be expressed as: \n     \\[\n     G(n) = \\sum_{i=1}^{n} G(i-1) \\times G(n-i)\n     \\]\n\n3. **Base Cases**:\n   - \\( G(0) = 1 \\): An empty tree is considered one unique BST.\n   - \\( G(1) = 1 \\): A single node tree is exactly one unique BST.\n\n4. **Steps to Solve**:\n   - Initialize a list \\( dp \\) where \\( dp[i] \\) stores the number of unique BSTs that can be formed with \\( i \\) nodes.\n   - Fill this list from \\( 0 \\) to \\( n \\) using the recursive relationship described.\n   - The result will be \\( dp[n] \\).\n\n# Pseudocode\n\n```python\ndef numTrees(n):\n    # Initialize the dp array with zeros\n    dp = [0] * (n + 1)\n    \n    # Base cases\n    dp[0] = dp[1] = 1\n    \n    # Fill the dp array for each number from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            dp[i] += dp[j - 1] * dp[i - j]\n    \n    # The result is the number of unique BSTs with n nodes\n    return dp[n]\n```\n\nThis pseudocode outlines the steps to arrive at the solution using dynamic programming. The main idea is to build up the solution for larger trees from solutions of smaller subtrees, stored in a list `dp`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-unique-binary-search-trees"
    },
    {
        "name": "Interleaving String",
        "site": "LeetCode",
        "href": "/solution/LeetCode-interleaving-string",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        if (s1.length() + s2.length() != s3.length()) {\n            return false;\n        }\n        \n        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));\n        \n        for (int i = 0; i <= s1.length(); ++i) {\n            for (int j = 0; j <= s2.length(); ++j) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = true;\n                } else if (i == 0) {\n                    dp[i][j] = dp[i][j-1] && s2[j-1] == s3[i+j-1];\n                } else if (j == 0) {\n                    dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i+j-1];\n                } else {\n                    dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]) || (dp[i][j-1] && s2[j-1] == s3[i+j-1]);\n                }\n            }\n        }\n        \n        return dp[s1.length()][s2.length()];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() + s2.length() != s3.length()) {\n            return false;\n        }\n        \n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\n        \n        for (int i = 0; i <= s1.length(); i++) {\n            for (int j = 0; j <= s2.length(); j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = true;\n                } else if (i == 0) {\n                    dp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n                } else if (j == 0) {\n                    dp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\n                } else {\n                    dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || \n                               (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n                }\n            }\n        }\n        \n        return dp[s1.length()][s2.length()];\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [False] * (len(s2) + 1)\n        dp[0] = True\n        \n        for j in range(1, len(s2) + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s2)]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isInterleave(char* s1, char* s2, char* s3) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int len3 = strlen(s3);\n    \n    if (len1 + len2 != len3) {\n        return false;\n    }\n    \n    bool dp[len1 + 1][len2 + 1];\n    \n    for (int i = 0; i <= len1; i++) {\n        for (int j = 0; j <= len2; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = true;\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1];\n            } else {\n                dp[i][j] = (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]) || (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]);\n            }\n        }\n    }\n    \n    return dp[len1][len2];\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsInterleave(string s1, string s2, string s3) {\n        if (s1.Length + s2.Length != s3.Length) {\n            return false;\n        }\n        \n        bool[,] dp = new bool[s1.Length + 1, s2.Length + 1];\n        dp[0, 0] = true;\n        \n        for (int i = 1; i <= s1.Length; i++) {\n            dp[i, 0] = dp[i - 1, 0] && s1[i - 1] == s3[i - 1];\n        }\n        \n        for (int j = 1; j <= s2.Length; j++) {\n            dp[0, j] = dp[0, j - 1] && s2[j - 1] == s3[j - 1];\n        }\n        \n        for (int i = 1; i <= s1.Length; i++) {\n            for (int j = 1; j <= s2.Length; j++) {\n                dp[i, j] = (dp[i - 1, j] && s1[i - 1] == s3[i + j - 1]) || \n                           (dp[i, j - 1] && s2[j - 1] == s3[i + j - 1]);\n            }\n        }\n        \n        return dp[s1.Length, s2.Length];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {boolean}\n */\nconst isInterleave = (s1, s2, s3) => {\n    if (s1.length + s2.length !== s3.length) {\n        return false;\n    }\n    \n    const dp = new Array(s1.length + 1).fill(false).map(() => new Array(s2.length + 1).fill(false));\n    \n    for (let i = 0; i <= s1.length; i++) {\n        for (let j = 0; j <= s2.length; j++) {\n            if (i === 0 && j === 0) {\n                dp[i][j] = true;\n            } else if (i === 0) {\n                dp[i][j] = dp[i][j - 1] && s2[j - 1] === s3[i + j - 1];\n            } else if (j === 0) {\n                dp[i][j] = dp[i - 1][j] && s1[i - 1] === s3[i + j - 1];\n            } else {\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n            }\n        }\n    }\n    \n    return dp[s1.length][s2.length];\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isInterleave(s1: string, s2: string, s3: string): boolean {\n    if (s1.length + s2.length !== s3.length) {\n        return false;\n    }\n    \n    const dp: boolean[][] = Array.from({ length: s1.length + 1 }, () => Array(s2.length + 1).fill(false));\n    \n    for (let i = 0; i <= s1.length; i++) {\n        for (let j = 0; j <= s2.length; j++) {\n            if (i === 0 && j === 0) {\n                dp[i][j] = true;\n            } else if (i === 0) {\n                dp[i][j] = dp[i][j - 1] && s2[j - 1] === s3[i + j - 1];\n            } else if (j === 0) {\n                dp[i][j] = dp[i - 1][j] && s1[i - 1] === s3[i + j - 1];\n            } else {\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n            }\n        }\n    }\n    \n    return dp[s1.length][s2.length];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s1\n     * @param String $s2\n     * @param String $s3\n     * @return Boolean\n     */\n    function isInterleave($s1, $s2, $s3) {\n        $len1 = strlen($s1);\n        $len2 = strlen($s2);\n        $len3 = strlen($s3);\n        \n        if ($len1 + $len2 != $len3) {\n            return false;\n        }\n        \n        $dp = array_fill(0, $len1 + 1, false);\n        $dp[0] = true;\n        \n        for ($i = 0; $i <= $len1; $i++) {\n            for ($j = 0; $j <= $len2; $j++) {\n                $p = $i + $j - 1;\n                if ($i > 0) {\n                    $dp[$j] = ($dp[$j] && $s1[$i - 1] == $s3[$p]);\n                }\n                if ($j > 0) {\n                    $dp[$j] = $dp[$j] || ($dp[$j - 1] && $s2[$j - 1] == $s3[$p]);\n                }\n            }\n        }\n        \n        return $dp[$len2];\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isInterleave(s1: String, s2: String, s3: String): Boolean {\n        if (s1.length + s2.length != s3.length) {\n            return false\n        }\n        \n        val dp = Array(s1.length + 1) { BooleanArray(s2.length + 1) }\n        dp[0][0] = true\n        \n        for (i in 1..s1.length) {\n            dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1]\n        }\n        \n        for (j in 1..s2.length) {\n            dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1]\n        }\n        \n        for (i in 1..s1.length) {\n            for (j in 1..s2.length) {\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                           (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1])\n            }\n        }\n        \n        return dp[s1.length][s2.length]\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isInterleave(String s1, String s2, String s3) {\n    if (s1.length + s2.length != s3.length) {\n      return false;\n    }\n    \n    List<bool> dp = List.filled(s2.length + 1, false);\n\n    for (int i = 0; i <= s1.length; i++) {\n      for (int j = 0; j <= s2.length; j++) {\n        if (i == 0 && j == 0) {\n          dp[j] = true;\n        } else if (i == 0) {\n          dp[j] = dp[j - 1] && s2[j - 1] == s3[i + j - 1];\n        } else if (j == 0) {\n          dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1];\n        } else {\n          dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n      }\n    }\n\n    return dp[s2.length];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isInterleave(s1 string, s2 string, s3 string) bool {\n    if len(s1)+len(s2) != len(s3) {\n        return false\n    }\n\n    dp := make([][]bool, len(s1)+1)\n    for i := range dp {\n        dp[i] = make([]bool, len(s2)+1)\n    }\n\n    for i := 0; i <= len(s1); i++ {\n        for j := 0; j <= len(s2); j++ {\n            if i == 0 && j == 0 {\n                dp[i][j] = true\n            } else if i == 0 {\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[i+j-1]\n            } else if j == 0 {\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i+j-1]\n            } else {\n                dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]) || (dp[i][j-1] && s2[j-1] == s3[i+j-1])\n            }\n        }\n    }\n\n    return dp[len(s1)][len(s2)]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def is_interleave(s1, s2, s3)\n    m, n, l = s1.length, s2.length, s3.length\n    return false if m + n != l\n\n    dp = Array.new(m+1) { Array.new(n+1, false) }\n    dp[0][0] = true\n\n    (1..m).each do |i|\n        dp[i][0] = dp[i-1][0] && s1[i-1] == s3[i-1]\n    end\n\n    (1..n).each do |j|\n        dp[0][j] = dp[0][j-1] && s2[j-1] == s3[j-1]\n    end\n\n    (1..m).each do |i|\n        (1..n).each do |j|\n            dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]) || \n                       (dp[i][j-1] && s2[j-1] == s3[i+j-1])\n        end\n    end\n\n    dp[m][n]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isInterleave(s1: String, s2: String, s3: String): Boolean = {\n        val m = s1.length\n        val n = s2.length\n        if (m + n != s3.length) return false\n        val dp = Array.ofDim[Boolean](m + 1, n + 1)\n        dp(0)(0) = true\n        for (i <- 0 to m) {\n            for (j <- 0 to n) {\n                if (i > 0 && s1(i - 1) == s3(i + j - 1)) dp(i)(j) ||= dp(i - 1)(j)\n                if (j > 0 && s2(j - 1) == s3(i + j - 1)) dp(i)(j) ||= dp(i)(j - 1)\n            }\n        }\n        dp(m)(n)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        let len1 = s1.len();\n        let len2 = s2.len();\n        let len3 = s3.len();\n\n        if len1 + len2 != len3 {\n            return false;\n        }\n\n        let mut dp = vec![vec![false; len2 + 1]; len1 + 1];\n        dp[0][0] = true;\n\n        for i in 1..=len1 {\n            dp[i][0] = dp[i - 1][0] && s1.chars().nth(i - 1).unwrap() == s3.chars().nth(i - 1).unwrap();\n        }\n\n        for j in 1..=len2 {\n            dp[0][j] = dp[0][j - 1] && s2.chars().nth(j - 1).unwrap() == s3.chars().nth(j - 1).unwrap();\n        }\n\n        for i in 1..=len1 {\n            for j in 1..=len2 {\n                dp[i][j] = (dp[i - 1][j] && s1.chars().nth(i - 1).unwrap() == s3.chars().nth(i + j - 1).unwrap())\n                    || (dp[i][j - 1] && s2.chars().nth(j - 1).unwrap() == s3.chars().nth(i + j - 1).unwrap());\n            }\n        }\n\n        dp[len1][len2]\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given string `s3` can be formed by interleaving two other strings `s1` and `s2`. The interleaving of `s1` and `s2` means combining them in such a way that maintains the relative order of characters from both strings.\n\nWe can use dynamic programming to solve this problem efficiently. This approach involves creating a 1D array `dp` to track whether a substring of `s3` can be formed by interleaving substrings of `s1` and `s2`.\n\n# Explanation\n\n1. **Initial Checks:**\n    - If the length of `s3` is not equal to the sum of the lengths of `s1` and `s2`, return `False` immediately. This means it's impossible for `s3` to be an interleaving of `s1` and `s2` if their combined lengths don't match `s3`'s length.\n\n2. **Setting up the DP Array:**\n    - Create a DP array `dp` of size `(len(s2) + 1)` which is used to keep track of the possibility of forming `s3` using prefixes of `s1` and `s2`.\n    - Initialize `dp[0]` to `True` since an empty substring can interleave with another empty substring to form an empty string.\n\n3. **Update DP Array for `s2` Prefix:**\n    - Fill the DP array for the scenario where only `s2` is considered by checking each prefix of `s2` to see if it matches the corresponding prefix of `s3`.\n\n4. **Fill the DP Array Considering Both `s1` and `s2`:**\n    - Iterate through the characters of `s1` and `s2` and update the DP array indicating if the currently examined substrings of `s1` and `s2` can form the substring of `s3` up to the current index.\n\n5. **Return the Result:**\n    - The value at `dp[len(s2)]` will tell us if the entire `s3` can be formed by interleaving `s1` and `s2`.\n\n# Pseudocode\n\n```\nfunction isInterleave(s1, s2, s3):\n    if len(s1) + len(s2) != len(s3):\n        return False\n    \n    dp = array of (len(s2) + 1) initialized to False\n    dp[0] = True\n    \n    # Initialize dp array for prefixes of s2\n    for j from 1 to len(s2):\n        dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n    \n    # Fill dp array considering both s1 and s2\n    for i from 1 to len(s1):\n        dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n        for j from 1 to len(s2):\n            dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n    \n    return dp[len(s2)]\n```\n\nThis approach ensures that the solution runs efficiently in O(n*m) time complexity where `n` and `m` are the lengths of `s1` and `s2` respectively, while using only O(m) additional memory space, making it optimal given the problem's constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-interleaving-string"
    },
    {
        "name": "Validate Binary Search Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-validate-binary-search-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return validate(root, nullptr, nullptr);\n    }\n    \n    bool validate(TreeNode* node, TreeNode* minNode, TreeNode* maxNode) {\n        if (node == nullptr) {\n            return true;\n        }\n        \n        if ((minNode && node->val <= minNode->val) || (maxNode && node->val >= maxNode->val)) {\n            return false;\n        }\n        \n        return validate(node->left, minNode, node) && validate(node->right, node, maxNode);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValid(root, null, null);\n    }\n    \n    private boolean isValid(TreeNode node, Integer min, Integer max) {\n        if (node == null)\n            return true;\n        \n        if ((min != null && node.val <= min) || (max != null && node.val >= max))\n            return false;\n        \n        return isValid(node.left, min, node.val) && isValid(node.right, node.val, max);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n        \nclass Solution(object):\n    def isValidBST(self, root):\n        def helper(node, lower=float('-inf'), upper=float('inf')):\n            if not node:\n                return True\n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n        \n        return helper(root)\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsValidBST(TreeNode root) {\n        return IsValidBST(root, null, null);\n    }\n    \n    private bool IsValidBST(TreeNode node, TreeNode min, TreeNode max) {\n        if (node == null) return true;\n        \n        if ((min != null && node.val <= min.val) || (max != null && node.val >= max.val))\n            return false;\n        \n        return IsValidBST(node.left, min, node) && IsValidBST(node.right, node, max);\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\n    if (!root) {\n        return true;\n    }\n    \n    if (root.val <= min || root.val >= max) {\n        return false;\n    }\n    \n    return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode, right?: TreeNode) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction isValidBST(root: TreeNode | null, min: number = -Infinity, max: number = Infinity): boolean {\n    if (!root) {\n        return true;\n    }\n    \n    if (root.val <= min || root.val >= max) {\n        return false;\n    }\n    \n    return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $min\n     * @param Integer $max\n     * @return Boolean\n     */\n    function isValidBST($root, $min = null, $max = null) {\n        if ($root === null) {\n            return true;\n        }\n        \n        if (($min !== null && $root->val <= $min) || ($max !== null && $root->val >= $max)) {\n            return false;\n        }\n        \n        return $this->isValidBST($root->left, $min, $root->val) && $this->isValidBST($root->right, $root->val, $max);\n    }\n}\n\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isValidBST(root: TreeNode?): Boolean {\n        return validate(root, null, null)\n    }\n    \n    fun validate(node: TreeNode?, min: Int?, max: Int?): Boolean {\n        if (node == null) {\n            return true\n        }\n        \n        if ((min != null && node.`val` <= min) || (max != null && node.`val` >= max)) {\n            return false\n        }\n        \n        return validate(node.left, min, node.`val`) && validate(node.right, node.`val`, max)\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "// Definition for a binary tree node.\n// type TreeNode struct {\n//     Val int\n//     Left *TreeNode\n//     Right *TreeNode\n// }\n\nfunc isValidBST(root *TreeNode) bool {\n    var prev *TreeNode\n    return inorder(root, &prev)\n}\n\nfunc inorder(node *TreeNode, prev **TreeNode) bool {\n    if node == nil {\n        return true\n    }\n    \n    if !inorder(node.Left, prev) {\n        return false\n    }\n    \n    if *prev != nil && node.Val <= (*prev).Val {\n        return false\n    }\n    \n    *prev = node\n    return inorder(node.Right, prev)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef is_valid_bst(root)\n    def valid_bst_helper(node, min, max)\n        return true if node.nil?\n        \n        if (min != nil && node.val <= min) || (max != nil && node.val >= max)\n            return false\n        end\n        \n        return valid_bst_helper(node.left, min, node.val) && valid_bst_helper(node.right, node.val, max)\n    end\n    \n    valid_bst_helper(root, nil, nil)\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        fn is_valid(node: &Option<Rc<RefCell<TreeNode>>>, min: Option<i64>, max: Option<i64>) -> bool {\n            match node {\n                None => true,\n                Some(n) => {\n                    let val = n.borrow().val as i64;\n                    if let Some(min_val) = min {\n                        if val <= min_val {\n                            return false;\n                        }\n                    }\n                    if let Some(max_val) = max {\n                        if val >= max_val {\n                            return false;\n                        }\n                    }\n                    is_valid(&n.borrow().left, min, Some(val)) && is_valid(&n.borrow().right, Some(val), max)\n                }\n            }\n        }\n        is_valid(&root, None, None)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll use a recursive approach to verify that each node in the binary tree satisfies the conditions of a Binary Search Tree (BST).\n\n### # Explanation\n1. **Define the Problem**:\n   - We need to determine if the given binary tree is a valid BST.\n   - A BST must satisfy:\n     - All nodes in the left subtree are less than the current node's value.\n     - All nodes in the right subtree are greater than the current node's value.\n     - Both subtrees must also be BSTs.\n\n2. **Recursive Approach**:\n   - We'll employ a helper function that takes a node and boundary values (lower and upper) to determine valid ranges for node values.\n   - Initially, for the root, the boundaries are negative and positive infinity (`-inf` and `inf`).\n   - For each node, check if the node value falls within the valid range:\n     - If it does, recursively check the subtrees with updated boundaries:\n       - For the left subtree, update the upper boundary to the current node's value.\n       - For the right subtree, update the lower boundary to the current node's value.\n   - If any node violates the BST properties, return `False`.\n   - If all nodes comply, return `True`.\n\n### # Pseudocode\n```\nfunction isValidBST(root):\n    function helper(node, lower, upper):\n        if node is null:\n            return True\n        \n        val = node.val\n        if val <= lower or val >= upper:\n            return False\n        \n        if not helper(node.right, val, upper):\n            return False\n        \n        if not helper(node.left, lower, val):\n            return False\n        \n        return True\n    \n    return helper(root, -infinity, +infinity)\n```\n\n### Step-by-Step\n1. **Base Case**:\n   - If the `node` is `null`, return `True` because an empty tree is a valid BST.\n2. **Value Check**:\n   - Check if the current `node` value falls within the valid range (`lower < node.val < upper`).\n3. **Recursive Checks**:\n   - Recursively validate the right subtree with the updated lower bound (`lower = node.val`).\n   - Recursively validate the left subtree with the updated upper bound (`upper = node.val`).\n4. **Return Result**:\n   - Combine the results of the subtree checks. If all are valid, the entire tree is a valid BST; otherwise, it is not.\n\nThe proposed solution efficiently checks the BST properties by leveraging recursion with boundary conditions. This guarantees that every node adheres to the BST rules.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-validate-binary-search-tree"
    },
    {
        "name": "Recover Binary Search Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-recover-binary-search-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/*\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x): val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        TreeNode *prev = NULL, *first = NULL, *second = NULL;\n        inorder(root, prev, first, second);\n        swap(first->val, second->val);\n    }\n    \n    void inorder(TreeNode* root, TreeNode*& prev, TreeNode*& first, TreeNode*& second) {\n        if(root == NULL) return;\n        \n        inorder(root->left, prev, first, second);\n        \n        if(prev != NULL && prev->val > root->val) {\n            if(first == NULL) first = prev;\n            second = root;\n        }\n        \n        prev = root;\n        \n        inorder(root->right, prev, first, second);\n    }\n};\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n\nclass Solution(object):\n    def recoverTree(self, root):\n        first = None\n        second = None\n        prev = TreeNode(float('-inf'))\n        stack = []\n        while stack or root:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            if first is None and prev.val >= root.val:\n                first = prev\n            if first is not None and prev.val >= root.val:\n                second = root\n            prev = root\n            root = root.right\n        first.val, second.val = second.val, first.val\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nvoid recoverTree(struct TreeNode* root){\n    struct TreeNode *first = NULL, *second = NULL, *prev = NULL, *temp = NULL;\n    struct TreeNode* current = root;\n    \n    while(current != NULL){\n        if(current->left == NULL){\n            if(prev != NULL && prev->val > current->val){\n                if(first == NULL){\n                    first = prev;\n                    second = current;\n                }\n                else{\n                    second = current;\n                }\n            }\n            prev = current;\n            current = current->right;\n        }\n        else{\n            temp = current->left;\n            while(temp->right != NULL && temp->right != current){\n                temp = temp->right;\n            }\n            \n            if(temp->right == NULL){\n                temp->right = current;\n                current = current->left;\n            }\n            else{\n                temp->right = NULL;\n                if(prev->val > current->val){\n                    if(first == NULL){\n                        first = prev;\n                        second = current;\n                    }\n                    else{\n                        second = current;\n                    }\n                }\n                prev = current;\n                current = current->right;\n            }\n        }\n    }\n    \n    int tempVal = first->val;\n    first->val = second->val;\n    second->val = tempVal;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void RecoverTree(TreeNode root) {\n        TreeNode x = null, y = null, pred = null;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n\n        while (stack.Count > 0 || root != null) {\n            while (root != null) {\n                stack.Push(root);\n                root = root.left;\n            }\n            \n            root = stack.Pop();\n            \n            if (pred != null && root.val < pred.val) {\n                y = root;\n                if (x == null) {\n                    x = pred;\n                } else {\n                    break;\n                }\n            }\n            pred = root;\n            root = root.right;\n        }\n        \n        int temp = x.val;\n        x.val = y.val;\n        y.val = temp;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\n\nvar recoverTree = function(root) {\n    let first = null;\n    let second = null;\n    let prev = new TreeNode(-Infinity);\n    \n    const inorder = (node) => {\n        if (node === null) return;\n        \n        inorder(node.left);\n        \n        if (first === null && prev.val >= node.val) {\n            first = prev;\n        }\n        \n        if (first !== null && prev.val >= node.val) {\n            second = node;\n        }\n        \n        prev = node;\n        \n        inorder(node.right);\n    };\n    \n    inorder(root);\n    \n    let temp = first.val;\n    first.val = second.val;\n    second.val = temp;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction recoverTree(root: TreeNode | null): void {\n    let prev = null;\n    let first: TreeNode | null = null;\n    let second: TreeNode | null = null;\n    \n    function inorder(node: TreeNode | null): void {\n        if (!node) return;\n        \n        inorder(node.left);\n        \n        if (prev && prev.val >= node.val) {\n            if (!first) {\n                first = prev;\n            }\n            second = node;\n        }\n        \n        prev = node;\n        \n        inorder(node.right);\n    }\n    \n    inorder(root);\n    \n    if (first && second) {\n        const temp = first.val;\n        first.val = second.val;\n        second.val = temp;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n */\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @return NULL\n     */\n    function recoverTree($root) {\n        $first = null;\n        $second = null;\n        $prev = new TreeNode(-INF);\n        \n        $this->inOrderTraversal($root, $prev, $first, $second);\n        \n        // Swap the values of the two nodes\n        $temp = $first->val;\n        $first->val = $second->val;\n        $second->val = $temp;\n    }\n    \n    function inOrderTraversal($root, &$prev, &$first, &$second) {\n        if ($root == null) return;\n        \n        $this->inOrderTraversal($root->left, $prev, $first, $second);\n        \n        if ($first == null && $prev->val >= $root->val) {\n            $first = $prev;\n        }\n        \n        if ($first != null && $prev->val >= $root->val) {\n            $second = $root;\n        }\n        \n        $prev = $root;\n        \n        $this->inOrderTraversal($root->right, $prev, $first, $second);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func recoverTree(_ root: TreeNode?) {\n        var prev: TreeNode? = nil\n        var first: TreeNode? = nil\n        var second: TreeNode? = nil\n        traverse(root, &prev, &first, &second)\n        if let firstNode = first, let secondNode = second {\n            let temp = firstNode.val\n            firstNode.val = secondNode.val\n            secondNode.val = temp\n        }\n    }\n    \n    func traverse(_ node: TreeNode?, _ prev: inout TreeNode?, _ first: inout TreeNode?, _ second: inout TreeNode?) {\n        if node == nil { return }\n        \n        traverse(node!.left, &prev, &first, &second)\n        \n        if let previous = prev {\n            if previous.val > node!.val {\n                if first == nil {\n                    first = previous\n                }\n                second = node\n            }\n        }\n        prev = node\n        \n        traverse(node!.right, &prev, &first, &second)\n    }\n}\n\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc recoverTree(root *TreeNode) {\n    var first, second, pre *TreeNode\n    var traverse func(node *TreeNode)\n    \n    traverse = func(node *TreeNode) {\n        if node == nil {\n            return\n        }\n        \n        traverse(node.Left)\n        \n        if pre != nil && pre.Val > node.Val {\n            if first == nil {\n                first = pre\n            }\n            second = node\n        }\n        \n        pre = node\n        \n        traverse(node.Right)\n    }\n    \n    traverse(root)\n    \n    first.Val, second.Val = second.Val, first.Val\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify the two nodes in a binary search tree (BST) that were swapped by mistake and restore the BST by swapping them back to their correct positions. The goal is to accomplish this without altering the tree\u2019s structure. Here\u2019s an explanation and pseudocode for how to solve this challenge:\n\n# Explanation\n1. **Understanding the Problem**: Given a BST where two nodes are swapped, we need to identify and swap them back to fix the BST. In a valid BST, an in-order traversal produces a sorted array.\n\n2. **Identify Misplaced Nodes**: By performing an in-order traversal, we can identify the two nodes that are out of order. The first misplaced node is where the current node's value is smaller than the previous node's value. The second misplaced node is where the current node\u2019s value is smaller than the previous node\u2019s value after the first misplaced node has been found.\n\n3. **Swapping Nodes**: Once both nodes are identified, simply swap their values to restore the BST.\n\nThe in-order traversal can be managed without extra space by using an iterative approach with a stack or by using the Morris Traversal for O(1) space complexity.\n\n# Pseudocode\n```  \n# Pseudocode\n\n# Define the TreeNode class if not already defined\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def recoverTree(root):\n        # Initialize variables\n        first = None\n        second = None\n        prev = TreeNode(float('-inf'))\n        stack = []\n\n        # Iterative in-order traversal\n        while stack or root:\n            # Travel to the leftmost node\n            while root:\n                stack.append(root)\n                root = root.left\n            # Process the node\n            root = stack.pop()\n\n            # Identify the misplaced nodes\n            if first is None and prev.val >= root.val:\n                first = prev\n            if first is not None and prev.val >= root.val:\n                second = root\n\n            # Move to the right node\n            prev = root\n            root = root.right\n\n        # Swap the misplaced nodes to recover the BST\n        first.val, second.val = second.val, first.val\n```\n\nThis pseudocode outlines a method for recovering a BST, which includes traversing the tree to identify the misplaced nodes and then swapping them to restore the tree\u2019s order. Use an iterative in-order traversal to achieve O(n) time complexity and, if needed, Morris Traversal for O(1) extra space complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-recover-binary-search-tree"
    },
    {
        "name": "Same Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-same-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        }\n        \n        if (p == nullptr || q == nullptr || p->val != q->val) {\n            return false;\n        }\n        \n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "public class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def isSameTree(self, p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\n    if (p == NULL && q == NULL) {\n        return true;\n    }\n    if (p == NULL || q == NULL) {\n        return false;\n    }\n    if (p->val != q->val) {\n        return false;\n    }\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\nvar isSameTree = function(p, q) {\n    if (!p && !q) {\n        return true;\n    }\n    if (!p || !q || p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (!p && !q) {\n        return true;\n    }\n    if (!p || !q || p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n  "
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode(this.val, [this.left = null, this.right = null]);\n */\n\nclass Solution {\n  bool isSameTree(TreeNode? p, TreeNode? q) {\n    if (p == null && q == null) {\n      return true;\n    }\n    if (p == null || q == null) {\n      return false;\n    }\n    if (p.val != q.val) {\n      return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p == nil && q == nil {\n        return true\n    }\n    if p == nil || q == nil {\n        return false\n    }\n    if p.Val != q.Val {\n        return false\n    }\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#     end\n# end\n\ndef is_same_tree(p, q)\n    return true if p.nil? && q.nil?\n    return false if p.nil? || q.nil?\n    \n    p.val == q.val && is_same_tree(p.left, q.left) && is_same_tree(p.right, q.right)\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if two binary trees are identical in terms of both structure and node values. We can achieve this by recursively comparing corresponding nodes in both trees. If all corresponding nodes are equal and their subtrees are also identical, then the two trees are considered identical.\n\n# Explanation\n\n1. **Base Cases**:\n    - If both nodes (`p` and `q`) are `None`, the trees at this position are identical. Return `True`.\n    - If only one of the nodes is `None`, the trees are not identical. Return `False`.\n\n2. **Node Comparison**:\n    - Compare the values of the current nodes of both trees. If they do not match, the trees are not identical. Return `False`.\n\n3. **Recursive Comparison**:\n    - Recursively check the left and right subtrees of the current nodes. If both left and right subtrees are identical, the trees are identical at this node.\n\n# Pseudocode\n\n```\nfunction isSameTree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    \n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n```\n\nThis pseudocode precisely follows the recursive approach to check if two binary trees are identical. Each call to `isSameTree` ensures that the current set of nodes and their corresponding subtrees are the same. The process continues until all nodes are checked or a discrepancy is found.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-same-tree"
    },
    {
        "name": "Binary Tree Level Order Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-level-order-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (root == nullptr) {\n            return result;\n        }\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> level;\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode* curr = q.front();\n                q.pop();\n                level.push_back(curr->val);\n                \n                if (curr->left) {\n                    q.push(curr->left);\n                }\n                if (curr->right) {\n                    q.push(curr->right);\n                }\n            }\n            \n            result.push_back(level);\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        if (root == null) {\n            return result;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> levelValues = new ArrayList<>();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode currentNode = queue.poll();\n                levelValues.add(currentNode.val);\n                \n                if (currentNode.left != null) {\n                    queue.offer(currentNode.left);\n                }\n                \n                if (currentNode.right != null) {\n                    queue.offer(currentNode.right);\n                }\n            }\n            \n            result.add(levelValues);\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def levelOrder(self, root):\n        if not root:\n            return []\n        \n        result = []\n        queue = [root]\n        \n        while queue:\n            level_size = len(queue)\n            level_values = []\n            \n            for _ in range(level_size):\n                node = queue.pop(0)\n                level_values.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level_values)\n        \n        return result\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\nvar levelOrder = function(root) {\n    if (!root) return [];\n    \n    const result = [];\n    const queue = [root];\n    \n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n        \n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevel.push(node.val);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        result.push(currentLevel);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction levelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    \n    const result: number[][] = [];\n    const queue: TreeNode[] = [root];\n    \n    while (queue.length > 0) {\n        const currentLevelVals: number[] = [];\n        const size = queue.length;\n        \n        for (let i = 0; i < size; i++) {\n            const node = queue.shift();\n            if (node) {\n                currentLevelVals.push(node.val);\n                if (node.left) queue.push(node.left);\n                if (node.right) queue.push(node.right);\n            }\n        }\n        \n        result.push(currentLevelVals);\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func levelOrder(_ root: TreeNode?) -> [[Int]] {\n        guard let root = root else { return [] }\n        \n        var result: [[Int]] = []\n        var queue: [TreeNode] = [root]\n        \n        while !queue.isEmpty {\n            var currentLevelValues: [Int] = []\n            for _ in 0..<queue.count {\n                let node = queue.removeFirst()\n                currentLevelValues.append(node.val)\n                if let left = node.left { queue.append(left) }\n                if let right = node.right { queue.append(right) }\n            }\n            result.append(currentLevelValues)\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc levelOrder(root *TreeNode) [][]int {\n    result := [][]int{}\n    if root == nil {\n        return result\n    }\n    \n    queue := []*TreeNode{root}\n    \n    for len(queue) > 0 {\n        level := []int{}\n        nextLevelNodes := []*TreeNode{}\n        \n        for _, node := range queue {\n            level = append(level, node.Val)\n            if node.Left != nil {\n                nextLevelNodes = append(nextLevelNodes, node.Left)\n            }\n            if node.Right != nil {\n                nextLevelNodes = append(nextLevelNodes, node.Right)\n            }\n        }\n        \n        result = append(result, level)\n        queue = nextLevelNodes\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n# end\n\ndef level_order(root)\n    return [] if root.nil?\n    \n    result = []\n    queue = [root]\n    \n    until queue.empty?\n        level = []\n        size = queue.size\n        \n        size.times do\n            node = queue.shift\n            level << node.val\n            \n            queue << node.left if node.left\n            queue << node.right if node.right\n        end\n        \n        result << level\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null)\n */\n\nobject Solution {\n    def levelOrder(root: TreeNode): List[List[Int]] = {\n        import scala.collection.mutable.Queue\n        var result = List[List[Int]]()\n        if (root == null) return result\n        val queue = Queue[TreeNode](root)\n        while (queue.nonEmpty) {\n            val currLevel = queue.dequeueAll(_ => true)\n            val levelValues = currLevel.map(_.value)\n            result = result :+ levelValues.toList\n            for (node <- currLevel) {\n                if (node.left != null) queue.enqueue(node.left)\n                if (node.right != null) queue.enqueue(node.right)\n            }\n        }\n        result\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//     pub val: i32,\n//     pub left: Option<Rc<RefCell<TreeNode>>>,\n//     pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        \n        if let Some(node) = root {\n            let mut queue = std::collections::VecDeque::new();\n            queue.push_back(node);\n            \n            while !queue.is_empty() {\n                let mut level_values = Vec::new();\n                let level_size = queue.len();\n                \n                for _ in 0..level_size {\n                    if let Some(curr) = queue.pop_front() {\n                        let curr_node = curr.borrow();\n                        level_values.push(curr_node.val);\n                        \n                        if let Some(left) = &curr_node.left {\n                            queue.push_back(left.clone());\n                        }\n                        \n                        if let Some(right) = &curr_node.right {\n                            queue.push_back(right.clone());\n                        }\n                    }\n                }\n                \n                result.push(level_values);\n            }\n        }\n        \n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform a level order traversal (also known as a breadth-first traversal) of a binary tree. In level order traversal, we visit all nodes level by level from left to right. Below is an explanation and the pseudocode for this approach. \n\n# Explanation\n1. **Initialization:**\n   - Check if the tree is empty. If it is, return an empty list.\n   - Initialize an empty list `result` to hold the values of nodes level by level.\n   - Use a queue to facilitate the breadth-first traversal, starting with the root node.\n\n2. **Traversal:**\n   - While there are nodes in the queue, do the following:\n     - Determine the number of nodes on the current level (`level_size`).\n     - Initialize an empty list `level_values` to store the values of nodes on this level.\n     - For each node on the current level:\n       - Pop the node from the front of the queue.\n       - Append its value to `level_values`.\n       - If the node has a left child, append the left child to the queue.\n       - If the node has a right child, append the right child to the queue.\n     - After processing all nodes on the current level, append `level_values` to `result`.\n\n3. **Return the result:**\n   - Once all levels have been processed, return the `result` list.\n\n# Pseudocode\n```plaintext\nfunction levelOrder(root)\n    if root is null\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue is not empty\n        level_size = length(queue)\n        level_values = []\n        \n        for i from 0 to level_size - 1\n            node = queue.pop(0)\n            level_values.append(node.val)\n            \n            if node.left is not null\n                queue.append(node.left)\n            if node.right is not null\n                queue.append(node.right)\n\n        result.append(level_values)\n\n    return result\n```\n\nThis pseudocode captures the breadth-first traversal by using a queue to process each level of the tree one at a time. Each level's values are collected and appended to the result list. The cycle continues until all levels of the tree have been traversed.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-level-order-traversal"
    },
    {
        "name": "Distinct Subsequences",
        "site": "LeetCode",
        "href": "/solution/LeetCode-distinct-subsequences",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int m = s.length(), n = t.length();\n        vector<vector<unsigned int>> dp(n + 1, vector<unsigned int>(m + 1, 0));\n        \n        for (int j = 0; j <= m; ++j) {\n            dp[0][j] = 1;\n        }\n        \n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                if (t[i - 1] == s[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];\n                } else {\n                    dp[i][j] = dp[i][j - 1];\n                }\n            }\n        }\n        \n        return dp[n][m];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numDistinct(String s, String t) {\n        int m = s.length();\n        int n = t.length();\n        \n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = 1;\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] += dp[i - 1][j - 1];\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numDistinct(self, s, t):\n        dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\n        for i in range(len(s) + 1):\n            dp[0][i] = 1\n        for i in range(1, len(t) + 1):\n            for j in range(1, len(s) + 1):\n                if t[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        return dp[-1][-1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int numDistinct(char* s, char* t) {\n    int m = strlen(s);\n    int n = strlen(t);\n    unsigned int dp[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        dp[0][i] = 0;\n    }\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n\\"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumDistinct(string s, string t) {\n        int m = s.Length;\n        int n = t.Length;\n\n        int[,] dp = new int[m + 1, n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            dp[i, 0] = 1;\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i, j] = dp[i - 1, j];\n                if (s[i - 1] == t[j - 1]) {\n                    dp[i, j] += dp[i - 1, j - 1];\n                }\n            }\n        }\n\n        return dp[m, n];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    const dp = Array(t.length + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= s.length; i++) {\n        for (let j = t.length; j >= 1; j--) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[j] += dp[j - 1];\n            }\n        }\n    }\n    \n    return dp[t.length];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numDistinct(s: string, t: string): number {\n    const dp: number[][] = Array.from({ length: t.length + 1 }, () => Array(s.length + 1).fill(0));\n    for (let i = 0; i <= s.length; i++) {\n        dp[0][i] = 1;\n    }\n    for (let i = 1; i <= t.length; i++) {\n        for (let j = 1; j <= s.length; j++) {\n            if (t[i - 1] === s[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    return dp[t.length][s.length];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Integer\n     */\n    function numDistinct($s, $t) {\n        $m = strlen($t);\n        $n = strlen($s);\n        $dp = array_fill(0, $m + 1, 0);\n        $dp[0] = 1;\n        \n        for ($i = 1; $i <= $n; $i++) {\n            for ($j = $m; $j > 0; $j--) {\n                if ($t[$j - 1] == $s[$i - 1]) {\n                    $dp[$j] += $dp[$j-1];\n                }\n            }\n        }\n        \n        return $dp[$m];\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numDistinct(s: String, t: String): Int {\n\n        val dp = Array(t.length + 1) { IntArray(s.length + 1) }\n        for (i in 0..s.length) dp[0][i] = 1\n\n        for (i in 1..t.length) {\n            for (j in 1..s.length) {\n                dp[i][j] = dp[i][j - 1] + if (t[i - 1] == s[j - 1]) dp[i - 1][j - 1] else 0\n            }\n        }\n\n        return dp[t.length][s.length]\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numDistinct(String s, String t) {\n    int m = s.length;\n    int n = t.length;\n    \n    List<List<int>> dp = List.generate(m + 1, (_) => List.filled(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n      dp[i][0] = 1;\n    }\n    \n    for (int i = 1; i <= m; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (s[i - 1] == t[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n        } else {\n          dp[i][j] = dp[i - 1][j];\n        }\n      }\n    }\n    \n    return dp[m][n];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numDistinct(s string, t string) int {\n\tdp := make([][]int, len(t)+1)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, len(s)+1)\n\t}\n\n\tfor j := range dp[0] {\n\t\tdp[0][j] = 1\n\t}\n\n\tfor i := 1; i <= len(t); i++ {\n\t\tfor j := 1; j <= len(s); j++ {\n\t\t\tif s[j-1] == t[i-1] {\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + dp[i][j-1]\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i][j-1]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[len(t)][len(s)]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {String} t\n# @return {Integer}\ndef num_distinct(s, t)\n    m, n = s.length, t.length\n    dp = Array.new(m+1) { Array.new(n+1, 0) }\n    \n    (0..m).each { |i| dp[i][0] = 1 }\n    \n    (1..m).each do |i|\n        (1..n).each do |j|\n            if s[i-1] == t[j-1]\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n            else\n                dp[i][j] = dp[i-1][j]\n            end\n        end\n    end\n    \n    return dp[m][n]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def numDistinct(s: String, t: String): Int = {\n        val dp = Array.fill(t.length + 1)(Array.fill(s.length + 1)(0))\n        for (j <- 0 to s.length) {\n            dp(0)(j) = 1\n        }\n        \n        for (i <- 1 to t.length; j <- 1 to s.length) {\n            if (t(i - 1) == s(j - 1)) {\n                dp(i)(j) = dp(i - 1)(j - 1) + dp(i)(j - 1)\n            } else {\n                dp(i)(j) = dp(i)(j - 1)\n            }\n        }\n        \n        dp(t.length)(s.length)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn num_distinct(s: String, t: String) -> i32 {\n        let s = s.chars().collect::<Vec<char>>();\n        let t = t.chars().collect::<Vec<char>>();\n        \n        let m = s.len();\n        let n = t.len();\n        \n        let mut dp = vec![vec![0; n + 1]; m + 1];\n        \n        for i in 0..=m {\n            dp[i][0] = 1;\n        }\n        \n        for i in 1..=m {\n            for j in 1..=n {\n                if s[i - 1] == t[j - 1] {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        dp[m][n]\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (num-distinct s t)\n  (-> string? string? exact-integer?)\n  (define (helper sIdx tIdx)\n    (cond\n      ((= tIdx (string-length t)) 1)\n      ((= sIdx (string-length s)) 0)\n      ((char=? (string-ref s sIdx) (string-ref t tIdx))\n       (+ (helper (add1 sIdx) (add1 tIdx))\n          (helper (add1 sIdx) tIdx)))\n      (else\n       (helper (add1 sIdx) tIdx))))\n  (helper 0 0)\n  )\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to use dynamic programming to count the number of distinct subsequences of the string `s` that can form the string `t`.\n\n### # Explanation\n\n1. **Create a 2D DP Array**: Initialize a 2D DP array `dp` where `dp[i][j]` represents the number of distinct subsequences of `s[:j]` (the first `j` characters of `s`) that equals `t[:i]` (the first `i` characters of `t`).\n\n2. **Initialization**:\n   - Set `dp[0][j]` to 1 for all `j`, which means an empty string `t` is a subsequence of any prefix of `s` exactly once.\n   - Set `dp[i][0]` to 0 for all `i > 0`, which means a non-empty string `t` cannot be a subsequence of an empty string `s`.\n\n3. **Filling the DP Table**:\n   - Iterate through `t` and `s` using two nested loops.\n   - If the characters `t[i-1]` and `s[j-1]` match, set `dp[i][j] = dp[i-1][j-1] + dp[i][j-1]`. This represents:\n     - Using the current character of `s` to match the current character of `t`.\n     - Not using the current character of `s`.\n   - If the characters do not match, set `dp[i][j] = dp[i][j-1]`. This represents:\n     - Skipping the current character of `s`.\n\n4. **Result**: The result will be found in `dp[len(t)][len(s)]`.\n\n### # Pseudocode\n\n```text\nfunction numDistinct(s, t):\n    let dp be a 2D array of size (len(t) + 1) x (len(s) + 1) filled with zeros\n    \n    # Initialize first row\n    for j from 0 to len(s):\n        dp[0][j] = 1\n    \n    # Fill the DP table\n    for i from 1 to len(t):\n        for j from 1 to len(s):\n            if t[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n    \n    # Return the result\n    return dp[len(t)][len(s)]\n```\n\nIn essence, this solution dynamically builds up the number of ways to form `t` using prefixes of `s`, by considering either matching the current characters or skipping them where necessary.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-distinct-subsequences"
    },
    {
        "name": "Best Time To Buy And Sell Stock Iii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-best-time-to-buy-and-sell-stock-iii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0;\n        \n        for(int price : prices) {\n            buy1 = max(buy1, -price);\n            sell1 = max(sell1, buy1 + price);\n            buy2 = max(buy2, sell1 - price);\n            sell2 = max(sell2, buy2 + price);\n        }\n        \n        return sell2;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int buy1 = Integer.MIN_VALUE;\n        int buy2 = Integer.MIN_VALUE;\n        int sell1 = 0;\n        int sell2 = 0;\n        \n        for (int price : prices) {\n            buy1 = Math.max(buy1, -price);\n            sell1 = Math.max(sell1, buy1 + price);\n            buy2 = Math.max(buy2, sell1 - price);\n            sell2 = Math.max(sell2, buy2 + price);\n        }\n        \n        return sell2;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxProfit(self, prices):\n        if len(prices) < 2:\n            return 0\n        \n        first_buy = float('-inf')\n        first_sell = 0\n        second_buy = float('-inf')\n        second_sell = 0\n        \n        for price in prices:\n            first_buy = max(first_buy, -price)\n            first_sell = max(first_sell, first_buy + price)\n            second_buy = max(second_buy, first_sell - price)\n            second_sell = max(second_sell, second_buy + price)\n        \n        return second_sell"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxProfit(int* prices, int pricesSize) {\n    int buy1 = INT_MIN, sell1 = 0;\n    int buy2 = INT_MIN, sell2 = 0;\n    \n    for (int i = 0; i < pricesSize; i++) {\n        buy1 = fmax(buy1, -prices[i]);\n        sell1 = fmax(sell1, buy1 + prices[i]);\n        buy2 = fmax(buy2, sell1 - prices[i]);\n        sell2 = fmax(sell2, buy2 + prices[i]);\n    }\n    \n    return sell2;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        int n = prices.Length;\n        if (n == 0) return 0;\n        \n        int firstBuy = Int32.MinValue;\n        int firstSell = 0;\n        int secondBuy = Int32.MinValue;\n        int secondSell = 0;\n        \n        for (int i = 0; i < n; i++) {\n            firstBuy = Math.Max(firstBuy, -prices[i]);\n            firstSell = Math.Max(firstSell, firstBuy + prices[i]);\n            secondBuy = Math.Max(secondBuy, firstSell - prices[i]);\n            secondSell = Math.Max(secondSell, secondBuy + prices[i]);\n        }\n        \n        return secondSell;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let firstBuy = Infinity, secondBuy = Infinity;\n    let firstSell = 0, secondSell = 0;\n    \n    for (let price of prices) {\n        firstBuy = Math.min(firstBuy, price);\n        firstSell = Math.max(firstSell, price - firstBuy);\n        secondBuy = Math.min(secondBuy, price - firstSell);\n        secondSell = Math.max(secondSell, price - secondBuy);\n    }\n    \n    return secondSell;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxProfit(prices: number[]): number {\n    let buy1 = Infinity, buy2 = Infinity;\n    let sell1 = 0, sell2 = 0;\n    \n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        sell1 = Math.max(sell1, price - buy1);\n        buy2 = Math.min(buy2, price - sell1);\n        sell2 = Math.max(sell2, price - buy2);\n    }\n    \n    return sell2;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        $n = count($prices);\n        $buy1 = $buy2 = PHP_INT_MAX;\n        $sell1 = $sell2 = 0;\n        \n        for ($i = 0; $i < $n; $i++) {\n            $buy1 = min($buy1, $prices[$i]);\n            $sell1 = max($sell1, $prices[$i] - $buy1);\n            $buy2 = min($buy2, $prices[$i] - $sell1);\n            $sell2 = max($sell2, $prices[$i] - $buy2);\n        }\n        \n        return $sell2;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        var buy1 = Int.min\n        var buy2 = Int.min\n        var sell1 = 0\n        var sell2 = 0\n        \n        for price in prices {\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, buy1 + price)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, buy2 + price)\n        }\n        \n        return sell2\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        var buy1 = Int.MIN_VALUE\n        var sell1 = 0\n        var buy2 = Int.MIN_VALUE\n        var sell2 = 0\n        for (price in prices) {\n            buy1 = maxOf(buy1, -price)\n            sell1 = maxOf(sell1, buy1 + price)\n            buy2 = maxOf(buy2, sell1 - price)\n            sell2 = maxOf(sell2, buy2 + price)\n        }\n        return sell2\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maxProfit(List<int> prices) {\n    if (prices.isEmpty) {\n      return 0;\n    }\n    \n    int n = prices.length;\n    int buy1 = -prices[0], sell1 = 0;\n    int buy2 = -prices[0], sell2 = 0;\n    \n    for (int i = 1; i < n; i++) {\n      buy1 = buy1 > -prices[i] ? buy1 : -prices[i];\n      sell1 = sell1 > buy1 + prices[i] ? sell1 : buy1 + prices[i];\n      buy2 = buy2 > sell1 - prices[i] ? buy2 : sell1 - prices[i];\n      sell2 = sell2 > buy2 + prices[i] ? sell2 : buy2 + prices[i];\n    }\n    \n    return sell2;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxProfit(prices []int) int {\n    n := len(prices)\n    if n == 0 {\n        return 0\n    }\n\n    K := 2\n    dp := make([][]int, K+1)\n    for i := 0; i <= K; i++ {\n        dp[i] = make([]int, n)\n    }\n\n    for k := 1; k <= K; k++ {\n        maxPrev := -prices[0]\n        for i := 1; i < n; i++ {\n            dp[k][i] = max(dp[k][i-1], prices[i]+maxPrev)\n            maxPrev = max(maxPrev, dp[k-1][i]-prices[i])\n        }\n    }\n\n    return dp[K][n-1]\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        val n = prices.length\n        var buy1 = Int.MaxValue\n        var sell1 = 0\n        var buy2 = Int.MaxValue\n        var sell2 = 0\n        for (i <- 0 until n) {\n            buy1 = buy1.min(prices(i))\n            sell1 = sell1.max(prices(i) - buy1)\n            buy2 = buy2.min(prices(i) - sell1)\n            sell2 = sell2.max(prices(i) - buy2)\n        }\n        sell2\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut buy1 = i32::MAX;\n        let mut buy2 = i32::MAX;\n        let mut sell1 = 0;\n        let mut sell2 = 0;\n        \n        for price in prices {\n            buy1 = buy1.min(price);\n            sell1 = sell1.max(price - buy1);\n            buy2 = buy2.min(price - sell1);\n            sell2 = sell2.max(price - buy2);\n        }\n        \n        sell2\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a dynamic programming approach to keep track of the four essential states:\n\n1. `first_buy`: The maximum profit after the first buy.\n2. `first_sell`: The maximum profit after the first sell.\n3. `second_buy`: The maximum profit after the second buy.\n4. `second_sell`: The maximum profit after the second sell.\n\nThese states are updated as we iterate through the list of stock prices. The final desired result is the value of `second_sell`.\n\n# Explanation\n\nIn this problem, we aim to maximize our profit by performing at most two transactions. To achieve this:\n\n1. We maintain four variables:\n   - `first_buy`: Maximum negative profit after the first buy (to minimize cost).\n   - `first_sell`: Maximum profit after the first sell.\n   - `second_buy`: Maximum profit after the second buy (accounting for the cost subtracted from first sell).\n   - `second_sell`: Maximum profit after the second sell.\n\n2. We iterate through the price list and update these variables to reflect the maximal profit at each stage:\n   - Update `first_buy` by considering the maximum of the previous `first_buy` and the negative of the current price (since buying reduces profit).\n   - Update `first_sell` by considering the maximum of the previous `first_sell` and the sum of `first_buy` and the current price.\n   - Update `second_buy` by considering the maximum of the previous `second_buy` and the difference between `first_sell` and the current price.\n   - Update `second_sell` by considering the maximum of the previous `second_sell` and the sum of `second_buy` and the current price.\n\n3. Finally, the answer is the value of `second_sell`.\n\n# Pseudocode\n\n```\nfunction maxProfit(prices):\n    if length of prices < 2:\n        return 0\n    \n    first_buy = -infinity\n    first_sell = 0\n    second_buy = -infinity\n    second_sell = 0\n    \n    for price in prices:\n        first_buy = max(first_buy, -price)\n        first_sell = max(first_sell, first_buy + price)\n        second_buy = max(second_buy, first_sell - price)\n        second_sell = max(second_sell, second_buy + price)\n    \n    return second_sell\n```\n\nIn this pseudocode, we initiate the four variables to track our state, iterate through the price list, and finally return the highest profit after two transactions. This approach ensures we never engage in multiple transactions simultaneously while adhering to the problem constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-best-time-to-buy-and-sell-stock-iii"
    },
    {
        "name": "Best Time To Buy And Sell Stock Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-best-time-to-buy-and-sell-stock-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int maxProfit = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            if (prices[i] > prices[i - 1]) {\n                maxProfit += prices[i] - prices[i - 1];\n            }\n        }\n        return maxProfit;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int maxProfit = 0;\n        \n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1]) {\n                maxProfit += prices[i] - prices[i - 1];\n            }\n        }\n        \n        return maxProfit;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        total_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                total_profit += prices[i] - prices[i - 1]\n        return total_profit"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxProfit(int* prices, int pricesSize) {\n    int profit = 0;\n    \n    for (int i = 1; i < pricesSize; i++) {\n        if (prices[i] > prices[i - 1]) {\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n    \n    return profit;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        int maxProfit = 0;\n        \n        for (int i = 1; i < prices.Length; i++) {\n            if (prices[i] > prices[i - 1]) {\n                maxProfit += prices[i] - prices[i - 1];\n            }\n        }\n        \n        return maxProfit;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = function(prices) {\n    let totalProfit = 0;\n    \n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            totalProfit += prices[i] - prices[i - 1];\n        }\n    }\n    \n    return totalProfit;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxProfit(prices: number[]): number {\n    let profit = 0;\n    \n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n    \n    return profit;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        $profit = 0;\n        for ($i = 1; $i < count($prices); $i++) {\n            if ($prices[$i] > $prices[$i - 1]) {\n                $profit += $prices[$i] - $prices[$i - 1];\n            }\n        }\n        return $profit;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        var maxProfit = 0\n        \n        for i in 1..<prices.count {\n            if prices[i] > prices[i - 1] {\n                maxProfit += prices[i] - prices[i - 1]\n            }\n        }\n        \n        return maxProfit\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        var totalProfit = 0\n        for (i in 1 until prices.size) {\n            if (prices[i] > prices[i - 1]) {\n                totalProfit += prices[i] - prices[i - 1]\n            }\n        }\n        return totalProfit\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maxProfit(List<int> prices) {\n    int maxProfit = 0;\n    \n    for (int i = 1; i < prices.length; i++) {\n      if (prices[i] > prices[i - 1]) {\n        maxProfit += prices[i] - prices[i - 1];\n      }\n    }\n    \n    return maxProfit;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxProfit(prices []int) int {\n    maxProfit := 0\n    \n    for i := 1; i < len(prices); i++ {\n        if prices[i] > prices[i-1] {\n            maxProfit += prices[i] - prices[i-1]\n        }\n    }\n    \n    return maxProfit\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    max_profit = 0\n    (1...prices.length).each do |i|\n        max_profit += [0, prices[i] - prices[i - 1]].max\n    end\n    max_profit\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        var totalProfit = 0\n        for (i <- 1 until prices.length) {\n            if (prices(i) > prices(i - 1)) {\n                totalProfit += prices(i) - prices(i - 1)\n            }\n        }\n        totalProfit\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut max_profit = 0;\n        \n        for i in 1..prices.len() {\n            if prices[i] > prices[i - 1] {\n                max_profit += prices[i] - prices[i - 1];\n            }\n        }\n        \n        max_profit\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to focus on an efficient way to maximize the profit from stock trades given an array of prices. The approach we're going to take involves iterating through the prices array and looking for increments where a profitable trade can be made.\n\n# Explanation\n\nThe core idea is to sum all the positive differences between consecutive days' prices. This approach works because if you sum up all increases (where the price on day `i` is higher than the price on day `i-1`), you cumulatively get the maximum profit achievable by buying and selling as many times as required.\n\n1. **Initialize total_profit:** Start with a profit value of zero.\n2. **Iterate through the prices:** Begin from the second day to the last day.\n3. **Check for profit opportunities:** If the price today is higher than the price yesterday, add the difference (today's price - yesterday's price) to the total profit.\n4. **Return the total profit:** After traversing all days, return the accumulated profit.\n\n# Pseudocode\n\n```       \n    function maxProfit(prices):\n        total_profit = 0\n        \n        for i from 1 to length(prices) - 1:\n            if prices[i] > prices[i - 1]:\n                total_profit = total_profit + (prices[i] - prices[i - 1])\n        \n        return total_profit\n```\n\nBy following these steps, you can derive the desired maximum profit by summing up all the gains from every increase in the stock prices.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-best-time-to-buy-and-sell-stock-ii"
    },
    {
        "name": "Best Time To Buy And Sell Stock",
        "site": "LeetCode",
        "href": "/solution/LeetCode-best-time-to-buy-and-sell-stock",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int maxProfit = 0;\n        int minPrice = INT_MAX;\n        \n        for(int i = 0; i < prices.size(); i++) {\n            minPrice = min(minPrice, prices[i]);\n            maxProfit = max(maxProfit, prices[i] - minPrice);\n        }\n        \n        return maxProfit;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int maxProfit = 0;\n        int minPrice = Integer.MAX_VALUE;\n        \n        for (int price : prices) {\n            minPrice = Math.min(minPrice, price);\n            maxProfit = Math.max(maxProfit, price - minPrice);\n        }\n        \n        return maxProfit;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            else:\n                max_profit = max(max_profit, price - min_price)\n        \n        return max_profit"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxProfit(int* prices, int pricesSize) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    \n    for (int i = 0; i < pricesSize; i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else if (prices[i] - minPrice > maxProfit) {\n            maxProfit = prices[i] - minPrice;\n        }\n    }\n    \n    return maxProfit;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        int maxProfit = 0;\n        int minPrice = Int32.MaxValue;\n        \n        for (int i = 0; i < prices.Length; i++) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            } else if (prices[i] - minPrice > maxProfit) {\n                maxProfit = prices[i] - minPrice;\n            }\n        }\n        \n        return maxProfit;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let maxProfit = 0;\n    let minPrice = prices[0];\n    \n    for (let i = 1; i < prices.length; i++) {\n        minPrice = Math.min(minPrice, prices[i]);\n        maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n    }\n    \n    return maxProfit;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxProfit(prices: number[]): number {\n    let maxProfit = 0;\n    let minPrice = prices[0];\n\n    for (let i = 1; i < prices.length; i++) {\n        const currentPrice = prices[i];\n        if (currentPrice < minPrice) {\n            minPrice = currentPrice;\n        } else {\n            maxProfit = Math.max(maxProfit, currentPrice - minPrice);\n        }\n    }\n\n    return maxProfit;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $prices\n     */\n    function maxProfit($prices) {\n        $maxProfit = 0;\n        $minPrice = PHP_INT_MAX;\n        \n        foreach ($prices as $price) {\n            $minPrice = min($minPrice, $price);\n            $maxProfit = max($maxProfit, $price - $minPrice);\n        }\n        \n        return $maxProfit;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        var maxProfit = 0\n        var minPrice = Int.max\n        \n        for price in prices {\n            minPrice = min(minPrice, price)\n            maxProfit = max(maxProfit, price - minPrice)\n        }\n        \n        return maxProfit\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        var maxProfit = 0\n        var minPrice = Int.MAX_VALUE\n        \n        for (price in prices) {\n            if (price < minPrice) {\n                minPrice = price\n            } else if (price - minPrice > maxProfit) {\n                maxProfit = price - minPrice\n            }\n        }\n        \n        return maxProfit\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maxProfit(List<int> prices) {\n    if (prices.isEmpty) {\n      return 0;\n    }\n    \n    int maxProfit = 0;\n    int minPrice = prices[0];\n    \n    for (int i = 1; i < prices.length; i++) {\n      if (prices[i] < minPrice) {\n        minPrice = prices[i];\n      } else if (prices[i] - minPrice > maxProfit) {\n        maxProfit = prices[i] - minPrice;\n      }\n    }\n    \n    return maxProfit;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxProfit(prices []int) int {\n    if len(prices) == 0 {\n        return 0\n    }\n    \n    maxProfit := 0\n    minPrice := prices[0]\n    \n    for i := 1; i < len(prices); i++ {\n        if prices[i] < minPrice {\n            minPrice = prices[i]\n        } else if prices[i] - minPrice > maxProfit {\n            maxProfit = prices[i] - minPrice\n        }\n    }\n    \n    return maxProfit\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    max_profit = 0\n    min_price = prices[0]\n    \n    prices.each do |price|\n        min_price = [min_price, price].min\n        max_profit = [max_profit, price - min_price].max\n    end\n    \n    max_profit\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        var maxProfit = 0\n        var minPrice = Int.MaxValue\n        \n        for (price <- prices) {\n            if (price < minPrice) {\n                minPrice = price\n            } else if (price - minPrice > maxProfit) {\n                maxProfit = price - minPrice\n            }\n        }\n        \n        maxProfit\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut min_price = i32::MAX;\n        let mut max_profit = 0;\n        \n        for price in prices {\n            if price < min_price {\n                min_price = price;\n            } else if price - min_price > max_profit {\n                max_profit = price - min_price;\n            }\n        }\n        \n        max_profit\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec max_profit(Prices :: [integer()]) -> integer().\nmax_profit(Prices) ->\n    MaxProfit = lists:foldl(fun(X, {MinPrice, MaxProfit}) ->\n        NewMinPrice = min(X, MinPrice),\n        NewMaxProfit = max(X - MinPrice, MaxProfit),\n        {NewMinPrice, NewMaxProfit}\n    end, {hd(Prices), 0}, tl(Prices)),\n    element(2, MaxProfit)."
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec max_profit(prices :: [integer]) :: integer\n  def max_profit(prices) do\n    Enum.reduce([hd(prices) | tl(prices)], {0, hd(prices)}, fn price, {max_profit, min_price} ->\n      {running_max, running_min} = if price < min_price, do: {0, price}, else: {price - min_price, min_price}\n      {max(max_profit, running_max), min(running_min, min_price)}\n    end) |> elem(0)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the objective is to find the maximum profit by buying and selling a stock. We need to buy the stock on a day when the price is low and sell it on a subsequent day when the price is higher. \n\n# Explanation\n1. **Initialization**:\n   - Check if the prices array is empty and return 0 if it is.\n   - Initialize a variable `min_price` to the first element in the `prices` array.\n   - Initialize a variable `max_profit` to 0.\n \n2. **Iteration**:\n   - Loop through each price in the `prices` array.\n   - For each price:\n     - If the current price is less than `min_price`, update `min_price` to the current price.\n     - Otherwise (i.e., if current price is greater than or equal to `min_price`), calculate the profit by subtracting `min_price` from the current price and update `max_profit` if this calculated profit is greater than the current `max_profit`.\n\n3. **Return**:\n   - After iterating through the `prices` array, return the `max_profit`.\n\nThis approach ensures we are keeping track of the lowest price observed so far (`min_price`) and the maximum profit achievable (`max_profit`) up to the current day in the iteration.\n\n# Pseudocode\n```\nfunction maxProfit(prices):\n    if prices is empty:\n        return 0\n\n    min_price = prices[0]\n    max_profit = 0\n\n    for each price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            max_profit = max(max_profit, price - min_price)\n\n    return max_profit\n```\n\nThis pseudocode efficiently finds the maximum profit by iterating through the `prices` list once (O(n) time complexity), keeping track of the minimum price seen so far and calculating the potential profit at each step.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-best-time-to-buy-and-sell-stock"
    },
    {
        "name": "Triangle",
        "site": "LeetCode",
        "href": "/solution/LeetCode-triangle",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        \n        for (int i = n - 2; i >= 0; i--) {\n            for (int j = 0; j < triangle[i].size(); j++) {\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        \n        return triangle[0][0];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            for (int j = 0; j < triangle.get(i).size(); j++) {\n                int current = triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1));\n                triangle.get(i).set(j, current);\n            }\n        }\n        return triangle.get(0).get(0);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        \n        dp = triangle[-1]\n        \n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        \n        return dp[0]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int minimumTotal(int** triangle, int triangleSize, int* triangleColSize) {\n    for (int i = triangleSize - 2; i >= 0; i--) {\n        for (int j = 0; j < triangleColSize[i]; j++) {\n            triangle[i][j] += fmin(triangle[i + 1][j], triangle[i + 1][j + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinimumTotal(IList<IList<int>> triangle) {\n        for (int i = triangle.Count - 2; i >= 0; i--) {\n            for (int j = 0; j < triangle[i].Count; j++) {\n                triangle[i][j] += Math.Min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        return triangle[0][0];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} triangle\n * @return {number}\n */\nconst minimumTotal = (triangle) => {\n    const n = triangle.length;\n    const dp = [...triangle[n - 1]];\n    \n    for (let i = n - 2; i >= 0; i--) {\n        for (let j = 0; j <= i; j++) {\n            dp[j] = triangle[i][j] + Math.min(dp[j], dp[j + 1]);\n        }\n    }\n    \n    return dp[0];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minimumTotal(triangle: number[][]): number {\n    for (let i = triangle.length - 2; i >= 0; i--) {\n        for (let j = 0; j < triangle[i].length; j++) {\n            triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n        }\n    }\n    \n    return triangle[0][0];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $triangle\n     */\n    function minimumTotal($triangle) {\n        $n = count($triangle);\n        $dp = $triangle[$n - 1];\n        \n        for ($i = $n - 2; $i >= 0; $i--) {\n            for ($j = 0; $j <= $i; $j++) {\n                $dp[$j] = $triangle[$i][$j] + min($dp[$j], $dp[$j + 1]);\n            }\n        }\n        \n        return $dp[0];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minimumTotal(_ triangle: [[Int]]) -> Int {\n        var dp = triangle.last!\n\n        for row in (0..<triangle.count-1).reversed() {\n            for i in 0..<triangle[row].count {\n                dp[i] = triangle[row][i] + min(dp[i], dp[i+1])\n            }\n        }\n\n        return dp[0]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minimumTotal(triangle: List<List<Int>>): Int {\n        val n = triangle.size\n        val dp = IntArray(n) { triangle[n-1][it] }\n        \n        for (i in n-2 downTo 0) {\n            for (j in 0..i) {\n                dp[j] = triangle[i][j] + minOf(dp[j], dp[j+1])\n            }\n        }\n        \n        return dp[0]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int minimumTotal(List<List<int>> triangle) {\n    for (int i = triangle.length - 2; i >= 0; i--) {\n      for (int j = 0; j < triangle[i].length; j++) {\n        triangle[i][j] += \n          triangle[i + 1][j] < triangle[i + 1][j + 1] ? triangle[i + 1][j] : triangle[i + 1][j + 1];\n      }\n    }\n    return triangle[0][0];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minimumTotal(triangle [][]int) int {\n    n := len(triangle)\n    dp := make([]int, n)\n\n    for i := range triangle[n-1] {\n        dp[i] = triangle[n-1][i]\n    }\n\n    for i := n - 2; i >= 0; i-- {\n        for j := 0; j <= i; j++ {\n            dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]\n        }\n    }\n\n    return dp[0]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} triangle\n# @return {Integer}\ndef minimum_total(triangle)\n    (triangle.length - 2).downto(0) do |i|\n        (0..triangle[i].length - 1).each do |j|\n            triangle[i][j] += [triangle[i + 1][j], triangle[i + 1][j + 1]].min\n        end\n    end\n    triangle[0][0]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minimumTotal(triangle: List[List[Int]]): Int = {\n        val n = triangle.length\n        val dp = Array.ofDim[Int](n + 1)\n\n        for (i <- n - 1 to 0 by -1) {\n            for (j <- 0 until triangle(i).length) {\n                dp(j) = triangle(i)(j) + dp(j).min(dp(j + 1))\n            }\n        }\n        dp(0)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n        let mut dp = triangle.last().unwrap().clone();\n        \n        for i in (0..triangle.len()-1).rev() {\n            for j in 0..triangle[i].len() {\n                dp[j] = triangle[i][j] + dp[j].min(dp[j+1]);\n            }\n        }\n        \n        dp[0]\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you'll need to find the minimum path sum from the top to the bottom of a triangle array. A dynamic programming approach is suitable for this problem, and we can efficiently solve it using O(n) extra space by modifying the last row incrementally.\n\n# Explanation\n\n1. **Initialization and Edge Cases**:\n   - Check if the `triangle` array is empty. If it is, return 0 as there are no paths.\n   - Initialize a `dp` array to store the intermediate minimum path sums. Start with the last row of the triangle.\n\n2. **Bottom-Up Calculation**:\n   - Iterate from the second-last row to the top row of the triangle.\n   - For each cell in a row, calculate the minimum path sum by considering the current cell value and the minimum of the two possible cells directly below in the `dp` array.\n\n3. **Result**:\n   - After processing all rows, `dp[0]` will hold the minimum path sum from the top to the bottom of the triangle.\n\n# Pseudocode\n\n```pseudocode\nFUNCTION minimumTotal(triangle)\n    # Step 1: Handle edge case\n    IF triangle is EMPTY\n        RETURN 0\n    END IF\n    \n    # Step 2: Initialize dp array with the last row of triangle\n    dp = COPY triangle[last row]\n    \n    # Step 3: Iterate from the second-last row to the top row\n    FOR i FROM length of triangle - 2 DOWN TO 0\n        # Step 4: Update dp array for the current row\n        FOR j FROM 0 TO length of triangle[i] - 1\n            dp[j] = triangle[i][j] + MIN(dp[j], dp[j + 1])\n        END FOR\n    END FOR\n    \n    # Step 5: The result is stored in dp[0]\n    RETURN dp[0]\nEND FUNCTION\n```\n\nThis approach ensures that we only use O(n) additional space, conforming to the constraints of the problem.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-triangle"
    },
    {
        "name": "Pascals Triangle Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-pascals-triangle-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> res(rowIndex + 1, 0);\n        res[0] = 1;\n        for(int i = 1; i <= rowIndex; i++){\n            for(int j = i; j >= 1; j--){\n                res[j] += res[j-1];\n            }\n        }\n        return res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> row = new ArrayList<>();\n        for (int i = 0; i <= rowIndex; i++) {\n            row.add(0, 1);\n            for (int j = 1; j < row.size() - 1; j++) {\n                row.set(j, row.get(j) + row.get(j + 1));\n            }\n        }\n        return row;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1] * (rowIndex + 1)\n        for i in range(2, rowIndex + 1):\n            for j in range(i - 1, 0, -1):\n                row[j] += row[j - 1]\n        return row"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume \n * caller calls free().\n */\nint* getRow(int rowIndex, int* returnSize){\n    *returnSize = rowIndex + 1;\n    int* row = (int*)malloc(*returnSize * sizeof(int));\n    \n    for(int i = 0; i <= rowIndex; i++){\n        for(int j = i; j >= 0; j--){\n            if(j == 0 || j == i){\n                row[j] = 1;\n            } else{\n                row[j] += row[j-1];\n            }\n        }\n    }\n    \n    return row;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> GetRow(int rowIndex) {\n        IList<int> result = new List<int>();\n        for(int i = 0; i <= rowIndex; i++){\n            result.Add(1);\n            for(int j = i - 1; j > 0; j--){\n                result[j] += result[j-1];\n            }\n        }\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} rowIndex\n * @return {number[]}\n */\nconst getRow = (rowIndex) => {\n    const result = [];\n    for (let i = 0; i <= rowIndex; i++) {\n        result[i] = 1;\n        for (let j = i - 1; j > 0; j--) {\n            result[j] = result[j] + result[j - 1];\n        }\n    }\n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function getRow(rowIndex: number): number[] {\n    const row: number[] = [1];\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] = row[j] + row[j - 1];\n        }\n        row.push(1);\n    }\n    return row;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $rowIndex\n     *\n     * @return Integer[]\n     */\n    function getRow($rowIndex) {\n        $row = [1];\n        for ($i = 1; $i <= $rowIndex; $i++) {\n            $nextRow = array_fill(0, $i + 1, 1);\n            for ($j = 1; $j < $i; $j++) {\n                $nextRow[$j] = $row[$j - 1] + $row[$j];\n            }\n            $row = $nextRow;\n        }\n        return $row;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func getRow(_ rowIndex: Int) -> [Int] {\n        var result = Array(repeating: 1, count: rowIndex + 1)\n        \n        for i in 1..<result.count {\n            for j in (1..<i).reversed() {\n                result[j] += result[j - 1]\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun getRow(rowIndex: Int): List<Int> {\n        val result = IntArray(rowIndex + 1) { 0 }\n        result[0] = 1\n        \n        for (i in 1..rowIndex) {\n            for (j in i downTo 1) {\n                result[j] += result[j - 1]\n            }\n        }\n        \n        return result.asList()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> getRow(int rowIndex) {\n    List<int> row = [1];\n    \n    for (int i = 1; i <= rowIndex; i++) {\n      List<int> newRow = [];\n      for (int j = 0; j <= i; j++) {\n        if (j == 0 || j == i) {\n          newRow.add(1);\n        } else {\n          newRow.add(row[j - 1] + row[j]);\n        }\n      }\n      row = newRow;\n    }\n    \n    return row;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func getRow(rowIndex int) []int {\n    numRows := rowIndex + 1\n    res := make([]int, numRows)\n    res[0] = 1\n    for i := 1; i < numRows; i++ {\n        for j := i; j > 0; j-- {\n            res[j] += res[j-1]\n        }\n    }\n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} row_index\n# @return {Integer[]}\ndef get_row(row_index)\n    row = [1]\n    (1..row_index).each do |i|\n        row = [1] + row.each_cons(2).map { |a, b| a + b } + [1]\n    end\n    row\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def getRow(rowIndex: Int): List[Int] = {\n        var row = List.fill(rowIndex + 1)(1)\n        \n        for (i <- 1 to rowIndex) {\n            for (j <- i - 1 to 1 by -1) {\n                row = row.updated(j, row(j) + row(j - 1))\n            }\n        }\n        \n        row\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate the `rowIndex`-th row of Pascal's Triangle using an efficient algorithm that operates in O(rowIndex) extra space.\n\n# Explanation\nPascal's Triangle is a triangular array of numbers where the value at each position is the sum of the two numbers directly above it. The first row (0th index) consists of a single `1`. Each subsequent row starts and ends with `1`, and each interior number is the sum of the two numbers above it from the previous row.\n\n1. **Initialization**: Create a list, `row`, with `rowIndex + 1` elements, all initialized to `1`.\n2. **Iteration** (Dynamic Programming): Start from the second row (index 2) up to `rowIndex`. For each row, update the elements from right to left to ensure we use values from the previous iteration's state only.\n3. **Update Rule**: For each element (from `i - 1` down to `1`), set `row[j]` to `row[j] + row[j - 1]`.\n\nThis algorithm ensures that we only retain the current row in memory and modify it in-place, thereby operating in O(rowIndex) space.\n\n# Pseudocode\n```pseudocode\nfunction getRow(rowIndex):\n    initialize row as a list of length rowIndex + 1 with all values 1\n    \n    for i from 2 to rowIndex (inclusive):\n        for j from i - 1 to 1 (inclusive, in reverse order):\n            row[j] = row[j] + row[j - 1]\n    \n    return row\n```\n\nThis pseudocode gives a clear step-by-step method for constructing the required row of Pascal's Triangle while adhering to the space constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-pascals-triangle-ii"
    },
    {
        "name": "Pascals Triangle",
        "site": "LeetCode",
        "href": "/solution/LeetCode-pascals-triangle",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> result(numRows);\n\n        for (int i = 0; i < numRows; i++) {\n            result[i].resize(i + 1);\n            result[i][0] = result[i][i] = 1;\n\n            for (int j = 1; j < i; j++) {\n                result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n            }\n        }\n\n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> triangle = new ArrayList<>();\n        \n        if (numRows == 0) {\n            return triangle;\n        }\n        \n        triangle.add(new ArrayList<>());\n        triangle.get(0).add(1);\n        \n        for (int i = 1; i < numRows; i++) {\n            List<Integer> row = new ArrayList<>();\n            List<Integer> prevRow = triangle.get(i - 1);\n            \n            row.add(1);\n            \n            for (int j = 1; j < i; j++) {\n                row.add(prevRow.get(j - 1) + prevRow.get(j));\n            }\n            \n            row.add(1);\n            triangle.add(row);\n        }\n        \n        return triangle;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0:\n            return []\n        \n        triangle = [[1]]\n        \n        for i in range(1, numRows):\n            prev_row = triangle[i - 1]\n            new_row = [1]\n            for j in range(1, i):\n                new_row.append(prev_row[j - 1] + prev_row[j])\n            new_row.append(1)\n            triangle.append(new_row)\n        \n        return triangle"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as \n*returnColumnSizes array.\n*/\n\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\n    *returnSize = numRows;\n    int **result = (int **)malloc(numRows * sizeof(int *));\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\n    \n    for(int i = 0; i < numRows; i++){\n        result[i] = (int *)malloc((i + 1) * sizeof(int));\n        (*returnColumnSizes)[i] = i + 1;\n        result[i][0] = 1;\n        result[i][i] = 1;\n        \n        for(int j = 1; j < i; j++){\n            result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n        }\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> Generate(int numRows) {\n        IList<IList<int>> triangle = new List<IList<int>>();\n        \n        if(numRows == 0){\n            return triangle;\n        }\n        \n        List<int> firstRow = new List<int>();\n        firstRow.Add(1);\n        triangle.Add(firstRow);\n        \n        for(int i = 1; i < numRows; i++){\n            List<int> prevRow = new List<int>(triangle[i - 1]);\n            List<int> row = new List<int>();\n            \n            row.Add(1);\n            for(int j = 1; j < i; j++){\n                row.Add(prevRow[j - 1] + prevRow[j]);\n            }\n            row.Add(1);\n            \n            triangle.Add(row);\n        }\n        \n        return triangle;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function(numRows) {\n    const result = [];\n    \n    for (let i = 0; i < numRows; i++) {\n        const row = new Array(i + 1).fill(1);\n        \n        for (let j = 1; j < row.length - 1; j++) {\n            row[j] = result[i - 1][j - 1] + result[i - 1][j];\n        }\n        \n        result.push(row);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function generate(numRows: number): number[][] {\n    const result: number[][] = [];\n    \n    for (let i = 0; i < numRows; i++) {\n        const row: number[] = new Array(i + 1).fill(1);\n        \n        for (let j = 1; j < row.length - 1; j++) {\n            row[j] = result[i - 1][j - 1] + result[i - 1][j];\n        }\n        \n        result.push(row);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $numRows\n     * @return Integer[][]\n     */\n    function generate($numRows) {\n        $triangle = array();\n        for ($i = 0; $i < $numRows; $i++) {\n            $triangle[$i] = array_fill(0, $i + 1, 0);\n            $triangle[$i][0] = 1;\n            $triangle[$i][$i] = 1;\n            for ($j = 1; $j < $i; $j++) {\n                $triangle[$i][$j] = $triangle[$i - 1][$j - 1] + $triangle[$i - 1][$j];\n            }\n        }\n        return $triangle;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func generate(_ numRows: Int) -> [[Int]] {\n        var triangle = [[Int]]()\n\n        if numRows == 0 {\n            return triangle\n        }\n\n        triangle.append([1])\n\n        for i in 1..<numRows {\n            var row = [1]\n\n            for j in 1..<i {\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            }\n\n            row.append(1)\n            triangle.append(row)\n        }\n\n        return triangle\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun generate(numRows: Int): List<List<Int>> {\n        val result = mutableListOf<MutableList<Int>>()\n        if (numRows == 0) return result\n        \n        result.add(mutableListOf(1))\n        \n        for (i in 1 until numRows) {\n            val prevRow = result[i - 1]\n            val row = mutableListOf<Int>()\n            row.add(1)\n            \n            for (j in 1 until i) {\n                row.add(prevRow[j - 1] + prevRow[j])\n            }\n            \n            row.add(1)\n            result.add(row)\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> generate(int numRows) {\n    List<List<int>> triangle = [];\n\n    for (int i = 0; i < numRows; i++) {\n      List<int> row = List<int>.filled(i + 1, 1);\n\n      for (int j = 1; j < row.length - 1; j++) {\n        row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\n      }\n\n      triangle.add(row);\n    }\n\n    return triangle;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func generate(numRows int) [][]int {\n    result := make([][]int, numRows)\n    \n    for i := 0; i < numRows; i++ {\n        row := make([]int, i+1)\n        row[0], row[i] = 1, 1\n        \n        for j := 1; j < i; j++ {\n            row[j] = result[i-1][j-1] + result[i-1][j]\n        }\n        \n        result[i] = row\n    }\n    \n    return result\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} num_rows\n# @return {Integer[][]}\ndef generate(num_rows)\n    triangle = Array.new(num_rows) { |i| Array.new(i+1) }\n    \n    (0...num_rows).each do |i|\n        triangle[i][0] = triangle[i][-1] = 1\n        \n        (1...i).each do |j|\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n        end\n    end\n    \n    triangle\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def generate(numRows: Int): List[List[Int]] = {\n        if (numRows == 0) return List()\n        else if (numRows == 1) return List(List(1))\n        else {\n            val res = collection.mutable.ListBuffer[List[Int]]()\n            res += List(1)\n            for (i <- 1 until numRows) {\n                val prev = res(i - 1)\n                val curr = (0 until i + 1).map(j => if (j == 0 || j == i) 1 else prev(j - 1) + prev(j)).toList\n                res += curr\n            }\n            res.toList\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\n        let mut triangle: Vec<Vec<i32>> = Vec::new();\n        \n        for i in 0..num_rows as usize {\n            let mut row = Vec::new();\n            for j in 0..=i {\n                if j == 0 || j == i {\n                    row.push(1);\n                } else {\n                    row.push(triangle[i - 1][j - 1] + triangle[i - 1][j]);\n                }\n            }\n            triangle.push(row);\n        }\n        \n        triangle\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can follow an iterative approach to build each level of Pascal's Triangle up to the specified number of rows (`numRows`). Here's a breakdown of our methodology:\n\n# Explanation\n1. **Initialization:** Start by initializing the triangle with the first row `[1]`.\n2. **Iterative Construction:** For each subsequent row from 1 to `numRows-1`, use the previous row to construct the new row.\n    - Start each new row with `1`.\n    - For each position between the first and last of the new row, calculate the value as the sum of the two numbers directly above it from the previous row.\n    - End each new row with `1`.\n3. **Return the Result:** After populating all rows, return the triangle.\n\n# Pseudocode\n\n```\nfunction generate(numRows):\n    if numRows == 0:\n        return []\n\n    triangle = [[1]]  # Start with the first row\n    \n    for i from 1 to numRows-1:\n        prev_row = triangle[i - 1]  # Get the previous row\n        new_row = [1]  # Start the new row with 1\n        \n        for j from 1 to i-1:  # Iterate over the positions in the new row\n            new_value = prev_row[j - 1] + prev_row[j]  # Calculate the new value\n            new_row.append(new_value)\n        \n        new_row.append(1)  # End the new row with 1\n        triangle.append(new_row)  # Add the new row to the triangle\n    \n    return triangle\n```\n\nThis pseudocode corresponds to the given code, and it will correctly generate Pascal's triangle up to the specified number of rows.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-pascals-triangle"
    },
    {
        "name": "Populating Next Right Pointers In Each Node Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-populating-next-right-pointers-in-each-node-ii",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\nclass Solution(object):\n    def connect(self, root):\n        if not root:\n            return None\n        queue = [root]\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.pop(0)\n                if i < size - 1:\n                    node.next = queue[0]\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return root\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * // Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * }\n */\n\nvar connect = function(root) {\n    if (!root) return root;\n    \n    let queue = [root];\n    \n    while (queue.length > 0) {\n        let levelSize = queue.length;\n        for (let i = 0; i < levelSize; i++) {\n            let currentNode = queue.shift();\n            if (i < levelSize - 1) {\n                currentNode.next = queue[0];\n            }\n            if (currentNode.left) {\n                queue.push(currentNode.left);\n            }\n            if (currentNode.right) {\n                queue.push(currentNode.right);\n            }\n        }\n    }\n    \n    return root;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for Node.\n * class Node {\n *     val: number\n *     left: Node | null\n *     right: Node | null\n *     next: Node | null\n * }\n */\nfunction connect(root: Node | null): Node | null {\n    if (!root) return root;\n    \n    let queue: Node[] = [root];\n    \n    while (queue.length > 0) {\n        let size = queue.length;\n        \n        for (let i = 0; i < size; i++) {\n            let node = queue.shift()!;\n            \n            if (i < size - 1) {\n                node.next = queue[0];\n            }\n            \n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n    }\n    \n    return root;\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Left *Node\n *     Right *Node\n *     Next *Node\n * }\n */\nfunc connect(root *Node) *Node {\n    if root == nil {\n        return root\n    }\n    \n    queue := []*Node{root}\n    \n    for len(queue) > 0 {\n        size := len(queue)\n        \n        for i := 0; i < size; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            \n            if i < size-1 {\n                node.Next = queue[0]\n            }\n            \n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n    }\n    \n    return root\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :left, :right, :next\n#     def initialize(val)\n#         @val = val\n#         @left = nil\n#         @right = nil\n#         @next = nil\n#     end\n# end\n\ndef connect(root)\n    return nil if root.nil?\n    \n    queue = [root]\n    \n    while !queue.empty?\n        level_size = queue.size\n        \n        level_size.times do |i|\n            current = queue.shift\n            queue << current.left if current.left\n            queue << current.right if current.right\n            \n            current.next = queue.first if i < level_size - 1\n        end\n    end\n    \n    return root\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var left: Node = null\n *   var right: Node = null\n *   var next: Node = null\n * }\n */\n\nobject Solution {\n  def connect(root: Node): Node = {\n    if (root == null) return null\n\n    val queue = scala.collection.mutable.Queue[Node]()\n    queue.enqueue(root)\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var prev: Node = null\n      for (_ <- 0 until size) {\n        val current = queue.dequeue()\n        if (prev != null) prev.next = current\n        prev = current\n\n        if (current.left != null) queue.enqueue(current.left)\n        if (current.right != null) queue.enqueue(current.right)\n      }\n    }\n\n    root\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to populate each `next` pointer of a binary tree node to point to its next right node. If there is no next right node, the `next` pointer should be set to `NULL`. \n\n# Explanation\nWe'll approach this problem using a level-order traversal (also known as breadth-first traversal) method. This method allows us to process all nodes level by level from left to right. We can utilize a queue data structure to facilitate this traversal. The solution must ensure that each node points to its right neighbor or is set to `NULL` if it is the last node on that level.\n\nSteps:\n1. Initialize a queue and add the root node to it.\n2. For each level, compute the number of nodes (`size`) and iterate over those nodes.\n3. Use the `next` pointer of the nodes to connect them to their right neighbors within the same level.\n4. Add the children of the current node to the queue for processing in the next level.\n5. Repeat the process until all levels are processed.\n\n# Pseudocode\n\n```\nclass Node:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        \n        # Initialize queue with root node\n        queue = [root]\n        \n        # While there are nodes to process\n        while queue:\n            # Get the number of nodes at the current level\n            size = len(queue)\n            \n            for i in range(size):\n                # Pop the first node from the queue\n                node = queue.pop(0)\n                \n                # Connect the current node to the next node in the queue\n                if i < size - 1:\n                    node.next = queue[0]\n                \n                # Add left and right children to the queue\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        # Return the modified tree\n        return root\n```\n\nThis pseudocode initializes a queue with the root, processes each level to connect the nodes, and ensures that each `next` pointer is correctly assigned. Each node\u2019s children are added to the queue to repeat the process for the next level.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-populating-next-right-pointers-in-each-node-ii"
    },
    {
        "name": "Populating Next Right Pointers In Each Node",
        "site": "LeetCode",
        "href": "/solution/LeetCode-populating-next-right-pointers-in-each-node",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\nclass Solution(object):\n    def connect(self, root):\n        if not root:\n            return root\n        \n        leftmost = root\n        while leftmost.left:\n            head = leftmost\n            while head:\n                head.left.next = head.right\n                if head.next:\n                    head.right.next = head.next.left\n                head = head.next\n            leftmost = leftmost.left\n        \n        return root\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * // Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * }\n * \n * @param {Node} root\n * @return {Node}\n */\nvar connect = function(root) {\n    if (!root) return root;\n    \n    const queue = [root];\n    \n    while (queue.length > 0) {\n        const size = queue.length;\n        \n        for (let i = 0; i < size; i++) {\n            const current = queue.shift();\n            \n            if (i < size - 1) {\n                current.next = queue[0];\n            }\n            \n            if (current.left) queue.push(current.left);\n            if (current.right) queue.push(current.right);\n        }\n    }\n    \n    return root;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for Node.\n * class Node {\n *     val: number;\n *     left: Node | null;\n *     right: Node | null;\n *     next: Node | null;\n *     constructor(val?: number, left?: Node, right?: Node, next?: Node) {\n *         this.val = (val===undefined ? 0 : val);\n *         this.left = (left===undefined ? null : left);\n *         this.right = (right===undefined ? null : right);\n *         this.next = (next===undefined ? null : next);\n *     }\n * }\n */\n\nfunction connect(root: Node | null): Node | null {\n    if (!root) return null;\n    \n    let levelStart = root;\n    \n    while (levelStart.left) {\n        let curr = levelStart;\n        \n        while (curr) {\n            curr.left.next = curr.right;\n            if (curr.next) {\n                curr.right.next = curr.next.left;\n            }\n            \n            curr = curr.next;\n        }\n        \n        levelStart = levelStart.left;\n    }\n    \n    return root;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "    /**\n     * Definition for a Node.\n     * class Node {\n     *     public $val;\n     *     public $left;\n     *     public $right;\n     *     public $next;\n     *     @param Integer $val \n     *     @param Node $left \n     *     @param Node $right \n     *     @param Node $next \n     *     function __construct($val = 0, $left = null, $right = null, $next = null) {\n     *         $this->val = $val;\n     *         $this->left = $left;\n     *         $this->right = $right;\n     *         $this->next = $next;\n     *     }\n     * }\n     */\n    \n    class Solution {\n        \n        /**\n         * @param Node $root\n         * @return Node\n         */\n        function connect($root) {\n            if ($root === null) {\n                return null;\n            }\n            \n            $this->connectNodes($root->left, $root->right);\n            return $root;\n        }\n        \n        function connectNodes($node1, $node2) {\n            if ($node1 === null || $node2 === null) {\n                return;\n            }\n            \n            $node1->next = $node2;\n            \n            $this->connectNodes($node1->left, $node1->right);\n            $this->connectNodes($node2->left, $node2->right);\n            \n            $this->connectNodes($node1->right, $node2->left);\n        }\n    }\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Left *Node\n *     Right *Node\n *     Next *Node\n * }\n */\n \n func connect(root *Node) *Node {\n    if root == nil {\n        return root\n    }\n    \n    leftmost := root\n    for leftmost.Left != nil {\n        head := leftmost\n        for head != nil {\n            head.Left.Next = head.Right\n            if head.Next != nil {\n                head.Right.Next = head.Next.Left\n            }\n            head = head.Next\n        }\n        leftmost = leftmost.Left\n    }\n    return root\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for Node.\n# class Node\n#     attr_accessor :val, :left, :right, :next\n#     def initialize(val)\n# @param {Node} root\n# @return {Node}\ndef connect(root)\n    return nil if root.nil?\n    \n    queue = [root]\n    \n    until queue.empty?\n        size = queue.size\n        prev = nil\n        \n        size.times do\n            node = queue.shift\n            prev.next = node if prev\n            prev = node\n            \n            queue << node.left if node.left\n            queue << node.right if node.right\n        end\n    end\n    \n    root\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n */\nobject Solution {\n    def connect(root: Node): Node = {\n        if (root == null) {\n            return null\n        }\n        if (root.left != null) {\n            root.left.next = root.right\n            if(root.next != null){\n                root.right.next = root.next.left\n            }\n            connect(root.left)\n            connect(root.right)\n        }\n        root\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to ensure that each node's `next` pointer in a perfect binary tree points to its next right node, and if there is no next right node, the `next` pointer should be set to NULL.\n\n### # Explanation:\n\n1. **Initialization**: If the given tree is empty, return `null`.\n2. **Level Traversal**: Start from the root node. As long as the current node has a left child (because it's a perfect binary tree, the presence of a left child ensures the presence of a right child):\n    - **Inner Loop**: For each node at the current level, link the left child to the right child.\n    - If the current node also has a `next` pointer, link the right child of the current node to the left child of the `next` node.\n3. **Move Down the Tree**: Proceed to the next level by moving to the leftmost node of the next level.\n4. **Finish and Return**: Continue this process until all nodes have been connected as required.\n\nThis method ensures O(1) extra space complexity (if we don't count the stack space of recursion).\n\n### # Pseudocode:\n\n```pseudocode\n# Define a Node class as given in the problem\nclass Node:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n# Define the Solution class with connect method\nclass Solution:\n    def connect(self, root):\n        if not root:\n            return root\n\n        # Initialize the leftmost node of the current level\n        leftmost = root\n\n        # Traverse levels as long as leftmost has a left child\n        while leftmost.left:\n            # Start from the leftmost node of this level\n            head = leftmost\n\n            while head:\n                # Connect left child to right child of the same node\n                head.left.next = head.right\n\n                # Connect right child to left child of the next node (if exists)\n                if head.next:\n                    head.right.next = head.next.left\n\n                # Move to the next node\n                head = head.next\n            \n            # Move to the next level\n            leftmost = leftmost.left\n        \n        return root\n```\n\nThis pseudocode accurately represents the solution's logic and step-by-step procedure for connecting each next pointer in a perfect binary tree.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-populating-next-right-pointers-in-each-node"
    },
    {
        "name": "Convert Sorted List To Binary Search Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-convert-sorted-list-to-binary-search-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n        if (head->next == nullptr) {\n            return new TreeNode(head->val);\n        }\n        \n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* prev = nullptr;\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            prev = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        if (prev != nullptr) {\n            prev->next = nullptr;\n        }\n        \n        TreeNode* root = new TreeNode(slow->val);\n        \n        if (head != slow) {\n            root->left = sortedListToBST(head);\n        }\n        \n        root->right = sortedListToBST(slow->next);\n        \n        return root;\n    }\n};\n  "
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return toBST(head, null);\n    }\n    \n    private TreeNode toBST(ListNode head, ListNode tail) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        if (head == tail) {\n            return null;\n        }\n        \n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        TreeNode node = new TreeNode(slow.val);\n        node.left = toBST(head, slow);\n        node.right = toBST(slow.next, tail);\n        \n        return node;\n    }\n}\n\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        def convertToBST(l, r):\n            if l > r:\n                return None\n            mid = (l + r) // 2\n            left = convertToBST(l, mid - 1)\n            node = TreeNode(self.head.val)\n            node.left = left\n            self.head = self.head.next\n            node.right = convertToBST(mid + 1, r)\n            return node\n        \n        self.head = head\n        size = 0\n        current = head\n        while current:\n            size += 1\n            current = current.next\n        return convertToBST(0, size - 1)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n \n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* sortedListToBST(struct ListNode* head) {\n    if(head == NULL) {\n        return NULL;\n    }\n    \n    if(head->next == NULL) {\n        struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n        root->val = head->val;\n        root->left = NULL;\n        root->right = NULL;\n        return root;\n    }\n    \n    struct ListNode* mid = head;\n    struct ListNode* prev = NULL;\n    struct ListNode* fast = head;\n    \n    while(fast != NULL && fast->next != NULL) {\n        fast = fast->next->next;\n        prev = mid;\n        mid = mid->next;\n    }\n    \n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = mid->val;\n    \n    if(prev != NULL) {\n        prev->next = NULL;\n        root->left = sortedListToBST(head);\n    } else {\n        root->left = NULL;\n    }\n    \n    root->right = sortedListToBST(mid->next);\n\n    return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "// Definition for singly-linked list.\n    // public class ListNode {\n    //     public int val;\n    //     public ListNode next;\n    //     public ListNode(int val=0, ListNode next=null) {\n    //         this.val = val;\n    //         this.next = next;\n    //     }\n    // }\n\npublic class Solution {\n    public TreeNode SortedListToBST(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode prev = null;\n        \n        while(fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        // Disconnect left part from mid node\n        if(prev != null) prev.next = null;\n\n        TreeNode root = new TreeNode(slow.val);\n        root.left = SortedListToBST(head);\n        root.right = SortedListToBST(slow.next);\n        \n        return root;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    const buildBST = (start, end) => {\n        if (start > end) {\n            return null;\n        }\n        const mid = Math.floor((start + end) / 2);\n        const left = buildBST(start, mid - 1);\n        const root = new TreeNode(head.val);\n        root.left = left;\n        head = head.next;\n        root.right = buildBST(mid + 1, end);\n        return root;\n    }\n    \n    let currentNode = head;\n    let listLength = 0;\n    while (currentNode) {\n        currentNode = currentNode.next;\n        listLength++;\n    }\n    \n    return buildBST(0, listLength - 1);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n */\nclass Solution {\n  \n    /**\n     * @param ListNode $head\n     * @return TreeNode\n     */\n    function sortedListToBST($head) {\n        if(!$head) {\n            return null;\n        }\n        \n        $mid = $this->findMid($head);\n        \n        $node = new TreeNode($mid->val);\n        \n        if($head === $mid) {\n            return $node;\n        }\n        \n        $node->left = $this->sortedListToBST($head);\n        $node->right = $this->sortedListToBST($mid->next);\n        \n        return $node;\n    }\n    \n    function findMid($head) {\n        $slow = $head;\n        $fast = $head;\n        $prev = null;\n        \n        while($fast && $fast->next) {\n            $prev = $slow;\n            $slow = $slow->next;\n            $fast = $fast->next->next;\n        }\n        \n        if($prev) {\n            $prev->next = null;\n        }\n        \n        return $slow;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     public var val: Int\n*     public var next: ListNode?\n*     public init() { self.val = 0; self.next = nil; }\n*     public init(_ val: Int) { self.val = val; self.next = nil; }\n*     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n* }\n*/\n\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     public var val: Int\n*     public var left: TreeNode?\n*     public var right: TreeNode?\n*     public init() { self.val = 0; self.left = nil; self.right = nil; }\n*     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n*     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n*         self.val = val\n*         self.left = left\n*         self.right = right\n*     }\n* }\n*/\n\nclass Solution {\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\n        guard let head = head else { return nil }\n        \n        let mid = findMiddle(head)\n        let root = TreeNode(mid.val)\n        \n        if head === mid {\n            return root\n        }\n        \n        root.left = sortedListToBST(head)\n        root.right = sortedListToBST(mid.next)\n        \n        return root\n    }\n    \n    func findMiddle(_ head: ListNode?) -> ListNode {\n        var slow = head\n        var fast = head\n        var prev: ListNode?\n        \n        while let nextFast = fast?.next {\n            prev = slow\n            slow = slow?.next\n            fast = nextFast.next\n        }\n        \n        if let prev = prev {\n            prev.next = nil\n        }\n        \n        return slow!\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n *\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n \n func sortedListToBST(head *ListNode) *TreeNode {\n     if head == nil {\n         return nil\n     }\n     \n     if head.Next == nil {\n         return &TreeNode{Val: head.Val}\n     }\n     \n     mid := findMiddleElement(head)\n     root := &TreeNode{Val: mid.Val}\n     \n     if head == mid {\n         return root\n     }\n     \n     root.Left = sortedListToBST(head)\n     root.Right = sortedListToBST(mid.Next)\n     \n     return root\n }\n \n func findMiddleElement(head *ListNode) *ListNode {\n     var prev *ListNode\n     slow, fast := head, head\n     \n     for fast != nil && fast.Next != nil {\n         prev = slow\n         slow = slow.Next\n         fast = fast.Next.Next\n     }\n     \n     if prev != nil {\n         prev.Next = nil\n     }\n     \n     return slow\n }"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\ndef sorted_list_to_bst(head)\n    def find_mid(start, tail)\n        slow = fast = start\n        while fast != tail && fast.next != tail\n            slow = slow.next\n            fast = fast.next.next\n        end\n        slow\n    end\n    \n    def convert_list_to_bst(start, tail)\n        return nil if start == tail\n        \n        mid = find_mid(start, tail)\n        node = TreeNode.new(mid.val)\n        \n        node.left = convert_list_to_bst(start, mid)\n        node.right = convert_list_to_bst(mid.next, tail)\n        \n        node\n    end\n    \n    return convert_list_to_bst(head, nil)\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a sorted singly linked list into a height-balanced binary search tree (BST). We can achieve this through a recursive step-by-step approach.\n\n## Explanation\n\nA height-balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. Given that the input list is sorted in ascending order, we can use the following strategy:\n1. Find the middle element of the list; this middle element will be the root of the BST.\n2. Recursively find the middle element of the left sublist to form the left subtree.\n3. Recursively find the middle element of the right sublist to form the right subtree.\n\nTo implement this:\n1. Count the number of nodes in the linked list.\n2. Use a helper function to convert the list to a BST. This function will recursively find the middle of the current list segment and create the corresponding tree nodes.\n\nHere's the pseudocode that outlines the solution:\n\n## Pseudocode\n```plaintext\n# Define a class for the TreeNode\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Define a function to convert the sorted list to a BST\nfunction sortedListToBST(head):\n    \n    # Helper function to convert list to BST\n    function convertToBST(l, r):\n        if l > r:\n            return None\n        mid = (l + r) // 2\n        \n        # Recursively form the left subtree\n        left = convertToBST(l, mid - 1)\n        \n        # Create the tree node corresponding to the middle of the list\n        node = TreeNode(current.val)\n        node.left = left\n        \n        # Move to the next list node\n        current = current.next\n        \n        # Recursively form the right subtree\n        node.right = convertToBST(mid + 1, r)\n        return node\n\n    # Count the size of the list\n    size = 0\n    current = head\n    while current:\n        size += 1\n        current = current.next\n    \n    # Initialize current node of the list\n    current = head\n    \n    # Convert the sorted list to a BST\n    return convertToBST(0, size - 1)\n```\n\nIn this pseudocode:\n1. `sortedListToBST` is the main function that starts the conversion process.\n2. `convertToBST` is a helper function that recursively constructs the BST.\n3. We first count the number of nodes in the list and initialize the `current` pointer to the head of the list.\n4. `convertToBST` is called with the full range of the list indices, and it constructs the BST maintaining the provided constraints and properties of a height-balanced BST.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-convert-sorted-list-to-binary-search-tree"
    },
    {
        "name": "Flatten Binary Tree To Linked List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-flatten-binary-tree-to-linked-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if (root == nullptr) {\n            return;\n        }\n        \n        flatten(root->left);\n        flatten(root->right);\n        \n        TreeNode* temp = root->right;\n        root->right = root->left;\n        root->left = nullptr;\n        \n        while (root->right != nullptr) {\n            root = root->right;\n        }\n        \n        root->right = temp;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        \n        if (root.left != null) {\n            TreeNode rightMost = root.left;\n            while (rightMost.right != null) {\n                rightMost = rightMost.right;\n            }\n            \n            rightMost.right = root.right;\n            root.right = root.left;\n            root.left = null;\n        }\n        \n        flatten(root.right);\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nvoid flatten(struct TreeNode* root){\n    if(root == NULL){\n        return;\n    }\n    \n    if(root->left){\n        flatten(root->left);\n        \n        struct TreeNode* temp = root->right;\n        root->right = root->left;\n        root->left = NULL;\n        \n        struct TreeNode* current = root->right;\n        while(current->right){\n            current = current->right;\n        }\n        current->right = temp;\n    }\n    \n    flatten(root->right);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public void Flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        \n        Flatten(root.left);\n        Flatten(root.right);\n        \n        TreeNode temp = root.right;\n        root.right = root.left;\n        root.left = null;\n        \n        while (root.right != null) {\n            root = root.right;\n        }\n        \n        root.right = temp;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = this.right = null\n */\n\nvar flatten = function(root) {\n    if (!root) {\n        return;\n    }\n    \n    const stack = [root];\n    \n    while (stack.length) {\n        const node = stack.pop();\n        \n        if (node.right) {\n            stack.push(node.right);\n        }\n        \n        if (node.left) {\n            stack.push(node.left);\n        }\n        \n        if (stack.length) {\n            node.right = stack[stack.length - 1];\n        }\n        \n        node.left = null;\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction flatten(root: TreeNode | null): void {\n    if (!root) return;\n    \n    let queue: TreeNode[] = [];\n    preorderTraversal(root, queue);\n    \n    for (let i = 1; i < queue.length; i++) {\n        root.left = null;\n        root.right = queue[i];\n        root = root.right;\n    }\n};\n\nfunction preorderTraversal(node: TreeNode, queue: TreeNode[]): void {\n    if (!node) return;\n    \n    queue.push(node);\n    preorderTraversal(node.left, queue);\n    preorderTraversal(node.right, queue);\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n\n    /**\n     * Definition for a binary tree node.\n     * class TreeNode {\n     *     public $val = null;\n     *     public $left = null;\n     *     public $right = null;\n     *     function __construct($value) {\n     *         $this->val = $value;\n     *     }\n     * }\n     */\n\n    /**\n     * @param TreeNode $root\n     * @return NULL\n     */\n    function flatten($root) {\n        if (!$root) return;\n        \n        $stack = [];\n        $stack[] = $root;\n        \n        while (!empty($stack)) {\n            $node = array_pop($stack);\n            \n            if ($node->right) {\n                $stack[] = $node->right;\n            }\n            if ($node->left) {\n                $stack[] = $node->left;\n            }\n            \n            if (!empty($stack)) {\n                $node->right = $stack[count($stack) - 1];\n            }\n            $node->left = null;\n        }\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func flatten(_ root: TreeNode?) {\n        var current = root\n        while current != nil {\n            if let left = current?.left {\n                var pre = left\n                while pre.right != nil {\n                    pre = pre.right!\n                }\n                pre.right = current?.right\n                current?.right = left\n                current?.left = nil\n            }\n            current = current?.right\n        }\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc flatten(root *TreeNode) {\n    if root == nil {\n        return\n    }\n\n    stack := []*TreeNode{root}\n    var prev *TreeNode\n\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        if prev != nil {\n            prev.Right = node\n            prev.Left = nil\n        }\n\n        if node.Right != nil {\n            stack = append(stack, node.Right)\n        }\n        if node.Left != nil {\n            stack = append(stack, node.Left)\n        }\n\n        prev = node\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class TreeNode\n    attr_accessor :val, :left, :right\n    def initialize(val = 0, left = nil, right = nil)\n        @val = val\n        @left = nil\n        @right = nil\n    end\nend\n\ndef flatten(root)\n    return if root.nil?\n    \n    flatten(root.left)\n    flatten(root.right)\n    \n    temp = root.right\n    root.right = root.left\n    root.left = nil\n    \n    current = root\n    current = current.right while current.right\n    current.right = temp\nend"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to flatten a given binary tree into a linked list in-place. The resulting \"linked list\" should follow the pre-order traversal order of the binary tree. Each node's right pointer should point to the next node in the list, and each node's left pointer should be null.\n\nHere's a step-by-step breakdown of the approach and the corresponding pseudocode.\n\n# Explanation\n\n1. **Initialization**: If the root is null, there is nothing to flatten, so return immediately.\n2. **Stack Utilization**: Use a stack to assist with the traversal and modification of the tree.\n   - Start by pushing the root node onto the stack.\n3. **Processing Nodes**:\n   - In every iteration, pop the top node from the stack.\n   - If the popped node has a right child, push the right child onto the stack.\n   - If the popped node has a left child, push the left child onto the stack.\n   - Connect the current node's right pointer to the next node in the stack (if any) and ensure the left pointer is null (as the linked list should only use right pointers).\n4. **Iteration Continuation**: Continue the process until the stack is empty.\n\nThis approach ensures that we traverse the tree in a pre-order manner and modify the pointers to form the desired linked list.\n\n# Pseudocode\n\n```\nDefine TreeNode class with attributes val, left, and right\n\nFunction flatten(root):\n    # Base case: if the root is null, return immediately\n    if root is null:\n        return\n    \n    # Initialize stack with the root node\n    stack = [root]\n    \n    # Iterate while there are nodes in the stack\n    while stack is not empty:\n        # Pop the top node from the stack\n        node = stack.pop()\n        \n        # If node has a right child, push it onto the stack\n        if node.right is not null:\n            stack.push(node.right)\n        \n        # If node has a left child, push it onto the stack\n        if node.left is not null:\n            stack.push(node.left)\n        \n        # Connect node's right pointer to the top of the stack (next node in pre-order)\n        if stack is not empty:\n            node.right = stack[-1]\n        \n        # Ensure node's left pointer is null\n        node.left = null\n```\n\nWith this pseudocode, the preparation and processing for flattening the binary tree conform to the specified constraints and requirements.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-flatten-binary-tree-to-linked-list"
    },
    {
        "name": "Path Sum Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-path-sum-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<vector<int>> result;\n        vector<int> path;\n        helper(root, targetSum, path, result);\n        return result;\n    }\n    \n    void helper(TreeNode* root, int targetSum, vector<int>& path, vector<vector<int>>& result) {\n        if (root == NULL) return;\n        \n        path.push_back(root->val);\n        \n        if (root->left == NULL && root->right == NULL && targetSum == root->val) {\n            result.push_back(path);\n        }\n        \n        helper(root->left, targetSum - root->val, path, result);\n        helper(root->right, targetSum - root->val, path, result);\n        \n        path.pop_back();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.*;\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int val) {\n *         this.val = val;\n *     }\n * }\n */\n\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        helper(root, targetSum, res, path);\n        return res;\n    }\n\n    private void helper(TreeNode node, int targetSum, List<List<Integer>> res, List<Integer> path) {\n        if (node == null) {\n            return;\n        }\n\n        path.add(node.val);\n\n        if (node.left == null && node.right == null && targetSum == node.val) {\n            res.add(new ArrayList<>(path));\n        } else {\n            helper(node.left, targetSum - node.val, res, path);\n            helper(node.right, targetSum - node.val, res, path);\n        }\n\n        path.remove(path.size() - 1);\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<IList<int>> PathSum(TreeNode root, int targetSum) {\n        var result = new List<IList<int>>();\n        Helper(root, targetSum, new List<int>(), result);\n        return result;\n    }\n    \n    private void Helper(TreeNode node, int targetSum, List<int> path, List<IList<int>> result) {\n        if (node == null) return;\n        \n        path.Add(node.val);\n        if (node.left == null && node.right == null && node.val == targetSum) {\n            result.Add(new List<int>(path));\n        } else {\n            Helper(node.left, targetSum - node.val, path, result);\n            Helper(node.right, targetSum - node.val, path, result);\n        }\n        \n        path.RemoveAt(path.Count - 1);\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\nvar pathSum = function(root, targetSum) {\n    const result = [];\n    const DFS = (node, sum, path) => {\n        if (!node) return;\n        path.push(node.val);\n        if (!node.left && !node.right && sum === node.val) {\n            result.push([...path]);\n        } else {\n            DFS(node.left, sum - node.val, path);\n            DFS(node.right, sum - node.val, path);\n        }\n        path.pop();\n    };\n    DFS(root, targetSum, []);\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val)\n *         this.left = (left === undefined ? null : left)\n *         this.right = (right === undefined ? null : right)\n *     }\n * }\n */\n\nfunction pathSum(root: TreeNode | null, targetSum: number): number[][] {\n    const result: number[][] = [];\n\n    const dfs = (node: TreeNode | null, currentPath: number[], pathSum: number) => {\n        if (!node) return;\n\n        currentPath.push(node.val);\n        pathSum += node.val;\n\n        if (!node.left && !node.right && pathSum === targetSum) {\n            result.push([...currentPath]);\n        }\n\n        dfs(node.left, currentPath, pathSum);\n        dfs(node.right, currentPath, pathSum);\n\n        currentPath.pop();\n    };\n\n    dfs(root, [], 0);\n\n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\nclass Solution {\n    \n    /**\n     * @param TreeNode $root\n     * @param Integer $targetSum\n     * @return Integer[][]\n     */\n    function pathSum($root, $targetSum) {\n        $result = [];\n        $path = [];\n        $this->dfs($root, $targetSum, [], $result);\n        return $result;\n    }\n    \n    function dfs($node, $sum, $path, &$result) {\n        if ($node === null) return;\n        \n        $path[] = $node->val;\n        \n        if ($node->left === null && $node->right === null && $sum === $node->val) {\n            $result[] = $path;\n            return;\n        }\n        \n        $this->dfs($node->left, $sum - $node->val, $path, $result);\n        $this->dfs($node->right, $sum - $node->val, $path, $result);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> [[Int]] {\n        var result: [[Int]] = []\n        var path: [Int] = []\n\n        func dfs(_ node: TreeNode?, _ sum: Int) {\n            guard let node = node else { return }\n            path.append(node.val)\n\n            if node.left == nil, node.right == nil, sum == node.val {\n                result.append(path)\n            }\n\n            dfs(node.left, sum - node.val)\n            dfs(node.right, sum - node.val)\n\n            path.removeLast()\n        }\n\n        dfs(root, targetSum)\n        return result\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n    var result [][]int\n    var path []int\n    var dfs func(*TreeNode, int)\n    \n    dfs = func(node *TreeNode, sum int) {\n        if node == nil {\n            return\n        }\n        \n        path = append(path, node.Val)\n        defer func() { path = path[:len(path)-1] }()\n        \n        if node.Left == nil && node.Right == nil && sum+node.Val == targetSum {\n            temp := make([]int, len(path))\n            copy(temp, path)\n            result = append(result, temp)\n            return\n        }\n        \n        dfs(node.Left, sum+node.Val)\n        dfs(node.Right, sum+node.Val)\n    }\n    \n    dfs(root, 0)\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef path_sum(root, target_sum)\n    res = []\n    dfs(root, target_sum, [], res)\n    res\nend\n\ndef dfs(node, target, path, res)\n    return if node.nil?\n    \n    path << node.val\n    if node.left.nil? && node.right.nil? && target == node.val\n        res << path.clone\n    else\n        dfs(node.left, target - node.val, path, res)\n        dfs(node.right, target - node.val, path, res)\n    end\n    \n    path.pop\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n * }\n */\n\nobject Solution {\n    def pathSum(root: TreeNode, targetSum: Int): List[List[Int]] = {\n        var result: List[List[Int]] = List()\n\n        def dfs(node: TreeNode, sumSoFar: Int, path: List[Int]): Unit = {\n            if (node == null) return\n\n            val newSum = sumSoFar + node.value\n            val newPath = path :+ node.value\n\n            if (node.left == null && node.right == null && newSum == targetSum) {\n                result = result :+ newPath\n            }\n\n            dfs(node.left, newSum, newPath)\n            dfs(node.right, newSum, newPath)\n        }\n\n        dfs(root, 0, List())\n        result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine all root-to-leaf paths in a binary tree where the sum of the node values in the path equals a given target sum.\n\n# Explanation\n\n1. **Tree Traversal**:\n    We will use Depth-First Search (DFS) to traverse the binary tree. DFS is appropriate here because we need to explore each path from the root to the leaf nodes.\n\n2. **Path Management**:\n    We will maintain a list to store the current path and a result list to store all valid paths that match the target sum.\n\n3. **Base Case Handling**:\n    If a node is `null`, we immediately return. If a node is a leaf node (i.e., it has no left or right children) and the sum of the path values equals the target sum, we append the path to the result list.\n\n4. **Recursive Exploration**:\n    We recursively call DFS on the left and right children of the current node, updating the remaining sum by subtracting the current node's value.\n\n5. **Backtracking**:\n    After exploring both children, we backtrack by removing the current node's value from the path list to explore other potential paths.\n\n# Pseudocode\n\n```plaintext\nDefine function pathSum(root, targetSum):\n    Initialize result as an empty list\n    \n    Define DFS(node, currentSum, path):\n        If node is null:\n            Return\n        \n        Append node.val to path\n        \n        If node is a leaf and node.val equals currentSum:\n            Append the current copy of path to result\n        Else:\n            Call DFS(node.left, currentSum - node.val, path)\n            Call DFS(node.right, currentSum - node.val, path)\n        \n        Remove last element from path (backtrack)\n    \n    Call DFS(root, targetSum, empty list)\n    \n    Return result\n```\n\nThis pseudocode outlines a recursive DFS approach, with backtracking, to explore all possible root-to-leaf paths and check their sums against the targetSum. The result list will contain all valid paths that meet the sum criteria.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-path-sum-ii"
    },
    {
        "name": "Path Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-path-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if(root == nullptr)\n            return false;\n        if(root->left == nullptr && root->right == nullptr)\n            return targetSum - root->val == 0;\n        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null) {\n            return false;\n        }\n        \n        if (root.left == null && root.right == null && targetSum - root.val == 0) {\n            return true;\n        }\n        \n        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nbool hasPathSum(struct TreeNode* root, int targetSum){\n    if (root == NULL) {\n        return false;\n    }\n    \n    if (root->left == NULL && root->right == NULL) {\n        return targetSum == root->val;\n    }\n    \n    return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool HasPathSum(TreeNode root, int targetSum) {\n        if (root == null) {\n            return false;\n        }\n        if (root.left == null && root.right == null && root.val == targetSum) {\n            return true;\n        }\n        return HasPathSum(root.left, targetSum - root.val) || HasPathSum(root.right, targetSum - root.val);\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\n\nvar hasPathSum = function(root, targetSum) {\n    if (!root) return false;\n    \n    if (!root.left && !root.right && targetSum === root.val) return true;\n    \n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction hasPathSum(root: TreeNode | null, targetSum: number): boolean {\n    if (!root) return false;\n    \n    if (!root.left && !root.right && root.val === targetSum) return true;\n    \n    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @param Integer $targetSum\n     * @return Boolean\n     */\n    function hasPathSum($root, $targetSum) {\n        if ($root === null) {\n            return false;\n        }\n        \n        if ($root->left === null && $root->right === null) {\n            return $targetSum - $root->val === 0;\n        }\n        \n        return $this->hasPathSum($root->left, $targetSum - $root->val) || $this->hasPathSum($root->right, $targetSum - $root->val);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n        if root == nil {\n            return false\n        }\n        if root!.left == nil && root!.right == nil {\n            return targetSum == root!.val\n        }\n        \n        let newSum = targetSum - root!.val\n        return hasPathSum(root!.left, newSum) || hasPathSum(root!.right, newSum)\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n    if root == nil {\n        return false\n    }\n    \n    if root.Left == nil && root.Right == nil {\n        return targetSum == root.Val\n    }\n    \n    return hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = \n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef has_path_sum(root, target_sum)\n    if root.nil?\n        return false\n    end\n    if root.left.nil? && root.right.nil? && root.val == target_sum\n        return true\n    end\n    return has_path_sum(root.left, target_sum - root.val) || has_path_sum(root.right, target_sum - root.val)\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n * \n */\nobject Solution {\n    def hasPathSum(root: TreeNode, targetSum: Int): Boolean = {\n        if (root == null) false\n        else if (root.left == null && root.right == null && targetSum - root.value == 0) true\n        else hasPathSum(root.left, targetSum - root.value) || hasPathSum(root.right, targetSum - root.value)\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE{\n  \n  defmodule Solution do\n    def has_path_sum(nil, _target_sum), do: false\n    def has_path_sum(%TreeNode{val: val, left: nil, right: nil}, target_sum), do: val == target_sum\n    def has_path_sum(%TreeNode{val: val, left: left, right: right}, target_sum) do\n      has_path_sum(left, target_sum - val) || has_path_sum(right, target_sum - val)\n    end\n  end\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if there exists a path from the root to any leaf in a given binary tree such that the sum of the node values along that path equals the `targetSum`.\n\n# Explanation\n1. **Base Case**:\n    - If the tree is empty (i.e., the root is `null`), return `false`.\n2. **Leaf Node Check**:\n    - If a node is a leaf (i.e., it has no left or right child), check if the current `targetSum` minus the node's value equals zero. If it does, return `true`.\n3. **Recursive Case**:\n    - Recursively check the left and right subtrees. For each subtree, the new `targetSum` should be reduced by the current node's value. If either subtree returns `true`, return `true`.\n4. **Combine Results**:\n    - If none of the conditions are satisfied, return `false`.\n\n# Pseudocode\n``` \nfunction hasPathSum(root, targetSum):\n    if root is null:\n        return false\n\n    if root.left is null and root.right is null and targetSum is equal to root.val:\n        return true\n\n    left_result = hasPathSum(root.left, targetSum - root.val)\n    right_result = hasPathSum(root.right, targetSum - root.val)\n\n    return left_result or right_result\n```\n\nThis pseudocode will recursively verify whether there is a path that meets the condition from the root to any leaf.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-path-sum"
    },
    {
        "name": "Minimum Depth Of Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-depth-of-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        if (root->left == nullptr && root->right == nullptr) {\n            return 1;\n        }\n        int leftDepth = (root->left == nullptr) ? INT_MAX : minDepth(root->left);\n        int rightDepth = (root->right == nullptr) ? INT_MAX : minDepth(root->right);\n        return 1 + min(leftDepth, rightDepth);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        if (root.left == null) {\n            return 1 + minDepth(root.right);\n        }\n        if (root.right == null) {\n            return 1 + minDepth(root.left);\n        }\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int minDepth(struct TreeNode* root) {\n    if(root == NULL) return 0;\n    \n    if(root->left == NULL && root->right == NULL) return 1;\n    \n    if(root->left == NULL) return 1 + minDepth(root->right);\n    \n    if(root->right == NULL) return 1 + minDepth(root->left);\n    \n    return 1 + fmin(minDepth(root->left), minDepth(root->right));\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MinDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        if (root.left == null) {\n            return 1 + MinDepth(root.right);\n        }\n        if (root.right == null) {\n            return 1 + MinDepth(root.left);\n        }\n        return 1 + Math.Min(MinDepth(root.left), MinDepth(root.right));\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n */\nvar minDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    if (!root.left && !root.right) {\n        return 1;\n    }\n    if (!root.left) {\n        return 1 + minDepth(root.right);\n    }\n    if (!root.right) {\n        return 1 + minDepth(root.left);\n    }\n    return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number;\n *     left: TreeNode | null;\n *     right: TreeNode | null;\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val);\n *         this.left = (left === undefined ? null : left);\n *         this.right = (right === undefined ? null : right);\n *     }\n * }\n */\nfunction minDepth(root: TreeNode | null): number {\n    if (!root) {\n        return 0;\n    }\n    if (!root.left && !root.right) {\n        return 1;\n    }\n    let min = Number.MAX_VALUE;\n    if (root.left) {\n        min = Math.min(min, minDepth(root.left));\n    }\n    if (root.right) {\n        min = Math.min(min, minDepth(root.right));\n    }\n    return min + 1;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\n\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function minDepth($root) {\n        if ($root == null) {\n            return 0;\n        }\n        \n        $leftDepth = $this->minDepth($root->left);\n        $rightDepth = $this->minDepth($root->right);\n        \n        if ($leftDepth == 0 || $rightDepth == 0) {\n            return 1 + max($leftDepth, $rightDepth);\n        } else {\n            return 1 + min($leftDepth, $rightDepth);\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func minDepth(_ root: TreeNode?) -> Int {\n        guard let root = root else { return 0 }\n        if root.left == nil && root.right == nil { // Leaf node\n            return 1\n        } else if root.left == nil {\n            return 1 + minDepth(root.right) // Only right child available\n        } else if root.right == nil {\n            return 1 + minDepth(root.left) // Only left child available\n        } else {\n            return 1 + min(minDepth(root.left), minDepth(root.right)) // Both children available\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n \nclass Solution {\n    fun minDepth(root: TreeNode?): Int {\n        if (root == null) {\n            return 0\n        }\n        \n        if (root.left == null && root.right == null) {\n            return 1\n        }\n        \n        val leftDepth = if (root.left != null) minDepth(root.left) else Int.MAX_VALUE\n        val rightDepth = if (root.right != null) minDepth(root.right) else Int.MAX_VALUE\n        \n        return 1 + Math.min(leftDepth, rightDepth)\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc minDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    \n    if root.Left == nil {\n        return 1 + minDepth(root.Right)\n    }\n    \n    if root.Right == nil {\n        return 1 + minDepth(root.Left)\n    }\n    \n    return 1 + min(minDepth(root.Left), minDepth(root.Right))\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef min_depth(root)\n    return 0 if root.nil?\n    if root.left.nil?\n        return 1 + min_depth(root.right)\n    elsif root.right.nil?\n        return 1 + min_depth(root.left)\n    else\n        return 1 + [min_depth(root.left), min_depth(root.right)].min\n    end\nend\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | 'tree_node',\n%%                     right = null :: 'null' | 'tree_node'}).\n\nmin_depth(null) -> 0;\nmin_depth(#tree_node{left = null, right = null}) -> 1;\nmin_depth(#tree_node{left = Left, right = null}) -> 1 + min_depth(Left);\nmin_depth(#tree_node{left = null, right = Right}) -> 1 + min_depth(Right);\nmin_depth(#tree_node{left = Left, right = Right}) -> 1 + min(min_depth(Left), min_depth(Right)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to determine the minimum depth of a binary tree. This is the number of nodes along the shortest path from the root node down to the nearest leaf node. The solution involves a recursive strategy to explore the tree's nodes, calculating the depth from the root to each leaf. \n\n# Explanation\n\n1. **Base Case**: \n   - If the root is `null`, the depth is `0`.\n   \n2. **Leaf Node Check**:\n   - If both the left and right children of the current node are `null`, it is a leaf node, and the depth is `1`.\n\n3. **Recursive Case**:\n   - If the left child is `null`, the minimum depth is `1 + minimum depth of the right subtree`.\n   - If the right child is `null`, the minimum depth is `1 + minimum depth of the left subtree`.\n   - If neither child is `null`, the minimum depth is `1 + the minimum of the minimum depths of both subtrees`.\n\n# Pseudocode\n\n```\nfunction minDepth(root):\n    # Base Case: Empty tree\n    if root is null:\n        return 0\n    \n    # If it's a leaf node\n    if root.left is null and root.right is null:\n        return 1\n    \n    # If left subtree is missing\n    if root.left is null:\n        return 1 + minDepth(root.right)\n    \n    # If right subtree is missing\n    if root.right is null:\n        return 1 + minDepth(root.left)\n    \n    # If both subtrees are present\n    return 1 + min(minDepth(root.left), minDepth(root.right))\n```\n\nThis pseudocode outlines the strategy for finding the minimum depth as described. It uses simple conditional checks and recursion to find and compare the depths of the left and right subtrees recursively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-depth-of-binary-tree"
    },
    {
        "name": "Balanced Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-balanced-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass Solution {\npublic:\n    int checkHeight(TreeNode* root) {\n        if (root == NULL) {\n            return 0;\n        }\n        int leftHeight = checkHeight(root->left);\n        if (leftHeight == -1) {\n            return -1;\n        }\n        int rightHeight = checkHeight(root->right);\n        if (rightHeight == -1) {\n            return -1;\n        }\n        if (abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        }\n        return max(leftHeight, rightHeight) + 1;\n    }\n    \n    bool isBalanced(TreeNode* root) {\n        return checkHeight(root) != -1;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return checkHeight(root) != -1;\n    }\n    \n    private int checkHeight(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int leftHeight = checkHeight(node.left);\n        if (leftHeight == -1) {\n            return -1;\n        }\n        \n        int rightHeight = checkHeight(node.right);\n        if (rightHeight == -1) {\n            return -1;\n        }\n        \n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        }\n        \n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def isBalanced(self, root):\n        def check_height(node):\n            if not node:\n                return 0\n            left_height = check_height(node.left)\n            if left_height == -1:\n                return -1\n            right_height = check_height(node.right)\n            if right_height == -1:\n                return -1\n            if abs(left_height - right_height) > 1:\n                return -1\n            return max(left_height, right_height) + 1\n        \n        return check_height(root) != -1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nint maxDepth(struct TreeNode* root) {\n    if (root == NULL) {\n        return 0;\n    }\n    int leftHeight = maxDepth(root->left);\n    int rightHeight = maxDepth(root->right);\n    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);\n}\n\nbool isBalanced(struct TreeNode* root){\n    if (root == NULL) {\n        return true;\n    }\n    \n    int leftHeight = maxDepth(root->left);\n    int rightHeight = maxDepth(root->right);\n    \n    if (abs(leftHeight - rightHeight) <= 1 && isBalanced(root->left) && isBalanced(root->right)) {\n        return true;\n    }\n    \n    return false;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsBalanced(TreeNode root) {\n        if(root == null) return true;\n        \n        return Math.Abs(Height(root.left) - Height(root.right)) <= 1 && IsBalanced(root.left) && IsBalanced(root.right);\n    }\n    \n    private int Height(TreeNode node) {\n        if(node == null) return 0;\n        \n        return 1 + Math.Max(Height(node.left), Height(node.right));\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\nvar isBalanced = function(root) {\n    const getHeight = (node) => {\n        if (node === null) {\n            return 0;\n        }\n        const leftHeight = getHeight(node.left);\n        const rightHeight = getHeight(node.right);\n        if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        }\n        return Math.max(leftHeight, rightHeight) + 1;\n    };\n    \n    return getHeight(root) !== -1;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction isBalanced(root: TreeNode | null): boolean {\n    function getHeight(node: TreeNode | null): number {\n        if (!node) return 0;\n        const leftHeight = getHeight(node.left);\n        const rightHeight = getHeight(node.right);\n        if (leftHeight === -1 || rightHeight === -1 || Math.abs(leftHeight - rightHeight) > 1)\n            return -1;\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    return getHeight(root) !== -1;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    function isBalanced($root) {\n        if ($root === null) return true;\n        \n        $leftHeight = $this->height($root->left);\n        $rightHeight = $this->height($root->right);\n        \n        if (abs($leftHeight - $rightHeight) > 1) return false;\n        \n        return $this->isBalanced($root->left) && $this->isBalanced($root->right);\n    }\n    \n    function height($node) {\n        if ($node === null) return 0;\n        \n        return 1 + max($this->height($node->left), $this->height($node->right));\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func isBalanced(_ root: TreeNode?) -> Bool {\n        func checkHeight(_ node: TreeNode?) -> Int {\n            if node == nil { return 0 }\n            let leftHeight = checkHeight(node?.left)\n            let rightHeight = checkHeight(node?.right)\n            if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1 {\n                return -1\n            }\n            return max(leftHeight, rightHeight) + 1\n        }\n        \n        return checkHeight(root) != -1\n    }\n}\n\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc isBalanced(root *TreeNode) bool {\n    return checkHeight(root) != -1\n}\n\nfunc checkHeight(node *TreeNode) int {\n    if node == nil {\n        return 0\n    }\n    \n    leftHeight := checkHeight(node.Left)\n    if leftHeight == -1 {\n        return -1\n    }\n    \n    rightHeight := checkHeight(node.Right)\n    if rightHeight == -1 {\n        return -1\n    }\n    \n    if abs(leftHeight-rightHeight) > 1 {\n        return -1\n    }\n    \n    return max(leftHeight, rightHeight) + 1\n}\n\nfunc abs(a int) int {\n    if a < 0 {\n        return -a\n    }\n    return a\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#     end\n# end\n\ndef is_balanced(root)\n    def height(node)\n        return 0 if node.nil?\n        \n        left_height = height(node.left)\n        right_height = height(node.right)\n        \n        return 1 + [left_height, right_height].max\n    end\n    \n    def balanced?(node)\n        return true if node.nil?\n        \n        left_height = height(node.left)\n        right_height = height(node.right)\n        \n        return (left_height - right_height).abs <= 1 && balanced?(node.left) && balanced?(node.right)\n    end\n    \n    balanced?(root)\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given binary tree is height-balanced. A binary tree is considered height-balanced if, for every node, the heights of its left and right subtrees differ by no more than one.\n\n# Explanation:\n1. **Understanding the Problem**: \n    - A tree is height-balanced if the difference between the heights of its left and right subtrees is at most 1 for every node.\n    - We need to recursively calculate the height of the left and right subtrees of each node.\n    - If for any node, the difference in heights exceeds 1, the tree is not balanced.\n   \n2. **Approach**:\n    - A helper function `check_height` can be used to recursively find the heights of the subtrees.\n    - If at any point we find that a subtree is not balanced (difference in heights > 1), we can return -1 to signify that the tree is not balanced.\n    - The main function `isBalanced` will invoke `check_height` on the root and return whether the tree is height-balanced.\n\n# Pseudocode:\n```python\n# Pseudocode for checking if a binary tree is height-balanced\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isBalanced(self, root):\n        # Helper function to check the height of the tree and determine balance\n        def check_height(node):\n            if not node:\n                return 0  # Base case: height of empty tree is 0\n            \n            # Recursively get the height of the left subtree\n            left_height = check_height(node.left)\n            if left_height == -1:\n                return -1  # Left subtree is not balanced\n            \n            # Recursively get the height of the right subtree\n            right_height = check_height(node.right)\n            if right_height == -1:\n                return -1  # Right subtree is not balanced\n            \n            # If the height difference is greater than 1, return -1 indicating unbalanced\n            if abs(left_height - right_height) > 1:\n                return -1  # Current tree is not balanced\n            \n            # Return the height of the tree rooted at the current node\n            return max(left_height, right_height) + 1\n        \n        # Check if the whole tree is balanced using the helper function\n        return check_height(root) != -1\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-balanced-binary-tree"
    },
    {
        "name": "Convert Sorted Array To Binary Search Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-convert-sorted-array-to-binary-search-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        if (nums.empty()) {\n            return nullptr;\n        }\n        return helper(nums, 0, nums.size() - 1);\n    }\n    \n    TreeNode* helper(vector<int>& nums, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = left + (right - left) / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n        root->left = helper(nums, left, mid - 1);\n        root->right = helper(nums, mid + 1, right);\n        return root;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return convertToBST(nums, 0, nums.length - 1);\n    }\n    \n    private TreeNode convertToBST(int[] nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        \n        int mid = start + (end - start) / 2;\n        TreeNode node = new TreeNode(nums[mid]);\n        node.left = convertToBST(nums, start, mid - 1);\n        node.right = convertToBST(nums, mid + 1, end);\n        \n        return node;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n    \nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* sortedArrayToBST(int* nums, int numsSize){\n    if(numsSize == 0) return NULL;\n    \n    int mid = numsSize / 2;\n    \n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = nums[mid];\n    \n    root->left = sortedArrayToBST(nums, mid);\n    root->right = sortedArrayToBST(nums + mid + 1, numsSize - mid - 1);\n    \n    return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode SortedArrayToBST(int[] nums) {\n        if(nums == null || nums.Length == 0) {\n            return null;\n        }\n        return BuildTree(nums, 0, nums.Length - 1);\n    }\n    \n    private TreeNode BuildTree(int[] nums, int left, int right) {\n        if(left > right) {\n            return null;\n        }\n        \n        int mid = left + (right - left) / 2;\n        TreeNode node = new TreeNode(nums[mid]);\n        \n        node.left = BuildTree(nums, left, mid - 1);\n        node.right = BuildTree(nums, mid + 1, right);\n        \n        return node;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n *\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n    if (nums.length === 0) return null;\n    \n    const mid = Math.floor(nums.length / 2);\n    const node = new TreeNode(nums[mid]);\n    \n    node.left = sortedArrayToBST(nums.slice(0, mid));\n    node.right = sortedArrayToBST(nums.slice(mid + 1));\n    \n    return node;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction sortedArrayToBST(nums: number[]): TreeNode | null {\n    if (nums.length === 0) return null;\n    const mid = Math.floor(nums.length / 2);\n    const root = new TreeNode(nums[mid]);\n    root.left = sortedArrayToBST(nums.slice(0, mid));\n    root.right = sortedArrayToBST(nums.slice(mid + 1));\n    return root;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param Integer[] $nums\n     * @return TreeNode\n     */\n    function sortedArrayToBST($nums) {\n        if (empty($nums)) {\n            return null;\n        }\n        \n        $mid = (int)(count($nums) / 2);\n        \n        $root = new TreeNode($nums[$mid]);\n        \n        $root->left = $this->sortedArrayToBST(array_slice($nums, 0, $mid));\n        $root->right = $this->sortedArrayToBST(array_slice($nums, $mid+1));\n        \n        return $root;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func sortedArrayToBST(_ nums: [Int]) -> TreeNode? {\n        if nums.isEmpty {\n            return nil\n        }\n        let mid = nums.count / 2\n        let node = TreeNode(nums[mid])\n        node.left = sortedArrayToBST(Array(nums[0..<mid]))\n        node.right = sortedArrayToBST(Array(nums[(mid + 1)...]))\n        return node\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n    mid := len(nums) / 2\n    root := &TreeNode{Val: nums[mid]}\n    root.Left = sortedArrayToBST(nums[:mid])\n    root.Right = sortedArrayToBST(nums[mid+1:])\n    return root\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef sorted_array_to_bst(nums)\n    return nil if nums.empty?\n    \n    mid = nums.length / 2\n    \n    node = TreeNode.new(nums[mid])\n    node.left = sorted_array_to_bst(nums[0...mid])\n    node.right = sorted_array_to_bst(nums[mid+1..-1])\n    \n    return node\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode \n= null, _right: TreeNode = null) {\n */\nobject Solution {\n    def sortedArrayToBST(nums: Array[Int]): TreeNode = {\n        def helper(left: Int, right: Int): TreeNode = {\n            if (left > right) return null\n            val mid = left + (right - left) / 2\n            val root = new TreeNode(nums(mid))\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            root\n        }\n        helper(0, nums.length - 1)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a sorted array into a height-balanced binary search tree (BST). Here's the detailed explanation and the pseudocode for it.\n\n### # Explanation\nA height-balanced binary search tree is one in which the depth of the two subtrees of every node never differs by more than one. To achieve this:\n1. The middle element of the array will be selected as the root node. This ensures that the tree remains balanced.\n2. Recursively apply this approach to the left half of the array to create the left subtree.\n3. Recursively apply this approach to the right half of the array to create the right subtree.\n4. Continue this until there are no elements left to create nodes with.\n\nThe above approach ensures that at each step, the tree is split almost evenly, resulting in a balanced BST.\n\n### # Pseudocode\n```plaintext\nfunction sortedArrayToBST(nums):\n    if nums is empty:\n        return null\n\n    mid = length(nums) // 2\n    root = create new TreeNode with value nums[mid]\n    \n    root.left = sortedArrayToBST(nums from start to mid-1)\n    root.right = sortedArrayToBST(nums from mid+1 to end)\n    \n    return root\n```\n\nIn this pseudocode:\n- `sortedArrayToBST(nums)` is a function that accepts the sorted array `nums`.\n- It first checks if the input array is empty. If it is, it returns `null` indicating no node.\n- It then finds the middle index of the array and creates a new tree node with the middle element as the root.\n- The function then recursively sets the left child of the root to be the result of `sortedArrayToBST` called on the left half of the array.\n- Similarly, it recursively sets the right child of the root to be the result of `sortedArrayToBST` called on the right half of the array.\n- Finally, it returns the root node, which has left and right subtrees built recursively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-convert-sorted-array-to-binary-search-tree"
    },
    {
        "name": "Binary Tree Level Order Traversal Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-level-order-traversal-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> result;\n        if (root == nullptr) {\n            return result;\n        }\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> level;\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode* curr = q.front();\n                q.pop();\n                level.push_back(curr->val);\n                \n                if (curr->left) {\n                    q.push(curr->left);\n                }\n                \n                if (curr->right) {\n                    q.push(curr->right);\n                }\n            }\n            \n            result.insert(result.begin(), level);\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> currLevel = new ArrayList<>();\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                currLevel.add(node.val);\n                \n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                \n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            \n            result.add(0, currLevel);\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        if not root:\n            return []\n        \n        result = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level_vals = []\n            \n            for _ in range(size):\n                node = queue.pop(0)\n                level_vals.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.insert(0, level_vals)\n        \n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint getHeight(struct TreeNode* root){\n    if(root == NULL){\n        return 0;\n    }\n    \n    int leftHeight = getHeight(root->left);\n    int rightHeight = getHeight(root->right);\n    \n    return leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;\n}\n\nvoid getLevelNodes(struct TreeNode* root, int level, int* levelSize, int** result){\n    if(root == NULL){\n        return;\n    }\n    \n    result[level][levelSize[level]++] = root->val;\n    \n    getLevelNodes(root->left, level - 1, levelSize, result);\n    getLevelNodes(root->right, level - 1, levelSize, result);\n}\n\nint** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int height = getHeight(root);\n    \n    *returnSize = height;\n    \n    int** result = (int**)malloc(sizeof(int*) * height);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * height);\n    \n    for(int i=0; i<height; i++){\n        result[i] = (int*)malloc(sizeof(int) * 2000);\n        (*returnColumnSizes)[i] = 0;\n    }\n    \n    getLevelNodes(root, height - 1, *returnColumnSizes, result);\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<IList<int>> LevelOrderBottom(TreeNode root) {\n        IList<IList<int>> result = new List<IList<int>>();\n        if (root == null) return result;\n        \n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        \n        while(queue.Count > 0) {\n            int levelSize = queue.Count;\n            IList<int> currentLevel = new List<int>();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.Dequeue();\n                currentLevel.Add(node.val);\n                \n                if (node.left != null) queue.Enqueue(node.left);\n                if (node.right != null) queue.Enqueue(node.right);\n            }\n            \n            result.Insert(0, currentLevel);\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nvar levelOrderBottom = function(root) {\n    if (!root) return [];\n    \n    const result = [];\n    const queue = [root];\n    \n    while (queue.length) {\n        const level = [];\n        const size = queue.length;\n        \n        for (let i = 0; i < size; i++) {\n            const node = queue.shift();\n            level.push(node.val);\n            \n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        result.unshift(level);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n */\nfunction levelOrderBottom(root: TreeNode | null): number[][] {\n    const result: number[][] = [];\n    if (!root) {\n        return result;\n    }\n    \n    const queue: TreeNode[] = [root];\n    \n    while (queue.length > 0) {\n        const level: number[] = [];\n        const size = queue.length;\n        for (let i = 0; i < size; i++) {\n            const node = queue.shift();\n            if (node) {\n                level.push(node.val);\n                if (node.left) queue.push(node.left);\n                if (node.right) queue.push(node.right);\n            }\n        }\n        result.unshift(level);\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[][]\n     */\n    function levelOrderBottom($root) {\n        $result = [];\n        if ($root === null) {\n            return $result;\n        }\n        \n        $queue = [];\n        array_push($queue, $root);\n        \n        while (!empty($queue)) {\n            $level = [];\n            $size = count($queue);\n            \n            for ($i = 0; $i < $size; $i++) {\n                $node = array_shift($queue);\n                $level[] = $node->val;\n                \n                if ($node->left !== null) {\n                    array_push($queue, $node->left);\n                }\n                \n                if ($node->right !== null) {\n                    array_push($queue, $node->right);\n                }\n            }\n            \n            array_unshift($result, $level);\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc levelOrderBottom(root *TreeNode) [][]int {\n    if root == nil {\n        return [][]int{}\n    }\n    \n    var result [][]int\n    queue := []*TreeNode{root}\n    \n    for len(queue) > 0 {\n        var level []int\n        size := len(queue)\n        for i := 0; i < size; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            \n            level = append(level, node.Val)\n            \n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n        result = append([][]int{level}, result...)\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef level_order_bottom(root)\n    return [] if root.nil?\n    result = []\n    queue = [root]\n\n    while !queue.empty?\n        level_size = queue.size\n        level_nodes = []\n\n        level_size.times do\n            node = queue.shift\n            level_nodes << node.val\n\n            queue << node.left if node.left\n            queue << node.right if node.right\n        end\n\n        result.unshift(level_nodes)\n    end\n\n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode \n= null, _right: TreeNode = null) {\n *     var value: Int = _value\n *     var left: TreeNode = _left\n *     var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def levelOrderBottom(root: TreeNode): List[List[Int]] = {\n        import scala.collection.mutable.Queue\n        if (root == null) return List()\n\n        val result = scala.collection.mutable.ListBuffer[List[Int]]()\n        val queue = Queue[TreeNode]()\n\n        queue.enqueue(root)\n\n        while (queue.nonEmpty) {\n            val level = scala.collection.mutable.ListBuffer[Int]()\n            val size = queue.size\n\n            for (_ <- 0 until size) {\n                val node = queue.dequeue()\n                level += node.value\n                if (node.left != null) queue.enqueue(node.left)\n                if (node.right != null) queue.enqueue(node.right)\n            }\n\n            result.prepend(level.toList)\n        }\n\n        result.toList\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform a bottom-up level order traversal of a given binary tree. This means we will traverse the tree level-by-level, starting from the leaves and moving up to the root.\n\n### # Explanation\n1. **Check if the tree is empty**: If the input root is null, return an empty list.\n2. **Initialize data structures**: \n   - `result` to store the final bottom-up level order traversal.\n   - `queue` to facilitate level order traversal using a breadth-first search approach.\n3. **Level Order Traversal using a Queue**:\n   - Iterate while there are nodes in the queue.\n   - For each level, store the node values in a temporary list (`level_vals`).\n   - Add the children of the current level nodes to the queue for the next iteration.\n   - Insert the level values at the beginning of the `result` list.\n4. **Return the `result`** which now contains the values from bottom to top.\n\n### # Pseudocode\n\n```text\n# Pseudocode\n\nfunction levelOrderBottom(root):\n    # If tree is empty\n    if root is null:\n        return []\n\n    # Initialize result list and queue\n    result = []\n    queue = [root]\n\n    # Process nodes level by level\n    while queue is not empty:\n        size = length of queue\n        level_vals = []\n\n        # Traverse all nodes at the current level\n        for i from 0 to size-1:\n            node = pop the first element of the queue\n            append node.val to level_vals\n            \n            # Add the left child to the queue if it exists\n            if node.left is not null:\n                append node.left to queue\n            \n            # Add the right child to the queue if it exists\n            if node.right is not null:\n                append node.right to queue\n                \n        # Insert current level values at the beginning of result\n        insert level_vals at the 0th index of result\n\n    # Return the result containing bottom-up level order traversal\n    return result\n```\n\nThis pseudocode outlines the approach for achieving a bottom-up level order traversal of a binary tree. By inserting each level at the start of the result list, we ensure that the final order is from bottom to top.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-level-order-traversal-ii"
    },
    {
        "name": "Construct Binary Tree From Inorder And Postorder Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-construct-binary-tree-from-inorder-and-postorder-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        unordered_map<int, int> inorder_map;\n        for (int i = 0; i < inorder.size(); ++i) {\n            inorder_map[inorder[i]] = i;\n        }\n        return buildTreeHelper(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1, inorder_map);\n    }\n    \n    TreeNode* buildTreeHelper(vector<int>& inorder, int in_start, int in_end, vector<int>& postorder, int post_start, int post_end, unordered_map<int, int>& inorder_map) {\n        if (in_start > in_end || post_start > post_end) {\n            return nullptr;\n        }\n        \n        int root_val = postorder[post_end];\n        TreeNode* root = new TreeNode(root_val);\n        \n        int root_idx = inorder_map[root_val];\n        int left_size = root_idx - in_start;\n        \n        root->left = buildTreeHelper(inorder, in_start, root_idx - 1, postorder, post_start, post_start + left_size - 1, inorder_map);\n        root->right = buildTreeHelper(inorder, root_idx + 1, in_end, postorder, post_start + left_size, post_end - 1, inorder_map);\n        \n        return root;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, postorder, postorder.length - 1, 0, inorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int postEnd, int inStart, int inEnd) {\n        if (inStart > inEnd) {\n            return null;\n        }\n\n        TreeNode root = new TreeNode(postorder[postEnd]);\n        int inIndex = 0;\n        for (int i = inStart; i <= inEnd; i++) {\n            if (inorder[i] == root.val) {\n                inIndex = i;\n            }\n        }\n\n        root.right = buildTreeHelper(inorder, postorder, postEnd - 1, inIndex + 1, inEnd);\n        root.left = buildTreeHelper(inorder, postorder, postEnd - (inEnd - inIndex) - 1, inStart, inIndex - 1);\n\n        return root;\n    }\n}\n\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){\n    if(inorderSize == 0) return NULL;\n    \n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = postorder[postorderSize - 1];\n    \n    int idx = 0;\n    for(int i = 0; i < inorderSize; i++) {\n        if(inorder[i] == root->val) {\n            idx = i;\n            break;\n        }\n    }\n    \n    root->left = buildTree(inorder, idx, postorder, idx);\n    root->right = buildTree(inorder + idx + 1, inorderSize - idx - 1, postorder + idx, postorderSize - idx - 1);\n    \n    return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\n        return BuildTreeHelper(inorder, postorder, 0, inorder.Length - 1, 0, postorder.Length - 1);\n    }\n    \n    private TreeNode BuildTreeHelper(int[] inorder, int[] postorder, int inStart, int inEnd, int postStart, int postEnd) {\n        if (inStart > inEnd || postStart > postEnd) {\n            return null;\n        }\n        \n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n        \n        int inIndex = 0;\n        for (int i = inStart; i <= inEnd; i++) {\n            if (inorder[i] == rootValue) {\n                inIndex = i;\n                break;\n            }\n        }\n        \n        int leftSize = inIndex - inStart;\n        \n        root.left = BuildTreeHelper(inorder, postorder, inStart, inIndex - 1, postStart, postStart + leftSize - 1);\n        root.right = BuildTreeHelper(inorder, postorder, inIndex + 1, inEnd, postStart + leftSize, postEnd - 1);\n        \n        return root;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n */\n\nvar buildTree = function(inorder, postorder) {\n    const build = (inStart, inEnd, postStart, postEnd) => {\n        if (inStart > inEnd || postStart > postEnd) return null;\n        \n        const rootVal = postorder[postEnd];\n        const root = new TreeNode(rootVal);\n        \n        let inIndex = inorder.indexOf(rootVal);\n        let leftSize = inIndex - inStart;\n        \n        root.left = build(inStart, inIndex - 1, postStart, postStart + leftSize - 1);\n        root.right = build(inIndex + 1, inEnd, postStart + leftSize, postEnd - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n    if (inorder.length === 0 || postorder.length === 0) {\n        return null;\n    }\n    \n    const rootVal = postorder.pop()!;\n    const root = new TreeNode(rootVal);\n    \n    const rootIndex = inorder.indexOf(rootVal);\n    \n    root.right = buildTree(inorder.slice(rootIndex + 1), postorder);\n    root.left = buildTree(inorder.slice(0, rootIndex), postorder);\n    \n    return root;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\n\nclass Solution {\n\n    private $inorderIndexMap;\n    private $postorder;\n    private $inorder;\n\n    function buildTree($inorder, $postorder) {\n        $this->postorder = $postorder;\n        $this->inorder = $inorder;\n\n        $this->inorderIndexMap = array_flip($inorder);\n        return $this->build(0, count($inorder) - 1, 0, count($postorder) - 1);\n    }\n\n    function build($inorderStart, $inorderEnd, $postorderStart, $postorderEnd) {\n        if ($postorderStart > $postorderEnd) {\n            return null;\n        }\n\n        $rootValue = $this->postorder[$postorderEnd];\n        $root = new TreeNode($rootValue);\n\n        $index = $this->inorderIndexMap[$rootValue];\n\n        $numLeft = $index - $inorderStart;\n        $root->left = $this->build($inorderStart, $index - 1, $postorderStart, $postorderStart + $numLeft - 1);\n        $root->right = $this->build($index + 1, $inorderEnd, $postorderStart + $numLeft, $postorderEnd - 1);\n\n        return $root;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    var index = [Int: Int]()\n\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\n        for (index, num) in inorder.enumerated() {\n            self.index[num] = index\n        }\n        return buildNode(inorder, 0, inorder.count - 1, postorder, 0, postorder.count - 1)\n    }\n\n    func buildNode(_ inorder: [Int], _ inStart: Int, _ inEnd: Int, _ postorder: [Int], _ postStart: Int, _ postEnd: Int) -> TreeNode? {\n        if inStart > inEnd || postStart > postEnd {\n            return nil\n        }\n        let rootVal = postorder[postEnd]\n        let rootIndex = index[rootVal]!\n\n        let root = TreeNode(rootVal)\n        let leftSize = rootIndex - inStart\n        root.left = buildNode(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1)\n        root.right = buildNode(inorder, rootIndex + 1, inEnd, postorder, postStart + leftSize, postEnd - 1)\n\n        return root\n    }\n}\n "
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc buildTree(inorder []int, postorder []int) *TreeNode {\n    if len(inorder) == 0 {\n        return nil\n    }\n    \n    rootVal := postorder[len(postorder)-1]\n    root := &TreeNode{Val: rootVal}\n    \n    i := 0\n    for ; i < len(inorder); i++ {\n        if inorder[i] == rootVal {\n            break\n        }\n    }\n    \n    root.Left = buildTree(inorder[:i], postorder[:i])\n    root.Right = buildTree(inorder[i+1:], postorder[i:len(postorder)-1])\n    \n    return root\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef build_tree(inorder, postorder)\n    return nil if inorder.empty?\n    \n    root_val = postorder.pop\n    root_index = inorder.index(root_val)\n    \n    root = TreeNode.new(root_val)\n    \n    root.right = build_tree(inorder[root_index + 1..-1], postorder)\n    root.left = build_tree(inorder[0...root_index], postorder)\n    \n    root\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        fn helper(inorder: &[i32], postorder: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\n            if postorder.is_empty() {\n                return None;\n            }\n        \n            let root_val = postorder[postorder.len() - 1];\n            let mut root = TreeNode {\n                val: root_val,\n                left: None,\n                right: None,\n            };\n        \n            let mut inorder_idx = 0;\n            while inorder[inorder_idx] != root_val {\n                inorder_idx += 1;\n            }\n        \n            let inorder_left = &inorder[..inorder_idx];\n            let inorder_right = &inorder[inorder_idx + 1..];\n        \n            let postorder_left = &postorder[..inorder_idx];\n            let postorder_right = &postorder[inorder_idx..postorder.len() - 1];\n        \n            root.left = helper(inorder_left, postorder_left);\n            root.right = helper(inorder_right, postorder_right);\n        \n            Some(Rc::new(RefCell::new(root)))\n        }\n    \n        helper(&inorder, &postorder)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to construct a binary tree given its inorder and postorder traversal arrays. This challenge requires understanding how these traversal methods relate to the structure of a binary tree.\n\nThe core idea is to use the properties of inorder and postorder traversals:\n- In postorder traversal, the last element is always the root of the subtree.\n- In inorder traversal, the elements to the left of the root are in the left subtree, and the elements to the right of the root are in the right subtree.\n\nHere\u2019s a structured approach to solve this problem:\n\n# Explanation\n\n1. **Identify the Root**: The last element in the postorder array is the root.\n2. **Find Root Index in Inorder Array**: Locate this root in the inorder array to split it into left and right subtrees.\n3. **Recursively Construct Subtrees**:\n   - For the left subtree, use the portion of the inorder array before the root, and the corresponding portion in the postorder array.\n   - For the right subtree, use the portion of the inorder array after the root, and the corresponding portion in the postorder array.\n4. **Base Case**: If the current segment of inorder or postorder is empty, return `None`.\n\n# Pseudocode\n\n```\nfunction buildTree(inorder, postorder):\n\n    # Helper function to construct the tree\n    function build(inStart, inEnd, postStart, postEnd):\n        if inStart > inEnd or postStart > postEnd:\n            return null\n        \n        # The last element in postorder segment is the root\n        rootValue = postorder[postEnd]\n        root = new TreeNode(rootValue)\n        \n        # Find the index of the root in inorder segment\n        rootIndex = index of rootValue in inorder array\n        \n        # Calculate the size of the left subtree\n        leftTreeSize = rootIndex - inStart\n        \n        # Recursively build the left and right subtrees\n        root.left = build(inStart, rootIndex - 1, postStart, postStart + leftTreeSize - 1)\n        root.right = build(rootIndex + 1, inEnd, postStart + leftTreeSize, postEnd - 1)\n        \n        return root\n    \n    # Initialize\n    return build(0, length of inorder - 1, 0, length of postorder - 1)\n```\n\nBy implementing this logic, we will be able to construct the binary tree from the given inorder and postorder traversal arrays. This process ensures that the tree respects the given traversals and preserves the properties of binary trees.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-construct-binary-tree-from-inorder-and-postorder-traversal"
    },
    {
        "name": "Minimum Number Of Arrows To Burst Balloons",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-number-of-arrows-to-burst-balloons",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& points) {\n        if (points.empty()) {\n            return 0;\n        }\n        sort(points.begin(), points.end(), [](vector<int>& a, vector<int>& b) {\n            return a[1] < b[1];\n        });\n        int arrows = 1;\n        int end = points[0][1];\n        for (int i = 1; i < points.size(); i++) {\n            if (points[i][0] > end) {\n                arrows++;\n                end = points[i][1];\n            }\n        }\n        return arrows;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        if (points == null || points.length == 0) {\n            return 0;\n        }\n        \n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\n        \n        int arrows = 1;\n        int end = points[0][1];\n        \n        for (int i = 1; i < points.length; i++) {\n            if (points[i][0] > end) {\n                arrows++;\n                end = points[i][1];\n            }\n        }\n        \n        return arrows;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findMinArrowShots(self, points):\n        if not points:\n            return 0\n        \n        points.sort(key=lambda x: x[1])\n        arrows = 1\n        end = points[0][1]\n        \n        for i in range(1, len(points)):\n            if points[i][0] > end:\n                arrows += 1\n                end = points[i][1]\n        \n        return arrows"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindMinArrowShots(int[][] points) {\n        if (points == null || points.Length == 0) return 0;\n        \n        Array.Sort(points, (a, b) => a[1].CompareTo(b[1]));\n        \n        int arrows = 1;\n        int end = points[0][1];\n        \n        for (int i = 1; i < points.Length; i++) {\n            if (points[i][0] > end) {\n                arrows++;\n                end = points[i][1];\n            }\n        }\n        \n        return arrows;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar findMinArrowShots = function(points) {\n    if (points.length === 0) return 0;\n    \n    points.sort((a, b) => a[1] - b[1]);\n    \n    let arrows = 1;\n    let currEnd = points[0][1];\n    \n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > currEnd) {\n            arrows++;\n            currEnd = points[i][1];\n        }\n    }\n    \n    return arrows;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findMinArrowShots(points: number[][]): number {\n    if (points.length === 0) return 0;\n    \n    points.sort((a, b) => a[1] - b[1]);\n    \n    let arrows = 1;\n    let end = points[0][1];\n    \n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > end) {\n            arrows++;\n            end = points[i][1];\n        }\n    }\n    \n    return arrows;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $points\n     */\n    function findMinArrowShots($points) {\n        if (empty($points)) return 0;\n        \n        usort($points, function($a, $b) {\n            return $a[1] <=> $b[1];\n        });\n        \n        $arrows = 1;\n        $end = $points[0][1];\n        \n        foreach ($points as $point) {\n            if ($point[0] > $end) {\n                $arrows++;\n                $end = $point[1];\n            }\n        }\n        \n        return $arrows;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findMinArrowShots(_ points: [[Int]]) -> Int {\n        guard points.count > 0 else {\n            return 0\n        }\n        \n        let sortedPoints = points.sorted { $0[1] < $1[1] }\n        var arrows = 1\n        var end = sortedPoints[0][1]\n        \n        for i in 1..<sortedPoints.count {\n            if sortedPoints[i][0] > end {\n                arrows += 1\n                end = sortedPoints[i][1]\n            }\n        }\n        \n        return arrows\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findMinArrowShots(points: Array<IntArray>): Int {\n        if (points.isEmpty()) return 0\n        points.sortBy { it[1] }\n        \n        var arrows = 1\n        var end = points[0][1]\n        \n        for (i in 1 until points.size) {\n            if (points[i][0] > end) {\n                arrows++\n                end = points[i][1]\n            }\n        }\n        \n        return arrows\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int findMinArrowShots(List<List<int>> points) {\n    if (points.isEmpty) return 0;\n    \n    points.sort((a, b) => a[1].compareTo(b[1]));\n    \n    int arrows = 1;\n    int end = points[0][1];\n    \n    for (int i = 1; i < points.length; i++) {\n      if (points[i][0] > end) {\n        arrows++;\n        end = points[i][1];\n      }\n    }\n    \n    return arrows;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findMinArrowShots(points [][]int) int {\n    if len(points) == 0 {\n        return 0\n    }\n\n    sort.Slice(points, func(i, j int) bool {\n        return points[i][1] < points[j][1]\n    })\n\n    arrows := 1\n    end := points[0][1]\n\n    for i := 1; i < len(points); i++ {\n        if points[i][0] > end {\n            arrows++\n            end = points[i][1]\n        }\n    }\n\n    return arrows\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} points\n# @return {Integer}\ndef find_min_arrow_shots(points)\n    return 0 if points.empty?\n    points.sort_by!{ |p| p[1] }\n    arrows = 1\n    end_pos = points[0][1]\n    \n    (1...points.length).each do |i|\n        if points[i][0] > end_pos\n            arrows += 1\n            end_pos = points[i][1]\n        end\n    end\n    \n    return arrows\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findMinArrowShots(points: Array[Array[Int]]): Int = {\n        if (points.isEmpty) return 0\n        \n        val sortedPoints = points.sortBy(_.last)\n        \n        var arrows = 1\n        var end = sortedPoints(0)(1)\n        \n        for (i <- 1 until sortedPoints.length) {\n            if (sortedPoints(i)(0) > end) {\n                arrows += 1\n                end = sortedPoints(i)(1)\n            }\n        }\n        \n        arrows\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_min_arrow_shots(points: Vec<Vec<i32>>) -> i32 {\n        if points.is_empty() {\n            return 0;\n        }\n        \n        let mut points = points;\n        points.sort_by_key(|x| x[1]);\n        \n        let mut arrows = 1;\n        let mut end = points[0][1];\n        \n        for i in 1..points.len() {\n            if points[i][0] > end {\n                arrows += 1;\n                end = points[i][1];\n            }\n        }\n        \n        arrows\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will devise a plan to efficiently determine the minimum number of arrows required to burst all given balloons. \n\n# Explanation\n1. **Sort the Balloons:** First, sort the list of balloons based on their end points (`xend`). Sorting helps in ensuring that we can select an arrow placement that can burst the maximum number of currently considered balloons.\n   \n2. **Initialize Arrows:** Start with the first balloon and assume we need at least one arrow.\n   \n3. **Determine Arrow Placement:** Place an arrow at the `xend` of the current balloon. For each subsequent balloon, check if its `xstart` is greater than the end of the current segment (where the last arrow was placed).\n   \n4. **Increment Arrow Count:** If a balloon's `xstart` is beyond the range of the current arrow, increment the arrow count and place a new arrow at this balloon's `xend`.\n\n5. **Repeat:** Continue this until all balloons have been considered.\n\nThis approach ensures that we always use the minimal number of arrows needed by trying to maximize the number of balloons burst by each consecutive arrow.\n\n# Pseudocode\n\n```\nclass Solution:\n    def findMinArrowShots(points):\n        # If there are no balloons, return 0\n        if not points:\n            return 0\n\n        # Sort balloons based on the end points\n        points.sort(key=lambda x: x[1])\n        \n        # Initialize number of arrows\n        arrows = 1\n\n        # Place an arrow at the end of the first balloon\n        current_end = points[0][1]\n\n        # Iterate through the rest of the balloons\n        for i in range(1, len(points)):\n            # If the start of the current balloon is beyond the reach of the last arrow\n            if points[i][0] > current_end:\n                # Increment the arrow count\n                arrows += 1\n                # Update the position where the new arrow is shot\n                current_end = points[i][1]\n\n        # Return the total number of arrows needed\n        return arrows\n\n# Example usage:\n# points = [[10,16],[2,8],[1,6],[7,12]]\n# Sol = Solution()\n# print(Sol.findMinArrowShots(points))  # Output: 2\n```\n\nThis methodology leverages sorting to help minimize the number of arrows used and employs a greedy approach to ensure the optimal solution.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-number-of-arrows-to-burst-balloons"
    },
    {
        "name": "4Sum Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-4sum-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int, int> mapAB;\n        int count = 0;\n        \n        for (int a : nums1) {\n            for (int b : nums2) {\n                mapAB[a + b]++;\n            }\n        }\n        \n        for (int c : nums3) {\n            for (int d : nums4) {\n                if (mapAB.find(-c - d) != mapAB.end()) {\n                    count += mapAB[-c - d];\n                }\n            }\n        }\n        \n        return count;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int count = 0;\n        \n        for (int num1 : nums1) {\n            for (int num2 : nums2) {\n                int sum = num1 + num2;\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n            }\n        }\n        \n        for (int num3 : nums3) {\n            for (int num4 : nums4) {\n                int target = - (num3 + num4);\n                count += map.getOrDefault(target, 0);\n            }\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def fourSumCount(self, nums1, nums2, nums3, nums4):\n        count = 0\n        sum_map = {}\n        \n        for i in nums1:\n            for j in nums2:\n                if i + j in sum_map:\n                    sum_map[i + j] += 1\n                else:\n                    sum_map[i + j] = 1\n        \n        for k in nums3:\n            for l in nums4:\n                if -k - l in sum_map:\n                    count += sum_map[-k - l]\n        \n        return count"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int cmp(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint fourSumCount(int* nums1, int nums1Size, int* nums2, int nums2Size, int* nums3, int nums3Size, int* nums4, int nums4Size) {\n    int count = 0;\n    int *sumsAB = (int*)malloc(nums1Size * nums2Size * sizeof(int));\n    int *sumsCD = (int*)malloc(nums3Size * nums4Size * sizeof(int));\n    \n    for(int i = 0; i < nums1Size; i++) {\n        for(int j = 0; j < nums2Size; j++) {\n            sumsAB[i*nums2Size + j] = nums1[i] + nums2[j];\n        }\n    }\n    \n    for(int i = 0; i < nums3Size; i++) {\n        for(int j = 0; j < nums4Size; j++) {\n            sumsCD[i*nums4Size + j] = nums3[i] + nums4[j];\n        }\n    }\n    \n    qsort(sumsAB, nums1Size * nums2Size, sizeof(int), cmp);\n    qsort(sumsCD, nums3Size * nums4Size, sizeof(int), cmp);\n    \n    int i = 0, j = nums3Size * nums4Size - 1;\n    while(i < nums1Size * nums2Size && j >= 0) {\n        if(sumsAB[i] + sumsCD[j] == 0) {\n            int cnt1 = 1, cnt2 = 1;\n            i++; j--;\n            while(i < nums1Size * nums2Size && sumsAB[i] == sumsAB[i - 1]) {\n                i++;\n                cnt1++;\n            }\n            while(j >= 0 && sumsCD[j] == sumsCD[j + 1]) {\n                j--;\n                cnt2++;\n            }\n            count += cnt1 * cnt2;\n        } else if(sumsAB[i] + sumsCD[j] < 0) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    \n    free(sumsAB);\n    free(sumsCD);\n    \n    return count;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        Dictionary<int, int> map = new Dictionary<int, int>();\n        int count = 0;\n        \n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                int sum1 = num1 + num2;\n                if (!map.ContainsKey(sum1)) {\n                    map[sum1] = 0;\n                }\n                map[sum1]++;\n            }\n        }\n        \n        foreach (var num3 in nums3) {\n            foreach (var num4 in nums4) {\n                int sum2 = -(num3 + num4);\n                if (map.ContainsKey(sum2)) {\n                    count += map[sum2];\n                }\n            }\n        }\n        \n        return count;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[]} nums3\n * @param {number[]} nums4\n * @return {number}\n */\nconst fourSumCount = (nums1, nums2, nums3, nums4) => {\n    const map = new Map();\n    let count = 0;\n\n    for (const num1 of nums1) {\n        for (const num2 of nums2) {\n            const sum = num1 + num2;\n            map.set(sum, (map.get(sum) || 0) + 1);\n        }\n    }\n\n    for (const num3 of nums3) {\n        for (const num4 of nums4) {\n            const target = -1 * (num3 + num4);\n            if (map.has(target)) {\n                count += map.get(target);\n            }\n        }\n    }\n\n    return count;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {\n    const map: Map<number, number> = new Map();\n    \n    let count = 0;\n    \n    for (let num1 of nums1) {\n        for (let num2 of nums2) {\n            const sum1_2 = num1 + num2;\n            if (map.has(sum1_2)) {\n                map.set(sum1_2, map.get(sum1_2)! + 1);\n            } else {\n                map.set(sum1_2, 1);\n            }\n        }\n    }\n    \n    for (let num3 of nums3) {\n        for (let num4 of nums4) {\n            const sum3_4 = num3 + num4;\n            if (map.has(-sum3_4)) {\n                count += map.get(-sum3_4)!;\n            }\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @param Integer[] $nums3\n     * @param Integer[] $nums4\n     * @return Integer\n     */\n    function fourSumCount($nums1, $nums2, $nums3, $nums4) {\n        $map = [];\n        $count = 0;\n        foreach ($nums1 as $num1) {\n            foreach ($nums2 as $num2) {\n                $sum = $num1 + $num2;\n                if (array_key_exists($sum, $map)) {\n                    $map[$sum]++;\n                } else {\n                    $map[$sum] = 1;\n                }\n            }\n        }\n        \n        foreach ($nums3 as $num3) {\n            foreach ($nums4 as $num4) {\n                $target = -$num3 - $num4;\n                if (array_key_exists($target, $map)) {\n                    $count += $map[$target];\n                }\n            }\n        }\n        \n        return $count;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func fourSumCount(_ nums1: [Int], _ nums2: [Int], _ nums3: [Int], _ nums4: [Int]) -> Int {\n        var count = 0\n        var sum1and2 = [Int: Int]()\n        \n        for num1 in nums1 {\n            for num2 in nums2 {\n                let sum = num1 + num2\n                sum1and2[sum, default: 0] += 1\n            }\n        }\n        \n        for num3 in nums3 {\n            for num4 in nums4 {\n                let target = -(num3 + num4)\n                if let val = sum1and2[target] {\n                    count += val\n                }\n            }\n        }\n        \n        return count\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun fourSumCount(nums1: IntArray, nums2: IntArray, nums3: IntArray, nums4: IntArray): Int {\n        val map = mutableMapOf<Int, Int>()\n        var count = 0\n        \n        for (num1 in nums1) {\n            for (num2 in nums2) {\n                val sum = num1 + num2\n                map[sum] = map.getOrDefault(sum, 0) + 1\n            }\n        }\n        \n        for (num3 in nums3) {\n            for (num4 in nums4) {\n                val complement = -(num3 + num4)\n                count += map.getOrDefault(complement, 0)\n            }\n        }\n        \n        return count\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int fourSumCount(List<int> nums1, List<int> nums2, List<int> nums3, List<int> nums4) {\n    Map<int, int> map = {};\n    int count = 0;\n\n    for (int num1 in nums1) {\n      for (int num2 in nums2) {\n        int sum = num1 + num2;\n        map[sum] = (map[sum] ?? 0) + 1;\n      }\n    }\n\n    for (int num3 in nums3) {\n      for (int num4 in nums4) {\n        int complement = -(num3 + num4);\n        if (map.containsKey(complement)) {\n          count += map[complement]!;\n        }\n      }\n    }\n\n    return count;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {\n    count := 0\n    sumMap := make(map[int]int)\n\n    for _, n1 := range nums1 {\n        for _, n2 := range nums2 {\n            sumMap[n1+n2]++\n        }\n    }\n\n    for _, n3 := range nums3 {\n        for _, n4 := range nums4 {\n            count += sumMap[-(n3 + n4)]\n        }\n    }\n\n    return count\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @param {Integer[]} nums3\n# @param {Integer[]} nums4\n# @return {Integer}\ndef four_sum_count(nums1, nums2, nums3, nums4)\n    sum_map = {}\n    count = 0\n    \n    nums1.each do |a|\n        nums2.each do |b|\n            sum_map[a + b] = sum_map.fetch(a + b, 0) + 1\n        end\n    end\n    \n    nums3.each do |c|\n        nums4.each do |d|\n            count += sum_map.fetch(-(c + d), 0)\n        end\n    end\n    \n    count\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def fourSumCount(nums1: Array[Int], nums2: Array[Int], nums3: Array[Int], nums4: Array[Int]): Int = {\n        var count = 0\n        val map = scala.collection.mutable.Map.empty[Int, Int]\n\n        for {\n            a <- nums1\n            b <- nums2\n        } {\n            val sum = a + b\n            map(sum) = map.getOrElse(sum, 0) + 1\n        }\n\n        for {\n            c <- nums3\n            d <- nums4\n        } {\n            val target = -(c + d)\n            if (map.contains(target)) {\n                count += map(target)\n            }\n        }\n\n        count\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn four_sum_count(nums1: Vec<i32>, nums2: Vec<i32>, nums3: Vec<i32>, nums4: Vec<i32>) -> i32 {\n        use std::collections::HashMap;\n\n        let mut count = 0;\n        let mut map = HashMap::new();\n\n        for &a in &nums1 {\n            for &b in &nums2 {\n                *map.entry(a + b).or_insert(0) += 1;\n            }\n        }\n\n        for &c in &nums3 {\n            for &d in &nums4 {\n                if let Some(&val) = map.get(&-(c + d)) {\n                    count += val;\n                }\n            }\n        }\n\n        count\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (four-sum-count nums1 nums2 nums3 nums4)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  \n  (define hash-table (make-hash))\n  (define (addToHashTable ht val)\n    (hash-set! ht val (add1 (hash-ref ht val 0))))\n  \n  (define (countPairsSumToZero ht lst1 lst2)\n    (for* ([num1 lst1] [num2 lst2])\n      (addToHashTable ht (+ num1 num2))))\n  \n  (countPairsSumToZero hash-table nums1 nums2)\n  \n  (define (countTotalPairsSumToZero ht lst1 lst2)\n    (define count 0)\n    (for* ([num1 lst1] [num2 lst2])\n      (define complement (- 0 (+ num1 num2)))\n      (set! count (+ count (hash-ref ht complement 0))))\n    count)\n  \n  (define total-count 0)\n  (set! total-count (+ total-count (countTotalPairsSumToZero hash-table nums3 nums4)))\n  \n  total-count)"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec four_sum_count(nums1 :: [integer], nums2 :: [integer], nums3 :: [integer], nums4 :: [integer]) :: integer\n\n  def four_sum_count(nums1, nums2, nums3, nums4) do\n    count = Enum.reduce(nums1, 0, fn a, acc1 ->\n      Enum.reduce(nums2, acc1, fn b, acc2 ->\n        Enum.reduce(nums3, acc2, fn c, acc3 ->\n          Enum.reduce(nums4, acc3, fn d, acc4 ->\n            acc4 + if a + b + c + d == 0, do: 1, else: 0\n          end)\n        end)\n      end)\n    end)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can break down the problem into a series of steps that utilize hash maps to efficiently count the number of tuples that sum to zero. The idea is to use a hash map to store the sums of pairs from the first two arrays, then check if the negative of those sums can be formed by pairs from the last two arrays. \n\n# Explanation\n1. **Initialization**: We initialize a counter `count` to keep track of the number of valid tuples and a dictionary `sum_map` to store the counts of the sums formed by pairs from `nums1` and `nums2`.\n2. **First Loop**: Iterate over all possible pairs `(i, j)` where `i` is from `nums1` and `j` is from `nums2`. For each pair, calculate the sum `i + j` and store this sum in the hash map `sum_map`. If the sum already exists in the map, increment its count; otherwise, initialize it to 1.\n3. **Second Loop**: Iterate over all possible pairs `(k, l)` where `k` is from `nums3` and `l` is from `nums4`. For each pair, calculate the sum `-k - l` (the negative of the sum). Check if this negative sum exists in `sum_map`. If it does, it indicates that there exists a pair from `nums1` and `nums2` whose sum, when added to the sum of the current pair from `nums3` and `nums4`, results in zero. In this case, increment `count` by the value stored in `sum_map` for this negative sum.\n4. **Return the Result**: After processing all pairs, return the value of `count`.\n\n# Pseudocode\n```\nfunction fourSumCount(nums1, nums2, nums3, nums4):\n    count = 0\n    sum_map = {}\n\n    # Populate the sum_map with sums from nums1 and nums2\n    for i in nums1:\n        for j in nums2:\n            sum_ij = i + j\n            if sum_ij in sum_map:\n                sum_map[sum_ij] += 1\n            else:\n                sum_map[sum_ij] = 1\n\n    # Check against sums from nums3 and nums4\n    for k in nums3:\n        for l in nums4:\n            sum_kl = -k - l\n            if sum_kl in sum_map:\n                count += sum_map[sum_kl]\n\n    return count\n```\n\nBy using a hash map to store intermediate sums, this approach efficiently reduces the problem's complexity compared to directly iterating over all quadruples, making it suitable for the given constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-4sum-ii"
    },
    {
        "name": "Minimum Moves To Equal Array Elements",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-moves-to-equal-array-elements",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minMoves(vector<int>& nums) {\n        int sum = 0;\n        int minNum = INT_MAX;\n        for (int num : nums) {\n            sum += num;\n            minNum = min(minNum, num);\n        }\n        return sum - minNum * nums.size();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minMoves(int[] nums) {\n        int min = nums[0];\n        int sum = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            min = Math.min(min, nums[i]);\n            sum += nums[i];\n        }\n        \n        return sum - min * nums.length;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minMoves(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        return sum(nums) - min(nums) * len(nums)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int minMoves(int* nums, int numsSize) {\n    int min = INT_MAX;\n    long long sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n        min = nums[i] < min ? nums[i] : min;\n    }\n    return sum - min * numsSize;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinMoves(int[] nums) {\n        int minNum = nums.Min();\n        int moves = 0;\n        \n        foreach (int num in nums) {\n            moves += num - minNum;\n        }\n        \n        return moves;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minMoves = (nums) => {\n    let min = Math.min(...nums);\n    let moves = 0;\n    \n    for (let num of nums) {\n        moves += num - min;\n    }\n    \n    return moves;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minMoves(nums: number[]): number {\n    const minNum = Math.min(...nums);\n    let moves = 0;\n    \n    for (let num of nums) {\n        moves += num - minNum;\n    }\n    \n    return moves;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     */\n    function minMoves($nums) {\n        $min = min($nums);\n        $moves = 0;\n        foreach ($nums as $num) {\n            $moves += $num - $min;\n        }\n        return $moves;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minMoves(_ nums: [Int]) -> Int {\n        let minNum = nums.min() ?? 0\n        var moves = 0\n        for num in nums {\n            moves += num - minNum\n        }\n        return moves\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minMoves(nums: IntArray): Int {\n        val minNum = nums.minOrNull() ?: 0\n        var moves = 0\n        for (num in nums) {\n            moves += num - minNum\n        }\n        return moves\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int minMoves(List<int> nums) {\n    int sum = 0;\n    int minNum = nums[0];\n    for (int num in nums) {\n      sum += num;\n      if (num < minNum) {\n        minNum = num;\n      }\n    }\n    return sum - nums.length * minNum;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minMoves(nums []int) int {\n    minNum := nums[0]\n    sum := nums[0]\n    \n    for _, num := range nums[1:] {\n        if num < minNum {\n            minNum = num\n        }\n        sum += num\n    }\n    \n    return sum - minNum * len(nums)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef min_moves(nums)\n    min_num = nums.min\n    moves = 0\n    nums.each { |num| moves += num - min_num }\n    moves\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minMoves(nums: Array[Int]): Int = {\n        val minNum = nums.min\n        var moves = 0\n        for (num <- nums) {\n            moves += num - minNum\n        }\n        moves\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn min_moves(nums: Vec<i32>) -> i32 {\n        let min_val = nums.iter().cloned().min().unwrap();\n        let mut moves = 0;\n        for num in nums {\n            moves += num - min_val;\n        }\n        moves\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (min-moves nums)\n  (-> (listof exact-integer?) exact-integer?)\n  (let ((min-val (apply min nums)))\n    (- (apply + nums) (* min-val (length nums)))\n  )\n)\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec min_moves(Nums :: [integer()]) -> integer().\nmin_moves(Nums) ->\n    Total = lists:sum(Nums),\n    Min = lists:min(Nums),\n    Length = length(Nums),\n    Total - Min * Length.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec min_moves(nums :: [integer]) :: integer\n  def min_moves(nums) do\n    Enum.sum(nums) - length(nums) * Enum.min(nums)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the minimum number of moves required to make all elements of the array equal. We can increment \\( n - 1 \\) elements of the array by 1 in each move. \n\n# Explanation\nGiven an array `nums`, the goal is to make all elements of the array equal with the minimum number of moves where in each move we can increment all elements except one by 1. \n\nTo achieve this:\n1. Note that incrementing \\( n - 1 \\) elements by 1 in the array is equivalent to decrementing one element by 1.\n2. Therefore, to transform the array into one where all elements are equal, we essentially need to convert all elements to the minimum element of the array.\n\nThe number of moves required is thus the total sum of all elements of the array minus the product of the minimum element in the array and the length of the array. This is because each move effectively reduces the number of differences between the larger elements and the smallest element.\n\n# Pseudocode\n```plaintext\nfunction minMoves(nums):\n    total_sum = sum(nums)            # Calculate the sum of all elements in nums\n    min_element = min(nums)          # Find the minimum element in nums\n    array_length = length(nums)      # Get the length of the array\n    \n    # The minimum number of moves required\n    moves = total_sum - (min_element * array_length)\n    \n    return moves\n```\n\nExplanation:\n1. Calculate the total sum of all elements in the array.\n2. Find the minimum element in the array.\n3. Calculate the length of the array.\n4. Compute the moves as the difference between the total sum and the product of the minimum element and the length of the array.\n5. Return the result as the minimum number of moves required.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-moves-to-equal-array-elements"
    },
    {
        "name": "Construct Binary Tree From Preorder And Inorder Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-construct-binary-tree-from-preorder-and-inorder-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0;\n        unordered_map<int, int> inorderMap;\n        for (int i = 0; i < inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return build(preorder, inorder, 0, inorder.size() - 1, preIndex, inorderMap);\n    }\n    \n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int inStart, int inEnd, int& preIndex, unordered_map<int, int>& inorderMap) {\n        if (inStart > inEnd) {\n            return nullptr;\n        }\n        \n        TreeNode* node = new TreeNode(preorder[preIndex++]);\n        \n        int inIndex = inorderMap[node->val];\n        \n        node->left = build(preorder, inorder, inStart, inIndex - 1, preIndex, inorderMap);\n        node->right = build(preorder, inorder, inIndex + 1, inEnd, preIndex, inorderMap);\n        \n        return node;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n    }\n\n    private TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {\n        if (preStart > preEnd || inStart > inEnd) {\n            return null;\n        }\n\n        int rootVal = preorder[preStart];\n        TreeNode root = new TreeNode(rootVal);\n\n        int rootIndex = 0;\n        for (int i = inStart; i <= inEnd; i++) {\n            if (inorder[i] == rootVal) {\n                rootIndex = i;\n                break;\n            }\n        }\n\n        int leftSize = rootIndex - inStart;\n\n        root.left = buildTree(preorder, preStart + 1, preStart + leftSize, inorder, inStart, rootIndex - 1);\n        root.right = buildTree(preorder, preStart + leftSize + 1, preEnd, inorder, rootIndex + 1, inEnd);\n\n        return root;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        if inorder:\n            root_val = preorder.pop(0)\n            root_index = inorder.index(root_val)\n            root = TreeNode(root_val)\n            root.left = self.buildTree(preorder, inorder[:root_index])\n            root.right = self.buildTree(preorder, inorder[root_index + 1:])\n            return root\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){\n    if (preorderSize == 0) return NULL;\n    \n    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val = preorder[0];\n    \n    int idx = 0;\n    for (int i = 0; i < inorderSize; i++) {\n        if (inorder[i] == preorder[0]) {\n            idx = i;\n            break;\n        }\n    }\n    \n    root->left = buildTree(preorder + 1, idx, inorder, idx);\n    root->right = buildTree(preorder + idx + 1, preorderSize - idx - 1, inorder + idx + 1, inorderSize - idx - 1);\n    \n    return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\n        return BuildTreeHelper(preorder, 0, preorder.Length - 1, inorder, 0, inorder.Length - 1);\n    }\n    \n    private TreeNode BuildTreeHelper(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {\n        if (preStart > preEnd || inStart > inEnd) {\n            return null;\n        }\n        \n        int rootValue = preorder[preStart];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndex = Array.IndexOf(inorder, rootValue);\n\n        int leftTreeSize = rootIndex - inStart;\n\n        root.left = BuildTreeHelper(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, rootIndex - 1);\n        root.right = BuildTreeHelper(preorder, preStart + leftTreeSize + 1, preEnd, inorder, rootIndex + 1, inEnd);\n\n        return root;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nvar buildTree = function(preorder, inorder) {\n    const build = (p_start, p_end, i_start, i_end) => {\n        if (p_start > p_end) return null;\n        \n        const rootVal = preorder[p_start];\n        const root = new TreeNode(rootVal);\n        \n        let rootIndex = i_start;\n        while (inorder[rootIndex] !== rootVal) rootIndex++;\n        \n        const leftSize = rootIndex - i_start;\n        \n        root.left = build(p_start + 1, p_start + leftSize, i_start, rootIndex - 1);\n        root.right = build(p_start + leftSize + 1, p_end, rootIndex + 1, i_end);\n        \n        return root;\n    };\n    \n    return build(0, preorder.length - 1, 0, inorder.length - 1);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val)\n *         this.left = (left === undefined ? null : left)\n *         this.right = (right === undefined ? null : right)\n *     }\n * }\n */\nfunction buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n    if (preorder.length === 0) return null;\n    \n    const rootVal = preorder[0];\n    const root = new TreeNode(rootVal);\n    \n    const midIdx = inorder.indexOf(rootVal);\n    \n    root.left = buildTree(preorder.slice(1, midIdx + 1), inorder.slice(0, midIdx));\n    root.right = buildTree(preorder.slice(midIdx + 1), inorder.slice(midIdx + 1));\n    \n    return root;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n    public $index = 0;\n    public $map = [];\n\n    function buildTree($preorder, $inorder) {\n        foreach($inorder as $key => $val) {\n            $this->map[$val] = $key;\n        }\n        return $this->helper($preorder, 0, count($preorder) - 1);\n    }\n\n    function helper(&$preorder, $start, $end) {\n        if($start > $end) {\n            return null;\n        }\n        \n        $rootVal = $preorder[$this->index];\n        $this->index++;\n        $index = $this->map[$rootVal];\n        \n        $root = new TreeNode($rootVal);\n        $root->left = $this->helper($preorder, $start, $index - 1);\n        $root->right = $this->helper($preorder, $index + 1, $end);\n        \n        return $root;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {\n        if preorder.isEmpty || inorder.isEmpty {\n            return nil\n        }\n        \n        let rootVal = preorder[0]\n        let root = TreeNode(rootVal)\n        \n        let rootIndex = inorder.firstIndex(of: rootVal)!\n        \n        let inorderLeft = Array(inorder[0..<rootIndex])\n        let inorderRight = Array(inorder[rootIndex + 1..<inorder.count])\n        \n        let preorderLeft = Array(preorder[1..<1+inorderLeft.count])\n        let preorderRight = Array(preorder[1+inorderLeft.count..<preorder.count])\n        \n        root.left = buildTree(preorderLeft, inorderLeft)\n        root.right = buildTree(preorderRight, inorderRight)\n        \n        return root\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n    if len(preorder) == 0 {\n        return nil\n    }\n    \n    rootVal := preorder[0]\n    root := &TreeNode{Val: rootVal}\n    \n    var mid int\n    for i := range inorder {\n        if inorder[i] == rootVal {\n            mid = i\n            break\n        }\n    }\n    \n    root.Left = buildTree(preorder[1:mid+1], inorder[:mid])\n    root.Right = buildTree(preorder[mid+1:], inorder[mid+1:])\n    \n    return root\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = \ndef build_tree(preorder, inorder)\n    return helper(0, 0, inorder.length - 1, preorder, inorder)\nend\n\ndef helper(pre_start, in_start, in_end, preorder, inorder)\n    return nil if pre_start > preorder.length - 1 || in_start > in_end\n    \n    root = TreeNode.new(preorder[pre_start])\n    \n    in_index = in_start\n    while in_index <= in_end\n        break if inorder[in_index] == root.val\n        in_index += 1\n    end\n    \n    root.left = helper(pre_start + 1, in_start, in_index - 1, preorder, inorder)\n    root.right = helper(pre_start + in_index - in_start + 1, in_index + 1, in_end, preorder, inorder)\n    \n    return root\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n */\n\nobject Solution {\n  def buildTree(preorder: Array[Int], inorder: Array[Int]): TreeNode = {\n    def helper(preorderStart: Int, preorderEnd: Int, inorderStart: Int, inorderEnd: Int): TreeNode = {\n      if (preorderStart > preorderEnd) return null\n\n      val rootValue = preorder(preorderStart)\n      val root = new TreeNode(rootValue)\n\n      var inorderRootIdx = inorderStart\n      while (inorder(inorderRootIdx) != rootValue) {\n        inorderRootIdx += 1\n      }\n\n      val leftTreeSize = inorderRootIdx - inorderStart\n\n      root.left = helper(preorderStart + 1, preorderStart + leftTreeSize, inorderStart, inorderRootIdx - 1)\n      root.right = helper(preorderStart + leftTreeSize + 1, preorderEnd, inorderRootIdx + 1, inorderEnd)\n\n      root\n    }\n\n    helper(0, preorder.length - 1, 0, inorder.length - 1)\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to construct a binary tree using preorder and inorder traversal arrays. We will employ a recursive approach to build the tree.\n\nHere is a detailed explanation of the method used to solve the problem:\n\n### # Explanation\n1. **Understanding Traversals**:\n    - **Preorder Traversal**: In preorder traversal, the nodes are recursively visited in this order: root, left, right.\n    - **Inorder Traversal**: In inorder traversal, the nodes are recursively visited in this order: left, root, right.\n2. **Building the Tree**:\n    - The first element of the preorder array is always the root of the tree or sub-tree.\n    - Locate this root element in the inorder array. This divides the inorder array into left and right subtrees.\n    - Recursively build the left subtree using the parts of the preorder and inorder arrays corresponding to the left subtree.\n    - Recursively build the right subtree using the parts of the preorder and inorder arrays corresponding to the right subtree.\n\n### # Pseudocode\nThe pseudocode below outlines the step-by-step logic to build the binary tree:\n\n```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def buildTree(preorder, inorder):\n        # Base case: if inorder array is empty, return None\n        if not inorder:\n            return None\n        \n        # The first element in the preorder traversal is the root\n        root_val = preorder.pop(0)\n        \n        # Find the index of the root in the inorder traversal\n        root_index = inorder.index(root_val)\n        \n        # Create the root node\n        root = TreeNode(root_val)\n        \n        # Recursively build the left subtree and right subtree\n        root.left = buildTree(preorder, inorder[:root_index])\n        root.right = buildTree(preorder, inorder[root_index + 1:])\n        \n        # Return the root node\n        return root\n```\n\n### Steps Recap:\n1. Check if the `inorder` array is empty, return `None` (base case).\n2. Extract the first element from `preorder`. This is the root value of the current subtree.\n3. Find the root's index in the `inorder` array.\n4. Create the root node for the tree/sub-tree.\n5. Split the `inorder` array into the left and right parts relative to the root's index and recursively build left and right subtrees.\n6. Assign the returned subtrees to the root's left and right pointers, respectively.\n7. Return the root.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-construct-binary-tree-from-preorder-and-inorder-traversal"
    },
    {
        "name": "Binary Tree Zigzag Level Order Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-zigzag-level-order-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (root == nullptr) {\n            return result;\n        }\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        bool leftToRight = true;\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> level(size);\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                \n                int index = leftToRight ? i : (size - 1 - i);\n                level[index] = node->val;\n                \n                if (node->left != nullptr) {\n                    q.push(node->left);\n                }\n                \n                if (node->right != nullptr) {\n                    q.push(node->right);\n                }\n            }\n            \n            result.push_back(level);\n            leftToRight = !leftToRight;\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean leftToRight = true;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (leftToRight) {\n                    level.add(node.val);\n                } else {\n                    level.add(0, node.val);\n                }\n\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            result.add(level);\n            leftToRight = !leftToRight;\n        }\n\n        return result;\n    }\n}\n\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {\n    if (!root) {\n        *returnSize = 0;\n        *returnColumnSizes = NULL;\n        return NULL;\n    }\n    \n    int** res = (int**)malloc(sizeof(int*) * 2000);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 2000);\n    *returnSize = 0;\n    \n    struct TreeNode** queue = (struct TreeNode**)malloc(sizeof(struct TreeNode*) * 2000);\n    int front = 0, rear = 0;\n    bool leftToRight = true;\n    \n    queue[rear++] = root;\n    \n    while (front < rear) {\n        int levelSize = rear - front;\n        int* level = (int*)malloc(sizeof(int) * levelSize);\n        \n        for (int i = 0; i < levelSize; i++) {\n            struct TreeNode* node = queue[front++];\n            int index = leftToRight ? i : levelSize - 1 - i;\n            level[index] = node->val;\n            \n            if (node->left) queue[rear++] = node->left;\n            if (node->right) queue[rear++] = node->right;\n        }\n        \n        res[*returnSize] = level;\n        (*returnColumnSizes)[*returnSize] = levelSize;\n        (*returnSize)++;\n        leftToRight = !leftToRight;\n    }\n    \n    return res;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nusing System.Collections.Generic;\n\npublic class Solution {\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {\n        IList<IList<int>> result = new List<IList<int>>();\n        if (root == null) return result;\n        \n        Queue<TreeNode> queue = new Queue<TreeNode>();\n        queue.Enqueue(root);\n        bool zigzag = false;\n        \n        while (queue.Count > 0) {\n            int size = queue.Count;\n            IList<int> level = new List<int>();\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.Dequeue();\n                if (zigzag) {\n                    level.Insert(0, node.val);\n                }\n                else {\n                    level.Add(node.val);\n                }\n                \n                if (node.left != null) queue.Enqueue(node.left);\n                if (node.right != null) queue.Enqueue(node.right);\n            }\n            \n            result.Add(level);\n            zigzag = !zigzag;\n        }\n        \n        return result;\n    }\n}\n  "
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\n\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function(root) {\n    if (!root) return [];\n    \n    const result = [];\n    let level = 0;\n    \n    const traverse = (node, level) => {\n        if (!node) return;\n\n        if (!result[level]) {\n            result[level] = [];\n        }\n        \n        if (level % 2 === 0) {\n            result[level].push(node.val);  \n        } else {\n            result[level].unshift(node.val);  \n        }\n        \n        traverse(node.left, level + 1);\n        traverse(node.right, level + 1);\n    }\n    \n    traverse(root, 0);\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number;\n *     left: TreeNode | null;\n *     right: TreeNode | null;\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val);\n *         this.left = (left === undefined ? null : left);\n *         this.right = (right === undefined ? null : right);\n *     }\n * }\n */\nfunction zigzagLevelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    \n    const result: number[][] = [];\n    let level: number[] = [];\n    let queue: TreeNode[] = [root];\n    let zigzag: boolean = false;\n    \n    while (queue.length) {\n        const len = queue.length;\n        \n        for (let i = 0; i < len; i++) {\n            const node = queue.shift()!;\n            if (zigzag) {\n                level.unshift(node.val);\n            } else {\n                level.push(node.val);\n            }\n            \n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        \n        result.push(level);\n        level = [];\n        zigzag = !zigzag;\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\n\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[][]\n     */\n    function zigzagLevelOrder($root) {\n        $result = [];\n        if ($root === null) {\n            return $result;\n        }\n        \n        $queue = [];\n        array_push($queue, $root);\n        $zigZag = false;\n        \n        while (!empty($queue)) {\n            $level = [];\n            $count = count($queue);\n            for ($i = 0; $i < $count; $i++) {\n                $node = array_shift($queue);\n                if ($zigZag) {\n                    array_unshift($level, $node->val);\n                } else {\n                    array_push($level, $node->val);\n                }\n                \n                if ($node->left !== null) {\n                    array_push($queue, $node->left);\n                }\n                if ($node->right !== null) {\n                    array_push($queue, $node->right);\n                }\n            }\n            array_push($result, $level);\n            $zigZag = !$zigZag;\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\n        guard let root = root else { return [] }\n        \n        var result = [[Int]]()\n        var queue = [root]\n        var isZigZag = false\n        \n        while !queue.isEmpty {\n            var level = [Int]()\n            let size = queue.count\n            \n            for _ in 0..<size {\n                let node = queue.removeFirst()\n                \n                if isZigZag {\n                    level.insert(node.val, at: 0)\n                } else {\n                    level.append(node.val)\n                }\n                \n                if let left = node.left {\n                    queue.append(left)\n                }\n                if let right = node.right {\n                    queue.append(right)\n                }\n            }\n            \n            result.append(level)\n            isZigZag.toggle()\n        }\n        \n        return result\n    }\n}\n\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\n        if (root == null) return emptyList()\n        \n        val result = mutableListOf<List<Int>>()\n        var level = 0\n        val queue = LinkedList<TreeNode>()\n        queue.offer(root)\n        \n        while (queue.isNotEmpty()) {\n            val levelSize = queue.size\n            val levelValues = mutableListOf<Int>()\n            \n            for (i in 0 until levelSize) {\n                val node = queue.poll()\n                \n                if (level % 2 == 0) {\n                    levelValues.add(node.`val`)\n                } else {\n                    levelValues.add(0, node.`val`)\n                }\n                \n                node.left?.let { queue.offer(it) }\n                node.right?.let { queue.offer(it) }\n            }\n            \n            result.add(levelValues)\n            level++\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "package main\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\n    if root == nil {\n        return [][]int{}\n    }\n    \n    var result [][]int\n    queue := []*TreeNode{root}\n    level := 0\n    \n    for len(queue) > 0 {\n        levelSize := len(queue)\n        levelValues := make([]int, levelSize)\n        \n        for i := 0; i < levelSize; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            \n            index := i\n            if level % 2 == 1 {\n                index = levelSize - 1 - i\n            }\n            levelValues[index] = node.Val\n            \n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n        \n        result = append(result, levelValues)\n        level++\n    }\n    \n    return result\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef zigzag_level_order(root)\n    return [] if root.nil?\n    result = []\n    queue = [root]\n    zigzag = false\n    \n    until queue.empty?\n        level_size = queue.size\n        level_values = []\n        \n        level_size.times do\n            node = queue.shift\n            if zigzag\n                level_values.unshift(node.val)\n            else\n                level_values << node.val\n            end\n            queue << node.left if node.left\n            queue << node.right if node.right\n        end\n        \n        result << level_values\n        zigzag = !zigzag\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n * }\n */\nobject Solution {\n    def zigzagLevelOrder(root: TreeNode): List[List[Int]] = {\n        import scala.collection.mutable.Queue\n        import scala.collection.mutable.ListBuffer\n        \n        if (root == null) return List()\n        \n        val result = ListBuffer[List[Int]]()\n        val queue = Queue[TreeNode]()\n        var level = 0\n        \n        queue.enqueue(root)\n        while (queue.nonEmpty) {\n            val levelSize = queue.length\n            val levelValues = ListBuffer[Int]()\n            \n            0 until levelSize foreach { _ =>\n                val node = queue.dequeue()\n                if (level % 2 == 0) levelValues += node.value\n                else levelValues.prepend(node.value)\n                \n                if (node.left != null) queue.enqueue(node.left)\n                if (node.right != null) queue.enqueue(node.right)\n            }\n            \n            result += levelValues.toList\n            level += 1\n        }\n        \n        result.toList\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform a zigzag level order traversal on a binary tree. This involves traversing the tree level by level, but alternating the direction of traversal at each level (left to right and then right to left).\n\n# Explanation\n1. **Base Case**: If the root is `null`, return an empty list.\n2. **Data Structures**: Use a list to store the result and a queue for level order traversal.\n3. **Traversal**: \n   - Add the root node to the queue.\n   - Use a loop to process each level until the queue is empty.\n   - Use a boolean flag to track whether the current level should be traversed from left to right or right to left.\n   - For each level, create a temporary list to store the node values.\n   - Add children of the current node to the queue for the next level.\n   - After processing all nodes at the current level, append the temporary list to the result list.\n   - Toggle the boolean flag for the next level.\n4. **Return the Result**: After processing all levels, return the result list.\n\n# Pseudocode\n```\nFunction zigzagLevelOrder(root):\n    If root is None:\n        Return an empty list\n\n    result = []\n    queue = [root]\n    leftToRight = True\n\n    While queue is not empty:\n        levelSize = length of queue\n        currentLevel = []\n\n        For i from 0 to levelSize - 1:\n            node = queue.pop(0)\n            If leftToRight:\n                currentLevel.append(node.val)\n            Else:\n                currentLevel.insert(0, node.val)\n            \n            If node.left is not None:\n                queue.append(node.left)\n            \n            If node.right is not None:\n                queue.append(node.right)\n        \n        result.append(currentLevel)\n        leftToRight = Not leftToRight\n    \n    Return result\n```\n\nThis pseudocode outlines the steps necessary to implement the zigzag level order traversal for a binary tree. Each level alternates direction as required by the challenge.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-zigzag-level-order-traversal"
    },
    {
        "name": "Maximum Depth Of Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-maximum-depth-of-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        int leftDepth = maxDepth(root->left);\n        int rightDepth = maxDepth(root->right);\n        \n        return 1 + max(leftDepth, rightDepth);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n*/\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int leftDepth = maxDepth(root.left);\n            int rightDepth = maxDepth(root.right);\n            return Math.max(leftDepth, rightDepth) + 1;\n        }\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nint maxDepth(struct TreeNode* root) {\n    if(root == NULL)\n        return 0;\n    \n    int left_depth = maxDepth(root->left);\n    int right_depth = maxDepth(root->right);\n    \n    return left_depth > right_depth ? left_depth + 1 : right_depth + 1;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MaxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n        return 1 + Math.Max(MaxDepth(root.left), MaxDepth(root.right));\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *      this.val = (val===undefined ? 0 : val);\n *      this.left = (left===undefined ? null : left);\n *      this.right = (right===undefined ? null : right);\n * }\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    \n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction maxDepth(root: TreeNode | null): number {\n    if (!root) {\n        return 0;\n    }\n    \n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxDepth($root) {\n        if ($root == null) {\n            return 0;\n        }\n        $leftDepth = $this->maxDepth($root->left);\n        $rightDepth = $this->maxDepth($root->right);\n        return max($leftDepth, $rightDepth) + 1;\n    }\n}\n\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func maxDepth(_ root: TreeNode?) -> Int {\n        guard let root = root else {\n            return 0\n        }\n        \n        let leftDepth = maxDepth(root.left)\n        let rightDepth = maxDepth(root.right)\n        \n        return 1 + max(leftDepth, rightDepth)\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode(this.val, {this.left, this.right});\n * }\n */\n\nclass Solution {\n  int maxDepth(TreeNode? root) {\n    if (root == null) {\n      return 0;\n    }\n    \n    int leftDepth = maxDepth(root.left);\n    int rightDepth = maxDepth(root.right);\n    \n    return 1 + max(leftDepth, rightDepth);\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    \n    leftDepth := maxDepth(root.Left)\n    rightDepth := maxDepth(root.Right)\n    \n    if leftDepth > rightDepth {\n        return leftDepth + 1\n    }\n    return rightDepth + 1\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef max_depth(root)\n    return 0 if root.nil?\n    \n    left_depth = max_depth(root.left)\n    right_depth = max_depth(root.right)\n    \n    return 1 + [left_depth, right_depth].max\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::cmp::max;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n\nimpl Solution {\n    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        match root {\n            Some(node) => {\n                let node = node.borrow();\n                1 + max(Solution::max_depth(node.left.clone()), Solution::max_depth(node.right.clone()))\n            }\n            None => 0\n        }\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | 'tree_node',\n%%                     right = null :: 'null' | 'tree_node'}).\n\nmax_depth(null) -> 0;\nmax_depth(#tree_node{left = L, right = R}) -> 1 + max(max_depth(L), max_depth(R)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the maximum depth of a binary tree. We can achieve this through a recursive approach. Below are detailed explanations and pseudocode for the solution.\n\n# Explanation\n\n1. **Definition**:\n   - The maximum depth of a binary tree is the number of nodes along the longest path from the root node to the farthest leaf node.\n\n2. **Base Case**:\n   - If the current node (`root`) is `null`, the depth is `0`.\n\n3. **Recursive Case**:\n   - Compute the depth of the left subtree by recursively calling the function on the left child.\n   - Compute the depth of the right subtree by recursively calling the function on the right child.\n   - The maximum depth at the current node is `1` (for the current node itself) plus the maximum of the depths of the left and right subtrees.\n\n# Pseudocode\n\n```\nfunction maxDepth(root):\n    # Base case: if the tree is empty, the depth is 0\n    if root is null:\n        return 0\n\n    # Recursive case: compute the depth of left and right subtrees\n    leftDepth = maxDepth(root.left)\n    rightDepth = maxDepth(root.right)\n\n    # The maximum depth of the current tree is 1 (for the root itself) \n    # plus the maximum of the depths of the left and right subtrees\n    return 1 + max(leftDepth, rightDepth)\n```\n\nWith this pseudocode, you can implement the solution in any programming language of your choice. The central idea is to use recursion to traverse the tree and compute the depth based on the maximum depth of its subtrees.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-maximum-depth-of-binary-tree"
    },
    {
        "name": "Repeated Substring Pattern",
        "site": "LeetCode",
        "href": "/solution/LeetCode-repeated-substring-pattern",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        int n = s.size();\n        for (int i = 1; i <= n / 2; i++) {\n            if (n % i == 0) {\n                string sub = s.substr(0, i);\n                string temp = \"\";\n                for (int j = 0; j < n / i; j++) {\n                    temp += sub;\n                }\n                if (temp == s) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        int n = s.length();\n        for (int i = 1; i <= n / 2; i++) {\n            if (n % i == 0) {\n                String sub = s.substring(0, i);\n                StringBuilder sb = new StringBuilder();\n                for (int j = 0; j < n / i; j++) {\n                    sb.append(sub);\n                }\n                if (sb.toString().equals(s)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s in (s + s)[1:-1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool repeatedSubstringPattern(char* s) {\n    int len = strlen(s);\n    for (int i = 1; i <= len / 2; i++) {\n        if (len % i == 0) {\n            int flag = 1;\n            for (int j = i; j < len; j++) {\n                if (s[j] != s[j % i]) {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool RepeatedSubstringPattern(string s) {\n        string str = s + s;\n        return str.Substring(1, str.Length - 2).Contains(s);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst repeatedSubstringPattern = (s) => {\n    for (let i = 1; i <= s.length / 2; i++) {\n        if (s.length % i === 0) {\n            const substr = s.slice(0, i);\n            if (substr.repeat(s.length / i) === s) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function repeatedSubstringPattern(s: string): boolean {\n    const n = s.length;\n    for (let i = 1; i <= n / 2; i++) {\n        if (n % i === 0) {\n            const subStr = s.substring(0, i);\n            let repeated = true;\n            for (let j = i; j < n; j += i) {\n                if (s.substring(j, j + i) !== subStr) {\n                    repeated = false;\n                    break;\n                }\n            }\n            if (repeated) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function repeatedSubstringPattern($s) {\n        $n = strlen($s);\n        for ($i = 1; $i <= $n / 2; $i++) {\n            if ($n % $i == 0 && $s == str_repeat(substr($s, 0, $i), $n / $i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "import kotlin.math.sqrt\n\nclass Solution {\n    fun repeatedSubstringPattern(s: String): Boolean {\n        val n = s.length\n        for (i in 1..n / 2) {\n            if (n % i == 0) {\n                val sub = s.substring(0, i)\n                if (s == sub.repeat(n / i)) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool repeatedSubstringPattern(String s) {\n      int n = s.length;\n      for (int i = 1; i <= n ~/ 2; i++) {\n          if (n % i == 0) {\n              String sub = s.substring(0, i);\n              String newStr = '';\n              for (int j = 0; j < n ~/ i; j++) {\n                  newStr += sub;\n              }\n              if (newStr == s) {\n                  return true;\n              }\n          }\n      }\n      return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func repeatedSubstringPattern(s string) bool {\n    size := len(s)\n    for i := 1; i <= size/2; i++ {\n        if size%i == 0 {\n            sub := s[:i]\n            if strings.Repeat(sub, size/i) == s {\n                return true\n            }\n        }\n    }\n    return false\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Boolean}\ndef repeated_substring_pattern(s)\n    (s + s)[1..-2].include? s\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def repeatedSubstringPattern(s: String): Boolean = {\n        (s + s).substring(1, 2 * s.length - 1).contains(s)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn repeated_substring_pattern(s: String) -> bool {\n        let double_s = format!(\"{}{}\", s, s);\n        double_s[1..double_s.len() - 1].contains(&s)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given string \\( s \\) can be formed by repeating a substring of itself multiple times.\n\n# Explanation\n\n1. **Main Idea**: A string can be thought of as repeated if after doubling the string and removing the first and last characters, the original string still exists as a substring.\n\n2. **Doubling the String**: If \\( s \\) is doubled, every possible rotation (concatenation combination of substrings that form \\( s \\)) will appear as a substring in this doubled string.\n\n3. **Remove Ends**: To ensure we don't match the original string trivially (which would always happen in the center of the doubled string), remove the first and last characters from the doubled string.\n\n4. **Check Substring**: If \\( s \\) appears in this modified doubled version, then \\( s \\) can be constructed by repeating a substring of itself.\n\n# Pseudocode\n\n```\n# Define the function to check for repeated substring pattern\ndef repeatedSubstringPattern(s):\n    \n    # Step 1: Double the string\n    doubled_s = s + s\n    \n    # Step 2: Slice off the first and last character of the doubled string\n    modified_doubled_s = doubled_s[1:-1]\n    \n    # Step 3: Check if original string appears in the modified doubled string\n    if s in modified_doubled_s:\n        return True\n    else:\n        return False\n```\n\nThis methodology effectively identifies whether a string can be constructed by appending multiple copies of a substring of itself.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-repeated-substring-pattern"
    },
    {
        "name": "Assign Cookies",
        "site": "LeetCode",
        "href": "/solution/LeetCode-assign-cookies",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.Arrays;\n\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0;\n        for (int j = 0; i < g.length && j < s.length; j++) {\n            if (g[i] <= s[j]) {\n                i++;\n            }\n        }\n        return i;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findContentChildren(self, g, s):\n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int cmpFunc(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint findContentChildren(int* g, int gSize, int* s, int sSize) {\n    int i = 0, j = 0;\n    int result = 0;\n    \n    qsort(g, gSize, sizeof(int), cmpFunc);\n    qsort(s, sSize, sizeof(int), cmpFunc);\n    \n    while (i < gSize && j < sSize) {\n        if (g[i] <= s[j]) {\n            result++;\n            i++;\n        }\n        j++;\n    }\n    \n    return result;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindContentChildren(int[] g, int[] s) \n    {\n        Array.Sort(g);\n        Array.Sort(s);\n        \n        int contentChildren = 0;\n        int gIndex = 0;\n        int sIndex = 0;\n        \n        while (gIndex < g.Length && sIndex < s.Length) {\n            if (s[sIndex] >= g[gIndex]) {\n                contentChildren++;\n                gIndex++;\n                sIndex++;\n            } else {\n                sIndex++;\n            }\n        }\n        \n        return contentChildren;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nconst findContentChildren = (g, s) => {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    \n    let i = 0;\n    let j = 0;\n    let count = 0;\n    \n    while (i < g.length && j < s.length) {\n        if (g[i] <= s[j]) {\n            count++;\n            i++;\n            j++;\n        } else {\n            j++;\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findContentChildren(g: number[], s: number[]): number {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    \n    let i = 0;\n    let j = 0;\n    let count = 0;\n    \n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            count++;\n            i++;\n            j++;\n        } else {\n            j++;\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $g\n     * @param Integer[] $s\n     * @return Integer\n     */\n    function findContentChildren($g, $s) {\n         $count = 0;\n        sort($g);\n        sort($s);\n        $i = 0;\n        $j = 0;\n\n        while ($i < count($g) && $j < count($s)) {\n            if ($g[$i] <= $s[$j]) {\n                $count++;\n                $i++;\n                $j++;\n            } else {\n                $j++;\n            }\n        }\n\n        return $count;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\n        var sortedGreedFactors = g.sorted()\n        var sortedCookies = s.sorted()\n        \n        var i = 0\n        var j = 0\n        var contentChildren = 0\n        \n        while i < sortedGreedFactors.count && j < sortedCookies.count {\n            if sortedCookies[j] >= sortedGreedFactors[i] {\n                contentChildren += 1\n                i += 1\n            }\n            j += 1\n        }\n        \n        return contentChildren\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findContentChildren(g: IntArray, s: IntArray): Int {\n        g.sort()\n        s.sort()\n        var child = 0\n        var cookie = 0\n        \n        while (child < g.size && cookie < s.size) {\n            if (g[child] <= s[cookie]) {\n                child++\n            }\n            cookie++\n        }\n        \n        return child\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int findContentChildren(List<int> g, List<int> s) {\n    g.sort();\n    s.sort();\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    \n    while (i < g.length && j < s.length) {\n      if (s[j] >= g[i]) {\n        count++;\n        i++;\n      }\n      j++;\n    }\n    \n    return count;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findContentChildren(g []int, s []int) int {\n    sort.Ints(g)\n    sort.Ints(s)\n    \n    content := 0\n    gIndex := 0\n    sIndex := 0\n    \n    for gIndex < len(g) && sIndex < len(s) {\n        if s[sIndex] >= g[gIndex] {\n            content++\n            gIndex++\n        }\n        sIndex++\n    }\n    \n    return content\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} g\n# @param {Integer[]} s\n# @return {Integer}\ndef find_content_children(g, s)\n    g.sort!\n    s.sort!\n    content = 0\n    i, j = 0, 0\n    while i < g.length && j < s.length\n        if s[j] >= g[i]\n            content += 1\n            i += 1\n        end\n        j += 1\n    end\n    return content\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findContentChildren(g: Array[Int], s: Array[Int]): Int = {\n        val sortedG = g.sorted\n        val sortedS = s.sorted\n        var i = 0\n        var j = 0\n        var count = 0\n\n        while (i < sortedG.length && j < sortedS.length) {\n            if (sortedS(j) >= sortedG(i)) {\n                count += 1\n                i += 1\n            }\n            j += 1\n        }\n\n        count\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_content_children(g: Vec<i32>, s: Vec<i32>) -> i32 {\n        let mut g = g;\n        let mut s = s;\n        \n        g.sort();\n        s.sort();\n        \n        let mut i = 0;\n        let mut j = 0;\n        let mut count = 0;\n        \n        while i < g.len() && j < s.len() {\n            if s[j] >= g[i] {\n                count += 1;\n                i += 1;\n            }\n            j += 1;\n        }\n        \n        count\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec find_content_children(G :: [integer()], S :: [integer()]) -> integer().\nfind_content_children(G, S) ->\n    greedy_children(lists:sort(G), lists:sort(S), 0).\n\ngreedy_children([], _, Count) ->\n    Count;\ngreedy_children(_, [], Count) ->\n    Count;\ngreedy_children([Gh | Gt], [Sh | St], Count) when Sh >= Gh ->\n    greedy_children(Gt, St, Count + 1);\ngreedy_children(G, [_ | St], Count) ->\n    greedy_children(G, St, Count).\n"
            },
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int content = 0;\n        int i = 0;\n        int j = 0;\n        while (i < g.size() && j < s.size()) {\n            if (s[j] >= g[i]) {\n                content++;\n                i++;\n            }\n            j++;\n        }\n        return content;\n    }\n};"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (find-content-children g s)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  \n  (define sorted-g (sort g <))\n  (define sorted-s (sort s <))\n  \n  (define (helper idx-g idx-s count)\n    (cond\n      [(or (>= idx-g (length sorted-g)) (>= idx-s (length sorted-s))) count]\n      [(>= (list-ref sorted-s idx-s) (list-ref sorted-g idx-g))\n       (helper (add1 idx-g) (add1 idx-s) (add1 count))]\n      [else\n       (helper idx-g (add1 idx-s) count)]\n      )\n    )\n  \n  (helper 0 0 0)\n  )"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to maximize the number of children who are content with the given cookies. This can be done by matching the smallest greed factor with the smallest available cookie size that meets or exceeds it and moving on to the next child and cookie.\n\n# Explanation\n1. **Sorting**: Start by sorting the lists `g` and `s`. This allows us to use a greedy approach to pair the smallest available cookies with the least greedy children first.\n2. **Two Pointers**: Use two pointers (`i` for children and `j` for cookies) to iterate through both lists.\n3. **Greed Factor Matching**: For each child, check if there is a cookie that meets or exceeds the child\u2019s greed factor. If a suitable cookie is found, move to the next child and the next cookie.\n4. **Counting Content Children**: Increment the pointer for children and cookies separately, based on whether a cookie was assigned or not.\n5. **Completion**: The process continues until one of the lists is fully iterated, and the count of content children will be the pointer for children.\n\n# Pseudocode\n```\nfunction findContentChildren(g, s):\n    sort array g\n    sort array s\n    \n    i = 0  // pointer for children\n    j = 0  // pointer for cookies\n    \n    while i < length of g and j < length of s:\n        if g[i] <= s[j]:  // if current cookie can satisfy the current child\n            i += 1  // move to the next child\n        j += 1  // move to the next cookie\n\n    return i  // number of content children is i\n```\n\nThis pseudocode ensures that you maximize the number of content children by using the smallest adequate cookie available for each child.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-assign-cookies"
    },
    {
        "name": "132 Pattern",
        "site": "LeetCode",
        "href": "/solution/LeetCode-132-pattern",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 3) {\n            return false;\n        }\n        \n        stack<int> st;\n        vector<int> minPrefix(n);\n        minPrefix[0] = nums[0];\n        \n        for (int i = 1; i < n; i++) {\n            minPrefix[i] = min(minPrefix[i - 1], nums[i]);\n        }\n        \n        for (int j = n - 1; j >= 0; j--) {\n            if (nums[j] > minPrefix[j]) {\n                while (!st.empty() && st.top() <= minPrefix[j]) {\n                    st.pop();\n                }\n                if (!st.empty() && st.top() < nums[j]) {\n                    return true;\n                }\n                st.push(nums[j]);\n            }\n        }\n        \n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean find132pattern(int[] nums) {\n        if (nums.length < 3) {\n            return false;\n        }\n        \n        int n = nums.length;\n        int min_i = Integer.MAX_VALUE;\n        for (int j = 0; j < n; j++) {\n            min_i = Math.min(min_i, nums[j]);\n            for (int k = j+1; k < n; k++) {\n                if (nums[k] < nums[j] && nums[k] > min_i) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def find132pattern(self, nums):\n        stack = []\n        s3 = float('-inf')\n        \n        for i in range(len(nums)-1, -1, -1):\n            if nums[i] < s3:\n                return True\n            else:\n                while stack and nums[i] > stack[-1]:\n                    s3 = stack.pop()\n            stack.append(nums[i])\n        \n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool find132pattern(int* nums, int numsSize) {\n    if (numsSize < 3) {\n        return false;\n    }\n    \n    int i, j, k;\n    int min_i = nums[0];\n    \n    for (j = 1; j < numsSize - 1; j++) {\n        for (k = j + 1; k < numsSize; k++) {\n            if (nums[k] < nums[j] && nums[j] > min_i && nums[k] > min_i) {\n                return true;\n            }\n        }\n        min_i = fmin(min_i, nums[j]);\n    }\n    \n    return false;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool Find132pattern(int[] nums) {\n        if(nums.Length < 3) return false;\n        \n        int n = nums.Length;\n        int[] minArr = new int[n];\n        minArr[0] = nums[0];\n        \n        for(int i = 1; i < n; i++){\n            minArr[i] = Math.Min(minArr[i-1], nums[i]);\n        }\n        \n        Stack<int> stack = new Stack<int>();\n        \n        for(int j = n-1; j >= 0; j--){\n            if(nums[j] > minArr[j]){\n                while(stack.Count > 0 && stack.Peek() <= minArr[j]){\n                    stack.Pop();\n                }\n                if(stack.Count > 0 && stack.Peek() < nums[j]){\n                    return true;\n                }\n                stack.Push(nums[j]);\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar find132pattern = function(nums) {\n    const n = nums.length;\n    const stack = [];\n    let third = -Infinity;\n\n    for (let i = n - 1; i >= 0; i--) {\n        if (nums[i] < third) {\n            return true;\n        }\n        while (stack.length > 0 && nums[i] > stack[stack.length - 1]) {\n            third = stack.pop();\n        }\n        stack.push(nums[i]);\n    }\n\n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function find132pattern(nums: number[]): boolean {\n    const n = nums.length;\n    if (n < 3) {\n        return false;\n    }\n\n    const stack: number[] = [];\n    let third = -Infinity;\n\n    for (let i = n - 1; i >= 0; i--) {\n        if (nums[i] < third) {\n            return true;\n        }\n\n        while (stack.length > 0 && nums[i] > stack[stack.length - 1]) {\n            third = stack.pop()!;\n        }\n\n        stack.push(nums[i]);\n    }\n\n    return false;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function find132pattern($nums) {\n        $n = count($nums);\n        $stack = [];\n        $s3 = PHP_INT_MIN;\n        \n        for ($i = $n - 1; $i >= 0; $i--) {\n            if ($nums[$i] < $s3) {\n                return true;\n            }\n            while (!empty($stack) && $nums[$i] > end($stack)) {\n                $s3 = array_pop($stack);\n            }\n            if ($nums[$i] > $s3) {\n                $stack[] = $nums[$i];\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func find132pattern(_ nums: [Int]) -> Bool {\n        var minArray = [Int](repeating: 0, count: nums.count)\n        var stack = [Int]()\n        \n        minArray[0] = nums[0]\n        for i in 1..<nums.count {\n            minArray[i] = min(minArray[i-1], nums[i])\n        }\n        \n        for j in stride(from: nums.count-1, through: 0, by: -1) {\n            if nums[j] > minArray[j] {\n                while !stack.isEmpty && stack.last! <= minArray[j] {\n                    stack.removeLast()\n                }\n                if !stack.isEmpty && stack.last! < nums[j] {\n                    return true\n                }\n                stack.append(nums[j])\n            }\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun find132pattern(nums: IntArray): Boolean {\n        var third = Int.MIN_VALUE\n        val stack = Stack<Int>()\n\n        for (i in nums.size - 1 downTo 0) {\n            if (nums[i] < third) {\n                return true\n            }\n            while (stack.isNotEmpty() && nums[i] > stack.peek()) {\n                third = stack.pop()\n            }\n            stack.push(nums[i])\n        }\n\n        return false\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool find132pattern(List<int> nums) {\n    if (nums.length < 3) {\n      return false;\n    }\n    \n    int n = nums.length;\n    List<int> minSoFar = List.filled(n, 0);\n    minSoFar[0] = nums[0];\n    \n    for (int i = 1; i < n; i++) {\n      minSoFar[i] = nums[i] < minSoFar[i - 1] ? nums[i] : minSoFar[i - 1];\n    }\n    \n    List<int> stack = [];\n    for (int j = n - 1; j >= 0; j--) {\n      if (nums[j] > minSoFar[j]) {\n        while (stack.isNotEmpty && stack.last <= minSoFar[j]) {\n          stack.removeLast();\n        }\n        if (stack.isNotEmpty && stack.last < nums[j]) {\n          return true;\n        }\n        stack.add(nums[j]);\n      }\n    }\n    \n    return false;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func find132pattern(nums []int) bool {\n    if len(nums) < 3 {\n        return false\n    }\n\n    stack := make([]int, 0)\n    third := math.MinInt64\n\n    for i := len(nums) - 1; i >= 0; i-- {\n        if nums[i] < third {\n            return true\n        }\n\n        for len(stack) > 0 && nums[i] > stack[len(stack)-1] {\n            third = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n        }\n\n        stack = append(stack, nums[i])\n    }\n\n    return false\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find132pattern(nums: Vec<i32>) -> bool {\n        let n = nums.len();\n        let mut stack = Vec::new();\n        let mut second = std::i32::MIN;\n        \n        for i in (0..n).rev() {\n            if nums[i] < second {\n                return true;\n            }\n            while !stack.is_empty() && nums[i] > stack[stack.len() - 1] {\n                second = stack.pop().unwrap();\n            }\n            stack.push(nums[i]);\n        }\n        \n        false\n    }\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef find132pattern(nums)\n    n = nums.length\n    min_i = []\n    min_i[0] = nums[0]\n    (1..n-1).each do |i|\n        min_i[i] = [min_i[i-1], nums[i]].min\n    end\n    stack = []\n    (n-1).downto(0) do |j|\n        if nums[j] > min_i[j]\n            while !stack.empty? && stack.last <= min_i[j]\n                stack.pop\n            end\n            return true if !stack.empty? && stack.last < nums[j]\n            stack.push(nums[j])\n        end\n    end\n    return false\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find a subsequence of three integers in the given array, such that they form a \"132 pattern\" (i.e., an integer `nums[k]` that lies between `nums[i]` and `nums[j]` where `i < j < k` and `nums[i] < nums[k] < nums[j]`). Here's the explanation and the corresponding pseudocode to solve the challenge.\n\n# Explanation\n\n1. **Initialize Structures**:\n   - Use a stack to manage elements and keep track of potential `nums[k]`.\n   - Use a variable (`s3`) to keep track of the current max possible value for `nums[k]`.\n   \n2. **Iterate Backward**:\n   - Traverse the list from the end to the beginning. This allows us to enforce the condition `i < j < k` while maintaining and updating potential `nums[k]` values with the stack.\n   \n3. **Pattern Check**:\n   - For each element, check if the current element (`nums[i]`) is less than `s3`. If true, it means we found a `132` pattern.\n   - If not, ensure the stack helps find the next best potential `nums[k]` by maintaining elements greater than current `nums[i]` and picking the topmost smaller elements.\n\n4. **Update Stack**:\n   - Push the current element to the stack after above checks.\n\n# Pseudocode\n\n```plaintext\nfunction find132pattern(nums):\n    if length of nums < 3:\n        return False\n    \n    initialize stack as empty list\n    initialize s3 to negative infinity\n    \n    for i from len(nums) - 1 to 0:\n        if nums[i] < s3:\n            return True\n        while stack is not empty and nums[i] > stack[-1]:\n            s3 = stack.pop()\n        push nums[i] to stack\n    \n    return False\n```\n\nThis pseudocode outlines the approach to solving the problem with the stack-based method, ensuring it operates within efficient time complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-132-pattern"
    },
    {
        "name": "Circular Array Loop",
        "site": "LeetCode",
        "href": "/solution/LeetCode-circular-array-loop",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean circularArrayLoop(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            \n            int slow = i;\n            int fast = getNextIndex(nums, i);\n            \n            while (nums[fast] * nums[i] > 0 && nums[getNextIndex(nums, fast)] * nums[i] > 0) {\n                if (slow == fast) {\n                    if (slow == getNextIndex(nums, slow)) {\n                        break;\n                    }\n                    return true;\n                }\n                slow = getNextIndex(nums, slow);\n                fast = getNextIndex(nums, getNextIndex(nums, fast));\n            }\n            \n            slow = i;\n            while (nums[slow] * nums[i] > 0) {\n                int next = getNextIndex(nums, slow);\n                nums[slow] = 0;\n                slow = next;\n            }\n        }\n        \n        return false;\n    }\n    \n    private int getNextIndex(int[] nums, int i) {\n        int n = nums.length;\n        return (i + nums[i] % n + n) % n;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def circularArrayLoop(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            slow = i\n            fast = self.next_index(nums, i)\n            while nums[slow] * nums[fast] > 0 and nums[fast] * nums[self.next_index(nums, fast)] > 0:\n                if slow == fast:\n                    if slow == self.next_index(nums, slow):\n                        break\n                    return True\n                slow = self.next_index(nums, slow)\n                fast = self.next_index(nums, self.next_index(nums, fast))\n            \n            slow = i\n            val = nums[i]\n            while nums[slow] * val > 0:\n                next_slow = self.next_index(nums, slow)\n                nums[slow] = 0\n                slow = next_slow\n        return False\n    \n    def next_index(self, nums, i):\n        n = len(nums)\n        return (i + nums[i]) % n if ((i + nums[i]) % n) >= 0 else n + ((i + nums[i]) % n)\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool CircularArrayLoop(int[] nums) {\n        if (nums == null || nums.Length < 2) return false;\n\n        for (int i = 0; i < nums.Length; i++) {\n            if (nums[i] == 0) continue;\n            int slow = i;\n            int fast = getNext(nums, i);\n\n            while (nums[fast] * nums[i] > 0 && nums[getNext(nums, fast)] * nums[i] > 0) {\n                if (slow == fast) {\n                    if (slow == getNext(nums, slow)) break; // Cycle of length 1\n                    return true;\n                }\n                slow = getNext(nums, slow);\n                fast = getNext(nums, getNext(nums, fast));\n            }\n\n            slow = i;\n            int val = nums[i];\n            while (nums[slow] * val > 0) {\n                int next = getNext(nums, slow);\n                nums[slow] = 0;\n                slow = next;\n            }\n        }\n\n        return false;\n    }\n\n    private int getNext(int[] nums, int i) {\n        int next = i + nums[i];\n        if (next < 0) {\n            return (next % nums.Length + nums.Length) % nums.Length;\n        } else {\n            return next % nums.Length;\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar circularArrayLoop = function(nums) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 0) continue;\n        let slow = i, fast = getNextIndex(i, nums);\n\n        while (nums[i] * nums[fast] > 0 && nums[i] * nums[getNextIndex(fast, nums)] > 0) {\n            if (slow === fast) {\n                if (slow === getNextIndex(slow, nums)) break;\n                return true;\n            }\n            slow = getNextIndex(slow, nums);\n            fast = getNextIndex(getNextIndex(fast, nums), nums);\n        }\n        \n        let position = i;\n        while (nums[position] * nums[getNextIndex(position, nums)] > 0) {\n            let next = getNextIndex(position, nums);\n            nums[position] = 0;\n            position = next;\n        }\n    }\n    \n    return false;\n};\n\nfunction getNextIndex(i, nums) {\n    const n = nums.length;\n    return ((i + nums[i]) % n + n) % n;\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function circularArrayLoop(nums: number[]): boolean {\n    const n = nums.length;\n\n    for (let i = 0; i < n; i++) {\n        if (nums[i] === 0) {\n            continue;\n        }\n\n        let slow = i, fast = next(nums, i);\n\n        // If cycle is not valid, mark all elements as 0\n        while (nums[i] * nums[fast] > 0 && nums[i] * nums[next(nums, fast)] > 0) {\n            if (slow === fast) {\n                if (slow === next(nums, slow)) {\n                    break;\n                }\n                return true;\n            }\n            slow = next(nums, slow);\n            fast = next(nums, next(nums, fast));\n        }\n\n        slow = i;\n        let val = nums[i];\n        while (nums[slow] * val > 0) {\n            let nextIdx = next(nums, slow);\n            nums[slow] = 0;\n            slow = nextIdx;\n        }\n    }\n\n    return false;\n};\n\nfunction next(nums: number[], i: number): number {\n    const n = nums.length;\n    return ((i + nums[i]) % n + n) % n;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     */\n    function circularArrayLoop($nums) {\n        $n = count($nums);\n        for ($i = 0; $i < $n; $i++) {\n            if ($nums[$i] == 0) {\n                continue;\n            }\n            $slow = $i;\n            $fast = $this->getNext($nums, $i);\n            while ($nums[$fast] * $nums[$i] > 0 && $nums[$this->getNext($nums, $fast)] * $nums[$i] > 0) {\n                if ($slow == $fast) {\n                    if ($slow == $this->getNext($nums, $slow)) {\n                        break;\n                    }\n                    return true;\n                }\n                $slow = $this->getNext($nums, $slow);\n                $fast = $this->getNext($nums, $this->getNext($nums, $fast));\n            }\n            $slow = $i;\n            $val = $nums[$i];\n            while ($nums[$slow] * $val > 0) {\n                $next = $this->getNext($nums, $slow);\n                $nums[$slow] = 0;\n                $slow = $next;\n            }\n        }\n        return false;\n    }\n\n    function getNext($nums, $i) {\n        $n = count($nums);\n        return (($i + $nums[$i]) % $n + $n) % $n;\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool circularArrayLoop(List<int> nums) {\n    int n = nums.length;\n    \n    for (int i = 0; i < n; i++) {\n      if (nums[i] == 0) continue;\n      \n      int slow = i;\n      int fast = getNextIndex(i, nums);\n      \n      while (nums[fast] * nums[i] > 0 && nums[getNextIndex(fast, nums)] * nums[i] > 0) {\n        if (slow == fast) {\n          if (slow == getNextIndex(slow, nums)) break;\n          return true;\n        }\n        \n        slow = getNextIndex(slow, nums);\n        fast = getNextIndex(getNextIndex(fast, nums), nums);\n      }\n      \n      int cur = i;\n      int val = nums[i];\n      while (nums[cur] * val > 0) {\n        int next = getNextIndex(cur, nums);\n        nums[cur] = 0;\n        cur = next;\n      }\n    }\n    \n    return false;\n  }\n  \n  int getNextIndex(int i, List<int> nums) {\n    int n = nums.length;\n    return (i + nums[i] % n + n) % n;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func circularArrayLoop(nums []int) bool {\n    n := len(nums)\n    next := func(cur int) int {\n        return ((cur + nums[cur])%n + n) % n\n    }\n    \n    for i := 0; i < n; i++ {\n        if nums[i] == 0 {\n            continue\n        }\n        slow, fast := i, next(i)\n        \n        for nums[fast]*nums[i] > 0 && nums[next(fast)]*nums[i] > 0 {\n            if slow == fast {\n                if slow == next(slow) {\n                    break\n                }\n                return true\n            }\n            slow = next(slow)\n            fast = next(next(fast))\n        }\n        \n        slow = i\n        val := nums[i]\n        for nums[slow]*val > 0 {\n            nextSlow := next(slow)\n            nums[slow] = 0\n            slow = nextSlow\n        }\n    }\n    \n    return false\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun circularArrayLoop(nums: IntArray): Boolean {\n        val n = nums.size\n        for (i in nums.indices) {\n            var slow = i\n            var fast = i\n            while (nums[getIndex(slow, nums)] * nums[i] > 0 && nums[getIndex(fast, nums)] * nums[i] > 0 && nums[getIndex(getIndex(fast, nums), nums)] * nums[i] > 0) {\n                slow = getIndex(slow, nums)\n                fast = getIndex(getIndex(fast, nums), nums)\n                if (slow == fast) {\n                    if (slow == getIndex(slow, nums)) break\n                    return true\n                }\n            }\n            var j = i\n            while (nums[j] * nums[i] > 0) {\n                val next = getIndex(j, nums)\n                nums[j] = 0\n                j = next\n            }\n        }\n        return false\n    }\n\n    private fun getIndex(index: Int, nums: IntArray): Int {\n        var result = index + nums[index]\n        while (result < 0) {\n            result += nums.size\n        }\n        return result % nums.size\n    }\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef circular_array_loop(nums)\n    nums.each_with_index do |num, idx|\n        slow = fast = idx\n        direction = num.positive? ? 1 : -1\n        \n        while nums[slow] * direction > 0 && nums[fast] * direction > 0 && nums[next_idx(fast, nums)] * direction > 0\n            slow = next_idx(slow, nums)\n            fast = next_idx(next_idx(fast, nums), nums)\n            \n            if slow == fast\n                if slow == next_idx(slow, nums)\n                    break\n                else\n                    return true\n                end\n            end\n        end\n        \n        start = idx\n        while nums[start] * direction > 0\n            temp = start\n            start = next_idx(start, nums)\n            nums[temp] = 0\n        end\n    end\n    \n    false\nend\n\ndef next_idx(idx, nums)\n    next_index = idx + nums[idx]\n    next_index %= nums.length\n    next_index >= 0 ? next_index : next_index + nums.length\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn circular_array_loop(nums: Vec<i32>) -> bool {\n        let n = nums.len();\n        \n        for i in 0..n {\n            let mut slow = i;\n            let mut fast = i;\n            \n            while nums[slow] * nums[Solution::next(&nums, slow)] > 0 &&\n                  nums[fast] * nums[Solution::next(&nums, fast)] > 0 &&\n                  nums[fast] * nums[Solution::next(&nums, Solution::next(&nums, fast))] > 0 {\n                slow = Solution::next(&nums, slow);\n                fast = Solution::next(&nums, Solution::next(&nums, fast));\n                \n                if slow == fast {\n                    if slow == Solution::next(&nums, slow) {\n                        break;\n                    }\n                    return true;\n                }\n            }\n        }\n        \n        false\n    }\n    \n    fn next(nums: &Vec<i32>, i: usize) -> usize {\n        let n = nums.len() as i32;\n        let next_index = (i as i32 + nums[i] + n) as usize % n as usize;\n        next_index\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if there is any cycle in a circular array of integers where the movement through the array follows certain rules, and every element in the cycle must either be all positive or all negative.\n\n# Explanation\n\n1. **Input Array Characteristics**: The array consists of non-zero integers. A positive value signifies moving forward, while a negative value means moving backward. The array is circular; hence moving from one end of the array can lead to the other end.\n\n2. **Cycle Definition**: A cycle is valid if all elements within the cycle must have the same sign (either all positive or all negative). Moreover, the cycle length must be greater than 1.\n\n3. **Approach**: We can utilize a two-pointer technique (slow and fast pointers) to detect a cycle, similar to the \"Floyd's Tortoise and Hare\" algorithm which is used for cycle detection in linked lists.\n   - For each index not yet visited, we initiate two pointers starting from that index.\n   - Move the slow pointer one step at a time and the fast pointer two steps at a time.\n   - If at any point the slow and fast pointers meet, a potential cycle is detected.\n   - If a cycle is detected, check if it's a valid cycle based on the problem's requirements (e.g., length > 1, all same signs).\n   - To avoid revisiting nodes, mark all nodes visited in a failed attempt by setting them to 0.\n\n4. **Edge Cases**: Handle scenarios where the cycle length is 1 or the pointers revisit nodes incorrectly.\n\n# Pseudocode\n\n```pseudo\nfunction circularArrayLoop(nums):\n    n = length(nums)\n    \n    function next_index(nums, current):\n        n = length(nums)\n        return (current + nums[current]) % n if ((current + nums[current]) % n) >= 0 else n + ((current + nums[current]) % n)\n    \n    for i from 0 to n-1:\n        if nums[i] == 0:\n            continue\n        \n        slow = i\n        fast = next_index(nums, i)\n        \n        while nums[slow] * nums[fast] > 0 and nums[fast] * nums[next_index(nums, fast)] > 0:\n            if slow == fast:\n                if slow == next_index(nums, slow):  # Single element loop check\n                    break\n                return True\n            slow = next_index(nums, slow)\n            fast = next_index(nums, next_index(nums, fast))\n        \n        # Mark all indices in the failed attempt as zero\n        slow = i\n        val = nums[i]\n        while nums[slow] * val > 0:\n            next_slow = next_index(nums, slow)\n            nums[slow] = 0\n            slow = next_slow\n    \n    return False\n```\n\nIn this pseudocode:\n- A helper function `next_index` is used to calculate the next index in the circular array.\n- The main function iterates through each index to check for cycles using the two-pointer technique.\n- If a cycle is detected, it returns `True`. If no valid cycle is found, it returns `False`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-circular-array-loop"
    },
    {
        "name": "Poor Pigs",
        "site": "LeetCode",
        "href": "/solution/LeetCode-poor-pigs",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        if (buckets == 1) return 0;\n        int pigs = 0;\n        int states = minutesToTest/minutesToDie + 1;\n        while (pow(states, pigs) < buckets) {\n            pigs++;\n        }\n        return pigs;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        int pigs = 0;\n        int states = minutesToTest/minutesToDie + 1;\n        while (Math.pow(states, pigs) < buckets) {\n            pigs++;\n        }\n        return pigs;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    int states = minutesToTest/minutesToDie + 1;\n    \n    while (pow(states, pigs) < buckets) {\n        pigs++;\n    }\n    \n    return pigs;\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function poorPigs(buckets: number, minutesToDie: number, minutesToTest: number): number {\n    let pigs = 0;\n    let states = Math.floor(minutesToTest/minutesToDie) + 1;\n    \n    while (Math.pow(states, pigs) < buckets) {\n        pigs++;\n    }\n    \n    return pigs;\n};"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func poorPigs(_ buckets: Int, _ minutesToDie: Int, _ minutesToTest: Int) -> Int {\n        var pigNumber = 0\n        var states = (minutesToTest/minutesToDie) + 1\n        while pow(Double(states), Double(pigNumber)) < Double(buckets) {\n            pigNumber += 1\n        }\n        return pigNumber\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun poorPigs(buckets: Int, minutesToDie: Int, minutesToTest: Int): Int {\n        var pigs = 0\n        var testInterval = minutesToTest / minutesToDie + 1\n        while (Math.pow(testInterval.toDouble(), pigs.toDouble()) < buckets) {\n            pigs++\n        }\n        return pigs\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    int rounds = minutesToTest ~/ minutesToDie + 1;\n    while (pow(rounds, pigs) < buckets) {\n      pigs++;\n    }\n    return pigs;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func poorPigs(buckets int, minutesToDie int, minutesToTest int) int {\n    pigs := 0\n    base := minutesToTest/minutesToDie + 1\n    for pow := 0; pow < buckets; pow++ {\n        if power(base, pow) >= buckets {\n            return pigs\n        }\n        pigs++\n    }\n    return pigs\n}\n\nfunc power(base, exp int) int {\n    result := 1\n    for exp > 0 {\n        if exp%2 == 1 {\n            result *= base\n        }\n        exp /= 2\n        base *= base\n    }\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} buckets\n# @param {Integer} minutes_to_die\n# @param {Integer} minutes_to_test\n# @return {Integer}\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test)\n    pigs = 0\n    while (minutes_to_test / minutes_to_die + 1) ** pigs < buckets\n        pigs += 1\n    end\n    pigs\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def poorPigs(buckets: Int, minutesToDie: Int, minutesToTest: Int): Int = {\n        var pigs = 0\n        var tests = minutesToTest / minutesToDie + 1\n        \n        while (Math.pow(tests, pigs) < buckets) {\n            pigs += 1\n        }\n        \n        pigs\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int PoorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        int pigs = 0;\n        int states = minutesToTest / minutesToDie + 1;\n        \n        while (Math.Pow(states, pigs) < buckets) {\n            pigs++;\n        }\n        \n        return pigs;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} buckets\n * @param {number} minutesToDie\n * @param {number} minutesToTest\n * @return {number}\n */\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\n    let pigs = 0;\n    while (Math.pow((Math.floor(minutesToTest/minutesToDie) + 1), pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to determine the minimum number of pigs necessary to identify the single poisonous bucket within the given time constraints. \n\n# Explanation\n\n1. **Understand the Problem**: We have a certain number of buckets, with exactly one being poisonous. We're given specified durations for `minutesToDie` (how long it takes for a pig to die after consuming poison) and `minutesToTest` (total time we have to determine the poisonous bucket). We need to find the minimum number of pigs required.\n\n2. **Determine Test Rounds**: Calculate how many complete tests can be conducted within the total testing time. The number of tests `t` is given by:\n\\[ t = \\left\\lfloor \\frac{\\text{minutesToTest}}{\\text{minutesToDie}} \\right\\rfloor \\]\n\n3. **State Representation**: Each pig has three states per test (alive, dead, not tested). For each pig, over `t` tests, it has \\((t + 1)\\) possibilities. If there are `p` pigs, the total combination of test results is \\((t + 1)^p\\).\n\n4. **Covering All Buckets**: We require that the number of possible outcomes (combinations of pigs surviving and dying) must at least equal the number of buckets to cover all possibilities:\n\\[ (t + 1)^p \\geq \\text{buckets} \\]\n\n5. **Determine Number of Pigs**: The minimum number of pigs `p` is the smallest integer satisfying the above inequation.\n\n# Pseudocode\n\n```plaintext\nfunction poorPigs(buckets, minutesToDie, minutesToTest):\n    \n    # Determine the number of test rounds possible\n    t = minutesToTest // minutesToDie\n    \n    # Initialize pigs count\n    pigs = 0\n    \n    # Increase the number of pigs until (t + 1)^pigs is at least the number of buckets\n    while (t + 1) ** pigs < buckets:\n        pigs += 1\n    \n    return pigs\n```\n\nThe pseudocode above follows the logic detailed in the explanation and will help determine the minimum number of pigs required to solve the problem based on given inputs.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-poor-pigs"
    },
    {
        "name": "Lfu Cache",
        "site": "LeetCode",
        "href": "/solution/LeetCode-lfu-cache",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class LFUCache {\nprivate:\n    int capacity;\n    int minFreq;\n    unordered_map<int, pair<int, int>> cache;\n    unordered_map<int, list<int>::iterator> keyIter;\n    unordered_map<int, list<int>> freqKeys;\n\npublic:\n    LFUCache(int capacity) {\n        this->capacity = capacity;\n        minFreq = 0;\n    }\n\n    int get(int key) {\n        if (cache.find(key) == cache.end()) {\n            return -1;\n        }\n        int value = cache[key].first;\n        int freq = cache[key].second;\n        updateFreq(key, value, freq);\n        return value;\n    }\n\n    void put(int key, int value) {\n        if (capacity == 0) {\n            return;\n        }\n        if (cache.find(key) != cache.end()) {\n            cache[key].first = value;\n            updateFreq(key, value, cache[key].second);\n        } else {\n            if (cache.size() >= capacity) {\n                int minKey = freqKeys[minFreq].back();\n                freqKeys[minFreq].pop_back();\n                if (freqKeys[minFreq].empty()) {\n                    freqKeys.erase(minFreq);\n                }\n                cache.erase(minKey);\n                keyIter.erase(minKey);\n            }\n            cache[key] = {value, 1};\n            minFreq = 1;\n            freqKeys[1].push_front(key);\n            keyIter[key] = freqKeys[1].begin();\n        }\n    }\n\nprivate:\n    void updateFreq(int key, int value, int freq) {\n        freqKeys[freq].erase(keyIter[key]);\n        if (freqKeys[freq].empty()) {\n            if (freq == minFreq) {\n                minFreq++;\n            }\n            freqKeys.erase(freq);\n        }\n        cache[key].second++;\n        freqKeys[freq + 1].push_front(key);\n        keyIter[key] = freqKeys[freq + 1].begin();\n    }\n};\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class LFUCache {\n    \n    Map<Integer, Integer> keyToVal;\n    Map<Integer, Integer> keyToCount;\n    Map<Integer, Integer> countToFreq;\n    Map<Integer, LinkedHashSet<Integer>> freqToKeys;\n    int capacity;\n    int minFreq;\n\n    public LFUCache(int capacity) {\n        keyToVal = new HashMap<>();\n        keyToCount = new HashMap<>();\n        countToFreq = new HashMap<>();\n        freqToKeys = new HashMap<>();\n        freqToKeys.put(1, new LinkedHashSet<>());\n        this.capacity = capacity;\n        this.minFreq = 1;\n    }\n\n    public int get(int key) {\n        if (!keyToVal.containsKey(key)) {\n            return -1;\n        }\n        int freq = keyToCount.get(key);\n        int newFreq = freq + 1;\n        keyToCount.put(key, newFreq);\n        countToFreq.put(freq, countToFreq.get(freq) - 1);\n        countToFreq.put(newFreq, countToFreq.getOrDefault(newFreq, 0) + 1);\n\n        if (freq == minFreq && countToFreq.get(freq) == 0) {\n            minFreq = newFreq;\n        }\n\n        freqToKeys.get(freq).remove(key);\n        freqToKeys.putIfAbsent(newFreq, new LinkedHashSet<>());\n        freqToKeys.get(newFreq).add(key);\n\n        return keyToVal.get(key);\n    }\n\n    public void put(int key, int value) {\n        if (capacity <= 0) {\n            return;\n        }\n\n        if (!keyToVal.containsKey(key)) {\n            if (keyToVal.size() >= capacity) {\n                int removedKey = freqToKeys.get(minFreq).iterator().next();\n                keyToVal.remove(removedKey);\n                keyToCount.remove(removedKey);\n                freqToKeys.get(minFreq).remove(removedKey);\n                countToFreq.put(minFreq, countToFreq.get(minFreq) - 1);\n            }\n            keyToVal.put(key, value);\n            keyToCount.put(key, 1);\n            countToFreq.put(1, countToFreq.getOrDefault(1, 0) + 1);\n            freqToKeys.get(1).add(key);\n            minFreq = 1;\n        } else {\n            keyToVal.put(key, value);\n            int freq = keyToCount.get(key);\n            int newFreq = freq + 1;\n            keyToCount.put(key, newFreq);\n            countToFreq.put(freq, countToFreq.get(freq) - 1);\n            countToFreq.put(newFreq, countToFreq.getOrDefault(newFreq, 0) + 1);\n\n            if (freq == minFreq && countToFreq.get(freq) == 0) {\n                minFreq = newFreq;\n            }\n\n            freqToKeys.get(freq).remove(key);\n            freqToKeys.putIfAbsent(newFreq, new LinkedHashSet<>());\n            freqToKeys.get(newFreq).add(key);\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.freqMap = new Map();\n\n    this.get = function(key) {\n        if (this.cache.has(key)) {\n            const [value, freq] = this.cache.get(key);\n            this.cache.set(key, [value, freq + 1]);\n            this.freqMap.get(freq).delete(key);\n\n            if (this.freqMap.get(freq).size === 0) {\n                this.freqMap.delete(freq);\n            }\n\n            if (!this.freqMap.has(freq + 1)) {\n                this.freqMap.set(freq + 1, new Set());\n            }\n            this.freqMap.get(freq + 1).add(key);\n\n            return value;\n        } else {\n            return -1;\n        }\n    };\n\n    this.put = function(key, value) {\n        if (this.capacity === 0) return;\n\n        if (this.cache.has(key)) {\n            const [, freq] = this.cache.get(key);\n            this.cache.set(key, [value, freq + 1]);\n\n            this.freqMap.get(freq).delete(key);\n\n            if (this.freqMap.get(freq).size === 0) {\n                this.freqMap.delete(freq);\n            }\n\n            if (!this.freqMap.has(freq + 1)) {\n                this.freqMap.set(freq + 1, new Set());\n            }\n            this.freqMap.get(freq + 1).add(key);\n        } else {\n            if (this.cache.size === this.capacity) {\n                const minFreq = Math.min(...this.freqMap.keys());\n                const lfu = this.freqMap.get(minFreq).values().next().value;\n\n                this.cache.delete(lfu);\n                this.freqMap.get(minFreq).delete(lfu);\n                if (this.freqMap.get(minFreq).size === 0) {\n                    this.freqMap.delete(minFreq);\n                }\n            }\n\n            this.cache.set(key, [value, 1]);\n            if (!this.freqMap.has(1)) {\n                this.freqMap.set(1, new Set());\n            }\n            this.freqMap.get(1).add(key);\n        }\n    };\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class LFUCache {\n    capacity: number;\n    cache: Map<number, number>;\n    frequency: Map<number, number>;\n    timestamp: Map<number, number>;\n    \n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.cache = new Map();\n        this.frequency = new Map();\n        this.timestamp = new Map();\n    }\n\n    get(key: number): number {\n        if (!this.cache.has(key)) {\n            return -1;\n        }\n\n        this.updateFrequency(key);\n        return this.cache.get(key);\n    }\n\n    put(key: number, value: number): void {\n        if (this.capacity === 0) {\n            return;\n        }\n\n        if (this.cache.size >= this.capacity && !this.cache.has(key)) {\n            this.evict();\n        }\n\n        this.cache.set(key, value);\n        this.updateFrequency(key);\n    }\n\n    private updateFrequency(key: number): void {\n        const currFreq = this.frequency.get(key) || 0;\n        this.frequency.set(key, currFreq + 1);\n        this.timestamp.set(key, Date.now());\n    }\n\n    private evict(): void {\n        let minFreq = Infinity;\n        let oldestTime = Infinity;\n        let keyToRemove: number | null = null;\n\n        for (const [key, freq] of this.frequency) {\n            if (freq < minFreq || (freq === minFreq && this.timestamp.get(key)! < oldestTime)) {\n                minFreq = freq;\n                keyToRemove = key;\n                oldestTime = this.timestamp.get(key)!;\n            }\n        }\n\n        if (keyToRemove !== null) {\n            this.cache.delete(keyToRemove);\n            this.frequency.delete(keyToRemove);\n            this.timestamp.delete(keyToRemove);\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class LFUCache(capacity: Int) {\n    private val cache = hashMapOf<Int, Int>()\n    private val frequencyMap = hashMapOf<Int, Int>()\n    private val usedMap = hashMapOf<Int, Int>()\n    private var minFrequency = 0\n    private val maxCapacity = capacity\n\n    fun get(key: Int): Int {\n        if (!cache.containsKey(key)) {\n            return -1\n        }\n        updateFrequency(key)\n        return cache[key] ?: -1\n    }\n\n    fun put(key: Int, value: Int) {\n        if (maxCapacity <= 0) return\n\n        if (cache.containsKey(key)) {\n            cache[key] = value\n            updateFrequency(key)\n        } else {\n            if (cache.size >= maxCapacity) {\n                evictLeastUsed()\n            }\n            cache[key] = value\n            frequencyMap[key] = 1\n            minFrequency = 1\n        }\n        updateFrequency(key)\n    }\n\n    private fun updateFrequency(key: Int) {\n        val frequency = frequencyMap.getOrDefault(key, 0)\n        frequencyMap[key] = frequency + 1\n        val used = usedMap.getOrDefault(key, 0)\n        usedMap[key] = used + 1\n\n        if (frequency > 0) {\n            val keys = frequencyMap.filterValues { it == frequency }.keys\n            keys.forEach { updateLru(it) }\n            if (frequency == minFrequency && keys.isEmpty()) {\n                minFrequency++\n            }\n        }\n    }\n\n    private fun updateLru(key: Int) {\n        val used = usedMap[key] ?: 0\n        usedMap[key] = used + 1\n    }\n\n    private fun evictLeastUsed() {\n        val keys = frequencyMap.filterValues { it == minFrequency }.keys\n        var leastUsedKey = -1\n        var minUsed = Int.MAX_VALUE\n        for (key in keys) {\n            val used = usedMap.getOrDefault(key, 0)\n            if (used < minUsed) {\n                minUsed = used\n                leastUsedKey = key\n            }\n        }\n        if (leastUsedKey != -1) {\n            cache.remove(leastUsedKey)\n            frequencyMap.remove(leastUsedKey)\n            usedMap.remove(leastUsedKey)\n        }\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class LFUCache\n=begin\n    :type capacity: Integer\n    def initialize(capacity)\n        \n    end\n\n    :type key: Integer\n    :rtype Integer\n    def get(key)\n        \n    end\n\n    :type key: Integer\n    :type value: Integer\n    :rtype nil\n    def put(key, value)\n        \n    end\n=end\n    def initialize(capacity)\n        @capacity = capacity\n        @cache = {}\n        @freq = {}\n        @min_freq = 0\n    end\n\n    def get(key)\n        return -1 if !@cache.key?(key)\n\n        value, freq = @cache[key]\n        update_freq(key, value, freq)\n        value\n    end\n\n    def put(key, value)\n        return if @capacity == 0\n\n        if @cache.key?(key)\n            _, cur_freq = @cache[key]\n            update_freq(key, value, cur_freq)\n        else\n            if @cache.size >= @capacity\n                remove_lfu\n            end\n            add_new_key(key, value)\n        end\n    end\n\n    private\n\n    def update_freq(key, value, freq)\n        @freq[freq].delete(key)\n        @freq[freq].shift if @freq[freq].empty?\n\n        @freq[freq + 1] ||= []\n        @freq[freq + 1] << key\n        @cache[key] = [value, freq + 1]\n\n        if !@freq.key?(@min_freq) || @freq[@min_freq].empty?\n            @min_freq += 1\n        end\n    end\n\n    def remove_lfu\n        lfu_key = @freq[@min_freq].shift\n        @cache.delete(lfu_key)\n    end\n\n    def add_new_key(key, value)\n        @cache[key] = [value, 1]\n        @freq[1] ||= []\n        @freq[1] << key\n        @min_freq = 1\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "import scala.collection.mutable\n\nclass LFUCache(_capacity: Int) {\n    case class Node(key: Int, var value: Int, var freq: Int)\n    \n    var capacity: Int = _capacity\n    var minFreq: Int = 0\n    var cache: mutable.Map[Int, Node] = mutable.Map.empty\n    var freqMap: mutable.Map[Int, mutable.LinkedHashSet[Node]] = mutable.Map.empty\n\n    def increaseFreq(node: Node): Unit = {\n        val freq = node.freq\n        freqMap(freq) -= node\n        if (freqMap(freq).isEmpty) {\n            freqMap -= freq\n            if (minFreq == freq) minFreq += 1\n        }\n        \n        node.freq += 1\n        freqMap.getOrElseUpdate(node.freq, mutable.LinkedHashSet.empty) += node\n    }\n\n    def get(key: Int): Int = {\n        cache.get(key) match {\n            case Some(node) =>\n                increaseFreq(node)\n                node.value\n            case None => -1\n        }\n    }\n\n    def put(key: Int, value: Int): Unit = {\n        if (capacity == 0) return\n        \n        cache.get(key) match {\n            case Some(node) =>\n                node.value = value\n                increaseFreq(node)\n            case None =>\n                if (cache.size == capacity) {\n                    val toEvict = freqMap(minFreq).head\n                    cache -= toEvict.key\n                    freqMap(minFreq) -= toEvict\n                    if (freqMap(minFreq).isEmpty) {\n                        freqMap -= minFreq\n                    }\n                }\n                \n                val node = Node(key, value, 1)\n                cache(key) = node\n                freqMap.getOrElseUpdate(1, mutable.LinkedHashSet.empty) += node\n                minFreq = 1\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement an LFU (Least Frequently Used) Cache that efficiently supports the `get` and `put` operations while maintaining the given constraints.\n\n# Explanation\nThe key concepts we'll use to implement LFU Cache are:\n1. **Hash Map (`cache`)**: To store key-value pairs where each entry is of the form `(key, (value, frequency))`.\n2. **Frequency Map (`freqMap`)**: To store keys with the same frequency together in a set.\n\n**Step-by-Step Approach**:\n1. **Initialize Cache and Frequency Map**: When we initialize the LFU Cache object, we set up the capacity, cache, and frequency map.\n2. **Get Operation**: \n   - Check if the key exists in the cache.\n   - If it does, retrieve its value and frequency, update its frequency, and move the key to the appropriate set in the `freqMap`.\n   - If not, return -1.\n3. **Put Operation**:\n   - If the key already exists, update its value and frequency.\n   - If the key does not exist, check if the cache is at capacity.\n     - If at capacity, find and remove the LFU key.\n   - Insert the new key and set its frequency to 1.\n\n**Tie-Breaking**:\n- Maintain the order of keys in the `freqMap` sets to ensure least recently used (LRU) is removed first when there is a tie in frequencies.\n\n# Pseudocode\n\n```pseudo\nclass LFUCache:\n    function __init__(capacity):\n        this.capacity = capacity\n        this.cache = {}   # stores key: (value, frequency)\n        this.freqMap = {} # stores frequency: set of keys\n        this.minFreq = 0  # tracks the minimum frequency in the cache\n\n    function get(key):\n        if key not in cache:\n            return -1\n        value, freq = cache[key]\n        # Update frequency\n        cache[key] = (value, freq + 1)\n        # Move the key to the new freq\n        freqMap[freq].remove(key)\n        if not freqMap[freq]:\n            del freqMap[freq]\n            if minFreq == freq:\n                minFreq += 1\n        if freq + 1 not in freqMap:\n            freqMap[freq + 1] = set()\n        freqMap[freq + 1].add(key)\n        return value\n\n    function put(key, value):\n        if capacity == 0:\n            return\n        if key in cache:\n            _, freq = cache[key]\n            cache[key] = (value, freq + 1)\n            freqMap[freq].remove(key)\n            if not freqMap[freq]:\n                del freqMap[freq]\n                if minFreq == freq:\n                    minFreq += 1\n            if freq + 1 not in freqMap:\n                freqMap[freq + 1] = set()\n            freqMap[freq + 1].add(key)\n        else:\n            if len(cache) >= capacity:\n                # Remove LFU Key\n                lfuKey = next(iter(freqMap[minFreq]))\n                freqMap[minFreq].remove(lfuKey)\n                if not freqMap[minFreq]:\n                    del freqMap[minFreq]\n                del cache[lfuKey]\n            # Insert new key with freq 1\n            cache[key] = (value, 1)\n            if 1 not in freqMap:\n                freqMap[1] = set()\n            freqMap[1].add(key)\n            minFreq = 1\n```\n\nThis pseudocode outlines the logic and structure for implementing the LFU cache as described. With it, you can now translate this structure into an actual programming language like Python, C++, or Java.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-lfu-cache"
    },
    {
        "name": "Valid Palindrome",
        "site": "LeetCode",
        "href": "/solution/LeetCode-valid-palindrome",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        string cleanS;\n        for(auto c : s){\n            if(isalnum(c)){\n                cleanS += tolower(c);\n            }\n        }\n        \n        int left = 0, right = cleanS.size() - 1;\n        while(left < right){\n            if(cleanS[left] != cleanS[right]){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n        int left = 0, right = s.length()-1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        cleaned_s = ''.join(char.lower() for char in s if char.isalnum())\n        return cleaned_s == cleaned_s[::-1]\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isPalindrome(char* s) {\n    int left = 0, right = strlen(s) - 1;\n    \n    while (left < right) {\n        if (!isalnum(s[left])) {\n            left++;\n        } else if (!isalnum(s[right])) {\n            right--;\n        } else {\n            if (tolower(s[left]) != tolower(s[right])) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n    }\n    \n    return true;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsPalindrome(string s) {\n        s = s.ToLower();\n        StringBuilder sb = new StringBuilder();\n        foreach (char c in s)\n        {\n            if (Char.IsLetterOrDigit(c))\n            {\n                sb.Append(c);\n            }\n        }\n        string filteredString = sb.ToString();\n        int left = 0;\n        int right = filteredString.Length - 1;\n\n        while (left < right)\n        {\n            if (filteredString[left] != filteredString[right])\n            {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isPalindrome(s: string): boolean {\n    const alphanumericString = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    let left = 0;\n    let right = alphanumericString.length - 1;\n    \n    while (left < right) {\n        if (alphanumericString[left] !== alphanumericString[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Boolean\n     */\n    function isPalindrome($s) {\n        $s = strtolower(preg_replace(\"/[^A-Za-z0-9]/\", '', $s));\n        $reversed = strrev($s);\n        return $s === $reversed;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isPalindrome(_ s: String) -> Bool {\n        let alphanumericString = s.lowercased().components(separatedBy: CharacterSet.alphanumerics.inverted).joined()\n        return alphanumericString == String(alphanumericString.reversed())\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isPalindrome(s: String): Boolean {\n        val filteredString = s.filter { it.isLetterOrDigit() }\n        val reversedString = filteredString.reversed()\n        return filteredString.equals(reversedString, ignoreCase = true)\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isPalindrome(String s) {\n    s = s.toLowerCase().replaceAll(RegExp(r'[^a-z0-9]'), '');\n    for (int i = 0, j = s.length - 1; i < j; i++, j--) {\n      if (s[i] != s[j]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "import \"strings\"\nimport \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    s = strings.ToLower(s)\n    var sb strings.Builder\n    for _, ch := range s {\n        if unicode.IsLetter(ch) || unicode.IsDigit(ch) {\n            sb.WriteRune(ch)\n        }\n    }\n    \n    cleanedStr := sb.String()\n    left, right := 0, len(cleanedStr)-1\n    for left < right {\n        if cleanedStr[left] != cleanedStr[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    \n    return true\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Boolean}\ndef is_palindrome(s)\n    s = s.downcase.gsub(/[^a-z0-9]/, '')\n    s == s.reverse\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to check if a given string `s` can be considered a palindrome after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. We should read the resulting string both forwards and backwards to determine if it is the same.\n\n# Explanation\n1. **Convert to Lowercase and Remove Non-Alphanumeric Characters:** First, transform the given string to lowercase and remove any characters that are not letters or numbers.\n2. **Check Palindrome:** Compare the cleaned string to its reverse. If they are identical, the string is a palindrome; otherwise, it is not.\n\n# Pseudocode\n1. Define the method `isPalindrome` accepting a string `s`.\n2. Initialize an empty string `cleaned_s`.\n3. Iterate over each character in the string `s`.\n   - If the character is alphanumeric, convert it to lowercase and append to `cleaned_s`.\n4. Compare `cleaned_s` to its reverse.\n5. Return `true` if `cleaned_s` is the same forwards and backwards, otherwise return `false`.\n\nHere is the pseudocode:\n\n```\nfunction isPalindrome(s):\n    # Step 1: Initialize an empty string to store the cleaned string\n    cleaned_s = \"\"\n    \n    # Step 2: Loop through each character in the input string\n    for each character in s:\n        # Step 3: Check if the character is alphanumeric\n        if character is alphanumeric:\n            # Step 4: Convert to lowercase and add to cleaned_s\n            cleaned_s += toLowerCase(character)\n    \n    # Step 5: Check if cleaned_s is the same as its reverse\n    if cleaned_s is equal to reverse(cleaned_s):\n        return true\n    else:\n        return false\n```\nThis pseudocode ensures that any given string `s` is processed to remove non-alphanumeric characters, converts the characters to lowercase, and checks if the cleaned string is a palindrome.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-valid-palindrome"
    },
    {
        "name": "Binary Tree Maximum Path Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-maximum-path-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left\n(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int max_sum = INT_MIN;\n        maxPathSumHelper(root, max_sum);\n        return max_sum;\n    }\n    \n    int maxPathSumHelper(TreeNode* root, int& max_sum) {\n        if (root == nullptr) return 0;\n        \n        int left_sum = max(0, maxPathSumHelper(root->left, max_sum));\n        int right_sum = max(0, maxPathSumHelper(root->right, max_sum));\n        \n        int total_sum = root->val + left_sum + right_sum;\n        \n        max_sum = max(max_sum, total_sum);\n        \n        return root->val + max(left_sum, right_sum);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    int maxPathSum = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        calculateSum(root);\n        return maxPathSum;\n    }\n    \n    private int calculateSum(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int left = Math.max(0, calculateSum(node.left));\n        int right = Math.max(0, calculateSum(node.right));\n        \n        maxPathSum = Math.max(maxPathSum, left + right + node.val);\n        \n        return Math.max(left, right) + node.val;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint maxPathSum(struct TreeNode* root) {\n    int max_sum = INT_MIN;\n    \n    int maxGain(struct TreeNode* node) {\n        if (node == NULL) {\n            return 0;\n        }\n        \n        int left_gain = fmax(maxGain(node->left), 0);\n        int right_gain = fmax(maxGain(node->right), 0);\n        \n        int node_path_sum = node->val + left_gain + right_gain;\n        \n        max_sum = fmax(max_sum, node_path_sum);\n        \n        return node->val + fmax(left_gain, right_gain);\n    }\n    \n    maxGain(root);\n    \n    return max_sum;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    int maxPathSum = int.MinValue;\n\n    public int MaxPathSum(TreeNode root) {\n        CalculateMaxPathSum(root);\n        return maxPathSum;\n    }\n\n    private int CalculateMaxPathSum(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n\n        int leftSum = Math.Max(0, CalculateMaxPathSum(node.left));\n        int rightSum = Math.Max(0, CalculateMaxPathSum(node.right));\n\n        int currentPathSum = node.val + leftSum + rightSum;\n        maxPathSum = Math.Max(maxPathSum, currentPathSum);\n\n        return node.val + Math.Max(leftSum, rightSum);\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let maxSum = -Infinity;\n    \n    const maxPathSumRecursive = (node) => {\n        if (node === null) {\n            return 0;\n        }\n        \n        const leftSum = Math.max(maxPathSumRecursive(node.left), 0);\n        const rightSum = Math.max(maxPathSumRecursive(node.right), 0);\n        \n        const currentSum = node.val + leftSum + rightSum;\n        maxSum = Math.max(maxSum, currentSum);\n        \n        return node.val + Math.max(leftSum, rightSum);\n    };\n    \n    maxPathSumRecursive(root);\n    \n    return maxSum;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxPathSum(root: TreeNode | null): number {\n    let maxSum: number = -Infinity;\n    \n    const dfs = (node: TreeNode | null): number => {\n        if (!node) return 0;\n        \n        const leftSum = Math.max(0, dfs(node.left));\n        const rightSum = Math.max(0, dfs(node.right));\n        \n        maxSum = Math.max(maxSum, node.val + leftSum + rightSum);\n        \n        return node.val + Math.max(leftSum, rightSum);\n    };\n    \n    dfs(root);\n    \n    return maxSum;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxPathSum($root) {\n        $maxSum = PHP_INT_MIN;\n        $this->maxPathSumHelper($root, $maxSum);\n        return $maxSum;\n    }\n    \n    function maxPathSumHelper($node, &$maxSum) {\n        if ($node === null) return 0;\n        \n        $leftSum = max(0, $this->maxPathSumHelper($node->left, $maxSum));\n        $rightSum = max(0, $this->maxPathSumHelper($node->right, $maxSum));\n        \n        $maxSum = max($maxSum, $node->val + $leftSum + $rightSum);\n        \n        return $node->val + max($leftSum, $rightSum);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n */\n\nclass Solution {\n    func maxPathSum(_ root: TreeNode?) -> Int {\n        var maxSum = Int.min\n        \n        func maxGain(_ node: TreeNode?) -> Int {\n            guard let node = node else { return 0 }\n            \n            let leftGain = max(maxGain(node.left), 0)\n            let rightGain = max(maxGain(node.right), 0)\n            \n            let currentSum = node.val + leftGain + rightGain\n            maxSum = max(maxSum, currentSum)\n            \n            return node.val + max(leftGain, rightGain)\n        }\n        \n        _ = maxGain(root)\n        return maxSum\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    var maxSum = Int.MIN_VALUE\n    \n    fun maxPathSum(root: TreeNode?): Int {\n        fun maxGain(node: TreeNode?): Int {\n            if (node == null) return 0\n            val leftGain = maxOf(0, maxGain(node.left))\n            val rightGain = maxOf(0, maxGain(node.right))\n            \n            val newPathSum = node.`val` + leftGain + rightGain\n            maxSum = maxOf(maxSum, newPathSum)\n            \n            return node.`val` + maxOf(leftGain, rightGain)\n        }\n        \n        maxGain(root)\n        \n        return maxSum\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int maxPathSum(TreeNode? root) {\n    int maxSum = -1001;\n    \n    int maxPath(TreeNode? node) {\n      if (node == null) return 0;\n      \n      int leftSum = max(0, maxPath(node.left));\n      int rightSum = max(0, maxPath(node.right));\n      \n      maxSum = max(maxSum, node.val + leftSum + rightSum);\n      \n      return node.val + max(leftSum, rightSum);\n    }\n    \n    maxPath(root);\n    \n    return maxSum;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc maxPathSum(root *TreeNode) int {\n    var maxSum int\n    maxSum = root.Val\n    var maxPath func(node *TreeNode) int\n    maxPath = func(node *TreeNode) int {\n        if node == nil {\n            return 0\n        }\n        left := max(maxPath(node.Left), 0)\n        right := max(maxPath(node.Right), 0)\n        maxSum = max(maxSum, node.Val+left+right)\n        return node.Val + max(left, right)\n    }\n\n    maxPath(root)\n    return maxSum\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef max_path_sum(root)\n    @max_sum = -Float::INFINITY\n    \n    def helper(node)\n        return 0 if node.nil?\n        \n        left_sum = [helper(node.left), 0].max\n        right_sum = [helper(node.right), 0].max\n        \n        current_sum = left_sum + right_sum + node.val\n        @max_sum = [@max_sum, current_sum].max\n        \n        return [left_sum, right_sum].max + node.val\n    end\n    \n    helper(root)\n    \n    return @max_sum\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: \nTreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def maxPathSum(root: TreeNode): Int = {\n        var maxSum = Int.MinValue\n        \n        def maxPathSumHelper(node: TreeNode): Int = {\n            if (node == null) return 0\n            \n            val leftSum = math.max(0, maxPathSumHelper(node.left))\n            val rightSum = math.max(0, maxPathSumHelper(node.right))\n            \n            maxSum = math.max(maxSum, node.value + leftSum + rightSum)\n            \n            math.max(leftSum, rightSum) + node.value\n        }\n        \n        maxPathSumHelper(root)\n        \n        maxSum\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::cmp;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut result = i32::MIN;\n        Self::max_gain(&root, &mut result);\n        result\n    }\n    \n    fn max_gain(node: &Option<Rc<RefCell<TreeNode>>>, result: &mut i32) -> i32 {\n        if let Some(n) = node {\n            let n = n.borrow();\n            let left_gain = cmp::max(0, Self::max_gain(&n.left, result));\n            let right_gain = cmp::max(0, Self::max_gain(&n.right, result));\n            \n            let price_newpath = n.val + left_gain + right_gain;\n            \n            *result = cmp::max(*result, price_newpath);\n            \n            n.val + cmp::max(left_gain, right_gain)\n        } else {\n            0\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse the binary tree and calculate the maximum path sum such that the path can start and end at any node, considering both branches of the tree recursively. Here is the explanation and pseudocode for this approach.\n\n# Explanation\n\n1. **Define the TreeNode Structure**: Each node in the binary tree contains a value `val` and pointers to its left and right children.\n2. **Recursive Function**: Create a recursive function to compute the maximum path sum for each subtree rooted at the current node.\n3. **Initialize Max Sum**: Start with a very small number (`-Infinity`) as the initial maximum path sum.\n4. **Base Case**: If the current node is `null`, return `0` because a null node contributes nothing to the path sum.\n5. **Calculate Left and Right Sums**: Recursively calculate the maximum path sums of the left and right subtrees.\n6. **Ignore Negative Paths**: If the computed path sum of the left or right subtree is negative, treat it as `0` since it reduces the overall path sum.\n7. **Update Current Sum**: Calculate the path sum if the path passes through the current node, including both left and right children.\n8. **Update Maximum Sum**: Update the global maximum path sum if the current path sum is greater than previously recorded.\n9. **Return Path Sum**: For the parent's path computation, return the maximum path sum of the current node combined with either the left or right subtree, ensuring to include the higher path sum only.\n\n# Pseudocode\n\n```\n# Definition of the binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Function to find the maximum path sum\ndef maxPathSum(root):\n    # Initialize the maximum path sum to a very small number\n    max_sum = -Infinity\n\n    # Recursive function to calculate maximum path sum\n    def maxPathSumRecursive(node):\n        nonlocal max_sum  # Access the variable from the outer scope\n        \n        # Base case: if node is null, return 0\n        if node is null:\n            return 0\n        \n        # Compute the maximum path sum of the left and right subtrees\n        left_sum = max(maxPathSumRecursive(node.left), 0)\n        right_sum = max(maxPathSumRecursive(node.right), 0)\n        \n        # Calculate the maximum path sum through the current node including both left and right children\n        current_sum = node.val + left_sum + right_sum\n        \n        # Update the global maximum path sum\n        max_sum = max(max_sum, current_sum)\n        \n        # Return the maximum path sum including either left or right child, not both\n        return node.val + max(left_sum, right_sum)\n    \n    # Start the recursion with the root node\n    maxPathSumRecursive(root)\n    \n    # Return the global maximum path sum found\n    return max_sum\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-maximum-path-sum"
    },
    {
        "name": "Word Ladder",
        "site": "LeetCode",
        "href": "/solution/LeetCode-word-ladder",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> wordSet(wordList.begin(), wordList.end());\n        if (wordSet.find(endWord) == wordSet.end()) {\n            return 0;\n        }\n        \n        queue<string> q;\n        q.push(beginWord);\n        int ladderLength = 1;\n        \n        while (!q.empty()) {\n            int levelSize = q.size();\n            for (int i = 0; i < levelSize; ++i) {\n                string currentWord = q.front();\n                q.pop();\n                \n                if (currentWord == endWord) {\n                    return ladderLength;\n                }\n                \n                for (int j = 0; j < currentWord.length(); ++j) {\n                    char originalChar = currentWord[j];\n                    for (char c = 'a'; c <= 'z'; ++c) {\n                        if (c == originalChar) {\n                            continue;\n                        }\n                        currentWord[j] = c;\n                        if (wordSet.find(currentWord) != wordSet.end()) {\n                            q.push(currentWord);\n                            wordSet.erase(currentWord);\n                        }\n                    }\n                    currentWord[j] = originalChar;\n                }\n            }\n            ++ladderLength;\n        }\n        \n        return 0;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord)) {\n            return 0;\n        }\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.offer(beginWord);\n        \n        int level = 1;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentWord = queue.poll();\n                char[] wordArray = currentWord.toCharArray();\n                for (int j = 0; j < wordArray.length; j++) {\n                    char originalChar = wordArray[j];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (wordArray[j] == c) {\n                            continue;\n                        }\n                        wordArray[j] = c;\n                        String newWord = new String(wordArray);\n                        if (newWord.equals(endWord)) {\n                            return level + 1;\n                        }\n                        if (wordSet.contains(newWord)) {\n                            queue.offer(newWord);\n                            wordSet.remove(newWord);\n                        }\n                    }\n                    wordArray[j] = originalChar;\n                }\n            }\n            level++;\n        }\n        \n        return 0;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "from collections import deque\n\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n        \n        queue = deque()\n        queue.append((beginWord, 1))\n        \n        while queue:\n            currentWord, length = queue.popleft()\n            if currentWord == endWord:\n                return length\n            \n            for i in range(len(currentWord)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    nextWord = currentWord[:i] + char + currentWord[i+1:]\n                    if nextWord in wordSet:\n                        wordSet.remove(nextWord)\n                        queue.append((nextWord, length+1))\n        \n        return 0\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\n        HashSet<string> wordSet = new HashSet<string>(wordList);\n        \n        if (!wordSet.Contains(endWord)) {\n            return 0;\n        }\n        \n        Queue<string> queue = new Queue<string>();\n        queue.Enqueue(beginWord);\n        \n        int level = 1;\n        \n        while (queue.Count > 0) {\n            int size = queue.Count;\n            \n            for (int i = 0; i < size; i++) {\n                string currentWord = queue.Dequeue();\n                \n                char[] charArray = currentWord.ToCharArray();\n                \n                for (int j = 0; j < charArray.Length; j++) {\n                    char originalChar = charArray[j];\n                    \n                    for (char c = 'a'; c <= 'z'; c++) {\n                        charArray[j] = c;\n                        string newWord = new string(charArray);\n                        \n                        if (newWord.Equals(endWord)) {\n                            return level + 1;\n                        }\n                        \n                        if (wordSet.Contains(newWord) && !newWord.Equals(currentWord)) {\n                            queue.Enqueue(newWord);\n                            wordSet.Remove(newWord);\n                        }\n                    }\n                    charArray[j] = originalChar;\n                }\n            }\n            \n            level++;\n        }\n        \n        return 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const queue = [[beginWord, 1]];\n\n    while (queue.length) {\n        const [word, level] = queue.shift();\n\n        if (word === endWord) {\n            return level;\n        }\n\n        for (let i = 0; i < word.length; i++) {\n            for (let j = 0; j < 26; j++) {\n                const newWord = word.slice(0, i) + String.fromCharCode(97 + j) + word.slice(i + 1);\n\n                if (wordSet.has(newWord)) {\n                    queue.push([newWord, level + 1]);\n                    wordSet.delete(newWord);\n                }\n            }\n        }\n    }\n\n    return 0;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    let queue = [beginWord];\n    let level = 1;\n\n    while (queue.length > 0) {\n        const nextQueue: string[] = [];\n\n        for (const word of queue) {\n            if (word === endWord) return level;\n\n            for (let i = 0; i < word.length; i++) {\n                for (let j = 0; j < 26; j++) {\n                    const newWord = word.slice(0, i) + String.fromCharCode(97 + j) + word.slice(i + 1);\n                    if (wordSet.has(newWord)) {\n                        nextQueue.push(newWord);\n                        wordSet.delete(newWord);\n                    }\n                }\n            }\n        }\n\n        queue = nextQueue;\n        level++;\n    }\n\n    return 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $beginWord\n     * @param String $endWord\n     * @param String[] $wordList\n     * @return Integer\n     */\n    function ladderLength($beginWord, $endWord, $wordList) {\n        $wordSet = array_flip($wordList);\n        if (!isset($wordSet[$endWord])) {\n            return 0;\n        }\n        \n        $queue = [$beginWord];\n        $level = 1;\n        \n        while (!empty($queue)) {\n            $next = [];\n            foreach ($queue as $word) {\n                for ($i = 0; $i < strlen($word); $i++) {\n                    $oldChar = $word[$i];\n                    for ($j = 0; $j < 26; $j++) {\n                        $word[$i] = chr(97 + $j);\n                        if ($word === $endWord) {\n                            return $level + 1;\n                        }\n                        if (isset($wordSet[$word])) {\n                            $next[] = $word;\n                            unset($wordSet[$word]);\n                        }\n                    }\n                    $word[$i] = $oldChar;\n                }\n            }\n            $queue = $next;\n            $level++;\n        }\n        \n        return 0;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\n        var wordSet = Set(wordList)\n        if !wordSet.contains(endWord) {\n            return 0\n        }\n        \n        var queue = [(beginWord, 1)]\n        \n        while !queue.isEmpty {\n            let (word, steps) = queue.removeFirst()\n            \n            if word == endWord {\n                return steps\n            }\n            \n            for i in 0..<word.count {\n                var chars = Array(word)\n                for char in \"abcdefghijklmnopqrstuvwxyz\" {\n                    chars[i] = char\n                    let newWord = String(chars)\n                    if wordSet.contains(newWord) {\n                        queue.append((newWord, steps + 1))\n                        wordSet.remove(newWord)\n                    }\n                }\n            }\n        }\n        \n        return 0\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun ladderLength(beginWord: String, endWord: String, wordList: List<String>): Int {\n        val wordSet = wordList.toMutableSet()\n        if (endWord !in wordSet) return 0\n        \n        var level = 1\n        val queue = LinkedList<String>()\n        queue.offer(beginWord)\n        \n        while (queue.isNotEmpty()) {\n            val size = queue.size\n            repeat(size) {\n                val currentWord = queue.poll()\n                \n                for (i in 0 until currentWord.length) {\n                    val wordArray = currentWord.toCharArray()\n                    for (c in 'a'..'z') {\n                        wordArray[i] = c\n                        val newWord = String(wordArray)\n                        \n                        if (newWord == currentWord) continue\n                        if (newWord == endWord) return level + 1\n                        if (newWord in wordSet) {\n                            queue.offer(newWord)\n                            wordSet.remove(newWord)\n                        }\n                    }\n                }\n            }\n            level++\n        }\n        \n        return 0\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func ladderLength(beginWord string, endWord string, wordList []string) int {\n    wordSet := make(map[string]bool)\n    for _, word := range wordList {\n        wordSet[word] = true\n    }\n\n    if _, ok := wordSet[endWord]; !ok {\n        return 0\n    }\n\n    queue := []string{beginWord}\n    level := 1\n\n    for len(queue) > 0 {\n        size := len(queue)\n        for i := 0; i < size; i++ {\n            currentWord := queue[0]\n            queue = queue[1:]\n\n            if currentWord == endWord {\n                return level\n            }\n\n            for j := 0; j < len(currentWord); j++ {\n                for c := 'a'; c <= 'z'; c++ {\n                    newWord := currentWord[:j] + string(c) + currentWord[j+1:]\n                    if _, ok := wordSet[newWord]; ok {\n                        queue = append(queue, newWord)\n                        delete(wordSet, newWord)\n                    }\n                }\n            }\n        }\n        level++\n    }\n\n    return 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} begin_word\n# @param {String} end_word\n# @param {String[]} word_list\n# @return {Integer}\ndef ladder_length(begin_word, end_word, word_list)\n    return 0 if !word_list.include?(end_word)\n    \n    word_set = Set.new(word_list)\n    \n    queue = Queue.new\n    queue.push([begin_word, 1])\n    \n    while !queue.empty?\n        current_word, length = queue.pop\n        \n        if current_word == end_word\n            return length\n        end\n        \n        (0...current_word.length).each do |i|\n            ('a'..'z').each do |char|\n                new_word = current_word.dup\n                new_word[i] = char\n                \n                if word_set.include?(new_word)\n                    queue.push([new_word, length + 1])\n                    word_set.delete(new_word)\n                end\n            end\n        end\n    end\n    \n    return 0\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def ladderLength(beginWord: String, endWord: String, wordList: List[String]): Int = {\n        import scala.collection.mutable\n        val wordSet = wordList.toSet\n        val queue = mutable.Queue[(String, Int)]((beginWord, 1))\n        val visited = mutable.Set[String]()\n\n        while (queue.nonEmpty) {\n            val (currentWord, level) = queue.dequeue()\n            if (currentWord == endWord) {\n                return level\n            }\n            for (i <- 0 until currentWord.length) {\n                for (c <- 'a' to 'z') {\n                    val newWord = currentWord.updated(i, c)\n                    if (wordSet.contains(newWord) && !visited.contains(newWord)) {\n                        visited.add(newWord)\n                        queue.enqueue((newWord, level + 1))\n                    }\n                }\n            }\n        }\n\n        0\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        use std::collections::{HashSet, VecDeque};\n\n        let word_set: HashSet<String> = word_list.into_iter().collect();\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        queue.push_back((begin_word, 1));\n\n        while let Some((word, steps)) = queue.pop_front() {\n            if word == end_word {\n                return steps;\n            }\n\n            let chars: Vec<char> = word.chars().collect();\n            for i in 0..chars.len() {\n                let original_char = chars[i];\n\n                for c in 'a'..='z' {\n                    if c == original_char {\n                        continue;\n                    }\n\n                    let mut new_chars = chars.clone();\n                    new_chars[i] = c;\n                    let new_word: String = new_chars.iter().collect();\n                    if word_set.contains(&new_word) && visited.insert(new_word.clone()) {\n                        queue.push_back((new_word, steps + 1));\n                    }\n                }\n            }\n        }\n\n        0\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the length of the shortest transformation sequence from the `beginWord` to the `endWord` using the words from `wordList`. We\u2019ll use a Breadth-First Search (BFS) approach to ensure that we find the shortest path. Here is a structured explanation and pseudocode to help achieve this.\n\n# Explanation\n\n1. **Initialization**:\n   - Convert `wordList` to a set `wordSet` for O(1) lookups.\n   - If `endWord` is not in `wordSet`, return 0 because no transformation can complete without the `endWord`.\n\n2. **BFS Setup**:\n   - Initialize a queue with a tuple of the `beginWord` and its transformation length (start at 1).\n   - Use a while loop to process elements in the queue.\n\n3. **Processing the Queue**:\n   - For each word in the queue, generate all possible next words by changing each letter to any letter from 'a' to 'z'.\n   - If the resulting word is in `wordSet`, remove it from `wordSet` (to prevent reprocessing) and add it to the queue with an incremented length.\n\n4. **Checking for EndWord**:\n   - If at any point the `currentWord` matches the `endWord`, return the current transformation length.\n\n5. **Termination**:\n   - If the queue is exhausted without finding `endWord`, return 0.\n\n# Pseudocode\n\n```pseudocode\n# Given function signature\nfunction ladderLength(beginWord, endWord, wordList):\n    # Convert the wordList to a set for quick lookups\n    wordSet = set(wordList)\n    \n    # If endWord is not in the wordSet, return 0\n    if endWord not in wordSet:\n        return 0\n\n    # Initialize the queue for BFS with the initial word and length\n    queue = deque([(beginWord, 1)])\n\n    # While there are elements in the queue\n    while queue is not empty:\n        # Dequeue the front element\n        currentWord, length = queue.popleft()\n\n        # Check if the currentWord is the endWord\n        if currentWord == endWord:\n            return length\n\n        # Try all possible single-letter transformations\n        for i from 0 to length of currentWord:\n            original_char = currentWord[i]\n            for char in 'a' to 'z':\n                # Skip replacing with the same character\n                if char == original_char:\n                    continue\n\n                # Form the next word\n                nextWord = currentWord[:i] + char + currentWord[i+1:]\n\n                # If the next word is in the wordSet\n                if nextWord in wordSet:\n                    # Remove the nextWord from wordSet to prevent reprocessing\n                    wordSet.remove(nextWord)\n                    # Enqueue the next word with incremented length\n                    queue.append((nextWord, length + 1))\n\n    # If we exhaust the queue without finding endWord, return 0\n    return 0\n```\n\nThis approach ensures an efficient search for the shortest transformation sequence by leveraging BFS and ensures uniqueness by using a set.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-word-ladder"
    },
    {
        "name": "Word Break",
        "site": "LeetCode",
        "href": "/solution/LeetCode-word-break",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        int n = s.length();\n\n        vector<bool> dp(n + 1, false);\n        dp[0] = true;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[n];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        \n        for(int i = 1; i <= s.length(); i++) {\n            for(int j = 0; j < i; j++) {\n                if(dp[j] && wordSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return dp[s.length()];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[len(s)]"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool WordBreak(string s, IList<string> wordDict) {\n        HashSet<string> dict = new HashSet<string>(wordDict);\n        bool[] dp = new bool[s.Length + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= s.Length; i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && dict.Contains(s.Substring(j, i - j))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[s.Length];\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function wordBreak(s: string, wordDict: string[]): boolean {\n    const dp: boolean[] = new Array(s.length + 1).fill(false);\n    dp[0] = true;\n\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && wordDict.includes(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    return dp[s.length];\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\n        var dp = Array(repeating: false, count: s.count + 1)\n        dp[0] = true\n        \n        let set = Set(wordDict)\n        \n        for i in 1...s.count {\n            for j in 0..<i {\n                if dp[j] && set.contains(String(s[s.index(s.startIndex, offsetBy: j)..<s.index(s.startIndex, offsetBy: i)])) {\n                    dp[i] = true\n                    break\n                }\n            }\n        }\n        \n        return dp[s.count]\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun wordBreak(s: String, wordDict: List<String>): Boolean {\n        val dp = BooleanArray(s.length + 1)\n        dp[0] = true\n        for (i in 1..s.length) {\n            for (j in 0 until i) {\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\n                    dp[i] = true\n                    break\n                }\n            }\n        }\n        return dp[s.length]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = wordDict.toSet();\n    List<bool> dp = List.filled(s.length + 1, false);\n    dp[0] = true;\n\n    for (int i = 1; i <= s.length; i++) {\n      for (int j = 0; j < i; j++) {\n        if (dp[j] && dict.contains(s.substring(j, i))) {\n          dp[i] = true;\n          break;\n        }\n      }\n    }\n\n    return dp[s.length];\n  }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, one approach is to use dynamic programming (DP). We can define a DP array `dp` where `dp[i]` is `True` if the substring `s[0:i]` can be segmented into words from the `wordDict`, and `False` otherwise. The key idea is to iterate through the string and check if any substring `s[j:i]` (ending at position `i` and starting at position `j`) is in the `wordDict` and the substring `s[0:j]` can be segmented (i.e., `dp[j]` is `True`).\n\n# Explanation\n1. Initialize a boolean DP array `dp` of size `len(s) + 1` with all values set to `False`.\n2. Set `dp[0]` to `True` because an empty substring can always be segmented.\n3. Iterate through each position `i` from 1 to `len(s)`.\n4. For each position `i`, iterate through each previous position `j` from 0 to `i`.\n5. Check if the substring `s[j:i]` is in the `wordDict` and if `dp[j]` is `True`.\n6. If both conditions are met, set `dp[i]` to `True` and break the inner loop.\n7. Finally, return `dp[len(s)]` which indicates if the whole string `s` can be segmented.\n\n# Pseudocode\n```\nfunction wordBreak(s, wordDict):\n    # Step 1: Initialize the DP array with False values\n    dp = array of False of size (len(s) + 1)\n    dp[0] = True  # Base case: empty substring can be segmented\n    \n    # Step 2: Process each position in the string\n    for i from 1 to len(s):\n        # Step 3: Check each substring ending at position i\n        for j from 0 to i:\n            # Step 4: Check if substring s[j:i] is in wordDict and if s[0:j] can be segmented\n            if dp[j] == True and substring s[j:i] in wordDict:\n                dp[i] = True\n                break  # No need to check further, move to the next position i\n    \n    # Step 5: Return the result for the whole string\n    return dp[len(s)]\n```\n\nBy following this pseudocode, you can implement a solution for the Word Break problem using dynamic programming.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-word-break"
    },
    {
        "name": "Longest Consecutive Sequence",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-consecutive-sequence",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> numSet(nums.begin(), nums.end());\n        int longestStreak = 0;\n\n        for (int num : nums) {\n            if (numSet.find(num - 1) == numSet.end()) {\n                int currentNum = num;\n                int currentStreak = 1;\n\n                while (numSet.find(currentNum + 1) != numSet.end()) {\n                    currentNum++;\n                    currentStreak++;\n                }\n\n                longestStreak = max(longestStreak, currentStreak);\n            }\n        }\n\n        return longestStreak;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            set.add(num);\n        }\n        \n        int longestStreak = 0;\n        \n        for (int num : set) {\n            if (!set.contains(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n                \n                while (set.contains(currentNum + 1)) {\n                    currentNum++;\n                    currentStreak++;\n                }\n                \n                longestStreak = Math.max(longestStreak, currentStreak);\n            }\n        }\n        \n        return longestStreak;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        num_set = set(nums)\n        longest_streak = 0\n        \n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n                \n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n                \n                longest_streak = max(longest_streak, current_streak)\n        \n        return longest_streak"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LongestConsecutive(int[] nums) {\n        if (nums == null || nums.Length == 0)\n            return 0;\n        \n        HashSet<int> numSet = new HashSet<int>();\n        foreach (int num in nums) {\n            numSet.Add(num);\n        }\n        \n        int longestStreak = 0;\n        foreach (int num in numSet) {\n            if (!numSet.Contains(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n                \n                while (numSet.Contains(currentNum + 1)) {\n                    currentNum++;\n                    currentStreak++;\n                }\n                \n                longestStreak = Math.Max(longestStreak, currentStreak);\n            }\n        }\n        \n        return longestStreak;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function(nums) {\n    const numSet = new Set(nums);\n    let longestStreak = 0;\n\n    for (let num of numSet) {\n        if (!numSet.has(num - 1)) {\n            let currentNum = num;\n            let currentStreak = 1;\n\n            while (numSet.has(currentNum + 1)) {\n                currentNum++;\n                currentStreak++;\n            }\n\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function longestConsecutive(nums: number[]): number {\n    const numSet = new Set(nums);\n    let longestStreak = 0;\n\n    for (let num of numSet) {\n        if (!numSet.has(num - 1)) {\n            let currentNum = num;\n            let currentStreak = 1;\n\n            while (numSet.has(currentNum + 1)) {\n                currentNum++;\n                currentStreak++;\n            }\n\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function longestConsecutive($nums) {\n        $set = array_flip($nums);\n        $longest = 0;\n        \n        foreach ($set as $num => $val) {\n            if (!isset($set[$num - 1])) {\n                $currentNum = $num;\n                $currentStreak = 1;\n                \n                while (isset($set[$currentNum + 1])) {\n                    $currentNum++;\n                    $currentStreak++;\n                }\n                \n                $longest = max($longest, $currentStreak);\n            }\n        }\n        \n        return $longest;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func longestConsecutive(_ nums: [Int]) -> Int {\n        var numSet = Set(nums)\n        var longestStreak = 0\n        \n        for num in numSet {\n            if !numSet.contains(num - 1) {\n                var currentNum = num\n                var currentStreak = 1\n                \n                while numSet.contains(currentNum + 1) {\n                    currentNum += 1\n                    currentStreak += 1\n                }\n                \n                longestStreak = max(longestStreak, currentStreak)\n            }\n        }\n        \n        return longestStreak\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun longestConsecutive(nums: IntArray): Int {\n        if(nums.isEmpty()) return 0\n        \n        val numSet = nums.toHashSet()\n        var longestStreak = 0\n        \n        for(num in numSet){\n            if(num - 1 !in numSet){\n                var currentNum = num\n                var currentStreak = 1\n                \n                while(currentNum + 1 in numSet){\n                    currentNum++\n                    currentStreak++\n                }\n                \n                longestStreak = maxOf(longestStreak, currentStreak)\n            }\n        }\n        \n        return longestStreak\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int longestConsecutive(List<int> nums) {\n    Set<int> numSet = Set.from(nums);\n    int longestStreak = 0;\n    \n    for (int num in numSet) {\n      if (!numSet.contains(num - 1)) {\n        int currentNum = num;\n        int currentStreak = 1;\n        \n        while (numSet.contains(currentNum + 1)) {\n          currentNum++;\n          currentStreak++;\n        }\n        \n        longestStreak = currentStreak > longestStreak ? currentStreak : longestStreak;\n      }\n    }\n    \n    return longestStreak;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func longestConsecutive(nums []int) int {\n    numSet := make(map[int]bool)\n    for _, num := range nums {\n        numSet[num] = true\n    }\n\n    longestStreak := 0\n    for num := range numSet {\n        if !numSet[num-1] {\n            currentNum := num\n            currentStreak := 1\n\n            for numSet[currentNum+1] {\n                currentNum++\n                currentStreak++\n            }\n\n            if currentStreak > longestStreak {\n                longestStreak = currentStreak\n            }\n        }\n    }\n\n    return longestStreak\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef longest_consecutive(nums)\n    set = Set.new(nums)\n    longest_streak = 0\n    \n    set.each do |num|\n        if !set.include?(num - 1)\n            current_num = num\n            current_streak = 1\n            \n            while set.include?(current_num + 1)\n                current_num += 1\n                current_streak += 1\n            end\n            \n            longest_streak = [longest_streak, current_streak].max\n        end\n    end\n    \n    return longest_streak\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def longestConsecutive(nums: Array[Int]): Int = {\n        if (nums.isEmpty) return 0\n\n        val numSet = nums.toSet\n        var longestStreak = 0\n\n        for (num <- numSet) {\n            if (!numSet.contains(num - 1)) {\n                var currentNum = num\n                var currentStreak = 1\n\n                while (numSet.contains(currentNum + 1)) {\n                    currentNum += 1\n                    currentStreak += 1\n                }\n\n                longestStreak = Math.max(longestStreak, currentStreak)\n            }\n        }\n\n        longestStreak\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\n        use std::collections::HashSet;\n\n        let mut num_set: HashSet<i32> = nums.into_iter().collect();\n        let mut longest_streak = 0;\n\n        for &num in num_set.iter() {\n            if !num_set.contains(&(num - 1)) {\n                let mut current_num = num;\n                let mut current_streak = 1;\n\n                while num_set.contains(&(current_num + 1)) {\n                    current_num += 1;\n                    current_streak += 1;\n                }\n\n                longest_streak = longest_streak.max(current_streak);\n            }\n        }\n\n        longest_streak\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to find the length of the longest consecutive sequence in an array of integers. Here's an explanation of the methodology and the pseudocode for the solution.\n\n# Explanation\n1. The primary goal is to find the longest sequence of consecutive numbers in an unsorted array of integers.\n2. To achieve a time complexity of O(n), you can use a set to store the elements of the array. This allows for average O(1) time complexity for both insertions and lookups.\n3. Iterate through each number in the set. For each number, check if it is the start of a sequence. A number is the start of a sequence if the previous number (`num-1`) is not in the set.\n4. If a number is the start of a sequence, keep incrementing the number to find the length of the sequence.\n5. Keep track of the maximum length of any sequence found during the iteration.\n\n# Pseudocode\n```\nfunction longestConsecutive(nums):\n    # Create a set with the given numbers to allow for O(1) lookups\n    num_set = set(nums)\n    longest_streak = 0\n    \n    # Iterate through each number in the set\n    for number in num_set:\n        # Check if the number is the start of a sequence\n        if (number - 1) is not in num_set:\n            current_number = number\n            current_streak = 1\n            \n            # Increment the number to find the length of the current sequence\n            while (current_number + 1) is in num_set:\n                current_number += 1\n                current_streak += 1\n            \n            # Update the longest streak found so far\n            longest_streak = max(longest_streak, current_streak)\n    \n    # Return the longest consecutive sequence length\n    return longest_streak\n```\n\nBy following the above methodology and pseudocode, you can efficiently solve the problem of finding the longest consecutive sequence in an array of integers within O(n) time complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-consecutive-sequence"
    },
    {
        "name": "Sum Root To Leaf Numbers",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sum-root-to-leaf-numbers",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n */\n\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n    \n    int dfs(TreeNode* node, int currSum) {\n        if (node == nullptr) {\n            return 0;\n        }\n        \n        currSum = currSum * 10 + node->val;\n        \n        if (node->left == nullptr && node->right == nullptr) {\n            return currSum;\n        }\n        \n        int leftSum = dfs(node->left, currSum);\n        int rightSum = dfs(node->right, currSum);\n        \n        return leftSum + rightSum;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n    \n    private int dfs(TreeNode node, int currentSum) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int newSum = currentSum * 10 + node.val;\n        \n        if (node.left == null && node.right == null) {\n            return newSum;\n        }\n        \n        return dfs(node.left, newSum) + dfs(node.right, newSum);\n    }\n}\n\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        def dfs(node, current_sum):\n            if not node:\n                return 0\n            current_sum = current_sum * 10 + node.val\n            if not node.left and not node.right:\n                return current_sum\n            return dfs(node.left, current_sum) + dfs(node.right, current_sum)\n        \n        return dfs(root, 0)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint sumNumbers(struct TreeNode* root) {\n    if (root == NULL) return 0;\n    \n    int sum = 0;\n    helper(root, 0, &sum);\n    \n    return sum;\n}\n\nvoid helper(struct TreeNode* node, int pathSum, int* total) {\n    if (node == NULL) return;\n    \n    pathSum = pathSum * 10 + node->val;\n    \n    if (node->left == NULL && node->right == NULL) {\n        *total += pathSum;\n        return;\n    }\n    \n    helper(node->left, pathSum, total);\n    helper(node->right, pathSum, total);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n */\npublic class Solution {\n    public int SumNumbers(TreeNode root) {\n        return DFS(root, 0);\n    }\n    \n    private int DFS(TreeNode node, int currentSum) {\n        if (node == null) return 0;\n        \n        currentSum = currentSum * 10 + node.val;\n        \n        if (node.left == null && node.right == null) {\n            return currentSum;\n        }\n        \n        int leftSum = DFS(node.left, currentSum);\n        int rightSum = DFS(node.right, currentSum);\n        \n        return leftSum + rightSum;\n    }\n}\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\nvar sumNumbers = function(root) {\n    let sum = 0;\n    const dfs = (node, value) => {\n        if (!node) return;\n        \n        value = value * 10 + node.val;\n        \n        if (!node.left && !node.right) {\n            sum += value;\n            return;\n        }\n        \n        dfs(node.left, value);\n        dfs(node.right, value);\n    };\n    \n    dfs(root, 0);\n    \n    return sum;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: \nTreeNode | null) {\n */\n\nfunction sumNumbers(root: TreeNode | null): number {\n    if (!root) {\n        return 0;\n    }\n    \n    let totalSum = 0;\n    \n    const dfs = (node: TreeNode, currentSum: number) => {\n        currentSum = currentSum * 10 + node.val;\n        \n        if (!node.left && !node.right) {\n            totalSum += currentSum;\n            return;\n        }\n        \n        if (node.left) {\n            dfs(node.left, currentSum);\n        }\n        \n        if (node.right) {\n            dfs(node.right, currentSum);\n        }\n    };\n    \n    dfs(root, 0);\n    \n    return totalSum;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n */\n\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function sumNumbers($root, $prevSum = 0) {\n        if ($root == null) {\n            return 0;\n        }\n        \n        $currentSum = $prevSum * 10 + $root->val;\n        \n        if ($root->left == null && $root->right == null) {\n            return $currentSum;\n        }\n        \n        return $this->sumNumbers($root->left, $currentSum) + $this->sumNumbers($root->right, $currentSum);  \n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func sumNumbers(_ root: TreeNode?) -> Int {\n        return dfs(root, 0)\n    }\n    \n    func dfs(_ node: TreeNode?, _ currentSum: Int) -> Int {\n        guard let node = node else { return 0 }\n        \n        let newSum = currentSum * 10 + node.val\n        \n        if node.left == nil, node.right == nil {\n            return newSum\n        }\n        \n        return dfs(node.left, newSum) + dfs(node.right, newSum)\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc sumNumbers(root *TreeNode) int {\n    return dfs(root, 0)\n}\n\nfunc dfs(node *TreeNode, num int) int {\n    if node == nil {\n        return 0\n    }\n    \n    num = num*10 + node.Val\n    \n    if node.Left == nil && node.Right == nil {\n        return num\n    }\n    \n    return dfs(node.Left, num) + dfs(node.Right, num)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n\ndef sum_numbers(root, sum = 0)\n    return 0 if root.nil?\n    \n    sum = sum * 10 + root.val\n    \n    return sum if root.left.nil? && root.right.nil?\n    \n    return sum_numbers(root.left, sum) + sum_numbers(root.right, sum)\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def sumNumbers(root: TreeNode): Int = {\n        def dfs(node: TreeNode, current: Int): Int = {\n            if (node == null) return 0\n            val next = current * 10 + node.value\n            if (node.left == null && node.right == null) return next\n            dfs(node.left, next) + dfs(node.right, next)\n        }\n        \n        dfs(root, 0)\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n-spec sum_numbers(Root :: #tree_node{} | null) -> integer().\nsum_numbers(Root) ->\n    sum_numbers(Root, 0).\n    \nsum_numbers(null, Sum) ->\n    Sum;\nsum_numbers(#tree_node{val = Val, left = null, right = null}, Sum) ->\n    Sum * 10 + Val;\nsum_numbers(#tree_node{val = Val, left = Left, right = null} = Root, Sum) ->\n    sum_numbers(Left, Sum * 10 + Val);\nsum_numbers(#tree_node{val = Val, left = null, right = Right} = Root, Sum) ->\n    sum_numbers(Right, Sum * 10 + Val);\nsum_numbers(#tree_node{val = Val, left = Left, right = Right} = Root, Sum) ->\n    sum_numbers(Left, Sum * 10 + Val) + sum_numbers(Right, Sum * 10 + Val).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to traverse each path from the root to the leaves of the binary tree and sum the integer values formed by these paths.\n\n# Explanation\n1. **Tree Node Definition**: Each node in the binary tree has a value (from 0 to 9) and may have left and right children, both of which can either be `None` or another node.\n2. **Depth-First Search (DFS)**: This is the best approach to traverse the binary tree from the root to each leaf node.\n3. **Path Sum Calculation**: For each node visited, the current path sum is updated by multiplying the current sum by 10 and adding the node's value.\n4. **Leaf Node Check**: When a leaf node (a node without children) is reached, the current path sum is returned as that path's contribution to the total.\n5. **Recursion**: Use recursion to traverse all possible root-to-leaf paths and accumulate the sums.\n\n# Pseudocode\n```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def sumNumbers(root):\n        # Helper function to perform DFS\n        def dfs(node, current_sum):\n            # Base case: if node is None, return 0\n            if not node:\n                return 0\n\n            # Calculate the new sum including the current node\n            current_sum = current_sum * 10 + node.val\n\n            # If the current node is a leaf node, return the current sum\n            if not node.left and not node.right:\n                return current_sum\n\n            # Recursively traverse left subtree and right subtree and sum the results\n            left_sum = dfs(node.left, current_sum)\n            right_sum = dfs(node.right, current_sum)\n            \n            # Combine the sums from left and right subtrees\n            return left_sum + right_sum\n\n        # Start DFS traversal from the root with initial sum 0\n        return dfs(root, 0)\n```\n\nThis pseudocode utilizes a helper function `dfs` to recursively compute the root-to-leaf path sums and aggregates them to return the total sum of all paths.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sum-root-to-leaf-numbers"
    },
    {
        "name": "Surrounded Regions",
        "site": "LeetCode",
        "href": "/solution/LeetCode-surrounded-regions",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        if (board.empty()) {\n            return;\n        }\n\n        int rows = board.size();\n        int cols = board[0].size();\n\n        queue<pair<int, int>> q;\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if ((i == 0 || i == rows - 1 || j == 0 || j == cols - 1) && board[i][j] == 'O') {\n                    q.push({i, j});\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            int i = q.front().first;\n            int j = q.front().second;\n            q.pop();\n\n            if (i >= 0 && i < rows && j >= 0 && j < cols && board[i][j] == 'O') {\n                board[i][j] = 'B';\n\n                q.push({i - 1, j});\n                q.push({i + 1, j});\n                q.push({i, j - 1});\n                q.push({i, j + 1});\n            }\n        }\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == 'B') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void solve(char[][] board) {\n        if (board == null || board.length == 0) {\n            return;\n        }\n        \n        int m = board.length;\n        int n = board[0].length;\n        \n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') {\n                dfs(board, i, 0);\n            }\n            if (board[i][n - 1] == 'O') {\n                dfs(board, i, n - 1);\n            }\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (board[0][j] == 'O') {\n                dfs(board, 0, j);\n            }\n            if (board[m - 1][j] == 'O') {\n                dfs(board, m - 1, j);\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == '*') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n    \n    private void dfs(char[][] board, int i, int j) {\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != 'O') {\n            return;\n        }\n        \n        board[i][j] = '*';\n        \n        dfs(board, i + 1, j);\n        dfs(board, i - 1, j);\n        dfs(board, i, j + 1);\n        dfs(board, i, j - 1);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def solve(self, board):\n        def dfs(i, j):\n            if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == 'O':\n                board[i][j] = 'S'\n                dfs(i+1, j)\n                dfs(i-1, j)\n                dfs(i, j+1)\n                dfs(i, j-1)\n        \n        if not board or not board[0]:\n            return\n        \n        rows, cols = len(board), len(board[0])\n        \n        for i in range(rows):\n            dfs(i, 0)\n            dfs(i, cols-1)\n        \n        for j in range(cols):\n            dfs(0, j)\n            dfs(rows-1, j)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == 'S':\n                    board[i][j] = 'O'\n                else:\n                    board[i][j] = 'X'"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void solve(char** board, int boardSize, int* boardColSize) {\n    \n    if (board == NULL || boardSize == 0 || *boardColSize == 0) {\n        return;\n    }\n    \n    // Helper function to mark 'O's connected to border as safe\n    void markSafe(int row, int col) {\n        if (row < 0 || row >= boardSize || col < 0 || col >= *boardColSize || board[row][col] != 'O') {\n            return;\n        }\n        \n        board[row][col] = 'S'; // Mark as safe\n        \n        markSafe(row - 1, col); // Check North\n        markSafe(row + 1, col); // Check South\n        markSafe(row, col - 1); // Check West\n        markSafe(row, col + 1); // Check East\n    }\n    \n    // Mark 'O's connected to border as safe starting from border cells\n    for (int i = 0; i < boardSize; i++) {\n        markSafe(i, 0); // Left border\n        markSafe(i, *boardColSize - 1); // Right border\n    }\n    \n    for (int j = 0; j < *boardColSize; j++) {\n        markSafe(0, j); // Top border\n        markSafe(boardSize - 1, j); // Bottom border\n    }\n    \n    // Flip 'O's to 'X's and revert 'S's back to 'O's\n    for (int i = 0; i < boardSize; i++) {\n        for (int j = 0; j < *boardColSize; j++) {\n            if (board[i][j] == 'O') {\n                board[i][j] = 'X';\n            } else if (board[i][j] == 'S') {\n                board[i][j] = 'O';\n            }\n        }\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void Solve(char[][] board) {\n        if (board == null || board.Length == 0) return;\n        \n        int rows = board.Length;\n        int cols = board[0].Length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if ((i == 0 || i == rows - 1 || j == 0 || j == cols - 1) && board[i][j] == 'O') {\n                    DFS(board, i, j);\n                }\n            }\n        }\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == '1') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n    \n    private void DFS(char[][] board, int i, int j) {\n        if (i < 0 || i >= board.Length || j < 0 || j >= board[0].Length || board[i][j] != 'O') {\n            return;\n        }\n        \n        board[i][j] = '1';\n        DFS(board, i + 1, j);\n        DFS(board, i - 1, j);\n        DFS(board, i, j + 1);\n        DFS(board, i, j - 1);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place \ninstead.\n */\nvar solve = function(board) {\n    const dfs = (i, j) => {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== 'O') {\n            return;\n        }\n        \n        board[i][j] = '-';\n        \n        dfs(i + 1, j);\n        dfs(i - 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    };\n    \n    const rows = board.length;\n    const cols = board[0].length;\n    \n    for (let i = 0; i < rows; i++) {\n        dfs(i, 0);\n        dfs(i, cols - 1);\n    }\n    \n    for (let j = 0; j < cols; j++) {\n        dfs(0, j);\n        dfs(rows - 1, j);\n    }\n    \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (board[i][j] === 'O') {\n                board[i][j] = 'X';\n            } else if (board[i][j] === '-') {\n                board[i][j] = 'O';\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify board in-place instead.\n */\nfunction solve(board: string[][]): void {\n    const dfs = (i: number, j: number) => {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== 'O') {\n            return;\n        }\n        \n        board[i][j] = 'T'; // Temporarily mark 'O' as 'T'\n        dfs(i + 1, j);\n        dfs(i - 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    };\n    \n    const m = board.length;\n    const n = board[0].length;\n    \n    for (let i = 0; i < m; i++) {\n        dfs(i, 0);\n        dfs(i, n - 1);\n    }\n    \n    for (let j = 0; j < n; j++) {\n        dfs(0, j);\n        dfs(m - 1, j);\n    }\n    \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (board[i][j] === 'O') {\n                board[i][j] = 'X';\n            } else if (board[i][j] === 'T') {\n                board[i][j] = 'O';\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $board\n     * @return NULL\n     */\n    function solve(&$board) {\n        $rows = count($board);\n        $cols = count($board[0]);\n        \n        for ($i = 0; $i < $rows; $i++) {\n            for ($j = 0; $j < $cols; $j++) {\n                if (($i == 0 || $i == $rows - 1 || $j == 0 || $j == $cols - 1) && $board[$i][$j] == 'O') {\n                    $this->dfs($board, $i, $j);\n                }\n            }\n        }\n        \n        for ($i = 0; $i < $rows; $i++) {\n            for ($j = 0; $j < $cols; $j++) {\n                if ($board[$i][$j] == 'O') {\n                    $board[$i][$j] = 'X';\n                } elseif ($board[$i][$j] == '#') {\n                    $board[$i][$j] = 'O';\n                }\n            }\n        }\n    }\n    \n    function dfs(&$board, $i, $j) {\n        if ($i < 0 || $i >= count($board) || $j < 0 || $j >= count($board[0]) || $board[$i][$j] != 'O') {\n            return;\n        }\n        \n        $board[$i][$j] = '#';\n        \n        $this->dfs($board, $i + 1, $j);\n        $this->dfs($board, $i - 1, $j);\n        $this->dfs($board, $i, $j + 1);\n        $this->dfs($board, $i, $j - 1);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func solve(_ board: inout [[Character]]) {\n        let rows = board.count\n        let cols = board[0].count\n        \n        func dfs(_ i: Int, _ j: Int) {\n            if i < 0 || i >= rows || j < 0 || j >= cols || board[i][j] != \"O\" {\n                return\n            }\n            \n            board[i][j] = \"#\"\n            \n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        }\n        \n        // Iterate over the borders and mark the connected 'O's as safe\n        for i in 0..<rows {\n            dfs(i, 0)\n            dfs(i, cols - 1)\n        }\n        \n        for j in 0..<cols {\n            dfs(0, j)\n            dfs(rows - 1, j)\n        }\n        \n        // Flip 'O's to 'X's and restore '#' to 'O'\n        for i in 0..<rows {\n            for j in 0..<cols {\n                if board[i][j] == \"O\" {\n                    board[i][j] = \"X\"\n                } else if board[i][j] == \"#\" {\n                    board[i][j] = \"O\"\n                }\n            }\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun solve(board: Array<CharArray>): Unit {\n        fun dfs(board: Array<CharArray>, i: Int, j: Int) {\n            if (i < 0 || j < 0 || i >= board.size || j >= board[0].size || board[i][j] != 'O') return\n            board[i][j] = 'Y'\n            dfs(board, i + 1, j)\n            dfs(board, i - 1, j)\n            dfs(board, i, j + 1)\n            dfs(board, i, j - 1)\n        }\n        \n        for (i in board.indices) {\n            for (j in board[i].indices) {\n                if ((i == 0 || j == 0 || i == board.size - 1 || j == board[i].size - 1) && board[i][j] == 'O') {\n                    dfs(board, i, j)\n                }\n            }\n        }\n        \n        for (i in board.indices) {\n            for (j in board[i].indices) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X'\n                } else if (board[i][j] == 'Y') {\n                    board[i][j] = 'O'\n                }\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void solve(List<List<String>> board) {\n      if (board.isEmpty) return;\n      \n      int rows = board.length;\n      int cols = board[0].length;\n      \n      for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n          if ((i == 0 || i == rows - 1 || j == 0 || j == cols - 1) && board[i][j] == 'O') {\n            _dfs(board, i, j);\n          }\n        }\n      }\n      \n      for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n          if (board[i][j] == 'O') {\n            board[i][j] = 'X';\n          } else if (board[i][j] == '#') {\n            board[i][j] = 'O';\n          }\n        }\n      }\n    }\n    \n    void _dfs(List<List<String>> board, int i, int j) {\n      if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != 'O') {\n        return;\n      }\n      \n      board[i][j] = '#';\n      _dfs(board, i + 1, j);\n      _dfs(board, i - 1, j);\n      _dfs(board, i, j + 1);\n      _dfs(board, i, j - 1);\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func solve(board [][]byte) {\n    if len(board) == 0 {\n        return\n    }\n    \n    m, n := len(board), len(board[0])\n    \n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i < 0 || j < 0 || i >= m || j >= n || board[i][j] != 'O' {\n            return\n        }\n        \n        board[i][j] = 'A'\n        \n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    }\n    \n    for i := 0; i < m; i++ {\n        dfs(i, 0)\n        dfs(i, n-1)\n    }\n    for j := 0; j < n; j++ {\n        dfs(0, j)\n        dfs(m-1, j)\n    }\n    \n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if board[i][j] == 'O' {\n                board[i][j] = 'X'\n            } else if board[i][j] == 'A' {\n                board[i][j] = 'O'\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[][]} board\n# @return {Void} Do not return anything, modify board in-place instead.\ndef solve(board)\n    if board.empty? || board[0].empty?\n        return\n    end\n\n    rows, cols = board.length, board[0].length\n\n    for i in 0..rows-1\n        dfs(board, i, 0)\n        dfs(board, i, cols-1)\n    end\n\n    for j in 0..cols-1\n        dfs(board, 0, j)\n        dfs(board, rows-1, j)\n    end\n\n    for i in 0..rows-1\n        for j in 0..cols-1\n            if board[i][j] == 'O'\n                board[i][j] = 'X'\n            elsif board[i][j] == 'E'\n                board[i][j] = 'O'\n            end\n        end\n    end\nend\n\ndef dfs(board, i, j)\n    if i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != 'O'\n        return\n    end\n\n    board[i][j] = 'E'\n\n    dfs(board, i+1, j)\n    dfs(board, i-1, j)\n    dfs(board, i, j+1)\n    dfs(board, i, j-1)\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def solve(board: Array[Array[Char]]): Unit = {\n        def dfs(board: Array[Array[Char]], i: Int, j: Int): Unit = {\n            if (i < 0 || i >= board.length || j < 0 || j >= board(0).length || board(i)(j) != 'O') {\n                return\n            }\n            board(i)(j) = '#'\n            dfs(board, i + 1, j)\n            dfs(board, i - 1, j)\n            dfs(board, i, j + 1)\n            dfs(board, i, j - 1)\n        }\n\n        for (i <- board.indices) {\n            dfs(board, i, 0)\n            dfs(board, i, board(0).length - 1)\n        }\n        for (j <- board(0).indices) {\n            dfs(board, 0, j)\n            dfs(board, board.length - 1, j)\n        }\n\n        for {\n            i <- board.indices\n            j <- board(0).indices\n        } yield {\n            board(i)(j) match {\n                case 'O' => board(i)(j) = 'X'\n                case '#' => board(i)(j) = 'O'\n                case _ =>\n            }\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn solve(board: &mut Vec<Vec<char>>) {\n        let m = board.len();\n        let n = board[0].len();\n        \n        for i in 0..m {\n            for j in 0..n {\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) && board[i][j] == 'O' {\n                    Self::dfs(board, i as i32, j as i32);\n                }\n            }\n        }\n        \n        for i in 0..m {\n            for j in 0..n {\n                if board[i][j] == 'O' {\n                    board[i][j] = 'X';\n                } else if board[i][j] == '*' {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n    \n    fn dfs(board: &mut Vec<Vec<char>>, i: i32, j: i32) {\n        if i < 0 || i >= board.len() as i32 || j < 0 || j >= board[0].len() as i32 || board[i as usize][j as usize] != 'O' {\n            return;\n        }\n        \n        board[i as usize][j as usize] = '*';\n        \n        Self::dfs(board, i - 1, j);\n        Self::dfs(board, i + 1, j);\n        Self::dfs(board, i, j - 1);\n        Self::dfs(board, i, j + 1);\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll employ the Depth-First Search (DFS) strategy to mark and capture all regions of 'O's that are surrounded by 'X's. Here's how we can do it:\n\n# Explanation\n\n1. **Define the DFS Function**: We'll define a helper DFS function to mark connected 'O's starting from the border.\n2. **Traversal From the Border**: We'll traverse the board's border to find and mark all 'O's directly connected to the border using the DFS helper function. These 'O's are not surrounded by 'X', and we will mark them temporarily (for example, with 'S').\n3. **Update the Board**: After traversing the borders and marking 'O's:\n   - Convert all remaining 'O's in the board to 'X's since they are surrounded by X's.\n   - Convert all 'S' back to 'O's, as they should remain uncaptured.\n\n# Pseudocode\n\n```\nfunction solve(board):\n    # Edge case check - if the board is empty, return immediately\n    if board is empty:\n        return\n\n    # Helper function for Depth-First Search (DFS) to mark connected 'O's with 'S'\n    function dfs(i, j):\n        if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == 'O':\n            board[i][j] = 'S'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n    rows = len(board)\n    cols = len(board[0])\n\n    # Traverse the border and mark all 'O's connected to the border\n    for i in range(0, rows):\n        dfs(i, 0)       # Left border\n        dfs(i, cols - 1)  # Right border\n\n    for j in range(0, cols):\n        dfs(0, j)       # Top border\n        dfs(rows - 1, j)  # Bottom border\n\n    # Convert all 'S' to 'O' and all 'O' to 'X'\n    for i in range(0, rows):\n        for j in range(0, cols):\n            if board[i][j] == 'S':\n                board[i][j] = 'O'\n            else if board[i][j] == 'O':\n                board[i][j] = 'X'\n```\n\nThis approach ensures that only the 'O's that are completely surrounded by 'X's are flipped, while those on the borders or connected to the border remain unchanged.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-surrounded-regions"
    },
    {
        "name": "Palindrome Partitioning",
        "site": "LeetCode",
        "href": "/solution/LeetCode-palindrome-partitioning",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        vector<vector<string>> result;\n        vector<string> currentList;\n        backtrack(result, s, 0, currentList);\n        return result;\n    }\n    \n    void backtrack(vector<vector<string>>& result, string s, int start, vector<string>& currentList) {\n        if (start >= s.length()) {\n            result.push_back(currentList);\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                currentList.push_back(s.substr(start, end - start + 1));\n                backtrack(result, s, end + 1, currentList);\n                currentList.pop_back();\n            }\n        }\n    }\n    \n    bool isPalindrome(string s, int start, int end) {\n        while (start < end) {\n            if (s[start] != s[end]) {\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<>(), s, 0);\n        return result;\n    }\n\n    private void backtrack(List<List<String>> result, List<String> tempList, String s, int start) {\n        if (start == s.length()) {\n            result.add(new ArrayList<>(tempList));\n        } else {\n            for (int i = start; i < s.length(); i++) {\n                if (isPalindrome(s, start, i)) {\n                    tempList.add(s.substring(start, i + 1));\n                    backtrack(result, tempList, s, i + 1);\n                    tempList.remove(tempList.size() - 1);\n                }\n            }\n        }\n    }\n\n    private boolean isPalindrome(String s, int low, int high) {\n        while (low < high) {\n            if (s.charAt(low++) != s.charAt(high--)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n  "
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def partition(self, s):\n        def is_palindrome(s):\n            return s == s[::-1]\n\n        def backtrack(start, path):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n\n        res = []\n        backtrack(0, [])\n        return res"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<string>> Partition(string s) {\n        IList<IList<string>> result = new List<IList<string>>();\n        Backtrack(result, new List<string>(), s, 0);\n        return result;\n    }\n\n    private void Backtrack(IList<IList<string>> result, List<string> tempList, string s, int start) {\n        if (start == s.Length) {\n            result.Add(new List<string>(tempList));\n        } else {\n            for (int i = start; i < s.Length; i++) {\n                if (IsPalindrome(s, start, i)) {\n                    tempList.Add(s.Substring(start, i - start + 1));\n                    Backtrack(result, tempList, s, i + 1);\n                    tempList.RemoveAt(tempList.Count - 1);\n                }\n            }\n        }\n    }\n\n    private bool IsPalindrome(string s, int low, int high) {\n        while (low < high) {\n            if (s[low] != s[high]) {\n                return false;\n            }\n            low++;\n            high--;\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    const result = [];\n    \n    const isPalindrome = (str, start, end) => {\n        while (start < end) {\n            if (str[start] !== str[end]) {\n                return false;\n            }\n            start++;\n            end--;\n        }\n        return true;\n    };\n    \n    const backtrack = (startIndex, path) => {\n        if (startIndex === s.length) {\n            result.push([...path]);\n            return;\n        }\n        \n        for (let i = startIndex; i < s.length; i++) {\n            if (isPalindrome(s, startIndex, i)) {\n                path.push(s.substring(startIndex, i + 1));\n                backtrack(i + 1, path);\n                path.pop();\n            }\n        }\n    };\n    \n    backtrack(0, []);\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function partition(s: string): string[][] {\n    const result: string[][] = [];\n    \n    const isPalindrome = (str: string): boolean => {\n        let left = 0;\n        let right = str.length - 1;\n        while (left < right) {\n            if (str[left] !== str[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    };\n    \n    const backtrack = (start: number, path: string[]) => {\n        if (start === s.length) {\n            result.push([...path]);\n            return;\n        }\n        \n        for (let end = start; end < s.length; end++) {\n            const substring = s.substring(start, end + 1);\n            if (isPalindrome(substring)) {\n                path.push(substring);\n                backtrack(end + 1, path);\n                path.pop();\n            }\n        }\n    };\n    \n    backtrack(0, []);\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return String[][]\n     */\n    function partition($s) {\n        $result = [];\n        $current = [];\n        $this->backtrack($result, $current, $s, 0);\n        return $result;\n    }\n\n    function backtrack(&$result, &$current, $s, $start) {\n        if ($start == strlen($s)) {\n            $result[] = $current;\n            return;\n        }\n        \n        for ($i = $start; $i < strlen($s); $i++) {\n            if ($this->isPalindrome($s, $start, $i)) {\n                $substring = substr($s, $start, $i - $start + 1);\n                $current[] = $substring;\n                $this->backtrack($result, $current, $s, $i + 1);\n                array_pop($current);\n            }\n        }\n    }\n\n    function isPalindrome($s, $left, $right) {\n        while ($left < $right) {\n            if ($s[$left] !== $s[$right]) {\n                return false;\n            }\n            $left++;\n            $right--;\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func partition(_ s: String) -> [[String]] {\n        var result = [[String]]()\n        var currentList = [String]()\n        \n        backtrack(&result, Array(s), 0, &currentList)\n        \n        return result\n    }\n    \n    private func backtrack(_ result: inout [[String]], _ sArr: [Character], _ start: Int, _ currentList: inout [String]) {\n        if start == sArr.count {\n            result.append(currentList)\n            return\n        }\n        \n        for end in start..<sArr.count {\n            if isPalindrome(sArr, start, end) {\n                let substring = String(sArr[start...end])\n                currentList.append(substring)\n                backtrack(&result, sArr, end + 1, &currentList)\n                currentList.removeLast()\n            }\n        }\n    }\n    \n    private func isPalindrome(_ sArr: [Character], _ left: Int, _ right: Int) -> Bool {\n        var l = left\n        var r = right\n        \n        while l < r {\n            if sArr[l] != sArr[r] {\n                return false\n            }\n            l += 1\n            r -= 1\n        }\n        \n        return true\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun partition(s: String): List<List<String>> {\n        val result = mutableListOf<List<String>>()\n        backtrack(s, 0, mutableListOf(), result)\n        return result\n    }\n    \n    private fun backtrack(s: String, start: Int, path: MutableList<String>, result: MutableList<List<String>>) {\n        if (start == s.length) {\n            result.add(ArrayList(path))\n            return\n        }\n        \n        for (i in start until s.length) {\n            if (isPalindrome(s, start, i)) {\n                path.add(s.substring(start, i + 1))\n                backtrack(s, i + 1, path, result)\n                path.removeAt(path.size - 1)\n            }\n        }\n    }\n    \n    private fun isPalindrome(s: String, low: Int, high: Int): Boolean {\n        var i = low\n        var j = high\n        while (i < j) {\n            if (s[i] != s[j]) {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<String>> partition(String s) {\n    List<List<String>> result = [];\n    List<String> currentList = [];\n    backtrack(result, s, 0, currentList);\n    return result;\n  }\n\n  void backtrack(List<List<String>> result, String s, int start, List<String> currentList) {\n    if (start == s.length) {\n      result.add(List.from(currentList));\n      return;\n    }\n\n    for (int i = start; i < s.length; i++) {\n      if (isPalindrome(s, start, i)) {\n        currentList.add(s.substring(start, i + 1));\n        backtrack(result, s, i + 1, currentList);\n        currentList.removeLast();\n      }\n    }\n  }\n\n  bool isPalindrome(String s, int low, int high) {\n    while (low < high) {\n      if (s[low] != s[high]) {\n        return false;\n      }\n      low++;\n      high--;\n    }\n    return true;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func partition(s string) [][]string {\n    var result [][]string\n    var path []string\n    backtrack(&result, path, s, 0)\n    return result\n}\n\nfunc backtrack(result *[][]string, path []string, s string, idx int) {\n    if idx == len(s) {\n        temp := make([]string, len(path))\n        copy(temp, path)\n        *result = append(*result, temp)\n        return\n    }\n    \n    for i := idx; i < len(s); i++ {\n        if isPalindrome(s, idx, i) {\n            path = append(path, s[idx:i+1])\n            backtrack(result, path, s, i+1)\n            path = path[:len(path)-1]\n        }\n    }\n}\n\nfunc isPalindrome(s string, left, right int) bool {\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {String[][]}\ndef partition(s)\n    result = []\n    backtrack(s, 0, [], result)\n    result\nend\n\ndef backtrack(s, start, path, result)\n    if start == s.length\n        result << path.dup\n        return\n    end\n    \n    (start...s.length).each do |i|\n        if is_palindrome(s, start, i)\n            path << s[start..i]\n            backtrack(s, i + 1, path, result)\n            path.pop\n        end\n    end\nend\n\ndef is_palindrome(s, low, high)\n    while low < high\n        return false if s[low] != s[high]\n        low += 1\n        high -= 1\n    end\n    true\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def partition(s: String): List[List[String]] = {\n        def isPalindrome(str: String): Boolean = {\n            str == str.reverse\n        }\n        \n        def backtrack(start: Int, current: List[String]): List[List[String]] = {\n            if (start >= s.length) {\n                List(current)\n            } else {\n                (start until s.length).flatMap(end => {\n                    val substring = s.substring(start, end + 1)\n                    if (isPalindrome(substring)) {\n                        backtrack(end + 1, current :+ substring)\n                    } else {\n                        List()\n                    }\n                }).toList\n            }\n        }\n        \n        backtrack(0, List())\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn partition(s: String) -> Vec<Vec<String>> {\n        fn is_palindrome(s: &str) -> bool {\n            let n = s.len();\n            let s = s.as_bytes();\n            let mut dp = vec![vec![false; n]; n];\n            \n            for i in 0..n {\n                dp[i][i] = true;\n            }\n            \n            for len in 2..=n {\n                for i in 0..n-len+1 {\n                    let j = i + len - 1;\n                    if len == 2 {\n                        dp[i][j] = s[i] == s[j];\n                    } else {\n                        dp[i][j] = s[i] == s[j] && dp[i+1][j-1];\n                    }\n                }\n            }\n            \n            dp[0][n-1]\n        }\n        \n        fn backtrack(s: &str, start: usize, path: &mut Vec<String>, res: &mut Vec<Vec<String>>) {\n            if start == s.len() {\n                res.push(path.clone());\n                return;\n            }\n            \n            for end in start..s.len() {\n                let substr = &s[start..=end];\n                if is_palindrome(substr) {\n                    path.push(substr.to_string());\n                    backtrack(s, end + 1, path, res);\n                    path.pop();\n                }\n            }\n        }\n        \n        let mut res = Vec::new();\n        let mut path = Vec::new();\n        \n        backtrack(&s, 0, &mut path, &mut res);\n        \n        res\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify all possible partitions of a given string such that each partition is a palindrome. We can achieve this by using backtracking to explore all potential partitions and checking if each substring is a palindrome.\n\n# Explanation\n\n1. **Palindrome Check Function**: \n   - We'll need a helper function to check if a given substring is a palindrome. A substring is a palindrome if it reads the same backward as forward.\n\n2. **Backtracking Function**:\n   - We'll use a backtracking approach to explore all possible ways to split the string.\n   - Start from the beginning of the string and try to partition it at each possible position.\n   - For each partition, check if the left part is a palindrome using the palindrome check function.\n   - If it is, add this substring to the current path and recursively attempt to partition the remainder of the string.\n   - If the end of the string is reached, add the current partitioning to the result list.\n\n3. **Return All Valid Partitions**:\n   - Once the backtracking process is complete, we'll have a list of all valid palindrome partitions.\n\n# Pseudocode\n\n```\nfunction is_palindrome(substring):\n    return substring == reverse(substring)\n\nfunction backtrack(start, path, res, s):\n    if start == length(s):\n        append path to res\n        return\n    for end from start + 1 to length(s) + 1:\n        if is_palindrome(substring(s, start, end)):\n            append substring(s, start, end) to path\n            backtrack(end, path, res, s)\n            remove last element from path\n            \nfunction partition(s):\n    res = empty list\n    backtrack(0, empty list, res, s)\n    return res\n```\n\nIn summary, the algorithm iterates through each possible ending point for a substring, checks for palindrome status, and uses backtracking to explore all possible partitions of the string.\n\nBy using the above pseudocode approach, we can find all possible palindrome partitions for the given string effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-palindrome-partitioning"
    },
    {
        "name": "Palindrome Partitioning Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-palindrome-partitioning-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<vector<bool>> isPalindrome(n, vector<bool>(n, false));\n        vector<int> dp(n, INT_MAX);\n\n        for (int end = 0; end < n; end++) {\n            for (int start = 0; start <= end; start++) {\n                if (s[start] == s[end] && (end - start <= 2 || isPalindrome[start + 1][end - 1])) {\n                    isPalindrome[start][end] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (isPalindrome[0][i]) {\n                dp[i] = 0;\n            } else {\n                for (int j = 0; j < i; j++) {\n                    if (isPalindrome[j + 1][i]) {\n                        dp[i] = min(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n        }\n\n        return dp[n - 1];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minCut(String s) {\n        int n = s.length();\n        boolean[][] isPalindrome = new boolean[n][n];\n        int[] dp = new int[n];\n        \n        for (int end = 0; end < n; end++) {\n            dp[end] = end;\n            for (int start = 0; start <= end; start++) {\n                if (s.charAt(start) == s.charAt(end) && (end - start <= 2 || isPalindrome[start + 1][end - 1])) {\n                    isPalindrome[start][end] = true;\n                    dp[end] = (start == 0) ? 0 : Math.min(dp[end], dp[start - 1] + 1);\n                }\n            }\n        }\n        \n        return dp[n - 1];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minCut(self, s):\n        n = len(s)\n        is_palindrome = [[False] * n for _ in range(n)]\n        \n        for i in range(n):\n            is_palindrome[i][i] = True\n        \n        for length in range(2, n + 1):\n            for start in range(n - length + 1):\n                end = start + length - 1\n                if length == 2:\n                    is_palindrome[start][end] = s[start] == s[end]\n                else:\n                    is_palindrome[start][end] = s[start] == s[end] and is_palindrome[start + 1][end - 1]\n        \n        dp = [float('inf')] * n\n        for end in range(n):\n            if is_palindrome[0][end]:\n                dp[end] = 0\n            else:\n                dp[end] = min(dp[end], min(dp[i - 1] + 1 for i in range(end, 0, -1) if is_palindrome[i][end]))\n        \n        return dp[n - 1]\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinCut(string s) {\n        int n = s.Length;\n        bool[,] isPalindrome = new bool[n, n];\n        int[] dp = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            dp[i] = i;\n            for (int j = 0; j <= i; j++) {\n                if (s[j] == s[i] && (i - j < 2 || isPalindrome[j + 1, i - 1])) {\n                    isPalindrome[j, i] = true;\n                    dp[i] = (j == 0) ? 0 : Math.Min(dp[i], dp[j - 1] + 1);\n                }\n            }\n        }\n        \n        return dp[n - 1];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar minCut = function(s) {\n    const n = s.length;\n    const isPalindrome = Array(n).fill(0).map(() => Array(n).fill(false));\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i; j < n; j++) {\n            if (s[i] === s[j] && (j - i <= 1 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n            }\n        }\n    }\n\n    const dp = Array(n).fill(Infinity);\n\n    for (let i = 0; i < n; i++) {\n        if (isPalindrome[0][i]) {\n            dp[i] = 0;\n        } else {\n            for (let j = 0; j < i; j++) {\n                if (isPalindrome[j + 1][i]) {\n                    dp[i] = Math.min(dp[i], dp[j] + 1);\n                }\n            }\n        }\n    }\n\n    return dp[n - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minCut(s: string): number {\n    const n = s.length;\n    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));\n    const dp = Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        let minCuts = i;\n        for (let j = 0; j <= i; j++) {\n            if (s[i] === s[j] && (i - j <= 1 || isPalindrome[j + 1][i - 1])) {\n                isPalindrome[j][i] = true;\n                minCuts = j === 0 ? 0 : Math.min(minCuts, dp[j - 1] + 1);\n            }\n        }\n        dp[i] = minCuts;\n    }\n    \n    return dp[n - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function minCut($s) {\n        $n = strlen($s);\n        $dp = array_fill(0, $n, 0);\n        \n        for ($i = 0; $i < $n; $i++) {\n            $dp[$i] = $i;\n        }\n        \n        for ($i = 0; $i < $n; $i++) {\n            $this->checkPalindrome($s, $dp, $i, $i);\n            $this->checkPalindrome($s, $dp, $i, $i + 1);\n        }\n        \n        return $dp[$n - 1];\n    }\n    \n    function checkPalindrome($s, &$dp, $left, $right) {\n        $n = strlen($s);\n        while ($left >= 0 && $right < $n && $s[$left] == $s[$right]) {\n            $cut = ($left == 0) ? 0 : $dp[$left - 1] + 1;\n            $dp[$right] = min($dp[$right], $cut);\n            $left--;\n            $right++;\n        }\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minCut(_ s: String) -> Int {\n        if s.isEmpty || s.count == 1 {\n            return 0\n        }\n        \n        let sArray = Array(s)\n        let n = s.count\n        var dp = Array(repeating: Array(repeating: false, count: n), count: n)\n        var cuts = Array(repeating: 0, count: n)\n        \n        for j in 0..<n {\n            var minCuts = j\n            for i in 0...j {\n                if sArray[i] == sArray[j] && (j - i <= 1 || dp[i+1][j-1]) {\n                    dp[i][j] = true\n                    minCuts = i == 0 ? 0 : min(minCuts, 1 + cuts[i - 1])\n                }\n            }\n            cuts[j] = minCuts\n        }\n        \n        return cuts[n-1]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minCut(s: String): Int {\n        val n = s.length\n        val dp = IntArray(n) { it }\n        val isPalindrome = Array(n) { BooleanArray(n) }\n\n        for (i in 0 until n) {\n            for (j in 0..i) {\n                if (s[i] == s[j] && (i - j <= 1 || isPalindrome[j + 1][i - 1])) {\n                    isPalindrome[j][i] = true\n                    if (j == 0) {\n                        dp[i] = 0\n                    } else {\n                        dp[i] = minOf(dp[i], dp[j - 1] + 1)\n                    }\n                }\n            }\n        }\n\n        return dp[n - 1]\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minCut(s string) int {\n    n := len(s)\n    dp := make([][]bool, n)\n    for i := range dp {\n        dp[i] = make([]bool, n)\n    }\n    \n    for length := 1; length <= n; length++ {\n        for i := 0; i+length <= n; i++ {\n            j := i + length - 1\n            if length == 1 {\n                dp[i][j] = true\n            } else if length == 2 {\n                dp[i][j] = s[i] == s[j]\n            } else {\n                dp[i][j] = s[i] == s[j] && dp[i+1][j-1]\n            }\n        }\n    }\n    \n    cuts := make([]int, n)\n    for i := range cuts {\n        cuts[i] = i\n    }\n    \n    for i := 0; i < n; i++ {\n        if dp[0][i] {\n            cuts[i] = 0\n        } else {\n            for j := 0; j < i; j++ {\n                if dp[j+1][i] {\n                    cuts[i] = min(cuts[i], cuts[j]+1)\n                }\n            }\n        }\n    }\n    \n    return cuts[n-1]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef min_cut(s)\n    n = s.length\n    is_palindrome = Array.new(n) { Array.new(n, false) }\n    \n    (0...n).each do |i|\n        is_palindrome[i][i] = true\n    end\n    \n    (2..n).each do |len|\n        (0...n-len+1).each do |start|\n            last = start + len - 1\n            if len == 2\n                is_palindrome[start][last] = s[start] == s[last]\n            else\n                is_palindrome[start][last] = s[start] == s[last] && is_palindrome[start+1][last-1]\n            end\n        end\n    end\n    \n    cuts = Array.new(n)\n    \n    (0...n).each do |i|\n        min_cut = i\n        (0..i).each do |j|\n            if is_palindrome[j][i]\n                min_cut = 0 if j == 0\n                min_cut = [min_cut, (j == 0 ? 0 : cuts[j-1]) + 1].min\n            end\n        end\n        cuts[i] = min_cut\n    end\n    \n    return cuts[n-1]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minCut(s: String): Int = {\n        val n = s.length\n        val isPalindrome = Array.ofDim[Boolean](n, n)\n        val dp = Array.fill(n)(0)\n\n        for (j <- 0 until n) {\n            dp(j) = j\n            for (i <- 0 to j) {\n                if (s(i) == s(j) && (j - i <= 1 || isPalindrome(i + 1)(j - 1))) {\n                    isPalindrome(i)(j) = true\n                    dp(j) = if (i == 0) 0 else Math.min(dp(j), dp(i - 1) + 1)\n                }\n            }\n        }\n\n        dp(n - 1)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn min_cut(s: String) -> i32 {\n        let n = s.len();\n        let s = s.chars().collect::<Vec<_>>();\n        let mut dp = vec![0; n];\n        let mut pal = vec![vec![false; n]; n];\n        \n        for i in 0..n {\n            let mut min = i as i32;\n            for j in 0..=i {\n                if s[i] == s[j] && (i - j <= 1 || pal[j + 1][i - 1]) {\n                    pal[j][i] = true;\n                    min = if j == 0 { 0 } else { min.min(dp[j - 1] + 1) };\n                }\n            }\n            dp[i] = min;\n        }\n        \n        dp[n - 1]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a dynamic programming approach to determine the minimum number of cuts needed to partition the string such that each substring is a palindrome. Here's a detailed explanation and pseudocode for the solution.\n\n# Explanation\n1. **Determine Palindromic Substrings**:\n   - Use a 2D list `is_palindrome` where `is_palindrome[i][j]` is `True` if the substring `s[i:j+1]` is a palindrome.\n   - Initialize `is_palindrome[i][i]` to `True` because any single character is a palindrome.\n   - For substrings of length two, check if both characters are equal.\n   - For longer substrings, check if the first and last characters are equal and if the substring excluding these characters is a palindrome.\n\n2. **Dynamic Programming Array**:\n   - Use an array `dp` where `dp[end]` is the minimum number of cuts needed for the substring `s[0:end+1]` to form palindromes.\n   - If `is_palindrome[0][end]` is `True`, then `dp[end]` is 0 because the whole substring is a palindrome and no cuts are needed.\n   - Otherwise, find the minimum cuts by considering every possible partition.\n\n# Pseudocode\n```pseudo\nfunction minCut(s):\n    n = length of s\n\n    # Step 1: Determine palindromic substrings\n    is_palindrome = 2D list of size n x n initialized with False\n    for i from 0 to n-1:\n        is_palindrome[i][i] = True   # Single characters are palindromes\n\n    for length from 2 to n:\n        for start from 0 to n - length:\n            end = start + length - 1\n            if length == 2:\n                is_palindrome[start][end] = (s[start] == s[end])\n            else:\n                is_palindrome[start][end] = (s[start] == s[end]) and is_palindrome[start + 1][end - 1]\n\n    # Step 2: Calculate minimum cuts using dynamic programming\n    dp = list of size n initialized with infinity\n    for end from 0 to n-1:\n        if is_palindrome[0][end]:\n            dp[end] = 0    # If s[0:end+1] is a palindrome, no cuts are needed\n        else:\n            for i from end down to 1:\n                if is_palindrome[i][end]:\n                    dp[end] = min(dp[end], dp[i - 1] + 1)\n\n    return dp[n - 1]\n```\n\nThis pseudocode describes the approach used to solve the palindrome partitioning problem. It first determines which substrings are palindromes and then calculates the minimum cuts needed using a dynamic programming approach.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-palindrome-partitioning-ii"
    },
    {
        "name": "Clone Graph",
        "site": "LeetCode",
        "href": "/solution/LeetCode-clone-graph",
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var cloneGraph = function(node) {\n    if (!node) return node;\n\n    const visited = new Map();\n\n    const dfs = (node) => {\n        if (visited.has(node)) {\n            return visited.get(node);\n        }\n\n        const clonedNode = new Node(node.val);\n        visited.set(node, clonedNode);\n\n        for (let neighbor of node.neighbors) {\n            clonedNode.neighbors.push(dfs(neighbor));\n        }\n\n        return clonedNode;\n    }\n\n    return dfs(node);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for Node.\n * class Node {\n *     val: number\n *     neighbors: Node[]\n *     constructor(val?: number, neighbors?: Node[]) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.neighbors = (neighbors===undefined ? [] : neighbors)\n *     }\n * }\n */\n\nfunction cloneGraph(node: Node | null): Node | null {\n    if (!node) return null;\n    \n    const visited = new Map<Node, Node>();\n    \n    const dfs = (current: Node | null): Node | null => {\n        if (!current) return null;\n        \n        if (visited.has(current)) {\n            return visited.get(current);\n        }\n        \n        const clonedNode = new Node(current.val);\n        visited.set(current, clonedNode);\n        \n        clonedNode.neighbors = current.neighbors.map(neighbor => dfs(neighbor));\n        \n        return clonedNode;\n    }\n    \n    return dfs(node);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $neighbors = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *         $this->neighbors = array();\n */\nclass Solution {\n    public $map = [];\n    function cloneGraph($node) {\n        if ($node == null) return $node;\n        \n        if (isset($this->map[$node->val])) {\n            return $this->map[$node->val];\n        }\n        \n        $newNode = new Node($node->val);\n        $this->map[$node->val] = $newNode;\n        \n        foreach ($node->neighbors as $neighbor) {\n            $newNode->neighbors[] = $this->cloneGraph($neighbor);\n        }\n        \n        return $newNode;\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a Node.\n * class Node(var `val`: Int) {\n *     var neighbors: ArrayList<Node?> = ArrayList<Node?>()\n * }\n */\nclass Solution {\n    private val map = HashMap<Int, Node>()\n    \n    fun cloneGraph(node: Node?): Node? {\n        if (node == null) return null\n        \n        if (map.containsKey(node.`val`)) {\n            return map[node.`val`]\n        }\n        \n        val newNode = Node(node.`val`)\n        map[node.`val`] = newNode\n        \n        node.neighbors.forEach {\n            newNode.neighbors.add(cloneGraph(it))\n        }\n        \n        return newNode\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Neighbors []*Node\n * }\n */\n\nfunc cloneGraph(node *Node) *Node {\n    if node == nil {\n        return nil\n    }\n\n    visited := make(map[*Node]*Node)\n    return clone(node, visited)\n}\n\nfunc clone(node *Node, visited map[*Node]*Node) *Node {\n    if _, ok := visited[node]; ok {\n        return visited[node]\n    }\n\n    newNode := &Node{Val: node.Val}\n    visited[node] = newNode\n\n    for _, neighbor := range node.Neighbors {\n        newNode.Neighbors = append(newNode.Neighbors, clone(neighbor, visited))\n    }\n\n    return newNode\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "import scala.collection.mutable\n\nobject Solution {\n  def cloneGraph(node: Node): Node = {\n    if (node == null) return null\n\n    val visited = mutable.Map[Int, Node]()\n\n    def cloneHelper(node: Node): Node = {\n      if (visited.contains(node.value)) {\n        return visited(node.value)\n      }\n\n      val cloneNode = new Node(node.value)\n      visited(node.value) = cloneNode\n\n      cloneNode.neighbors = node.neighbors.map(cloneHelper)\n\n      cloneNode\n    }\n\n    cloneHelper(node)\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create a deep copy of a connected undirected graph. A deep copy means that the new graph should not share any nodes or edges with the original graph, except for the values.\n\n# Explanation\n\nThe graph is given as an adjacency list, where each list at index `i` contains the neighbors for the node with value `i+1`. The approach involves using Depth-First Search (DFS) to traverse the graph and clone each node and its neighbors recursively.\n\nHere's a step-by-step approach:\n1. If the input node is `None`, return `None`.\n2. Use a map (or dictionary) to keep track of already visited (and cloned) nodes to avoid cycles and redundant processing.\n3. Implement a DFS function that, given a node:\n   - If the node has already been visited (cloned), return the cloned node from the map.\n   - Otherwise, create a clone of the node.\n   - Map the original node to its clone in the visited map.\n   - Recursively clone all neighbors and add them to the neighbor list of the cloned node.\n   - Return the cloned node.\n\n# Pseudocode\n\n```pseudocode\nfunction cloneGraph(Node node):\n    if node is None:\n        return node\n\n    map visited = new Map()\n\n    function dfs(Node node):\n        if visited.contains(node):\n            return visited.get(node)\n\n        Node clonedNode = new Node(node.val)\n        visited.set(node, clonedNode)\n\n        for each neighbor in node.neighbors:\n            clonedNode.neighbors.append(dfs(neighbor))\n\n        return clonedNode\n\n    return dfs(node)\n```\n\nIn this pseudocode:\n- We start by checking if the input node is `None`.\n- We declare a map `visited` to store the mapping of original nodes to their clones.\n- The `dfs` function performs the actual cloning using a recursive DFS approach.\n- The main function initiates the cloning process with the given node and returns the cloned graph.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-clone-graph"
    },
    {
        "name": "Gas Station",
        "site": "LeetCode",
        "href": "/solution/LeetCode-gas-station",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n = gas.size();\n        int total_tank = 0;\n        int curr_tank = 0;\n        int starting_station = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            total_tank += gas[i] - cost[i];\n            curr_tank += gas[i] - cost[i];\n            if (curr_tank < 0) {\n                starting_station = i + 1;\n                curr_tank = 0;\n            }\n        }\n        \n        return total_tank >= 0 ? starting_station : -1;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int total = 0;\n        int curr = 0;\n        int start = 0;\n\n        for (int i = 0; i < gas.length; i++) {\n            total += gas[i] - cost[i];\n            curr += gas[i] - cost[i];\n            if (curr < 0) {\n                start = i + 1;\n                curr = 0;\n            }\n        }\n\n        return total >= 0 ? start : -1;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        total_tank = 0\n        curr_tank = 0\n        starting_station = 0\n        \n        for i in range(len(gas)):\n            total_tank += gas[i] - cost[i]\n            curr_tank += gas[i] - cost[i]\n            \n            if curr_tank < 0:\n                starting_station = i + 1\n                curr_tank = 0\n                \n        return starting_station if total_tank >= 0 else -1"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) \n{\n    int total_tank = 0;\n    int curr_tank = 0;\n    int starting_station = 0;\n\n    for (int i = 0; i < gasSize; i++) {\n        total_tank += gas[i] - cost[i];\n        curr_tank += gas[i] - cost[i];\n        \n        if (curr_tank < 0) {\n            curr_tank = 0;\n            starting_station = i + 1;\n        }\n    }\n\n    return total_tank >= 0 ? starting_station : -1;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int CanCompleteCircuit(int[] gas, int[] cost) {\n        int total = 0;\n        int tank = 0;\n        int start = 0;\n\n        for (int i = 0; i < gas.Length; i++) {\n            total += gas[i] - cost[i];\n            tank += gas[i] - cost[i];\n\n            if (tank < 0) {\n                start = i + 1;\n                tank = 0;\n            }\n        }\n\n        return total >= 0 ? start : -1;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nvar canCompleteCircuit = function(gas, cost) {\n    let totalGas = 0;\n    let totalCost = 0;\n    let tank = 0;\n    let start = 0;\n    \n    for (let i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        tank += gas[i] - cost[i];\n        if (tank < 0) {\n            start = i + 1;\n            tank = 0;\n        }\n    }\n    \n    return totalGas < totalCost ? -1 : start;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function canCompleteCircuit(gas: number[], cost: number[]): number {\n    const totalGas = gas.reduce((acc, val) => acc + val, 0);\n    const totalCost = cost.reduce((acc, val) => acc + val, 0);\n\n    if (totalGas < totalCost) {\n        return -1;\n    }\n\n    let tank = 0;\n    let start = 0;\n    let remains = 0;\n\n    for (let i = 0; i < gas.length; i++) {\n        tank += gas[i] - cost[i];\n        if (tank < 0) {\n            start = i + 1;\n            remains += tank;\n            tank = 0;\n        }\n    }\n\n    return tank + remains >= 0 ? start : -1;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $gas\n     * @param Integer[] $cost\n     * @return Integer\n     */\n    function canCompleteCircuit($gas, $cost) {\n        $totalTank = 0;\n        $currentTank = 0;\n        $startIndex = 0;\n        \n        for ($i = 0; $i < count($gas); $i++) {\n            $totalTank += $gas[$i] - $cost[$i];\n            $currentTank += $gas[$i] - $cost[$i];\n            \n            if ($currentTank < 0) {\n                $startIndex = $i + 1;\n                $currentTank = 0;\n            }\n        }\n        \n        return $totalTank >= 0 ? $startIndex : -1;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -> Int {\n        var totalTank = 0\n        var currTank = 0\n        var startingStation = 0\n        \n        for i in 0..<gas.count {\n            totalTank += gas[i] - cost[i]\n            currTank += gas[i] - cost[i]\n            \n            if currTank < 0 {\n                startingStation = i + 1\n                currTank = 0\n            }\n        }\n        \n        return totalTank >= 0 ? startingStation : -1\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun canCompleteCircuit(gas: IntArray, cost: IntArray): Int {\n        var total = 0\n        var current = 0\n        var start = 0\n        \n        for (i in gas.indices) {\n            total += gas[i] - cost[i]\n            current += gas[i] - cost[i]\n            \n            if (current < 0) {\n                start = i + 1\n                current = 0\n            }\n        }\n        \n        return if (total >= 0) start else -1\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int canCompleteCircuit(List<int> gas, List<int> cost) {\n      int total = 0;\n      int sum = 0;\n      int start = 0;\n      \n      for (int i = 0; i < gas.length; i++) {\n          total += gas[i] - cost[i];\n          sum += gas[i] - cost[i];\n          \n          if (sum < 0) {\n              start = i + 1;\n              sum = 0;\n          }\n      }\n      \n      return total >= 0 ? start : -1;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func canCompleteCircuit(gas []int, cost []int) int {\n    totalTank := 0\n    currentTank := 0\n    start := 0\n    \n    for i := 0; i < len(gas); i++ {\n        totalTank += gas[i] - cost[i]\n        currentTank += gas[i] - cost[i]\n        \n        if currentTank < 0 {\n            start = i + 1\n            currentTank = 0\n        }\n    }\n    \n    if totalTank < 0 {\n        return -1\n    }\n    \n    return start\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} gas\n# @param {Integer[]} cost\n# @return {Integer}\ndef can_complete_circuit(gas, cost)\n    total_tank = 0\n    tank = 0\n    start = 0\n    gas.each_with_index do |g, i|\n        tank += g - cost[i]\n        total_tank += g - cost[i]\n        if tank < 0\n            start = i + 1\n            tank = 0\n        end\n    end\n    total_tank >= 0 ? start : -1\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def canCompleteCircuit(gas: Array[Int], cost: Array[Int]): Int = {\n        var totalGas = 0\n        var totalCost = 0\n        var currGas = 0\n        var start = 0\n\n        for (i <- gas.indices) {\n            totalGas += gas(i)\n            totalCost += cost(i)\n            currGas += gas(i) - cost(i)\n            if (currGas < 0) {\n                start = i + 1\n                currGas = 0\n            }\n        }\n\n        if (totalGas < totalCost) {\n            -1\n        } else {\n            start\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\n        let mut total_tank = 0;\n        let mut curr_tank = 0;\n        let mut starting_station = 0;\n\n        for i in 0..gas.len() {\n            total_tank += gas[i] - cost[i];\n            curr_tank += gas[i] - cost[i];\n\n            if curr_tank < 0 {\n                starting_station = i + 1;\n                curr_tank = 0;\n            }\n        }\n\n        if total_tank >= 0 {\n            return starting_station as i32;\n        } else {\n            return -1;\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to determine the starting gas station's index if you can travel around the circuit once in a clockwise direction using the given gas and cost arrays. If this is not possible, the function should return -1.\n\n# Explanation\n\nThe key idea is to keep track of the total gas left after performing a whole circuit and the current gas left during iteration over gas stations. The logic can be broken down as follows:\n\n1. Maintain two variables: `total_tank` for the net gas balance considering all stations, and `curr_tank` for the gas balance of the current trip segment.\n2. Initialize a variable `starting_station` to record the index of the potential starting station.\n3. Iterate through each gas station:\n   - Update the `total_tank` and `curr_tank` by subtracting the cost of moving to the next station from the gas available at the current station.\n   - If at any point `curr_tank` becomes negative, it means the car cannot reach the next station from the current starting station. Hence, reset `curr_tank` to 0 and update `starting_station` to the next station index.\n4. Finally, if the `total_tank` is non-negative after the loop, return `starting_station`; otherwise, return -1.\n\nThe uniqueness of the solution is guaranteed because there can only be one valid starting station if the solution exists.\n\n# Pseudocode\n\n```\nfunction canCompleteCircuit(gas, cost):\n    total_tank = 0\n    curr_tank = 0\n    starting_station = 0\n\n    for i from 0 to len(gas) - 1:\n        total_tank += gas[i] - cost[i]\n        curr_tank += gas[i] - cost[i]\n\n        if curr_tank < 0:\n            starting_station = i + 1\n            curr_tank = 0\n\n    if total_tank >= 0:\n        return starting_station\n    else:\n        return -1\n```\n\nThis pseudocode helps encapsulate the logic needed to determine the starting gas station that allows completion of the circuit or return -1 if it's not possible.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-gas-station"
    },
    {
        "name": "Candy",
        "site": "LeetCode",
        "href": "/solution/LeetCode-candy",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        vector<int> candies(n, 1);\n        \n        for (int i = 1; i < n; ++i) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n        \n        for (int i = n - 2; i >= 0; --i) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = max(candies[i], candies[i + 1] + 1);\n            }\n        }\n        \n        int total = accumulate(candies.begin(), candies.end(), 0);\n        \n        return total;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        \n        // Initialize each child with 1 candy\n        Arrays.fill(left, 1);\n        Arrays.fill(right, 1);\n        \n        // Scan from left to right to ensure higher ratings get more candies\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        \n        // Scan from right to left to ensure higher ratings get more candies\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        \n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            total += Math.max(left[i], right[i]);\n        }\n        \n        return total;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def candy(self, ratings):\n        candies = [1] * len(ratings)\n        \n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int candy(int* ratings, int ratingsSize) {\n    if (ratingsSize == 0) {\n        return 0;\n    }\n    \n    int candies[ratingsSize];\n    memset(candies, 0, sizeof(candies));\n    \n    for (int i = 0; i < ratingsSize; i++) {\n        candies[i] = 1;\n    }\n    \n    for (int i = 1; i < ratingsSize; i++) {\n        if (ratings[i] > ratings[i-1]) {\n            candies[i] = candies[i-1] + 1;\n        }\n    }\n    \n    for (int i = ratingsSize - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i+1] && candies[i] <= candies[i+1]) {\n            candies[i] = candies[i+1] + 1;\n        }\n    }\n    \n    int sum = 0;\n    for (int i = 0; i < ratingsSize; i++) {\n        sum += candies[i];\n    }\n    \n    return sum;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Candy(int[] ratings) {\n        int n = ratings.Length;\n        int[] leftToRight = new int[n];\n        int[] rightToLeft = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            leftToRight[i] = 1;\n            rightToLeft[i] = 1;\n        }\n\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                leftToRight[i] = leftToRight[i - 1] + 1;\n            }\n        }\n\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                rightToLeft[i] = rightToLeft[i + 1] + 1;\n            }\n        }\n\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.Max(leftToRight[i], rightToLeft[i]);\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} ratings\n * @return {number}\n */\nvar candy = function(ratings) {\n    const n = ratings.length;\n    const left = new Array(n).fill(1);\n    const right = new Array(n).fill(1);\n    \n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        }\n    }\n    \n    let res = left[n - 1];\n    \n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) {\n            right[i] = right[i + 1] + 1;\n        }\n        res += Math.max(left[i], right[i]);\n    }\n    \n    return res;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function candy(ratings: number[]): number {\n    const n = ratings.length;\n    if (n === 0) return 0;\n    \n    const leftToRight = new Array(n).fill(1);\n    const rightToLeft = new Array(n).fill(1);\n    \n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) {\n            leftToRight[i] = leftToRight[i - 1] + 1;\n        }\n    }\n    \n    let res = leftToRight[n - 1];\n    \n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) {\n            rightToLeft[i] = rightToLeft[i + 1] + 1;\n        }\n        res += Math.max(rightToLeft[i], leftToRight[i]);\n    }\n    \n    return res;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $ratings\n     * @return Integer\n     */\n    function candy($ratings) {\n        $n = count($ratings);\n        $left = array_fill(0, $n, 1);\n        $right = array_fill(0, $n, 1);\n        \n        for ($i = 1; $i < $n; $i++) {\n            if ($ratings[$i] > $ratings[$i - 1]) {\n                $left[$i] = $left[$i - 1] + 1;\n            }\n        }\n        \n        $total = $left[$n - 1];\n        \n        for ($i = $n - 2; $i >= 0; $i--) {\n            if ($ratings[$i] > $ratings[$i + 1]) {\n                $right[$i] = $right[$i + 1] + 1;\n            }\n            $total += max($right[$i], $left[$i]);\n        }\n        \n        return $total;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func candy(_ ratings: [Int]) -> Int {\n        let n = ratings.count\n        var candies = Array(repeating: 1, count: n)\n        \n        for i in 1..<n {\n            if ratings[i] > ratings[i-1] {\n                candies[i] = candies[i-1] + 1\n            }\n        }\n        \n        for i in (0..<(n-1)).reversed() {\n            if ratings[i] > ratings[i+1] {\n                candies[i] = max(candies[i], candies[i+1] + 1)\n            }\n        }\n        \n        return candies.reduce(0, +)\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun candy(ratings: IntArray): Int {\n        val n = ratings.size\n        val left = IntArray(n) { 1 }\n        val right = IntArray(n) { 1 }\n\n        for (i in 1 until n) {\n            if (ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1\n            }\n        }\n\n        var result = left[n - 1]\n        for (i in n - 2 downTo 0) {\n            if (ratings[i] > ratings[i + 1]) {\n                right[i] = right[i + 1] + 1\n            }\n            result += maxOf(left[i], right[i])\n        }\n\n        return result\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func candy(ratings []int) int {\n    n := len(ratings)\n    \n    left := make([]int, n)\n    right := make([]int, n)\n    \n    for i := 0; i < n; i++ {\n        left[i] = 1\n        right[i] = 1\n    }\n    \n    for i := 1; i < n; i++ {\n        if ratings[i] > ratings[i-1] {\n            left[i] = left[i-1] + 1\n        }\n    }\n    \n    for i := n-2; i >= 0; i-- {\n        if ratings[i] > ratings[i+1] {\n            right[i] = right[i+1] + 1\n        }\n    }\n    \n    result := 0\n    \n    for i := 0; i < n; i++ {\n        result += max(left[i], right[i])\n    }\n    \n    return result\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} ratings\n# @return {Integer}\ndef candy(ratings)\n    n = ratings.length\n    candies = Array.new(n, 1)\n    \n    (1...n).each do |i|\n        if ratings[i] > ratings[i-1]\n            candies[i] = candies[i-1] + 1\n        end\n    end\n    \n    (n-2).downto(0).each do |i|\n        if ratings[i] > ratings[i+1]\n            candies[i] = [candies[i], candies[i+1] + 1].max\n        end\n    end\n    \n    return candies.sum\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def candy(ratings: Array[Int]): Int = {\n        val n = ratings.length\n        val leftToRight = Array.fill(n)(1)\n        val rightToLeft = Array.fill(n)(1)\n\n        for (i <- 1 until n) {\n            if (ratings(i) > ratings(i - 1)) {\n                leftToRight(i) = leftToRight(i - 1) + 1\n            }\n        }\n\n        for (i <- n - 2 to 0 by -1) {\n            if (ratings(i) > ratings(i + 1)) {\n                rightToLeft(i) = rightToLeft(i + 1) + 1\n            }\n        }\n\n        var result = 0\n        for (i <- 0 until n) {\n            result += Math.max(leftToRight(i), rightToLeft(i))\n        }\n\n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn candy(ratings: Vec<i32>) -> i32 {\n        let n = ratings.len();\n        let mut candies = vec![1; n];\n        \n        for i in 1..n {\n            if ratings[i] > ratings[i-1] {\n                candies[i] = candies[i-1] + 1;\n            }\n        }\n        \n        for i in (0..n-1).rev() {\n            if ratings[i] > ratings[i+1] {\n                candies[i] = candies[i].max(candies[i+1] + 1);\n            }\n        }\n        \n        candies.iter().sum()\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to distribute candies to children based on their ratings such that each child gets at least one candy and children with higher ratings get more candies than their neighbors. Let's break down the problem and solution using pseudocode.\n\n# Explanation\n\n1. **Initial Setup**: Create an array `candies` where each child is initially given one candy.\n2. **Forward Pass**: Traverse the `ratings` list from left to right. For each child, if their rating is higher than the previous child, they get one more candy than the previous child.\n3. **Backward Pass**: Traverse the `ratings` list from right to left. For each child, if their rating is higher than the next child, they get the maximum of their current candies or one more candy than the next child.\n4. **Summing Candies**: Finally, sum up all the candies and return the result.\n\n# Pseudocode\n\n```\nfunction distributeCandies(ratings):\n    n = length of ratings\n    candies = array of size n initialized to 1\n\n    // Forward pass\n    for i from 1 to n-1:\n        if ratings[i] > ratings[i-1]:\n            candies[i] = candies[i-1] + 1\n\n    // Backward pass\n    for i from n-2 down to 0:\n        if ratings[i] > ratings[i+1]:\n            candies[i] = max(candies[i], candies[i+1] + 1)\n\n    // Summing up the candies\n    return sum(candies)\n```\n\nThis approach ensures that both conditions (each child gets at least one candy, and higher-rated children get more candies than their neighbors) are met efficiently. \n\nNow you can use this pseudocode to implement the solution in any programming language you are comfortable with.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-candy"
    },
    {
        "name": "Single Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-single-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int singleNumber(int* nums, int numsSize) {\n    int result = 0;\n    for (int i = 0; i < numsSize; i++) {\n        result ^= nums[i];\n    }\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int SingleNumber(int[] nums) {\n        int result = 0;\n        foreach (int num in nums) {\n            result ^= num;\n        }\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result ^= num;\n    }\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function singleNumber(nums: number[]): number {\n    let result = 0;\n    \n    for (let num of nums) {\n        result ^= num;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function singleNumber($nums) {\n        $single = 0;\n        foreach ($nums as $num) {\n            $single ^= $num;\n        }\n        return $single;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func singleNumber(_ nums: [Int]) -> Int {\n        var result = 0\n        for num in nums {\n            result ^= num\n        }\n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun singleNumber(nums: IntArray): Int {\n        var result = 0\n        for (num in nums) {\n            result = result xor num\n        }\n        return result\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int singleNumber(List<int> nums) {\n    int result = 0;\n    \n    for (int num in nums) {\n      result ^= num;\n    }\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func singleNumber(nums []int) int {\n    result := 0\n    for _, num := range nums {\n        result ^= num\n    }\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef single_number(nums)\n    nums.reduce(:^)\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def singleNumber(nums: Array[Int]): Int = {\n        nums.reduce((num1, num2) => num1 ^ num2)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        let mut result = 0;\n        \n        for num in nums {\n            result ^= num;\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (single-number nums)\n  (-> (listof exact-integer?) exact-integer?)\n  (foldl (\u03bb (num res) (bitwise-xor res num)) 0 nums))"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec single_number(Nums :: [integer()]) -> integer().\nsingle_number(Nums) ->\n    lists:foldl(fun(X, Acc) -> X bxor Acc end, 0, Nums).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify the single integer in a list where every other integer appears exactly twice. We must ensure that our solution has a linear runtime complexity and uses only constant extra space.\n\n# Explanation\nWe can achieve a linear runtime complexity (O(n)) and constant space complexity (O(1)) by using the bitwise XOR operator. The XOR operator has useful properties:\n1. \\( a \\oplus a = 0 \\) for any integer \\( a \\).\n2. \\( a \\oplus 0 = a \\).\n3. XOR is both commutative and associative.\n\nUsing these properties, if we XOR all the elements of the array together, the pairs of identical elements will cancel each other out and result in 0, leaving only the single number that does not have a pair.\n\n# Pseudocode\n1. Initialize a result variable to 0.\n2. Iterate through each element in the array.\n3. For each element, perform XOR with the result variable.\n4. After completing the iteration, the result variable will contain the single number.\n\n```plaintext\n# Pseudocode\n\nfunction singleNumber(nums):\n    result = 0\n    for each num in nums:\n        result = result XOR num\n    return result\n```\n\nThis pseudocode efficiently identifies the non-duplicated integer in the array using constant extra space and linear time complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-single-number"
    },
    {
        "name": "Single Number Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-single-number-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ones = 0, twos = 0;\n        \n        for (int num : nums) {\n            ones = (ones ^ num) & ~twos;\n            twos = (twos ^ num) & ~ones;\n        }\n        \n        return ones;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int seenOnce = 0, seenTwice = 0;\n        \n        for (int num : nums) {\n            seenOnce = ~seenTwice & (seenOnce ^ num);\n            seenTwice = ~seenOnce & (seenTwice ^ num);\n        }\n        \n        return seenOnce;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def singleNumber(self, nums):\n        ones = 0\n        twos = 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int singleNumber(int* nums, int numsSize) {\n    int ones = 0, twos = 0, common_bits;\n    for (int i = 0; i < numsSize; i++) {\n        twos |= (ones & nums[i]);\n        ones ^= nums[i];\n        common_bits = ones & twos;\n        ones &= ~common_bits;\n        twos &= ~common_bits;\n    }\n    return ones;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int SingleNumber(int[] nums) {\n        int ones = 0, twos = 0;\n        \n        foreach (int num in nums) {\n            ones = (ones ^ num) & ~twos;\n            twos = (twos ^ num) & ~ones;\n        }\n        \n        return ones;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let ones = 0, twos = 0;\n    \n    for (let num of nums) {\n        ones = (ones ^ num) & ~twos;\n        twos = (twos ^ num) & ~ones;\n    }\n    \n    return ones;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function singleNumber(nums: number[]): number {\n    let ones = 0, twos = 0;\n    \n    for (let num of nums) {\n        ones = (ones ^ num) & ~twos;\n        twos = (twos ^ num) & ~ones;\n    }\n    \n    return ones;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function singleNumber($nums) {\n        $ones = 0;\n        $twos = 0;\n        \n        foreach ($nums as $num) {\n            $ones = (~$twos) & ($ones ^ $num);\n            $twos = (~$ones) & ($twos ^ $num);\n        }\n        \n        return $ones;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func singleNumber(_ nums: [Int]) -> Int {\n        var seenOnce = 0\n        var seenTwice = 0\n        \n        for num in nums {\n            seenOnce = ~seenTwice & (seenOnce ^ num)\n            seenTwice = ~seenOnce & (seenTwice ^ num)\n        }\n        \n        return seenOnce\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun singleNumber(nums: IntArray): Int {\n        var seenOnce = 0\n        var seenTwice = 0\n        for (num in nums) {\n            seenOnce = seenOnce xor num and seenTwice.inv()\n            seenTwice = seenTwice xor num and seenOnce.inv()\n        }\n        return seenOnce\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int singleNumber(List<int> nums) {\n    int ones = 0, twos = 0;\n    \n    for (int num in nums) {\n      ones = (ones ^ num) & ~twos;\n      twos = (twos ^ num) & ~ones;\n    }\n    \n    return ones;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func singleNumber(nums []int) int {\n    ones, twos := 0, 0\n    for _, num := range nums {\n        ones = (ones ^ num) & ^twos\n        twos = (twos ^ num) & ^ones\n    }\n    return ones\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef single_number(nums)\n    ones = 0\n    twos = 0\n    \n    nums.each do |num|\n        ones = (ones ^ num) & (~twos)\n        twos = (twos ^ num) & (~ones)\n    end\n    \n    return ones\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def singleNumber(nums: Array[Int]): Int = {\n        var ones = 0\n        var twos = 0\n        nums.foreach { num =>\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        }\n        ones\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        let mut ones = 0;\n        let mut twos = 0;\n        for num in nums {\n            ones = (ones ^ num) & !twos;\n            twos = (twos ^ num) & !ones;\n        }\n        ones\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (single-number nums)\n  (-> (listof exact-integer?) exact-integer?)\n  (cond\n    [(= (length nums) 1) (car nums)]\n    [else\n     (let loop ([nums nums] [seen '()] [seen-twice '()])\n       (cond\n         [(null? nums) (car seen)]\n         [(member (car nums) seen-twice)\n          (loop (cdr nums) (remove (car nums) seen) (remove (car nums) seen-twice))]\n         [(member (car nums) seen)\n          (loop (cdr nums) seen (cons (car nums) seen-twice))]\n         [else\n          (loop (cdr nums) (cons (car nums) seen) seen-twice)]\n         ))]))\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec single_number(nums :: [integer]) :: integer\n  def single_number(nums) do\n    Enum.reduce(nums, %{}, fn x, acc ->\n      Map.update(acc, x, 1, &(&1 + 1))\n    end)\n    |> Enum.find(fn {_key, value} -> value == 1 end)\n    |> elem(0)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to identify the unique number in an array where every element appears three times except for one. The solution requires a linear runtime complexity and constant extra space.\n\n# Explanation\nThe algorithm uses bitwise operations to determine the unique number. The idea is to use two bitmasks, `ones` and `twos`, to track the bits that have appeared once and twice, respectively.\n\n1. Initialize `ones` and `twos` to 0.\n2. For each number in the array:\n   - Update `ones` with the XOR of `num` and `ones`, then mask out bits that appear three times by using `~twos`.\n   - Update `twos` similarly by considering the new value of `ones`.\n3. After processing all numbers, `ones` will hold the unique number.\n\nThis approach ensures that bits appearing three times are excluded from both `ones` and `twos`, leaving only the unique number in `ones`.\n\n# Pseudocode\n```\nfunction singleNumber(nums):\n    ones = 0\n    twos = 0\n    for each num in nums:\n        ones = (ones XOR num) AND (NOT twos)\n        twos = (twos XOR num) AND (NOT ones)\n    return ones\n```\n\nThis pseudocode outlines the steps needed to implement the solution efficiently, leveraging bitwise operations and maintaining a constant space complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-single-number-ii"
    },
    {
        "name": "Copy List With Random Pointer",
        "site": "LeetCode",
        "href": "/solution/LeetCode-copy-list-with-random-pointer",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.HashMap;\nimport java.util.Map;\n\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n\n        Map<Node, Node> map = new HashMap<>();\n        Node curr = head;\n\n        while (curr != null) {\n            map.put(curr, new Node(curr.val));\n            curr = curr.next;\n        }\n\n        curr = head;\n        while (curr != null) {\n            map.get(curr).next = map.get(curr.next);\n            map.get(curr).random = map.get(curr.random);\n            curr = curr.next;\n        }\n\n        return map.get(head);\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a Node.\n * struct Node {\n *     int val;\n *     struct Node *next;\n *     struct Node *random;\n * };\n */\n\nstruct Node* copyRandomList(struct Node* head) {\n    if (head == NULL) {\n        return NULL;\n    }\n    \n    struct Node* curr = head;\n    struct Node* next;\n    \n    // Create a copy of each node in the original list and insert it next to the original node\n    while (curr != NULL) {\n        next = curr->next;\n        \n        struct Node* copy = (struct Node*)malloc(sizeof(struct Node));\n        copy->val = curr->val;\n        copy->next = next;\n        copy->random = NULL;\n        \n        curr->next = copy;\n        curr = next;\n    }\n    \n    // Assign random pointers for the copy nodes\n    curr = head;\n    while (curr != NULL) {\n        next = curr->next->next;\n        if (curr->random != NULL) {\n            curr->next->random = curr->random->next;\n        }\n        curr = next;\n    }\n    \n    // Separate the original list and the copied list\n    struct Node* original = head;\n    struct Node* copy = head->next;\n    struct Node* result = copy;\n    \n    while (original != NULL) {\n        original->next = copy->next;\n        original = original->next;\n        if (original != NULL) {\n            copy->next = original->next;\n            copy = copy->next;\n        }\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "const copyRandomList = function(head) {\n    if (!head) return null;\n\n    let map = new Map();\n    let current = head;\n\n    while (current) {\n        map.set(current, new Node(current.val));\n        current = current.next;\n    }\n\n    current = head;\n\n    while (current) {\n        map.get(current).next = map.get(current.next) || null;\n        map.get(current).random = map.get(current.random) || null;\n        current = current.next;\n    }\n\n    return map.get(head);\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for Node.\n * class Node {\n *     val: number\n *     next: Node | null\n *     random: Node | null\n *     constructor(val?: number, next?: Node, random?: Node) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *         this.random = (random===undefined ? null : random)\n *     }\n * }\n */\nfunction copyRandomList(head: Node | null): Node | null {\n    if (!head) return null;\n    \n    const map = new Map();\n    let curr = head;\n    \n    while (curr) {\n        map.set(curr, new Node(curr.val));\n        curr = curr.next;\n    }\n    \n    curr = head;\n    while (curr) {\n        map.get(curr).next = map.get(curr.next) || null;\n        map.get(curr).random = map.get(curr.random) || null;\n        curr = curr.next;\n    }\n    \n    return map.get(head);\n};\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Next *Node\n *     Random *Node\n * }\n */\n\nfunc copyRandomList(head *Node) *Node {\n    if head == nil {\n        return nil\n    }\n\n    visited := make(map[*Node]*Node)\n\n    // Create new nodes without setting random pointer\n    current := head\n    for current != nil {\n        visited[current] = &Node{Val: current.Val}\n        current = current.Next\n    }\n\n    // Set the random pointers\n    current = head\n    for current != nil {\n        visited[current].Next = visited[current.Next]\n        visited[current].Random = visited[current.Random]\n        current = current.Next\n    }\n\n    // Return the head of the new list\n    return visited[head]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for Node.\n# class Node\n#     attr_accessor :val, :next, :random\n#     def initialize(val = 0)\n#         @val = val\n#         @next = nil\n#         @random = nil\n#     end\n\n# @param {Node} head\n# @return {Node}\ndef copyRandomList(head)\n  return nil if head.nil?\n  \n  node_mapping = {}\n  \n  current = head\n  while current\n    node_mapping[current] = Node.new(current.val)\n    current = current.next\n  end\n  \n  current = head\n  while current\n    node_mapping[current].next = node_mapping[current.next]\n    node_mapping[current].random = node_mapping[current.random]\n    current = current.next\n  end\n  \n  return node_mapping[head]\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create a deep copy of a linked list where each node has an additional random pointer. The following steps and pseudocode will help us achieve this:\n\n### # Explanation\n1. **Initial Checks**: If the input head is null, return null as no list exists.\n2. **Create New Nodes and Mapping**: Traverse the original list and create a new node for each node in the original list. Use a hash table (or dictionary) to map each original node to its corresponding new node. This helps in setting up the correct `next` and `random` pointers later.\n3. **Set Pointers**: Traverse the list again and use the hash table to set the `next` and `random` pointers for each new node.\n4. **Return New Head**: Finally, return the head of the newly created list.\n\n### # Pseudocode\n```\n# Define the Node class with necessary attributes (value, next, random)\nclass Node:\n    def __init__(self, val=0, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\n# Function to copy list with random pointer\ndef copyRandomList(head):\n    \n    # If the head is null, return null\n    if head is None:\n        return None\n    \n    # Initialize a dictionary to map original nodes to their copies\n    map = {}\n    \n    # First pass: Create new nodes and populate the map with original node to new node mapping\n    current = head\n    while current is not None:\n        map[current] = Node(current.val)\n        current = current.next\n    \n    # Second pass: Assign next and random pointers using the map\n    current = head\n    while current is not None:\n        if current.next is not None:\n            map[current].next = map[current.next]\n        if current.random is not None:\n            map[current].random = map[current.random]\n        current = current.next\n    \n    # Return the head of the newly created list\n    return map[head]\n\n# Driver: Using an example to illustrate\ninput_head = [...]  # Input linked list representation\ncopied_list_head = copyRandomList(input_head)\n```\nUsing this approach, we ensure that each node and pointer is correctly copied, and the new list is entirely independent of the original list. This guarantees a deep copy.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-copy-list-with-random-pointer"
    },
    {
        "name": "Lru Cache",
        "site": "LeetCode",
        "href": "/solution/LeetCode-lru-cache",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class LRUCache {\npublic:\n    LRUCache(int capacity) {\n        cap = capacity;\n    }\n    \n    int get(int key) {\n        if (cache.find(key) == cache.end()) {\n            return -1;\n        } else {\n            // Move the key to the front of the list\n            keyList.splice(keyList.begin(), keyList, cache[key].second);\n            return cache[key].first;\n        }\n    }\n    \n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            // Update the value if the key exists\n            cache[key].first = value;\n            keyList.splice(keyList.begin(), keyList, cache[key].second);\n        } else {\n            // Add the key-value pair\n            if (cache.size() >= cap) {\n                int deleteKey = keyList.back();\n                cache.erase(deleteKey);\n                keyList.pop_back();\n            }\n            keyList.push_front(key);\n        }\n        cache[key] = {value, keyList.begin()};\n    }\n    \nprivate:\n    unordered_map<int, pair<int, list<int>::iterator>> cache;\n    list<int> keyList;\n    int cap;\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class LRUCache {\n    private Map<Integer, Integer> map;\n    private LinkedList<Integer> list;\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        list = new LinkedList<>();\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            list.removeFirstOccurrence(key);\n            list.addFirst(key);\n            return map.get(key);\n        } else {\n            return -1;\n        }\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            list.removeFirstOccurrence(key);\n        } else if (list.size() >= capacity) {\n            map.remove(list.removeLast());\n        }\n\n        map.put(key, value);\n        list.addFirst(key);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class LRUCache(object):\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}\n        self.key_order = []\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key in self.cache:\n            self.key_order.remove(key)\n            self.key_order.append(key)\n            return self.cache[key]\n        else:\n            return -1\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.cache:\n            self.key_order.remove(key)\n        elif len(self.cache) == self.capacity:\n            LRU_key = self.key_order.pop(0)\n            del self.cache[LRU_key]\n\n        self.cache[key] = value\n        self.key_order.append(key)\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you'll need to design an LRU (Least Recently Used) Cache class that supports the following operations: `get` and `put`. The `get` function should return the value associated with a specific key if it exists and update the key's usage status, otherwise it should return -1. The `put` function should insert or update the key-value pair and ensure that the cache does not exceed its capacity by evicting the least recently used key if necessary.\n\nWe can use a combination of a dictionary to store key-value pairs and a linked list to maintain the order of key usage for efficient insertion, removal, and update operations. A `deque` from the `collections` module can be particularly useful for this.\n\nHere is the breakdown of how the algorithm works:\n\n# Explanation\n\n1. **Initialization**:\n   - The cache is initialized with a fixed capacity.\n   - Use a dictionary (`cache`) to store key-value pairs for O(1) access.\n   - Use a list (`key_order`) to maintain the order of keys by their recent usage. The most recently used key will be at the end of the list.\n\n2. **Get Operation**:\n   - If the key exists in the cache, update the key's position in `key_order` to the end (most recently used) and return its value.\n   - If the key does not exist, return -1.\n\n3. **Put Operation**:\n   - If the key already exists, update its value and move it to the end of `key_order`.\n   - If the key does not exist and the cache is at full capacity, remove the least recently used key (which is the first element in `key_order`).\n   - Add the new key-value pair to the cache and append the key to `key_order`.\n\n# Pseudocode\n\n```pseudo\nclass LRUCache:\n    def __init__(capacity: int):\n        # Initialize the LRU cache with positive size capacity\n        self.capacity = capacity\n        self.cache = {}  # Dictionary to store key-value pairs\n        self.key_order = []  # List to maintain the order of keys by their recent usage\n\n    def get(key: int) -> int:\n        if key in self.cache:\n            # Move the key to the end to mark it as recently used\n            self.key_order.remove(key)\n            self.key_order.append(key)\n            return self.cache[key]\n        else:\n            return -1  # Key does not exist\n\n    def put(key: int, value: int):\n        if key in self.cache:\n            # If the key is already in the cache, remove it from key_order\n            self.key_order.remove(key)\n        elif len(self.cache) == self.capacity:\n            # If the cache is full, remove the least recently used key\n            LRU_key = self.key_order.pop(0)\n            del self.cache[LRU_key]\n        \n        # Add the key-value pair to the cache and mark it as recently used\n        self.cache[key] = value\n        self.key_order.append(key)\n```\n\nBy following the above methodology, the `LRUCache` class ensures that both the `get` and `put` operations run in O(1) time complexity on average.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-lru-cache"
    },
    {
        "name": "Word Break Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-word-break-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        unordered_map<string, vector<string>> memo;\n\n        return wordBreakHelper(s, dict, memo);\n    }\n    \n    vector<string> wordBreakHelper(string s, unordered_set<string>& dict, unordered_map<string, vector<string>>& memo) {\n        if (memo.find(s) != memo.end()) {\n            return memo[s];\n        }\n        \n        vector<string> result;\n        \n        if (s.empty()) {\n            result.push_back(\"\");\n            return result;\n        }\n        \n        for (string word : dict) {\n            if (s.substr(0, word.length()) == word) {\n                vector<string> subList = wordBreakHelper(s.substr(word.length()), dict, memo);\n                \n                for (string sub : subList) {\n                    result.push_back(word + (sub.empty() ? \"\" : \" \") + sub);\n                }\n            }\n        }\n        \n        memo[s] = result;\n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        List<String> result = new ArrayList<>();\n        backtrack(s, wordDict, result, new StringBuilder(), 0);\n        return result;\n    }\n    \n    private void backtrack(String s, List<String> wordDict, List<String> result, StringBuilder sb, int start) {\n        if (start == s.length()) {\n            result.add(sb.toString().trim());\n            return;\n        }\n        \n        for (String word : wordDict) {\n            if (s.startsWith(word, start)) {\n                int len = word.length();\n                int sbLen = sb.length();\n                sb.append(word).append(\" \");\n                backtrack(s, wordDict, result, sb, start + len);\n                sb.setLength(sbLen);\n            }\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def backtrack(start, path):\n            if start == len(s):\n                result.append(' '.join(path))\n                return\n            for end in range(start + 1, len(s) + 1):\n                if s[start:end] in wordDict:\n                    backtrack(end, path + [s[start:end]])\n        \n        result = []\n        backtrack(0, [])\n        return result\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> WordBreak(string s, IList<string> wordDict) {\n        var dict = new HashSet<string>(wordDict);\n        return WordBreakHelper(s, dict, new Dictionary<string, List<string>>());\n    }\n    \n    private IList<string> WordBreakHelper(string s, HashSet<string> dict, Dictionary<string, List<string>> memo) {\n        if (memo.ContainsKey(s)) {\n            return memo[s];\n        }\n        \n        var result = new List<string>();\n        \n        if (dict.Contains(s)) {\n            result.Add(s);\n        }\n        \n        for (int i = 1; i < s.Length; i++) {\n            string right = s.Substring(i);\n            if (dict.Contains(right)) {\n                IList<string> left = WordBreakHelper(s.Substring(0, i), dict, memo);\n                foreach (string l in left) {\n                    result.Add(l + \" \" + right);\n                }\n            }\n        }\n        \n        memo[s] = result;\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nvar wordBreak = function(s, wordDict) {\n    const wordSet = new Set(wordDict);\n    const memo = new Map();\n    \n    const helper = (start) => {\n        if (memo.has(start)) return memo.get(start);\n        \n        const results = [];\n        if (start === s.length) {\n            results.push('');\n        }\n        \n        for (let end = start + 1; end <= s.length; end++) {\n            const word = s.substring(start, end);\n            if (wordSet.has(word)) {\n                const suffixes = helper(end);\n                for (const suffix of suffixes) {\n                    results.push(word + (suffix === '' ? '' : ' ') + suffix);\n                }\n            }\n        }\n        \n        memo.set(start, results);\n        return results;\n    };\n    \n    return helper(0);\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function wordBreak(s: string, wordDict: string[]): string[] {\n    const wordSet = new Set(wordDict);\n    const memo: { [key: string]: string[]} = {};\n\n    const backtrack = (startIndex: number): string[] => {\n        if (memo[startIndex]) {\n            return memo[startIndex];\n        }\n\n        if (startIndex === s.length) {\n            return [\"\"];\n        }\n\n        const result: string[] = [];\n\n        for (let endIndex = startIndex + 1; endIndex <= s.length; endIndex++) {\n            const word = s.substring(startIndex, endIndex);\n            if (wordSet.has(word)) {\n                const nextWords = backtrack(endIndex);\n                for (const nextWord of nextWords) {\n                    result.push(nextWord ? word + \" \" + nextWord : word);\n                }\n            }\n        }\n\n        memo[startIndex] = result;\n        return result;\n    };\n\n    return backtrack(0);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param String[] $wordDict\n     * @return String[]\n     */\n    function wordBreak($s, $wordDict) {\n        $memo = [];\n        return $this->dfs($s, $wordDict, $memo);\n    }\n    \n    function dfs($s, $wordDict, &$memo) {\n        if (array_key_exists($s, $memo)) {\n            return $memo[$s];\n        }\n        \n        $result = [];\n        foreach ($wordDict as $word) {\n            if (strpos($s, $word) === 0) {\n                $subStr = substr($s, strlen($word));\n                if (strlen($subStr) == 0) {\n                    $result[] = $word;\n                } else {\n                    $subResult = $this->dfs($subStr, $wordDict, $memo);\n                    foreach ($subResult as $w) {\n                        $result[] = $word . \" \" . $w;\n                    }\n                }\n            }\n        }\n        \n        $memo[$s] = $result;\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\n        var memo = [String: [String]]()\n\n        func backtrack(_ s: String) -> [String] {\n            if let result = memo[s] {\n                return result\n            }\n\n            var sentences = [String]()\n\n            for word in wordDict {\n                if s.hasPrefix(word) {\n                    let nextWordIndex = s.index(s.startIndex, offsetBy: word.count)\n                    if nextWordIndex == s.endIndex {\n                        sentences.append(word)\n                    } else {\n                        let nextSubstring = String(s[nextWordIndex...])\n                        let nextSentences = backtrack(nextSubstring)\n                        for nextSentence in nextSentences {\n                            sentences.append(word + \" \" + nextSentence)\n                        }\n                    }\n                }\n            }\n\n            memo[s] = sentences\n            return sentences\n        }\n\n        return backtrack(s)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\n        val map = HashMap<String, List<String>>()\n\n        fun wordBreakHelper(s: String): List<String> {\n            if (map.containsKey(s)) {\n                return map[s]!!\n            }\n\n            val result = mutableListOf<String>()\n\n            if (s.isEmpty()) {\n                result.add(\"\")\n                return result\n            }\n\n            for (word in wordDict) {\n                if (s.startsWith(word)) {\n                    val subList = wordBreakHelper(s.substring(word.length))\n                    for (sub in subList) {\n                        result.add(if (sub.isEmpty()) word else \"$word $sub\")\n                    }\n                }\n            }\n\n            map[s] = result\n            return result\n        }\n\n        return wordBreakHelper(s)\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> wordBreak(String s, List<String> wordDict) {\n    List<String> result = [];\n    if (s.isEmpty) {\n      return result;\n    }\n    return wordBreakHelper(s, wordDict, {});\n  }\n\n  List<String> wordBreakHelper(String s, List<String> wordDict, Map<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n      return memo[s]!;\n    }\n    List<String> result = [];\n    if (s.isEmpty) {\n      result.add(\"\");\n      return result;\n    }\n    for (String word in wordDict) {\n      if (s.startsWith(word)) {\n        List<String> subList = wordBreakHelper(s.substring(word.length), wordDict, memo);\n        for (String sub in subList) {\n          result.add(word + (sub.isEmpty ? \"\" : \" \") + sub);\n        }\n      }\n    }\n    memo[s] = result;\n    return result;\n  }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {String[]} word_dict\n# @return {String[]}\ndef word_break(s, word_dict)\n    result = []\n    backtrack(s, word_dict, \"\", result)\n    return result\nend\n\ndef backtrack(s, word_dict, path, result)\n    if s == \"\"\n        result << path.strip\n        return\n    end\n    \n    word_dict.each do |word|\n        if s.start_with?(word)\n            backtrack(s[word.length..-1], word_dict, \"#{path} #{word}\", result)\n        end\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def wordBreak(s: String, wordDict: List[String]): List[String] = {\n        import scala.collection.mutable.Map\n\n        var map = Map[String, List[String]]()\n\n        def wordBreakHelper(s: String): List[String] = {\n            if (map.contains(s)) return map(s)\n\n            var res = List[String]()\n            if (s.isEmpty) {\n                res = List(\"\")\n            } else {\n                for (word <- wordDict) {\n                    if (s.startsWith(word)) {\n                        val subList = wordBreakHelper(s.substring(word.length))\n                        for (sub <- subList) {\n                            res = (if (sub.isEmpty) word else word + \" \" + sub) :: res\n                        }\n                    }\n                }\n            }\n            map += (s -> res)\n            res\n        }\n\n        wordBreakHelper(s)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn word_break(s: String, word_dict: Vec<String>) -> Vec<String> {\n        use std::collections::{HashMap, HashSet};\n\n        fn backtrack(\n            s: &str,\n            word_dict: &HashSet<String>,\n            memo: &mut HashMap<String, Vec<String>>,\n        ) -> Vec<String> {\n            if let Some(result) = memo.get(s) {\n                return result.clone();\n            }\n\n            let mut sentences = vec![];\n            if word_dict.contains(s) {\n                sentences.push(s.to_string());\n            }\n\n            for i in 1..s.len() {\n                let (word_left, word_right) = s.split_at(i);\n                if word_dict.contains(word_left) {\n                    let previous_sentences = backtrack(word_right, word_dict, memo);\n                    for sentence in previous_sentences {\n                        let space = if !sentence.is_empty() { \" \" } else { \"\" };\n                        sentences.push(format!(\"{}{}{}\", word_left, space, sentence));\n                    }\n                }\n            }\n\n            memo.insert(s.to_string(), sentences.clone());\n            sentences\n        }\n\n        let word_dict_set: HashSet<String> = word_dict.iter().cloned().collect();\n        let result = backtrack(&s, &word_dict_set, &mut HashMap::new());\n\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you will need to implement a backtracking algorithm that recursively explores possible ways to segment the string `s` using words from the dictionary `wordDict`. The goal is to find all valid segments where each word is in the dictionary. \n\n## Explanation\n1. **Function Definition**: Define a function `wordBreak` that takes a string `s` and a list of dictionary words `wordDict`.\n2. **Backtracking Function**: Within the function, define a helper function `backtrack` that:\n    - Takes the current start index and the path of words formed so far.\n    - If the start index reaches the end of the string, convert the path to a sentence and add it to the results.\n    - Iterate over potential end indices to check substrings from the current start to possible end indices.\n    - If a valid dictionary word is found in the substring, recursively call `backtrack` with the new end index and the updated path.\n3. **Initialization and Result**: Initialize an empty list to store the results and call the `backtrack` function starting from index 0 with an empty path. Finally, return the list of results.\n\nThis approach uses recursion to explore all possible segmentations of the string and constructs valid sentences by gradually building words from the dictionary.\n\n## Pseudocode\n```python\n# Pseudocode\n\n# Define wordBreak function\nfunction wordBreak(s, wordDict):\n    # Define backtrack function\n    function backtrack(start, path):\n        # When the start index reaches the end of the string\n        if start == length of s:\n            # Join path to form a sentence and add to results\n            add ' '.join(path) to result\n            return\n        \n        # Iterate over potential end indices\n        for end from start + 1 to length of s + 1:\n            # Check if the substring is in the dictionary\n            if substring s[start:end] is in wordDict:\n                # Recursively explore further with new end index and updated path\n                backtrack(end, path + [s[start:end]])\n    \n    # Initialize result list\n    result = []\n    # Start backtracking from index 0 with empty path\n    backtrack(0, [])\n    # Return the list of results\n    return result\n```\n\nThis pseudocode outlines the necessary steps and structure to implement the solution for the given problem. The backtracking approach ensures that all possible valid segmentations are explored, and valid sentences are collected and returned.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-word-break-ii"
    },
    {
        "name": "Linked List Cycle",
        "site": "LeetCode",
        "href": "/solution/LeetCode-linked-list-cycle",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (head == NULL || head->next == NULL) {\n            return false;\n        }\n\n        ListNode *slow = head;\n        ListNode *fast = head->next;\n\n        while (slow != fast) {\n            if (fast == NULL || fast->next == NULL) {\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x; \n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head.next;\n        \n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        return true;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n \nbool hasCycle(struct ListNode *head) {\n    if (head == NULL || head->next == NULL) {\n        return false;\n    }\n    \n    struct ListNode *slow = head;\n    struct ListNode *fast = head->next;\n    \n    while (slow != fast) {\n        if (fast == NULL || fast->next == NULL) {\n            return false;\n        }\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return true;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool HasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head.next;\n        \n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        return true;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\nvar hasCycle = function(head) {\n    if (!head || !head.next) {\n        return false;\n    }\n    \n    let slow = head;\n    let fast = head.next;\n    \n    while (slow !== fast) {\n        if (!fast || !fast.next) {\n            return false;\n        }\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    return true;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction hasCycle(head: ListNode | null): boolean {\n    if (head === null) {\n        return false;\n    }\n    \n    let slow = head;\n    let fast = head;\n    \n    while (fast !== null && fast.next !== null) {\n        slow = slow!.next;\n        fast = fast.next.next;\n        \n        if (slow === fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.next = nil\n *     }\n * }\n */\n\nclass Solution {\n    func hasCycle(_ head: ListNode?) -> Bool {\n        var slow = head\n        var fast = head\n        \n        while fast != nil && fast?.next != nil {\n            slow = slow?.next\n            fast = fast?.next?.next\n            \n            if slow === fast {\n                return true\n            }\n        }\n        \n        return false\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc hasCycle(head *ListNode) bool {\n    if head == nil {\n        return false\n    }\n    \n    slow, fast := head, head\n    \n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        \n        if slow == fast {\n            return true\n        }\n    }\n    \n    return false\n}\n\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n * }\n */\nobject Solution {\n  def hasCycle(head: ListNode): Boolean = {\n    var slow = head\n    var fast = head\n    while (fast != null && fast.next != null) {\n      slow = slow.next\n      fast = fast.next.next\n      if (slow == fast) {\n        return true\n      }\n    }\n    false\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given linked list has a cycle in it. This can be achieved by using Floyd's Cycle-Finding Algorithm, also known as the \"Tortoise and Hare\" algorithm, which operates in O(1) space complexity.\n\n## Explanation\n\n1. The algorithm initializes two pointers, `slow` and `fast`. The `slow` pointer moves one step at a time while the `fast` pointer moves two steps at a time.\n2. If there is no cycle in the linked list, the `fast` pointer will eventually reach the end (i.e., `fast` or `fast.next` will be `null`).\n3. If there is a cycle, the `slow` and `fast` pointers will eventually meet at some node within the cycle, because the `fast` pointer would effectively \"lap\" the `slow` pointer.\n\n## Pseudocode\n\n```\n# Pseudocode for detecting a cycle in a linked list\n\nfunction hasCycle(head):\n    if head is null or head.next is null:\n        return false\n\n    initialize slow = head\n    initialize fast = head.next\n\n    while slow is not equal to fast:\n        if fast is null or fast.next is null:\n            return false\n        \n        move slow one step forward: slow = slow.next\n        move fast two steps forward: fast = fast.next.next\n\n    return true\n```\n\n### Steps:\n1. **Initialization:** Check if the head is null or if the list has only one node (i.e., `head.next` is null). Return `false` in either case as a single node cannot form a cycle.\n2. **Two Pointer Technique:** Use two pointers, `slow` starting at the head and `fast` starting at `head.next`.\n3. **Cycle Detection:** Move the `slow` pointer one step at a time and the `fast` pointer two steps at a time.\n   - If at any point `fast` or `fast.next` becomes null, return `false` (no cycle).\n   - If `slow` and `fast` meet, return `true` (cycle detected).\n\nThis method ensures that we can detect a cycle in a linked list in O(n) time complexity while using O(1) space.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-linked-list-cycle"
    },
    {
        "name": "Linked List Cycle Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-linked-list-cycle-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == NULL || head->next == NULL) {\n            return NULL;\n        }\n\n        ListNode *slow = head;\n        ListNode *fast = head;\n        bool hasCycle = false;\n\n        while (fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                hasCycle = true;\n                break;\n            }\n        }\n\n        if (!hasCycle) {\n            return NULL;\n        }\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n\n        return slow;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        boolean hasCycle = false;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                hasCycle = true;\n                break;\n            }\n        }\n        \n        if (!hasCycle) {\n            return null;\n        }\n        \n        slow = head;\n        \n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        return slow;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *detectCycle(struct ListNode *head) {\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n\n        if (slow == fast) {\n            struct ListNode *ptr = head;\n            while (ptr != slow) {\n                ptr = ptr->next;\n                slow = slow->next;\n            }\n            return ptr;\n        }\n    }\n\n    return NULL;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode DetectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if (slow == fast) {\n                ListNode slow2 = head;\n                while (slow2 != slow) {\n                    slow = slow.next;\n                    slow2 = slow2.next;\n                }\n                return slow;\n            }\n        }\n\n        return null;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\nvar detectCycle = function(head) {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow === fast) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n\n    return null;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next!;\n        fast = fast.next.next!;\n\n        if (slow === fast) {\n            let slow2 = head;\n            while (slow2 !== slow) {\n                slow2 = slow2!.next;\n                slow = slow!.next;\n            }\n            return slow2;\n        }\n    }\n\n    return null;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) {\n *         $this->val = $val;\n *         $this->next = null;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function detectCycle($head) {\n        $slow = $head;\n        $fast = $head;\n\n        while ($fast != null && $fast->next != null) {\n            $slow = $slow->next;\n            $fast = $fast->next->next;\n\n            if ($slow === $fast) {\n                $slow = $head;\n                while ($slow !== $fast) {\n                    $slow = $slow->next;\n                    $fast = $fast->next;\n                }\n                return $slow;\n            }\n        }\n\n        return null;\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    hasCycle := false\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            hasCycle = true\n            break\n        }\n    }\n    if !hasCycle {\n        return nil\n    }\n    slow = head\n    for slow != fast {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    return slow\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n  def detectCycle(head: ListNode): ListNode = {\n    var slow = head\n    var fast = head\n    var hasCycle = false\n    \n    while(fast != null && fast.next != null) {\n      slow = slow.next\n      fast = fast.next.next\n      \n      if(slow == fast) {\n        hasCycle = true\n        var ptr = head\n        while(ptr != slow) {\n          ptr = ptr.next\n          slow = slow.next\n        }\n        return ptr\n      }\n    }\n    \n    null\n  }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to detect the presence of a cycle in a linked list and return the node where the cycle begins if there is one. If there is no cycle, we return null. \n\n# Explanation\n1. **Use Two Pointers (Floyd's Tortoise and Hare Algorithm):**\n   - Use two pointers, `slow` and `fast`.\n   - `slow` moves one step at a time, while `fast` moves two steps at a time.\n   - If there is a cycle, `slow` and `fast` will eventually meet.\n\n2. **Find the Start of the Cycle:**\n   - When `slow` and `fast` meet, reset one pointer to the head of the list.\n   - Move both pointers one step at a time.\n   - The point at which they meet again is the start of the cycle.\n\n3. **Edge Cases:**\n   - If the list is empty (`head` is null).\n   - If there is no cycle in the list.\n\n# Pseudocode\n```pseudocode\nfunction detectCycle(head):\n    if head is null:\n        return null\n    \n    slow = head\n    fast = head\n    \n    while fast is not null and fast.next is not null:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            ptr = head\n            while ptr != slow:\n                ptr = ptr.next\n                slow = slow.next\n            return ptr\n    \n    return null\n```\n\nThis approach effectively detects and finds the starting point of a cycle in a linked list using constant space and is efficient in terms of both time and space complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-linked-list-cycle-ii"
    },
    {
        "name": "Reorder List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reorder-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if (!head || !head->next || !head->next->next) return;\n        \n        // Find the middle of the linked list\n        ListNode *slow = head, *fast = head;\n        while (fast->next && fast->next->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        // Reverse the second half of the list\n        ListNode *prev = nullptr, *curr = slow->next, *tmp;\n        slow->next = nullptr;\n        while (curr) {\n            tmp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = tmp;\n        }\n        \n        // Merge the two halves\n        ListNode *l1 = head, *l2 = prev;\n        while (l1 && l2) {\n            ListNode *l1_next = l1->next, *l2_next = l2->next;\n            l1->next = l2;\n            l2->next = l1_next;\n            l1 = l1_next;\n            l2 = l2_next;\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null || head.next.next == null) {\n            return;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode prev = null;\n        ListNode curr = slow.next;\n        slow.next = null;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n\n        ListNode p1 = head;\n        ListNode p2 = prev;\n        while (p2 != null) {\n            ListNode p1Next = p1.next;\n            ListNode p2Next = p2.next;\n            p1.next = p2;\n            p2.next = p1Next;\n            p1 = p1Next;\n            p2 = p2Next;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def reorderList(self, head):\n        if not head or not head.next:\n            return\n        \n        # Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # Merge the two halves\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nvoid reorderList(struct ListNode* head){\n    if(head == NULL || head->next == NULL || head->next->next == NULL) {\n        return;\n    }\n\n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n\n    // Find the middle of the linked list\n    while(fast->next != NULL && fast->next->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    struct ListNode* prev = NULL;\n    struct ListNode* curr = slow->next;\n    slow->next = NULL;\n\n    // Reverse the second half of the linked list\n    while(curr != NULL) {\n        struct ListNode* temp = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = temp;\n    }\n\n    struct ListNode* first = head;\n    struct ListNode* second = prev;\n\n    // Merge the two halves of the linked list\n    while(second != NULL) {\n        struct ListNode* temp1 = first->next;\n        struct ListNode* temp2 = second->next;\n\n        first->next = second;\n        second->next = temp1;\n\n        first = temp1;\n        second = temp2;\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val = 0, ListNode next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public void ReorderList(ListNode head) {\n        if (head == null || head.next == null) {\n            return;\n        }\n        \n        ListNode middle = FindMiddle(head);\n        ListNode reversedHalf = ReverseList(middle.next);\n        middle.next = null;\n        \n        MergeLists(head, reversedHalf);\n    }\n    \n    private ListNode FindMiddle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        return slow;\n    }\n    \n    private ListNode ReverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n        \n        while (current != null) {\n            ListNode nextTemp = current.next;\n            current.next = prev;\n            prev = current;\n            current = nextTemp;\n        }\n        \n        return prev;\n    }\n    \n    private void MergeLists(ListNode l1, ListNode l2) {\n        while (l1 != null && l2 != null) {\n            ListNode l1Next = l1.next;\n            ListNode l2Next = l2.next;\n            \n            l1.next = l2;\n            l2.next = l1Next;\n            \n            l1 = l1Next;\n            l2 = l2Next;\n        }\n    }\n}\n\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val === undefined ? 0 : val)\n *         this.next = (next === undefined ? null : next)\n *     }\n */\n\nfunction reorderList(head: ListNode | null): void {\n    if (!head || !head.next) {\n        return;\n    }\n    \n    let slow: ListNode | null = head;\n    let fast: ListNode | null = head;\n    \n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    let prev: ListNode | null = null;\n    let curr: ListNode | null = slow;\n    \n    while (curr) {\n        const nextTemp = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nextTemp;\n    }\n    \n    let firstPtr: ListNode | null = head;\n    let secondPtr: ListNode | null = prev;\n    \n    while (secondPtr.next) {\n        const firstPtrNext = firstPtr.next;\n        const secondPtrNext = secondPtr.next;\n        \n        firstPtr.next = secondPtr;\n        secondPtr.next = firstPtrNext;\n        \n        firstPtr = firstPtrNext;\n        secondPtr = secondPtrNext;\n    }\n};\n \n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return NULL\n     */\n    function reorderList($head) {\n        if ($head == null || $head->next == null) {\n            return;\n        }\n        \n        // Find the middle of the linked list\n        $slow = $head;\n        $fast = $head;\n        while ($fast != null && $fast->next != null) {\n            $slow = $slow->next;\n            $fast = $fast->next->next;\n        }\n        \n        // Reverse the second half of the linked list\n        $prev = null;\n        $curr = $slow;\n        while ($curr != null) {\n            $nextTemp = $curr->next;\n            $curr->next = $prev;\n            $prev = $curr;\n            $curr = $nextTemp;\n        }\n        \n        // Merge the two halves by alternating nodes\n        $first = $head;\n        $second = $prev;\n        while ($second->next != null) {\n            $temp = $first->next;\n            $first->next = $second;\n            $first = $temp;\n            \n            $temp = $second->next;\n            $second->next = $first;\n            $second = $temp;\n        }\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\nfunc reorderList(head *ListNode)  {\n    if head == nil || head.Next == nil {\n        return\n    }\n    \n    // Find the middle of the linked list\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    \n    // Reverse the second half of the linked list\n    var prev *ListNode\n    curr := slow\n    for curr != nil {\n        temp := curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = temp\n    }\n    \n    // Merge the two halves\n    p1, p2 := head, prev\n    for p2.Next != nil {\n        temp1, temp2 := p1.Next, p2.Next\n        p1.Next = p2\n        p2.Next = temp1\n        p1 = temp1\n        p2 = temp2\n    }\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n */\nobject Solution {\n    def reorderList(head: ListNode): Unit = {\n        def reverseList(node: ListNode): ListNode = {\n            var prev: ListNode = null\n            var current = node\n            while (current != null) {\n                val nextTemp = current.next\n                current.next = prev\n                prev = current\n                current = nextTemp\n            }\n            prev\n        }\n\n        def mergeLists(l1: ListNode, l2: ListNode): Unit = {\n            var temp1 = l1\n            var temp2 = l2\n            while (temp1 != null && temp2 != null) {\n                val next1 = temp1.next\n                val next2 = temp2.next\n\n                temp1.next = temp2\n                if (next1 != null) {\n                    temp2.next = next1\n                }\n\n                temp1 = next1\n                temp2 = next2\n            }\n        }\n\n        var slow = head\n        var fast = head\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next\n            fast = fast.next.next\n        }\n\n        var l1 = head\n        var l2 = slow.next\n        slow.next = null\n        l2 = reverseList(l2)\n\n        mergeLists(l1, l2)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will need to reorder a singly linked list in the specified format. Below is the methodology and pseudocode to address this problem.\n\n# Explanation\n1. **Find the Middle of the List**: Use the slow and fast pointer technique to locate the middle of the linked list. The `slow` pointer moves one step at a time while the `fast` pointer moves two steps at a time.\n2. **Reverse the Second Half of the List**: After finding the middle, reverse the second half of the list starting from the middle to the end.\n3. **Merge the Two Halves**: Finally, merge the two halves by alternately picking nodes from each half.\n\n# Pseudocode\n```\n1. If head is null or has only one node, return head as there is no reordering needed.\n2. Initialize two pointers, slow and fast, both pointing to head.\n3. Traverse the list with these pointers to find the middle:\n    a. Move slow one step each time.\n    b. Move fast two steps each time.\n    c. When fast reaches the end, slow will be at the middle.\n4. Reverse the second half of the list starting from the middle:\n    a. Initialize prev as None and curr as slow.\n    b. Iterate through the list:\n        i. Store next node of curr in next_node.\n        ii. Point curr.next to prev.\n        iii. Move prev to curr.\n        iv. Move curr to next_node.\n5. Merge the two halves:\n    a. Initialize first pointing to head and second pointing to prev (start of the reversed half).\n    b. Iterate while second.next is not null:\n        i. Store first.next in a temporary variable.\n        ii. Point first.next to second.\n        iii. Move first to the stored temporary variable.\n        iv. Store second.next in another temporary variable.\n        v. Point second.next to first.\n        vi. Move second to the stored temporary variable.\n```\n\nThis methodology ensures that the list is reordered in the required format with only node references being modified rather than the values themselves.\n\nUnderstanding and following these steps should guide you through the process of solving the coding challenge effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reorder-list"
    },
    {
        "name": "Binary Tree Preorder Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-preorder-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> s;\n        if (root != nullptr) {\n            s.push(root);\n        }\n\n        while (!s.empty()) {\n            TreeNode* current = s.top();\n            s.pop();\n            result.push_back(current->val);\n            if (current->right != nullptr) {\n                s.push(current->right);\n            }\n            if (current->left != nullptr) {\n                s.push(current->left);\n            }\n        }\n\n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        \n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        \n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            result.add(node.val);\n            \n            if (node.right != null) {\n                stack.push(node.right);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nvoid preorderHelper(struct TreeNode* node, int* result, int* returnSize){\n    if(node == NULL) return;\n    \n    result[(*returnSize)++] = node->val;\n    \n    preorderHelper(node->left, result, returnSize);\n    preorderHelper(node->right, result, returnSize);\n}\n\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\n    *returnSize = 0;\n    int* result = (int*)malloc(100 * sizeof(int));\n    \n    preorderHelper(root, result, returnSize);\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<int> PreorderTraversal(TreeNode root) {\n        IList<int> result = new List<int>();\n        if (root == null) return result;\n        \n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.Push(root);\n        \n        while (stack.Count > 0) {\n            TreeNode node = stack.Pop();\n            result.Add(node.val);\n            \n            if (node.right != null) {\n                stack.Push(node.right);\n            }\n            if (node.left != null) {\n                stack.Push(node.left);\n            }\n        }\n        \n        return result;\n    }\n}\n\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\nvar preorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n    let node = root;\n    \n    while (node || stack.length > 0) {\n        while (node) {\n            result.push(node.val);\n            stack.push(node);\n            node = node.left;\n        }\n        node = stack.pop();\n        node = node.right;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number;\n *     left: TreeNode | null;\n *     right: TreeNode | null;\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val);\n *         this.left = (left === undefined ? null : left);\n *         this.right = (right === undefined ? null : right);\n *     }\n * }\n */\n  \nfunction preorderTraversal(root: TreeNode | null): number[] {\n    const result: number[] = [];\n    const stack: TreeNode[] = [];\n    \n    let current: TreeNode | null = root;\n    \n    while (current || stack.length > 0) {\n        while (current) {\n            result.push(current.val);\n            stack.push(current);\n            current = current.left;\n        }\n        \n        const node = stack.pop()!;\n        current = node.right;\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\n        var result = [Int]()\n        var stack = [TreeNode]()\n        var node = root\n        \n        while !stack.isEmpty || node != nil {\n            while node != nil {\n                result.append(node!.val)\n                stack.append(node!)\n                node = node!.left\n            }\n            node = stack.removeLast().right\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc preorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n    \n    stack := []*TreeNode{}\n    result := []int{}\n    \n    for len(stack) > 0 || root != nil {\n        for root != nil {\n            result = append(result, root.Val)\n            stack = append(stack, root)\n            root = root.Left\n        }\n        \n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        root = node.Right\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef preorder_traversal(root)\n    result = []\n    return result if root.nil?\n    \n    stack = [root]\n    \n    while !stack.empty?\n        node = stack.pop\n        result << node.val\n        stack.push(node.right) if node.right\n        stack.push(node.left) if node.left\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n */\n\nobject Solution {\n    def preorderTraversal(root: TreeNode): List[Int] = {\n        if (root == null) return List()\n        \n        var result = List[Int]()\n        var stack = List[TreeNode](root)\n        \n        while (stack.nonEmpty) {\n            val node = stack.head\n            stack = stack.tail\n            result = node.value +: result\n            \n            if (node.right != null) stack = node.right +: stack\n            if (node.left != null) stack = node.left +: stack\n        }\n        \n        result.reverse\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | null,\n%%                     right = null :: 'null' | null}).\n\npreorder_traversal(null) -> [];\npreorder_traversal({tree_node, Val, Left, Right}) ->\n    [Val] ++ preorder_traversal(Left) ++ preorder_traversal(Right).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a method to perform a preorder traversal of a binary tree. Preorder traversal involves visiting nodes in the order: Root, Left, Right. We shall implement this both recursively and iteratively. However, the problem specifically asks for an iterative solution.\n\n# Explanation:\n1. We start by defining a `TreeNode` class to represent each node in the binary tree. Each node has a value (`val`), a left child (`left`), and a right child (`right`).\n2. The key idea for the iterative solution is to use a stack to keep track of nodes. We push the root node onto the stack and then follow the preorder pattern.\n3. While the stack is not empty, we pop a node from the stack, process its value, and then push its right and left children onto the stack (if they exist). The right child is pushed before the left child to ensure that the left child is processed first (since stacks are LIFO - Last In, First Out).\n4. Finally, we return the result list containing the values of nodes in preorder traversal.\n\n# Pseudocode:\n```\n# Definition of the TreeNode class\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Function for iterative preorder traversal\ndef preorderTraversal(root):\n    # Initialize the result list\n    result = []\n    \n    # If the tree is empty, return an empty list\n    if root is None:\n        return result\n\n    # Initialize the stack with the root node\n    stack = [root]\n    \n    # Loop until the stack is empty\n    while stack:\n        # Pop a node from the stack\n        node = stack.pop()\n        \n        # Process the node's value by adding it to the result list\n        result.append(node.val)\n        \n        # If the right child exists, push it onto the stack\n        if node.right:\n            stack.push(node.right)\n        \n        # If the left child exists, push it onto the stack\n        if node.left:\n            stack.push(node.left)\n    \n    # Return the result list containing the values in preorder\n    return result\n```\n\nIn this pseudocode:\n- The `TreeNode` class is defined with an initializer to set the node values and references to left and right children.\n- The `preorderTraversal` function performs the traversal using a stack, ensuring the right and left children are correctly processed to maintain the preorder sequence.\n  \nThis pseudocode can be implemented in any programming language that supports object-oriented concepts and stack operations.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-preorder-traversal"
    },
    {
        "name": "Binary Tree Postorder Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-postorder-traversal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if(root == NULL)\n            return result;\n        \n        stack<TreeNode*> st;\n        st.push(root);\n        while(!st.empty()) {\n            TreeNode* curr = st.top();\n            st.pop();\n            result.insert(result.begin(), curr->val);\n            if(curr->left)\n                st.push(curr->left);\n            if(curr->right)\n                st.push(curr->right);\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        \n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        \n        while (!stack.isEmpty()) {\n            TreeNode current = stack.pop();\n            result.add(0, current.val);\n            \n            if (current.left != null) {\n                stack.push(current.left);\n            }\n            if (current.right != null) {\n                stack.push(current.right);\n            }\n        }\n        \n        return result;\n    }\n}\n\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* postorderTraversal(struct TreeNode* root, int* returnSize){\n    if(root == NULL){\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    int* result = (int*)malloc(100 * sizeof(int));\n    int index = 0;\n    \n    struct TreeNode* stack[100];\n    int top = 0;\n    struct TreeNode* prev = NULL;\n    \n    while(root != NULL || top > 0){\n        while(root != NULL){\n            stack[top++] = root;\n            root = root->left;\n        }\n        \n        struct TreeNode* temp = stack[top - 1];\n        \n        if(temp->right == NULL || temp->right == prev){\n            result[index++] = temp->val;\n            top--;\n            prev = temp;\n        }else{\n            root = temp->right;\n        }\n    }\n    \n    *returnSize = index;\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> PostorderTraversal(TreeNode root) {\n        IList<int> result = new List<int>();\n        if (root == null) {\n            return result;\n        }\n\n        Stack<TreeNode> stack1 = new Stack<TreeNode>();\n        Stack<TreeNode> stack2 = new Stack<TreeNode>();\n        stack1.Push(root);\n\n        while (stack1.Count > 0) {\n            TreeNode node = stack1.Pop();\n            stack2.Push(node);\n\n            if (node.left != null) {\n                stack1.Push(node.left);\n            }\n\n            if (node.right != null) {\n                stack1.Push(node.right);\n            }\n        }\n\n        while (stack2.Count > 0) {\n            result.Add(stack2.Pop().val);\n        }\n\n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\n\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    const res = [];\n    const stack = [];\n    let curr = root;\n    let prev = null;\n    \n    while (curr || stack.length > 0) {\n        if (curr) {\n            stack.push(curr);\n            curr = curr.left;\n        } else {\n            let peekNode = stack[stack.length - 1];\n            if (peekNode.right && peekNode.right !== prev) {\n                curr = peekNode.right;\n            } else {\n                res.push(peekNode.val);\n                prev = stack.pop();\n            }\n        }\n    }\n    \n    return res;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction postorderTraversal(root: TreeNode | null): number[] {\n    const result: number[] = [];\n    const stack: TreeNode[] = [];\n    let current = root;\n    let lastVisited = null;\n    \n    while (current || stack.length > 0) {\n        if (current) {\n            stack.push(current);\n            current = current.left;\n        } else {\n            const peek = stack[stack.length - 1];\n            if (peek.right && peek.right !== lastVisited) {\n                current = peek.right;\n            } else {\n                result.push(peek.val);\n                lastVisited = stack.pop();\n            }\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function postorderTraversal($root) {\n        $result = [];\n        $stack = new SplStack();\n        $prev = null;\n\n        while (!empty($stack) || $root != null) {\n            while ($root != null) {\n                $stack[] = $root;\n                $root = $root->left;\n            }\n            $root = $stack->isEmpty() ? null : $stack->top(); // Check if the stack is empty before accessing top\n            if ($root == null) {\n                break; // Handle null case\n            }\n            if ($root->right == null || $root->right == $prev) {\n                $result[] = $root->val;\n                $prev = $root;\n                $stack->pop();\n                $root = null;\n            } else {\n                $root = $root->right;\n            }\n        }\n\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\n        var result = [Int]()\n        var stack = [TreeNode]()\n        var currentNode = root\n        var lastVisited: TreeNode? = nil\n        \n        while currentNode != nil || !stack.isEmpty {\n            if currentNode != nil {\n                stack.append(currentNode!)\n                currentNode = currentNode!.left\n            } else {\n                let peekNode = stack[stack.count - 1]\n                if peekNode.right != nil && lastVisited !== peekNode.right {\n                    currentNode = peekNode.right\n                } else {\n                    result.append(peekNode.val)\n                    lastVisited = stack.removeLast()\n                }\n            }\n        }\n        \n        return result\n    }\n}\n\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \n func postorderTraversal(root *TreeNode) []int {\n    var result []int\n    if root == nil {\n        return result\n    }\n    \n    stack := []*TreeNode{root}\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        \n        result = append([]int{node.Val}, result...)\n        \n        if node.Left != nil {\n            stack = append(stack, node.Left)\n        }\n        \n        if node.Right != nil {\n            stack = append(stack, node.Right)\n        }\n    }\n    \n    return result\n }\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#     end\n# end\n\ndef postorder_traversal(root)\n    result = []\n    stack = []\n    return result if root.nil?\n    \n    stack << root\n    while !stack.empty?\n        node = stack.pop\n        result.unshift(node.val)\n        stack << node.left if node.left\n        stack << node.right if node.right\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode \n= null, _right: TreeNode = null) {\n *   def value: Int = _value\n *   def left: TreeNode = _left\n *   def right: TreeNode = _right\n * }\n */\n\nobject Solution {\n  def postorderTraversal(root: TreeNode): List[Int] = {\n    def doPostorder(node: TreeNode, acc: List[Int]): List[Int] = {\n      if (node == null) {\n        acc\n      } else {\n        doPostorder(node.left, doPostorder(node.right, node.value :: acc))\n      }\n    }\n    doPostorder(root, List())\n  }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn postorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut stack = Vec::new();\n        \n        if let Some(node) = root {\n            stack.push(node);\n        }\n        \n        while let Some(curr) = stack.pop() {\n            let curr_borrow = curr.borrow();\n            result.push(curr_borrow.val);\n            \n            if let Some(left) = &curr_borrow.left {\n                stack.push(left.clone());\n            }\n\n            if let Some(right) = &curr_borrow.right {\n                stack.push(right.clone());\n            }\n        }\n        \n        result.reverse();\n        result\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | \npostorder_traversal(null) -> [];\npostorder_traversal({tree_node, Val, Left, Right}) ->\n    postorder_traversal(Left) ++ postorder_traversal(Right) ++ [Val].\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform a postorder traversal on a binary tree iteratively. Postorder traversal visits nodes in the following order: left subtree, right subtree, and then the root node.\n\n# Explanation\nThe main idea behind solving this iteratively is to use a stack to traverse the tree. We use another pointer `prev` to keep track of the previously visited node to help determine whether we have finished visiting the right subtree of the current node.\n\nHere's the step-by-step approach:\n\n1. **Initialization**: Initialize an empty list `res` to store the result, an empty stack `stack` to assist with traversal, a pointer `curr` initially pointing to the root, and a pointer `prev` initially set to `None`.\n\n2. **Traversal Loop**: Loop until either there are nodes on the stack or `curr` is not `None`.\n   - If `curr` is not `None`, push it onto the stack and move to its left child.\n   - If `curr` is `None`, peek at the top node of the stack.\n     - If the peeked node has a right child that has not been visited yet, move to the right child.\n     - Otherwise, visit the peeked node (add its value to `res`), pop it from the stack, and set `prev` to this node.\n\n3. **Return Result**: After the loop ends, `res` will contain the postorder traversal of the tree.\n\n# Pseudocode\n\n```pseudo\nfunction postorderTraversal(root):\n    # Initialize the result list, stack, current pointer, and previous pointer\n    res = []\n    stack = []\n    curr = root\n    prev = None\n\n    # Traverse the tree\n    while curr or stack is not empty:\n        if curr:\n            stack.push(curr)\n            curr = curr.left\n        else:\n            peekNode = stack.peek()\n            if peekNode.right and peekNode.right != prev:\n                curr = peekNode.right\n            else:\n                res.append(peekNode.val)\n                prev = stack.pop()\n\n    return res\n```\n\nThis pseudocode outlines how to implement an iterative postorder traversal for a binary tree using a stack and a previous node pointer to facilitate traversal and node visitation.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-postorder-traversal"
    },
    {
        "name": "Evaluate Reverse Polish Notation",
        "site": "LeetCode",
        "href": "/solution/LeetCode-evaluate-reverse-polish-notation",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> st;\n        for(string token : tokens){\n            if(token == \"+\"){\n                int num1 = st.top();\n                st.pop();\n                int num2 = st.top();\n                st.pop();\n                st.push(num1 + num2);\n            } else if(token == \"-\"){\n                int num1 = st.top();\n                st.pop();\n                int num2 = st.top();\n                st.pop();\n                st.push(num2 - num1);\n            } else if(token == \"*\"){\n                int num1 = st.top();\n                st.pop();\n                int num2 = st.top();\n                st.pop();\n                st.push(num1 * num2);\n            } else if(token == \"/\"){\n                int num1 = st.top();\n                st.pop();\n                int num2 = st.top();\n                st.pop();\n                st.push(num2 / num1);\n            } else {\n                st.push(stoi(token));\n            }\n        }\n        return st.top();\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.Stack;\n\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            if (token.equals(\"+\")) {\n                stack.push(stack.pop() + stack.pop());\n            } else if (token.equals(\"-\")) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a - b);\n            } else if (token.equals(\"*\")) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (token.equals(\"/\")) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a / b);\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n        }\n        return stack.pop();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token not in ['+', '-', '*', '/']:\n                stack.append(int(token))\n            else:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == '+':\n                    stack.append(num1 + num2)\n                elif token == '-':\n                    stack.append(num1 - num2)\n                elif token == '*':\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(float(num1) / num2))\n        return stack[0]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "typedef struct {\n    int top;\n    int capacity;\n    int* array;\n} Stack;\n\nStack* createStack(int capacity) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->array = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == -1;\n}\n\nvoid push(Stack* stack, int item) {\n    stack->array[++stack->top] = item;\n}\n\nint pop(Stack* stack) {\n    return stack->array[stack->top--];\n}\n\nint evalRPN(char** tokens, int tokensSize) {\n    Stack* stack = createStack(tokensSize);\n    for (int i = 0; i < tokensSize; i++) {\n        if (strcmp(tokens[i], \"+\") == 0) {\n            int a = pop(stack);\n            int b = pop(stack);\n            push(stack, b + a);\n        } else if (strcmp(tokens[i], \"-\") == 0) {\n            int a = pop(stack);\n            int b = pop(stack);\n            push(stack, b - a);\n        } else if (strcmp(tokens[i], \"*\") == 0) {\n            int a = pop(stack);\n            int b = pop(stack);\n            push(stack, b * a);\n        } else if (strcmp(tokens[i], \"/\") == 0) {\n            int a = pop(stack);\n            int b = pop(stack);\n            push(stack, b / a);\n        } else {\n            push(stack, atoi(tokens[i]));\n        }\n    }\n    int result = pop(stack);\n    free(stack->array);\n    free(stack);\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int EvalRPN(string[] tokens) {\n        Stack<int> stack = new Stack<int>();\n\n        foreach (string token in tokens) {\n            if (token == \"+\") {\n                int num2 = stack.Pop();\n                int num1 = stack.Pop();\n                stack.Push(num1 + num2);\n            } else if (token == \"-\") {\n                int num2 = stack.Pop();\n                int num1 = stack.Pop();\n                stack.Push(num1 - num2);\n            } else if (token == \"*\") {\n                int num2 = stack.Pop();\n                int num1 = stack.Pop();\n                stack.Push(num1 * num2);\n            } else if (token == \"/\") {\n                int num2 = stack.Pop();\n                int num1 = stack.Pop();\n                stack.Push(num1 / num2);\n            } else {\n                stack.Push(int.Parse(token));\n            }\n        }\n\n        return stack.Pop();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string[]} tokens\n * @return {number}\n */\nconst evalRPN = function(tokens) {\n    const stack = [];\n    for (let token of tokens) {\n        if (!isNaN(parseInt(token))) {\n            stack.push(parseInt(token));\n        } else {\n            const num2 = stack.pop();\n            const num1 = stack.pop();\n            if (token === '+') {\n                stack.push(num1 + num2);\n            } else if (token === '-') {\n                stack.push(num1 - num2);\n            } else if (token === '*') {\n                stack.push(num1 * num2);\n            } else if (token === '/') {\n                stack.push(parseInt(num1 / num2));\n            }\n        }\n    }\n    return stack.pop();\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function evalRPN(tokens: string[]): number {\n    const stack: number[] = [];\n    const operators = new Set(['+', '-', '*', '/']);\n    \n    for (const token of tokens) {\n        if (operators.has(token)) {\n            const num2 = stack.pop()!;\n            const num1 = stack.pop()!;\n            if (token === '+') stack.push(num1 + num2);\n            if (token === '-') stack.push(num1 - num2);\n            if (token === '*') stack.push(num1 * num2);\n            if (token === '/') stack.push(Math.trunc(num1 / num2));\n        } else {\n            stack.push(+token);\n        }\n    }\n    \n    return stack[0];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[] $tokens\n     */\n    function evalRPN($tokens) {\n        $stack = [];\n        $operators = ['+', '-', '*', '/'];\n        \n        foreach ($tokens as $token) {\n            if (in_array($token, $operators)) {\n                $operand2 = array_pop($stack);\n                $operand1 = array_pop($stack);\n                \n                if ($token == '+') {\n                    array_push($stack, $operand1 + $operand2);\n                } elseif ($token == '-') {\n                    array_push($stack, $operand1 - $operand2);\n                } elseif ($token == '*') {\n                    array_push($stack, $operand1 * $operand2);\n                } elseif ($token == '/') {\n                    array_push($stack, intval($operand1 / $operand2));\n                }\n            } else {\n                array_push($stack, intval($token));\n            }\n        }\n        \n        return $stack[0];\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to evaluate an arithmetic expression represented in Reverse Polish Notation (RPN). RPN is a mathematical notation where every operator follows all of its operands, making it easier to handle expressions without the need for parentheses.\n\n# Explanation\n\nIn RPN, if you encounter a number, you push it onto a stack. If you encounter an operator, you pop the necessary number of operands off the stack, perform the operation, and then push the result back onto the stack. The final result of the expression will be the last remaining element on the stack.\n\nConsider the following steps:\n1. Initialize an empty stack.\n2. Iterate through each token:\n   - If it's a number, push it onto the stack.\n   - If it's an operator, pop the required number of operands from the stack, perform the operation, and push the result back onto the stack.\n3. After processing all tokens, the resulting value on the stack is the result of the expression.\n\n# Pseudocode\n\nBelow is the detailed pseudocode for evaluating RPN:\n\n1. Initialize an empty stack `stack = []`.\n2. Loop through each token in the input `tokens`:\n   - If the token is a number:\n     - Convert it to an integer and push it onto the stack.\n   - If the token is an operator (`+`, `-`, `*`, `/`):\n     - Pop the top element from the stack (second operand) `num2 = stack.pop()`.\n     - Pop the next top element from the stack (first operand) `num1 = stack.pop()`.\n     - Perform the appropriate operation based on the token:\n       - `+`: Push `num1 + num2` onto the stack.\n       - `-`: Push `num1 - num2` onto the stack.\n       - `*`: Push `num1 * num2` onto the stack.\n       - `/`: Perform integer division with truncation toward zero: `push int(float(num1) / num2)`.\n3. The result of the expression will be the last remaining element in the stack. Return `stack[0]`.\n\nHere is the pseudocode:\n\n```\n# Pseudocode\n\nfunction evalRPN(tokens):\n    stack = []\n    \n    for each token in tokens:\n        if token is a number:\n            stack.append(to_integer(token))\n        else:\n            num2 = stack.pop()\n            num1 = stack.pop()\n            \n            if token == '+':\n                stack.append(num1 + num2)\n            elif token == '-':\n                stack.append(num1 - num2)\n            elif token == '*':\n                stack.append(num1 * num2)\n            elif token == '/':\n                # Perform integer division with truncation towards zero\n                stack.append(int(float(num1) / num2))\n    \n    return stack[0]\n```\n\nThis pseudocode will process the tokens in RPN format, handle all the arithmetic operations, and produce the correct result by following the stack-based approach.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-evaluate-reverse-polish-notation"
    },
    {
        "name": "Insertion Sort List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-insertion-sort-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if (!head || !head->next) {\n            return head;\n        }\n        \n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* curr = head;\n        ListNode* prev = dummy;\n        \n        while (curr) {\n            if (curr->next && curr->next->val < curr->val) {\n                while (prev->next && prev->next->val < curr->next->val) {\n                    prev = prev->next;\n                }\n                ListNode* temp = prev->next;\n                prev->next = curr->next;\n                curr->next = curr->next->next;\n                prev->next->next = temp;\n                prev = dummy;\n            } else {\n                curr = curr->next;\n            }\n        }\n        \n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        ListNode curr = head;\n        \n        while (curr != null) {\n            ListNode prev = dummy;\n            ListNode nextNode = curr.next;\n            \n            while (prev.next != null && prev.next.val < curr.val) {\n                prev = prev.next;\n            }\n            curr.next = prev.next;\n            prev.next = curr;\n            curr = nextNode;\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* insertionSortList(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    \n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->val = 0;\n    dummy->next = head;\n    \n    struct ListNode* prev = head;\n    struct ListNode* current = head->next;\n    \n    while (current != NULL) {\n        if (prev->val > current->val) {\n            struct ListNode* temp = dummy;\n            while (temp->next->val < current->val) {\n                temp = temp->next;\n            }\n            prev->next = current->next;\n            current->next = temp->next;\n            temp->next = current;\n            current = prev->next;\n        } else {\n            prev = current;\n            current = current->next;\n        }\n    }\n    \n    return dummy->next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val = 0, ListNode next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode InsertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(-1);\n        ListNode curr = head;\n        \n        while (curr != null) {\n            ListNode prev = dummy;\n            ListNode nextNode = curr.next;\n            \n            while (prev.next != null && prev.next.val < curr.val) {\n                prev = prev.next;\n            }\n            \n            curr.next = prev.next;\n            prev.next = curr;\n            curr = nextNode;\n        }\n        \n        return dummy.next;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nvar insertionSortList = function(head) {\n    if (!head || !head.next) return head;\n    \n    let dummy = new ListNode(0);\n    dummy.next = head;\n    \n    let curr = head;\n    \n    while (curr && curr.next) {\n        if (curr.val <= curr.next.val) {\n            curr = curr.next;\n        } else {\n            let temp = curr.next;\n            let prev = dummy;\n            while (prev.next.val < temp.val) {\n                prev = prev.next;\n            }\n            curr.next = temp.next;\n            temp.next = prev.next;\n            prev.next = temp;\n        }\n    }\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction insertionSortList(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) return head;\n    \n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = head;\n    while (current && current.next) {\n        if (current.val <= current.next.val) {\n            current = current.next;\n        } else {\n            let innerCurrent = dummy;\n            while (innerCurrent.next.val < current.next.val) {\n                innerCurrent = innerCurrent.next;\n            }\n            let temp = current.next;\n            current.next = temp.next;\n            temp.next = innerCurrent.next;\n            innerCurrent.next = temp;\n        }\n    }\n    \n    return dummy.next;\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun insertionSortList(head: ListNode?): ListNode? {\n        if (head == null || head.next == null) {\n            return head\n        }\n        \n        var dummy = ListNode(0)\n        var prev = dummy\n        var curr = head\n        \n        while (curr != null) {\n            var next = curr.next\n            \n            if (prev.next != null && prev.next!!.`val` > curr.`val`) {\n                prev = dummy\n            }\n            \n            while (prev.next != null && prev.next!!.`val` < curr.`val`) {\n                prev = prev.next!!\n            }\n            \n            curr.next = prev.next\n            prev.next = curr\n            \n            curr = next\n        }\n        \n        return dummy.next\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc insertionSortList(head *ListNode) *ListNode {\n    dummy := &ListNode{Val: 0, Next: nil}\n    prev := dummy\n    curr := head\n\n    for curr != nil {\n        next := curr.Next\n        for prev.Next != nil && prev.Next.Val < curr.Val {\n            prev = prev.Next\n        }\n        curr.Next = prev.Next\n        prev.Next = curr\n        prev = dummy\n        curr = next\n    }\n\n    return dummy.Next\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var x: Int = _x\n *   var next: ListNode = _next\n * }\n */\n\nobject Solution {\n    def insertionSortList(head: ListNode): ListNode = {\n        if (head == null || head.next == null) return head\n        \n        val dummy = new ListNode()\n        var curr = head\n        var prev = dummy\n        var next: ListNode = null\n        \n        while (curr != null) {\n            next = curr.next\n            while (prev.next != null && prev.next.x < curr.x) {\n                prev = prev.next\n            }\n            curr.next = prev.next\n            prev.next = curr\n            prev = dummy\n            curr = next\n        }\n        \n        dummy.next\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement an insertion sort algorithm specifically for a singly linked list. The primary idea is to iterate over the list, remove each element from its current position, and then insert it correctly into the sorted portion of the list.\n\n# Explanation\nInsertion sort works similarly for linked lists as it does for arrays, but the implementation differs due to the nature of linked lists and the absence of direct index-based access. Here are the key steps:\n1. Initialize a dummy node to serve as the sorted portion of the list.\n2. Traverse the original list with a pointer.\n3. For each node in the original list, determine its correct position in the sorted portion by comparing its value with those of the nodes in the sorted list.\n4. Insert the node into the correct position.\n5. Continue the process until all nodes are transferred to the sorted list.\n\n# Pseudocode\nBelow is the pseudocode for this solution:\n\n```\n# Define the ListNode class (if not already defined)\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef insertion_sort_list(head):\n    if not head or not head.next:\n        return head\n\n    # Initialize a dummy node to help with insertion\n    dummy = ListNode(0)\n    dummy.next = head\n\n    # Current node we are working on\n    current = head\n\n    # Iterate through the linked list\n    while current and current.next:\n        if current.val <= current.next.val:\n            # If current node is less than or equal to the next, just move forward\n            current = current.next\n        else:\n            # If next node needs to be repositioned\n            to_insert = current.next\n            current.next = to_insert.next\n\n            # Find the location to insert the node in the sorted part\n            prev = dummy\n            while prev.next and prev.next.val < to_insert.val:\n                prev = prev.next\n            \n            # Insert the node\n            to_insert.next = prev.next\n            prev.next = to_insert\n\n    return dummy.next\n```\n\nThis pseudocode outlines the logical flow of how the insertion sort algorithm can be applied to sort a singly linked list. The use of a dummy node simplifies edge cases, such as inserting at the head of the sorted list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-insertion-sort-list"
    },
    {
        "name": "Sort List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sort-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        \n        ListNode *slow = head, *fast = head, *prev = nullptr;\n        \n        while (fast != nullptr && fast->next != nullptr) {\n            prev = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        prev->next = nullptr;\n        \n        ListNode *left = sortList(head);\n        ListNode *right = sortList(slow);\n        \n        return merge(left, right);\n    }\n    \n    ListNode* merge(ListNode* l1, ListNode* l2) {\n        ListNode dummy(0);\n        ListNode *tail = &dummy;\n        \n        while (l1 != nullptr && l2 != nullptr) {\n            if (l1->val < l2->val) {\n                tail->next = l1;\n                l1 = l1->next;\n            } else {\n                tail->next = l2;\n                l2 = l2->next;\n            }\n            tail = tail->next;\n        }\n        \n        if (l1 != nullptr) {\n            tail->next = l1;\n        }\n        \n        if (l2 != nullptr) {\n            tail->next = l2;\n        }\n        \n        return dummy.next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n \nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode prev = null;\n        \n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        prev.next = null;\n        \n        ListNode left = sortList(head);\n        ListNode right = sortList(slow);\n        \n        return merge(left, right);\n    }\n    \n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode current = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n        \n        current.next = l1 != null ? l1 : l2;\n        \n        return dummy.next;\n    }\n}\n\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n\nclass Solution(object):\n    def sortList(self, head):\n        if not head or not head.next:\n            return head\n        \n        def merge(l1, l2):\n            dummy = ListNode()\n            curr = dummy\n            while l1 and l2:\n                if l1.val < l2.val:\n                    curr.next = l1\n                    l1 = l1.next\n                else:\n                    curr.next = l2\n                    l2 = l2.next\n                curr = curr.next\n            curr.next = l1 or l2\n            return dummy.next\n        \n        def split(node):\n            slow = fast = node\n            while fast.next and fast.next.next:\n                slow = slow.next\n                fast = fast.next.next\n            mid = slow.next\n            slow.next = None\n            return node, mid\n        \n        left, right = split(head)\n        \n        left = self.sortList(left)\n        right = self.sortList(right)\n        \n        return merge(left, right)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* sortList(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    \n    struct ListNode* slow = head;\n    struct ListNode* fast = head->next;\n    \n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    struct ListNode* mid = slow->next;\n    slow->next = NULL;\n    \n    struct ListNode* left = sortList(head);\n    struct ListNode* right = sortList(mid);\n    \n    struct ListNode dummy;\n    struct ListNode* tail = &dummy;\n    \n    while (left != NULL && right != NULL) {\n        if (left->val < right->val) {\n            tail->next = left;\n            left = left->next;\n        } else {\n            tail->next = right;\n            right = right->next;\n        }\n        tail = tail->next;\n    }\n    \n    if (left != NULL) {\n        tail->next = left;\n    } \n    if (right != NULL) {\n        tail->next = right;\n    }\n    \n    return dummy.next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode SortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode prev = null;\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        prev.next = null;\n        \n        ListNode left = SortList(head);\n        ListNode right = SortList(slow);\n        \n        return Merge(left, right);\n    }\n    \n    private ListNode Merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode current = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n        \n        if (l1 != null) {\n            current.next = l1;\n        }\n        if (l2 != null) {\n            current.next = l2;\n        }\n        \n        return dummy.next;\n    }\n}\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.next = (next===undefined ? null : next);\n * }\n */\nvar sortList = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    \n    let mid = getMid(head);\n    let left = sortList(head);\n    let right = sortList(mid);\n    \n    return merge(left, right);\n};\n\nconst getMid = (head) => {\n    let slow = head;\n    let fast = head;\n    \n    while (fast.next && fast.next.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    let mid = slow.next;\n    slow.next = null;\n    return mid;\n};\n\nconst merge = (l1, l2) => {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (l1 && l2) {\n        if (l1.val < l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    if (l1) {\n        current.next = l1;\n    }\n    if (l2) {\n        current.next = l2;\n    }\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next? : ListNode) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction sortList(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return head;\n    }\n\n    let slow = head;\n    let fast = head;\n    let prev: ListNode | null = null;\n\n    while (fast && fast.next) {\n        prev = slow;\n        slow = slow.next!;\n        fast = fast.next.next!;\n    }\n\n    if (prev) {\n        prev.next = null; // Split the list into two parts\n    }\n\n    const left = sortList(head);\n    const right = sortList(slow);\n\n    return merge(left, right);\n}\n\nfunction merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    const dummy = new ListNode();\n    let current = dummy;\n\n    while (l1 && l2) {\n        if (l1.val < l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n\n    current.next = l1 || l2;\n\n    return dummy.next;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n* Definition for a singly-linked list.\n* class ListNode {\n*     public $val = 0;\n*     public $next = null;\n*     function __construct($val = 0, $next = null) {\n*         $this->val = $val;\n*         $this->next = $next;\n*     }\n* }\n*/\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function sortList($head) {\n        if ($head == null || $head->next == null) {\n            return $head;\n        }\n\n        $fast = $head;\n        $slow = $head;\n        while ($fast->next != null && $fast->next->next != null) {\n            $fast = $fast->next->next;\n            $slow = $slow->next;\n        }\n\n        $mid = $slow->next;\n        $slow->next = null;\n\n        $left = $this->sortList($head);\n        $right = $this->sortList($mid);\n\n        return $this->merge($left, $right);\n    }\n\n    function merge($l1, $l2) {\n        $dummy = new ListNode(0);\n        $cur = $dummy;\n\n        while ($l1 != null && $l2 != null) {\n            if ($l1->val < $l2->val) {\n                $cur->next = $l1;\n                $l1 = $l1->next;\n            } else {\n                $cur->next = $l2;\n                $l2 = $l2->next;\n            }\n            $cur = $cur->next;\n        }\n\n        $cur->next = $l1 != null ? $l1 : $l2;\n\n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\n\nclass Solution {\n    func sortList(_ head: ListNode?) -> ListNode? {\n        if head == nil || head?.next == nil {\n            return head\n        }\n        \n        var prev: ListNode? = nil\n        var slow = head\n        var fast = head\n        \n        while fast != nil && fast?.next != nil {\n            prev = slow\n            slow = slow?.next\n            fast = fast?.next?.next\n        }\n        \n        prev?.next = nil\n        \n        let left = sortList(head)\n        let right = sortList(slow)\n        \n        return merge(left, right)\n    }\n    \n    func merge(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\n        if l1 == nil { return l2 }\n        if l2 == nil { return l1 }\n        \n        if l1!.val < l2!.val {\n            l1?.next = merge(l1?.next, l2)\n            return l1\n        } else {\n            l2?.next = merge(l1, l2?.next)\n            return l2\n        }\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc sortList(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    mid := findMiddle(head)\n    left := sortList(head)\n    right := sortList(mid)\n    return merge(left, right)\n}\n\nfunc findMiddle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    var prev *ListNode\n    for fast != nil && fast.Next != nil {\n        prev = slow\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    if prev != nil {\n        prev.Next = nil\n    }\n    return slow\n}\n\nfunc merge(l1 *ListNode, l2 *ListNode) *ListNode {\n    dummy := &ListNode{}\n    cur := dummy\n    for l1 != nil && l2 != nil {\n        if l1.Val < l2.Val {\n            cur.Next = l1\n            l1 = l1.Next\n        } else {\n            cur.Next = l2\n            l2 = l2.Next\n        }\n        cur = cur.Next\n    }\n    if l1 != nil {\n        cur.Next = l1\n    }\n    if l2 != nil {\n        cur.Next = l2\n    }\n    return dummy.Next\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | 'list_node'}).\n\nsort_list(Head) ->\n    List = linked_list_to_list(Head),\n    SortedList = lists:sort(fun(A, B) -> A =< B end, List),\n    list_to_linked_list(SortedList).\n\nlinked_list_to_list(null) ->\n    [];\nlinked_list_to_list(Node) ->\n    [Node#list_node.val | linked_list_to_list(Node#list_node.next)].\n\nlist_to_linked_list([]) ->\n    null;\nlist_to_linked_list([Val | T]) ->\n    Node = #list_node{val = Val, next = list_to_linked_list(T)},\n    Node.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to sort a linked list in ascending order. The goal is to perform sorting with O(n log n) time complexity and O(1) memory.\n\n# Explanation\nThe problem involves sorting a linked list, which we can efficiently accomplish using the merge sort algorithm. Merge sort has a time complexity of O(n log n) and can be implemented iteratively for O(1) space complexity, although we will use a recursive approach here which typically requires O(log n) space for the call stack.\n\nThe merge sort algorithm divides the list into two halves, sorts each half, and then merges the two sorted halves. Here are the steps:\n\n1. **Base Case:** If the list is empty or has only one element, it is already sorted.\n2. **Splitting:** Divide the list into two halves using the slow and fast pointer technique.\n3. **Sorting:** Recursively sort each half.\n4. **Merging:** Merge the two sorted halves into a single sorted list.\n\n# Pseudocode\n\n```pseudocode\n# Definition for singly-linked list node\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nfunction sortList(head):\n    if head is None or head.next is None:\n        return head\n\n    function merge(l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 if l1 else l2\n        return dummy.next\n\n    function split(node):\n        slow, fast = node\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        return node, mid\n\n    left, right = split(head)\n    left = sortList(left)\n    right = sortList(right)\n    return merge(left, right)\n```\n\nIn this pseudocode:\n\n1. `sortList` handles the base case and sets up the recursive sorting by calling itself.\n2. `merge` function merges two sorted linked lists into one.\n3. `split` function divides the linked list into two halves.\n4. The list is recursively divided and merged until it is completely sorted.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sort-list"
    },
    {
        "name": "Max Points On A Line",
        "site": "LeetCode",
        "href": "/solution/LeetCode-max-points-on-a-line",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        if(n <= 2) return n;\n        \n        int maxPoints = 2;\n        for(int i = 0; i < n; i++) {\n            unordered_map<long double, int> slopeFreq;\n            int samePoints = 0, localMax = 1;\n            \n            for(int j = 0; j < n; j++) {\n                if(i != j) {\n                    if(points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\n                        samePoints++;\n                    } else {\n                        long double slope = points[i][0] == points[j][0] ? DBL_MAX : (long double)(points[i][1] - points[j][1]) / (points[i][0] - points[j][0]);\n                        slopeFreq[slope]++;\n                        localMax = max(localMax, slopeFreq[slope]);\n                    }\n                }\n            }\n            maxPoints = max(maxPoints, localMax + samePoints + 1);\n        }\n        \n        return maxPoints;\n    }\n};"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the maximum number of points that lie on the same straight line on a 2D plane. The general approach involves iterating through each point, calculating the slope it forms with every other point, and counting how many points share the same slope, which implies they are collinear. Here's the step-by-step method to achieve this.\n\n# Explanation\n1. **Initialization and Edge Cases**:\n   - If the number of points is 2 or less, they are always collinear, so return the number of points directly.\n\n2. **Iterate through Each Point**:\n   - For each point, consider it as the base point.\n\n3. **Calculate Slopes**:\n   - For each other point, calculate the slope it forms with the base point. Special care is taken to handle vertical lines which could result in division by zero.\n\n4. **Count Frequency of Slopes**:\n   - Use a hashmap (or dictionary) to keep track of how many times each slope appears.\n\n5. **Maximize the Count**:\n   - The local maximum of points sharing the same slope with a base point will give a new candidate for the global maximum.\n\n6. **Same Points Handling**:\n   - If there are overlapping points, they should be counted as well.\n\n7. **Return the Maximum**:\n   - Return the maximum number of points which can be collinear detected during the iterations.\n\n# Pseudocode\n```\nfunction maxPoints(points):\n    n = length(points)\n    if n <= 2:\n        return n\n        \n    maxPoints = 0\n    \n    for i from 0 to n-1:\n        slopeFreq = empty hashmap\n        samePoints = 0\n        localMax = 1\n        \n        for j from 0 to n-1:\n            if i != j:\n                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\n                    samePoints += 1\n                else:\n                    if points[i][0] == points[j][0]:\n                        slope = INF  // Handling vertical lines\n                    else:\n                        slope = (points[i][1] - points[j][1]) / (points[i][0] - points[j][0])\n                    if slope in slopeFreq:\n                        slopeFreq[slope] += 1\n                    else:\n                        slopeFreq[slope] = 1\n                    localMax = max(localMax, slopeFreq[slope])\n        \n        maxPoints = max(maxPoints, localMax + samePoints + 1)\n    \n    return maxPoints\n```\n\nThis pseudocode outlines a method to methodically calculate and compare the number of collinear points for each base point, updating the maximum count as necessary.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-max-points-on-a-line"
    },
    {
        "name": "Ugly Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-ugly-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isUgly(int n) {\n        if(n <= 0) return false;\n        \n        while(n % 2 == 0) {\n            n /= 2;\n        }\n        \n        while(n % 3 == 0) {\n            n /= 3;\n        }\n        \n        while(n % 5 == 0) {\n            n /= 5;\n        }\n        \n        return n == 1;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isUgly(int n) {\n        if(n <= 0) {\n            return false;\n        }\n        \n        while(n % 2 == 0) {\n            n /= 2;\n        }\n        \n        while(n % 3 == 0) {\n            n /= 3;\n        }\n        \n        while(n % 5 == 0) {\n            n /= 5;\n        }\n        \n        return n == 1;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        return n == 1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isUgly(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    while (n % 5 == 0) {\n        n /= 5;\n    }\n    return n == 1;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsUgly(int n) {\n        if (n <= 0) {\n            return false;\n        }\n        \n        while (n % 2 == 0) {\n            n /= 2;\n        }\n        \n        while (n % 3 == 0) {\n            n /= 3;\n        }\n        \n        while (n % 5 == 0) {\n            n /= 5;\n        }\n        \n        return n == 1;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst isUgly = (n) => {\n    if (n <= 0) {\n        return false;\n    }\n    \n    while (n % 2 === 0) {\n        n /= 2;\n    }\n    \n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    \n    while (n % 5 === 0) {\n        n /= 5;\n    }\n    \n    return n === 1;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isUgly(n: number): boolean {\n    if (n <= 0) {\n        return false;\n    }\n    \n    while (n % 2 === 0) {\n        n /= 2;\n    }\n\n    while (n % 3 === 0) {\n        n /= 3;\n    }\n\n    while (n % 5 === 0) {\n        n /= 5;\n    }\n\n    return n === 1;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Boolean\n     */\n    function isUgly($n) {\n        if ($n <= 0) {\n            return false;\n        }\n        \n        while ($n % 2 == 0) {\n            $n /= 2;\n        }\n        while ($n % 3 == 0) {\n            $n /= 3;\n        }\n        while ($n % 5 == 0) {\n            $n /= 5;\n        }\n        \n        return $n == 1;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isUgly(_ n: Int) -> Bool {\n        if n <= 0 {\n            return false\n        }\n        \n        var num = n\n        \n        while num % 2 == 0 {\n            num /= 2\n        }\n        \n        while num % 3 == 0 {\n            num /= 3\n        }\n        \n        while num % 5 == 0 {\n            num /= 5\n        }\n        \n        return num == 1\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isUgly(n: Int): Boolean {\n        if (n <= 0) return false\n        var num = n\n        while (num % 2 == 0) num /= 2\n        while (num % 3 == 0) num /= 3\n        while (num % 5 == 0) num /= 5\n        return num == 1\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isUgly(int n) {\n    if (n <= 0) {\n      return false;\n    }\n    \n    while (n % 2 == 0) {\n      n ~/= 2;\n    }\n    while (n % 3 == 0) {\n      n ~/= 3;\n    }\n    while (n % 5 == 0) {\n      n ~/= 5;\n    }\n    \n    return n == 1;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isUgly(n int) bool {\n    if n <= 0 {\n        return false\n    }\n    \n    for n%2 == 0 {\n        n /= 2\n    }\n    \n    for n%3 == 0 {\n        n /= 3\n    }\n    \n    for n%5 == 0 {\n        n /= 5\n    }\n    \n    return n == 1\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Boolean}\ndef is_ugly(n)\n    return false if n <= 0\n    while n % 2 == 0\n        n /= 2\n    end\n    while n % 3 == 0\n        n /= 3\n    end\n    while n % 5 == 0\n        n /= 5\n    end\n    n == 1\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isUgly(n: Int): Boolean = {\n        if (n <= 0) {\n            return false\n        }\n        \n        var num = n\n        \n        while (num % 2 == 0) {\n            num /= 2\n        }\n        \n        while (num % 3 == 0) {\n            num /= 3\n        }\n        \n        while (num % 5 == 0) {\n            num /= 5\n        }\n        \n        num == 1\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_ugly(n: i32) -> bool {\n        if n <= 0 {\n            return false;\n        }\n        let mut num = n;\n        while num % 2 == 0 {\n            num /= 2;\n        }\n        while num % 3 == 0 {\n            num /= 3;\n        }\n        while num % 5 == 0 {\n            num /= 5;\n        }\n        num == 1\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (is-ugly n)\n  (-> exact-integer? boolean?)\n  (cond\n    ((<= n 0) #f)\n    ((= n 1) #t)\n    ((= (modulo n 2) 0) (is-ugly (/ n 2)))\n    ((= (modulo n 3) 0) (is-ugly (/ n 3)))\n    ((= (modulo n 5) 0) (is-ugly (/ n 5)))\n    (else #f)\n    )\n  )\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "is_ugly(N) ->\n    case N of\n        0 -> false;\n        _ when N rem 2 == 0 -> is_ugly(N div 2);\n        _ when N rem 3 == 0 -> is_ugly(N div 3);\n        _ when N rem 5 == 0 -> is_ugly(N div 5);\n        1 -> true;\n        _ -> false\n    end.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec is_ugly(n :: integer) :: boolean\n  def is_ugly(n) do\n    cond do\n      n <= 0 -> false\n      rem(n, 2) == 0 -> is_ugly(div(n, 2))\n      rem(n, 3) == 0 -> is_ugly(div(n, 3))\n      rem(n, 5) == 0 -> is_ugly(div(n, 5))\n      n == 1 -> true\n      true -> false\n    end\n  end\nend"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to determine if a given integer `n` is an ugly number. Ugly numbers are positive integers whose prime factors are only 2, 3, or 5.\n\n### # Explanation\n1. **Check the Base Condition**: First, if `n` is less than or equal to zero, it cannot be an ugly number as ugly numbers must be positive integers.\n2. **Factor Out 2, 3, and 5**: Continuously divide `n` by 2, 3, and 5 as long as possible. This step effectively removes all prime factors except 2, 3, and 5 from `n` if they exist.\n3. **Check the Resulting Value**: After the division process, if the remaining value of `n` is 1, then the original `n` was composed solely of the factors 2, 3, and 5, making it an ugly number. Otherwise, it contains other prime factors, and it's not an ugly number.\n\n### # Pseudocode\n``` \nfunction isUgly(n):\n    # Base condition: if n is less than or equal to zero, it's not an ugly number.\n    if n <= 0:\n        return False\n    \n    # Factor out 2 as much as possible\n    while n % 2 == 0:\n        n = n / 2\n    \n    # Factor out 3 as much as possible\n    while n % 3 == 0:\n        n = n / 3\n    \n    # Factor out 5 as much as possible\n    while n % 5 == 0:\n        n = n / 5\n    \n    # If the remaining n is 1, it means n was composed only of the prime factors 2, 3, and 5\n    return n == 1\n```\n\nThis pseudocode covers the basic logic necessary to determine if the given integer `n` is an ugly number. The while loops ensure that all the factors of 2, 3, and 5 are completely removed from `n`, and the final check confirms whether any other factors exist.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-ugly-number"
    },
    {
        "name": "Expression Add Operators",
        "site": "LeetCode",
        "href": "/solution/LeetCode-expression-add-operators",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        vector<string> res;\n        \n        backtrack(res, num, target, 0, \"\", 0, 0);\n        \n        return res;\n    }\n    \n    void backtrack(vector<string>& res, string num, int target, int start, string path, long eval, long prev) {\n        if (start == num.length()) {\n            if (eval == target) {\n                res.push_back(path);\n            }\n            return;\n        }\n        \n        for (int i = start; i < num.length(); i++) {\n            if (i != start && num[start] == '0') break;\n            string currStr = num.substr(start, i - start + 1);\n            long curr = stoll(currStr);\n            \n            if (start == 0) {\n                backtrack(res, num, target, i + 1, path + currStr, curr, curr);\n            } else {\n                backtrack(res, num, target, i + 1, path + \"+\" + currStr, eval + curr, curr);\n                backtrack(res, num, target, i + 1, path + \"-\" + currStr, eval - curr, -curr);\n                backtrack(res, num, target, i + 1, path + \"*\" + currStr, eval - prev + prev * curr, prev * curr);\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        List<String> res = new ArrayList<>();\n        if (num == null || num.length() == 0) {\n            return res;\n        }\n        \n        backtrack(res, num, target, new StringBuilder(), 0, 0, 0);\n        \n        return res;\n    }\n    \n    private void backtrack(List<String> res, String num, int target, StringBuilder path, int index, long eval, long multed) {\n        if (index == num.length()) {\n            if (eval == target) {\n                res.add(path.toString());\n            }\n            return;\n        }\n        \n        for (int i = index; i < num.length(); i++) {\n            if (i != index && num.charAt(index) == '0') {\n                break;\n            }\n            long curr = Long.parseLong(num.substring(index, i + 1));\n            int len = path.length();\n            if (index == 0) {\n                backtrack(res, num, target, path.append(curr), i + 1, curr, curr);\n                path.setLength(len);\n            } else {\n                backtrack(res, num, target, path.append(\"+\").append(curr), i + 1, eval + curr, curr);\n                path.setLength(len);\n                \n                backtrack(res, num, target, path.append(\"-\").append(curr), i + 1, eval - curr, -curr);\n                path.setLength(len);\n                \n                backtrack(res, num, target, path.append(\"*\").append(curr), i + 1, eval - multed + multed * curr, multed * curr);\n                path.setLength(len);\n            }\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        def backtrack(index, expression, value, prev):\n            if index == len(num):\n                if value == target:\n                    result.append(expression)\n                return\n            \n            for i in range(index, len(num)):\n                if i != index and num[index] == '0':\n                    break\n                \n                current_num = int(num[index:i+1])\n                if index == 0:\n                    backtrack(i+1, expression + str(current_num), current_num, current_num)\n                else:\n                    backtrack(i+1, expression + '+' + str(current_num), value + current_num, current_num)\n                    backtrack(i+1, expression + '-' + str(current_num), value - current_num, -current_num)\n                    backtrack(i+1, expression + '*' + str(current_num), value - prev + prev*current_num, prev*current_num)\n        \n        result = []\n        if not num:\n            return result\n        \n        backtrack(0, '', 0, 0)\n        \n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> AddOperators(string num, int target) {\n        IList<string> result = new List<string>();\n        Backtrack(result, \"\", num, target, 0, 0, 0);\n        return result;\n    }\n    \n    private void Backtrack(IList<string> result, string path, string num, int target, int index, long eval, long prev) {\n        if (index == num.Length) {\n            if (eval == target) {\n                result.Add(path);\n            }\n            return;\n        }\n        \n        for (int i = index; i < num.Length; i++) {\n            if (i != index && num[index] == '0') {\n                break;\n            }\n            long current = long.Parse(num.Substring(index, i - index + 1));\n            if (index == 0) {\n                Backtrack(result, path + current, num, target, i + 1, current, current);\n            } else {\n                Backtrack(result, path + \"+\" + current, num, target, i + 1, eval + current, current);\n                Backtrack(result, path + \"-\" + current, num, target, i + 1, eval - current, -current);\n                Backtrack(result, path + \"*\" + current, num, target, i + 1, eval - prev + prev * current, prev * current);\n            }\n        }\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function addOperators(num: string, target: number): string[] {\n    const result: string[] = [];\n\n    const backtrack = (\n        index: number,\n        path: string,\n        evalExpr: number,\n        multed: number\n    ) => {\n        if (index === num.length) {\n            if (evalExpr === target) {\n                result.push(path);\n            }\n            return;\n        }\n\n        for (let i = index; i < num.length; i++) {\n            if (i !== index && num[index] === \"0\") break;\n\n            const currStr = num.substring(index, i + 1);\n            const currNum = parseInt(currStr);\n\n            if (index === 0) {\n                backtrack(i + 1, currStr, currNum, currNum);\n            } else {\n                backtrack(\n                    i + 1,\n                    path + \"+\" + currStr,\n                    evalExpr + currNum,\n                    currNum\n                );\n                backtrack(\n                    i + 1,\n                    path + \"-\" + currStr,\n                    evalExpr - currNum,\n                    -currNum\n                );\n                backtrack(\n                    i + 1,\n                    path + \"*\" + currStr,\n                    evalExpr - multed + multed * currNum,\n                    multed * currNum\n                );\n            }\n        }\n    \n    };\n\n    backtrack(0, \"\", 0, 0);\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $num\n     * @param Integer $target\n     * @return String[]\n     */\n    function addOperators($num, $target) {\n        $result = [];\n        $this->backtrack($num, $target, $result, '', 0, 0, 0);\n        return $result;\n    }\n    \n    function backtrack($num, $target, &$result, $path, $index, $calculated, $prevNum) {\n        if ($index == strlen($num)) {\n            if ($calculated == $target) {\n                $result[] = $path;\n            }\n            return;\n        }\n        \n        for ($i = $index; $i < strlen($num); $i++) {\n            if ($i != $index && $num[$index] == '0') break;\n            $currentNum = intval(substr($num, $index, $i - $index + 1));\n            if ($index == 0) {\n                $this->backtrack($num, $target, $result, $path . $currentNum, $i + 1, $currentNum, $currentNum);\n            } else {\n                $this->backtrack($num, $target, $result, $path . '+' . $currentNum, $i + 1, $calculated + $currentNum, $currentNum);\n                $this->backtrack($num, $target, $result, $path . '-' . $currentNum, $i + 1, $calculated - $currentNum, -$currentNum);\n                $this->backtrack($num, $target, $result, $path . '*' . $currentNum, $i + 1, $calculated - $prevNum + $prevNum * $currentNum, $prevNum * $currentNum);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func addOperators(_ num: String, _ target: Int) -> [String] {\n        var result = [String]()\n        \n        func backtrack(_ index: Int, _ prevOperand: Int, _ currentOperand: Int, _ value: Int, _ path: String) {\n            if index == num.count {\n                if value == target {\n                    result.append(path)\n                }\n                return\n            }\n            \n            for i in index..<num.count {\n                let endIndex = num.index(num.startIndex, offsetBy: i+1)\n                let currentStr = String(num[num.index(num.startIndex, offsetBy: index)..<endIndex])\n                let currentNum = Int(currentStr)!\n                \n                if num[num.index(num.startIndex, offsetBy: index)] == \"0\" && i > index {\n                    continue\n                }\n                \n                if index == 0 {\n                    backtrack(i+1, currentNum, currentNum, currentNum, currentStr)\n                } else {\n                    backtrack(i+1, currentNum, currentOperand, value + currentNum, path + \"+\" + currentStr)\n                    backtrack(i+1, -currentNum, currentOperand, value - currentNum, path + \"-\" + currentStr)\n                    backtrack(i+1, prevOperand * currentNum, currentOperand, value - prevOperand + prevOperand * currentNum, path + \"*\" + currentStr)\n                }\n            }\n        }\n        \n        backtrack(0, 0, 0, 0, \"\")\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func addOperators(num string, target int) []string {\n    var res []string\n    \n    var backtrack func(index int, prevOperand int, currentOperand int, value int, path string)\n    backtrack = func(index int, prevOperand int, currentOperand int, value int, path string) {\n        if index == len(num) {\n            if value == target {\n                res = append(res, path)\n            }\n            return\n        }\n        \n        for i := index; i < len(num); i++ {\n            if i != index && num[index] == '0' {\n                break // avoid leading zeros\n            }\n            current := num[index : i+1]\n            currentNum, _ := strconv.Atoi(current)\n            \n            if index == 0 {\n                backtrack(i+1, currentNum, currentNum, currentNum, path+current)\n            } else {\n                backtrack(i+1, currentNum, currentNum, value+currentNum, path+\"+\"+current)\n                \n                backtrack(i+1, -currentNum, currentNum, value-currentNum, path+\"-\"+current)\n                \n                newOperand := prevOperand*currentNum\n                backtrack(i+1, newOperand, currentNum, value-prevOperand+newOperand, path+\"*\"+current)\n            }\n        }\n    }\n    \n    backtrack(0, 0, 0, 0, \"\")\n    \n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} num\n# @param {Integer} target\n# @return {String[]}\ndef add_operators(num, target)\n    res = []\n    backtrack(res, num, target, \"\", 0, 0, 0)\n    return res\nend\n\ndef backtrack(res, num, target, path, index, eval, multed)\n    if index == num.length\n        res << path if eval == target\n        return\n    end\n    \n    (index...num.length).each do |i|\n        next if i != index && num[index] == \"0\" # avoid leading zero\n        cur = num[index..i].to_i\n        \n        if index == 0\n            backtrack(res, num, target, path + cur.to_s, i+1, cur, cur)\n        else\n            backtrack(res, num, target, path + \"+\" + cur.to_s, i+1, eval + cur, cur)\n            backtrack(res, num, target, path + \"-\" + cur.to_s, i+1, eval - cur, -cur)\n            backtrack(res, num, target, path + \"*\" + cur.to_s, i+1, eval - multed + multed * cur, multed * cur)\n        end\n    end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate all possible expressions by inserting the binary operators '+', '-', and '*' between the digits of a string such that the resultant expression evaluates to a given target value. This can be achieved using a backtracking approach.\n\n# Explanation\nThe main idea is to explore all possible ways of inserting operators between the digits and evaluating these expressions. We use a recursive backtracking function to build the expressions and evaluate them as we go.\n\n1. **Backtracking Function**: We define a backtracking function that:\n   - Takes the current index in the string, the current expression formed, the current calculated value of the expression, and the previous number added to the calculated value.\n   - If we reach the end of the string and the calculated value matches the target, we add the current expression to the result list.\n   - At each step, we try all possible splits of the remaining string and insert '+', '-', or '*' operators between them while keeping track of the current value and previous number to handle precedence for '*'.\n\n2. **Edge Cases**:\n   - Expressions should not have operands with leading zeros.\n   - Ensure proper handling of multiplication in the presence of other operators.\n\n# Pseudocode\n```python\nfunction addOperators(num: string, target: int) -> list of strings:\n    define helper function backtrack(index, expression, value, prev):\n        if index == length of num:\n            if value == target:\n                append expression to result\n            return\n\n        for i from index to length of num:\n            # Avoid operands with leading zero\n            if i != index and num[index] is '0':\n                break\n\n            # Get current number from num\n            current_num = integer conversion of num substring from index to i+1\n\n            if index == 0:\n                # First number, no operator before it\n                backtrack(i + 1, expression + str(current_num), current_num, current_num)\n            else:\n                # Try adding '+' operator\n                backtrack(i + 1, expression + '+' + str(current_num), value + current_num, current_num)\n                # Try adding '-' operator\n                backtrack(i + 1, expression + '-' + str(current_num), value - current_num, -current_num)\n                # Try adding '*' operator\n                backtrack(i + 1, expression + '*' + str(current_num), value - prev + prev * current_num, prev * current_num)\n\n    result = empty list\n    if num is empty:\n        return result\n\n    # Start the backtracking\n    backtrack(0, '', 0, 0)\n\n    return result\n```\n\nThis pseudocode outlines the complete approach to solve the problem using backtracking. Each call to the `backtrack` function explores a different way of inserting operators and evaluates the resulting expression.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-expression-add-operators"
    },
    {
        "name": "Perfect Squares",
        "site": "LeetCode",
        "href": "/solution/LeetCode-perfect-squares",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j * j <= i; ++j) {\n                dp[i] = min(dp[i], dp[i - j * j] + 1);\n            }\n        }\n        return dp[n];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j * j <= i; j++) {\n                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n            }\n        }\n        \n        return dp[n];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = min(dp[i - j*j] + 1 for j in range(1, int(i**0.5) + 1))\n        return dp[n]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int numSquares(int n) {\n    while (n % 4 == 0)\n        n /= 4;\n    \n    if (n % 8 == 7)\n        return 4;\n    \n    for (int a = 0; a * a <= n; ++a) {\n        int b = sqrt(n - a * a);\n        if (a * a + b * b == n)\n            return !!a + !!b;\n    }\n    \n    return 3;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumSquares(int n) {\n        while (n % 4 == 0) {\n            n /= 4;\n        }\n        if (n % 8 == 7) {\n            return 4;\n        }\n        for (int a = 0; a * a <= n; a++) {\n            int b = (int)Math.Sqrt(n - a * a);\n            if (a * a + b * b == n) {\n                return (a == 0 ? 0 : 1) + (b == 0 ? 0 : 1);\n            }\n        }\n        return 3;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar numSquares = function(n) {\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numSquares(n: number): number {\n    const dp = new Array(n + 1).fill(Number.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j*j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j*j] + 1);\n        }\n    }\n    \n    return dp[n];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     */\n    function numSquares($n) {\n        $dp = array_fill(0, $n + 1, PHP_INT_MAX);\n        $dp[0] = 0;\n        \n        for ($i = 1; $i <= $n; $i++) {\n            for ($j = 1; $j * $j <= $i; $j++) {\n                $dp[$i] = min($dp[$i], $dp[$i - $j * $j] + 1);\n            }\n        }\n        \n        return $dp[$n];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func numSquares(_ n: Int) -> Int {\n        var dp = Array(repeating: Int.max, count: n + 1)\n        dp[0] = 0\n        \n        for i in 1...n {\n            var j = 1\n            while j * j <= i {\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n            }\n        }\n        \n        return dp[n]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numSquares(n: Int): Int {\n        val dp = IntArray(n + 1) { it }\n        for (i in 1..n) {\n            var j = 1\n            while (j * j <= i) {\n                dp[i] = minOf(dp[i], dp[i - j * j] + 1)\n                j++\n            }\n        }\n        return dp[n]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numSquares(int n) {\n    List<int> dp = List<int>.filled(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n      int minVal = i;\n      int j = 1;\n      int square = 1;\n      while (square <= i) {\n        minVal = min(minVal, 1 + dp[i - square]);\n        j++;\n        square = j * j;\n      }\n      dp[i] = minVal;\n    }\n    return dp[n];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numSquares(n int) int {\n    dp := make([]int, n+1)\n    for i := 1; i <= n; i++ {\n        dp[i] = i\n        for j := 1; j*j <= i; j++ {\n            dp[i] = min(dp[i], dp[i-j*j]+1)\n        }\n    }\n    return dp[n]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef num_squares(n)\n    dp = Array.new(n + 1, n)\n    dp[0] = 0\n    \n    (1..n).each do |i|\n        (1..Math.sqrt(i).to_i).each do |j|\n            dp[i] = [dp[i], dp[i - j * j] + 1].min\n        end\n    end\n    \n    return dp[n]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def numSquares(n: Int): Int = {\n        val dp = Array.fill(n + 1)(Int.MaxValue)\n        dp(0) = 0\n        \n        for (i <- 1 to n) {\n            var j = 1\n            while (j * j <= i) {\n                dp(i) = math.min(dp(i), dp(i - j * j) + 1)\n                j += 1\n            }\n        }\n        \n        dp(n)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn num_squares(n: i32) -> i32 {\n        let n = n as usize;\n        let mut dp = vec![0; n + 1];\n        for i in 1..=n {\n            dp[i] = i;\n            let mut j = 1;\n            while j * j <= i {\n                dp[i] = dp[i].min(dp[i - j * j] + 1);\n                j += 1;\n            }\n        }\n        dp[n] as i32\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to calculate the minimum number of perfect square numbers that sum up to a given integer `n`.\n\n# Explanation\n\n1. **Dynamic Programming Approach**: \n   - We use a list `dp` where `dp[i]` represents the least number of perfect squares that sum up to `i`.\n   - We initialize `dp[0]` to 0 because 0 can be expressed as the sum of zero numbers.\n   - For each integer `i` from 1 to `n`, we find the minimum number of perfect squares that sum up to `i` by iterating through all possible perfect squares less than or equal to `i` (i.e., 1, 4, 9, ..., until `j*j <= i` for some integer `j`).\n\n2. **State Transition**:\n   - `dp[i] = min(dp[i - j*j] + 1 for j in range(1, int(i**0.5) + 1))`\n   - This equation means that for each `i`, we try to subtract all possible perfect squares (`j*j`) to find the minimum `dp[i]` by leveraging already computed values.\n\n# Pseudocode\n\n```text\n# Pseudocode\n\ndefine function numSquares(n):\n    # Initialize a list dp with size n+1 where all values are set to 0\n    dp = list of size (n + 1) with all values 0\n    \n    # Loop through each number from 1 to n\n    for i from 1 to n:\n        # Calculate the minimum number of perfect squares for the current number i\n        dp[i] = infinity  # Start with an initial large value\n        # Check all possible perfect squares less than or equal to i\n        for j from 1 to int(sqrt(i)) + 1:\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n    \n    # Return the dp value for n, which is the least number of perfect squares that sum to n\n    return dp[n]\n\n# End of Pseudocode\n```\n\nThis approach ensures that each subproblem is solved optimally and leverages previously computed solutions for efficiency. The primary loop iterates up to `n`, and the inner loop iterates up to the square root of `i`, making the approach efficient for the given constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-perfect-squares"
    },
    {
        "name": "First Bad Version",
        "site": "LeetCode",
        "href": "/solution/LeetCode-first-bad-version",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# The isBadVersion API is already defined for you.\n# @param version, an integer\n# @return a bool\n# def isBadVersion(version):\n\nclass Solution:\n    def firstBadVersion(self, n):\n        left = 1\n        right = n\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\nint firstBadVersion(int n) {\n    int left = 1, right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/* The isBadVersion API is defined in the parent class \nVersionControl.\n      bool IsBadVersion(int version); */\n\npublic class Solution : VersionControl {\n    public int FirstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (IsBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n */\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function(isBadVersion) {\n    return function(n) {\n        let left = 1;\n        let right = n;\n        while (left < right) {\n            let mid = Math.floor(left + (right - left) / 2);\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    };\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/* The isBadVersion API is defined in the parent \nclass VersionControl.\n      public function isBadVersion($version){} */\nclass Solution extends VersionControl {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function firstBadVersion($n) {\n        $left = 1;\n        $right = $n;\n\n        while ($left < $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            \n            if ($this->isBadVersion($mid)) {\n                $right = $mid;\n            } else {\n                $left = $mid + 1;\n            }\n        }\n        \n        return $left;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * The knows API is defined in the parent class VersionControl.\n *     func isBadVersion(_ version: Int) -> Bool{}\n */\n \nclass Solution : VersionControl {\n    func firstBadVersion(_ n: Int) -> Int {\n        var left = 1\n        var right = n\n        \n        while left < right {\n            let mid = left + (right - left) / 2\n            if isBadVersion(mid) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        \n        return left\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# The is_bad_version API is already defined for you.\n# @param {Integer} version\n# @return {boolean} whether the version is bad\n# def is_bad_version(version):\n\ndef first_bad_version(n)\n    left = 1\n    right = n\n\n    while left < right\n        mid = left + (right - left) / 2\n        if is_bad_version(mid)\n            right = mid\n        else\n            left = mid + 1\n        end\n    end\n\n    return left\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn first_bad_version(&self, n: i32) -> i32 {\n        let (mut left, mut right) = (1, n);\n        while left < right {\n            let mid = left + (right - left) / 2;\n            if self.isBadVersion(mid) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        left\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify the first bad version from a set of product versions. The challenge aims to minimize the number of calls to the `isBadVersion` API. This problem can be efficiently solved using the binary search algorithm.\n\n# Explanation\n1. Binary Search: Since we need to minimize API calls, we'll utilize binary search which has a logarithmic time complexity, i.e., O(log n). This is efficient for the large input sizes specified in the constraints.\n2. Initialization:\n   - `left` points to the first version.\n   - `right` points to the last version.\n3. Iteration:\n   - Calculate `mid` as the average of `left` and `right`.\n   - Use `isBadVersion(mid)` to check if the middle version is bad.\n     - If `mid` is a bad version, then the first bad version must be at `mid` or earlier. Hence, update `right` to `mid`.\n     - If `mid` is not a bad version, then the first bad version must be after `mid`. Hence, update `left` to `mid + 1`.\n4. Stopping Condition:\n   - The loop terminates when `left` meets `right`. At this point, `left` will point to the first bad version.\n\n# Pseudocode\n```pseudocode\nfunction firstBadVersion(n):\n    left = 1\n    right = n\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if isBadVersion(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n```\n\nThis pseudocode outlines how to implement the binary search to find the first bad version. The critical steps are updating the `left` and `right` pointers based on the result of the `isBadVersion` function until the exact location of the first bad version is found.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-first-bad-version"
    },
    {
        "name": "H Index Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-h-index-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int n = citations.size();\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (citations[mid] == n - mid) {\n                return n - mid;\n            } else if (citations[mid] < n - mid) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return n - left;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int hIndex(int[] citations) {\n        int n = citations.length;\n        int left = 0, right = n - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (citations[mid] == n - mid) {\n                return n - mid;\n            } else if (citations[mid] < n - mid) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return n - left;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def hIndex(self, citations):\n        n = len(citations)\n        left, right = 0, n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if citations[mid] == n - mid:\n                return n - mid\n            elif citations[mid] < n - mid:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return n - left\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int hIndex(int* citations, int citationsSize) {\n    int left = 0, right = citationsSize - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == citationsSize - mid) {\n            return citationsSize - mid;\n        } else if (citations[mid] < citationsSize - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return citationsSize - left;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int HIndex(int[] citations) {\n        int n = citations.Length;\n        int left = 0, right = n - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (citations[mid] == n - mid) {\n                return n - mid;\n            } else if (citations[mid] < n - mid) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return n - left;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} citations\n * @return {number}\n */\nvar hIndex = function(citations) {\n    let n = citations.length;\n    let left = 0, right = n - 1;\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (citations[mid] === n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return n - left;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function hIndex(citations: number[]): number {\n    let left = 0;\n    let right = citations.length - 1;\n    let n = citations.length;\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (citations[mid] === n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return n - left;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $citations\n     * @return Integer\n     */\n    function hIndex($citations) {\n        $n = count($citations);\n        \n        $left = 0;\n        $right = $n - 1;\n        \n        while ($left <= $right) {\n            $mid = $left + floor(($right - $left) / 2);\n            \n            if ($citations[$mid] == $n - $mid) {\n                return $n - $mid;\n            } elseif ($citations[$mid] < $n - $mid) {\n                $left = $mid + 1;\n            } else {\n                $right = $mid - 1;\n            }\n        }\n        \n        return $n - $left;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func hIndex(_ citations: [Int]) -> Int {\n        var left = 0\n        var right = citations.count - 1\n        let n = citations.count\n        \n        while left <= right {\n            let mid = left + (right - left) / 2\n            if citations[mid] == n - mid {\n                return n - mid\n            } else if citations[mid] < n - mid {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        \n        return n - left\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun hIndex(citations: IntArray): Int {\n        var left = 0\n        var right = citations.size - 1\n        var n = citations.size\n\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n\n            if (citations[mid] == n - mid) {\n                return n - mid\n            } else if (citations[mid] < n - mid) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n\n        return n - left\n    }\n}\n  "
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int hIndex(List<int> citations) {\n    int n = citations.length;\n    int left = 0, right = n - 1;\n    while (left <= right) {\n      int mid = left + (right - left) ~/ 2;\n      if (citations[mid] == n - mid) {\n        return n - mid;\n      } else if (citations[mid] < n - mid) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    return n - left;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func hIndex(citations []int) int {\n    n := len(citations)\n    left, right := 0, n-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if citations[mid] == n-mid {\n            return n - mid\n        } else if citations[mid] < n-mid {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return n - left\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} citations\n# @return {Integer}\ndef h_index(citations)\n    n = citations.length\n    left = 0\n    right = n - 1\n    \n    while left <= right\n        mid = left + (right - left) / 2\n        if citations[mid] == n - mid\n            return n - mid\n        elsif citations[mid] < n - mid\n            left = mid + 1\n        else\n            right = mid - 1\n        end\n    end\n    \n    return n - left\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def hIndex(citations: Array[Int]): Int = {\n        var left = 0\n        var right = citations.length - 1\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            if (citations(mid) >= citations.length - mid) {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        }\n        citations.length - left\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn h_index(citations: Vec<i32>) -> i32 {\n        let n = citations.len() as i32;\n        let (mut left, mut right) = (0, n - 1);\n        \n        while left <= right {\n            let mid = left + (right - left) / 2;\n            if citations[mid as usize] == n - mid {\n                return n - mid;\n            } else if citations[mid as usize] < n - mid {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        n - left\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec h_index(Citations :: [integer()]) -> integer().\nh_index(Citations) ->\n    HIndex = h_index(Citations, length(Citations)),\n    HIndex.\n\nh_index(_, 0) ->\n    0;\nh_index(Citations, N) when hd(Citations) >= N ->\n    N;\nh_index(Citations, N) ->\n    h_index(tl(Citations), N-1)."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the h-index for a researcher based on an array of citation counts that is sorted in ascending order. We are required to implement an algorithm with a logarithmic time complexity, which suggests that using binary search would be suitable.\n\n# Explanation\n\n1. **Understanding the h-index:** According to the definition, a researcher's h-index is the maximum value \\( h \\) such that they have at least \\( h \\) papers with \\( h \\) or more citations each.\n\n2. **Binary Search Approach:** Given that the array is sorted, we can leverage binary search to find the h-index efficiently.\n   - Initialize two pointers, `left` and `right`, which will help in performing the binary search.\n   - Update the `mid` point in each iteration and determine if `citations[mid]` equals the number of papers that have at least `citations[mid]` citations, which is \\( n - mid \\).\n   - If `citations[mid]` equals \\( n - mid \\), it means we've found our h-index.\n   - If `citations[mid]` is less than \\( n - mid \\), move the `left` pointer to `mid + 1` to search in the right half.\n   - If `citations[mid]` is greater than \\( n - mid \\), move the `right` pointer to `mid - 1` to search in the left half.\n   - If no exact match is found, the h-index will be \\( n - left \\).\n\n# Pseudocode\n\n```python\ndef hIndex(citations):\n    # Initialize the length of the citations array\n    n = len(citations)\n    # Initialize left and right pointers for binary search\n    left, right = 0, n - 1\n    \n    # Perform binary search\n    while left <= right:\n        # Calculate the mid point\n        mid = left + (right - left) // 2\n        \n        # Check if citations[mid] is equal to n - mid\n        if citations[mid] == n - mid:\n            return n - mid\n        # If citations[mid] is less than n - mid, search in the right half\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        # If citations[mid] is greater than n - mid, search in the left half\n        else:\n            right = mid - 1\n    \n    # If no exact match is found, return n - left\n    return n - left\n```\n\nThis pseudocode outlines the binary search approach to find the h-index in a sorted citations array efficiently, ensuring logarithmic time complexity. The key steps involve comparing each midpoint to \\( n - mid \\) and adjusting the search range accordingly.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-h-index-ii"
    },
    {
        "name": "H Index",
        "site": "LeetCode",
        "href": "/solution/LeetCode-h-index",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        sort(citations.begin(), citations.end(), greater<int>());\n        for (int i = 0; i < citations.size(); ++i) {\n            if (i >= citations[i]) {\n                return i;\n            }\n        }\n        return citations.size();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int hIndex = 0;\n        for (int i = 0; i < citations.length; i++) {\n            int count = citations.length - i;\n            if (citations[i] >= count) {\n                hIndex = Math.max(hIndex, count);\n            }\n        }\n        return hIndex;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def hIndex(self, citations):\n        citations.sort(reverse=True)\n        i = 0\n        while i < len(citations) and citations[i] > i:\n            i += 1\n        return i\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int HIndex(int[] citations) {\n        Array.Sort(citations);\n        int n = citations.Length;\n        for (int i = 0; i < n; i++) {\n            if (citations[i] >= n - i) {\n                return n - i;\n            }\n        }\n        return 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} citations\n * @return {number}\n */\nconst hIndex = (citations) => {\n    citations.sort((a, b) => b - a);\n    let hIndex = 0;\n    \n    for (let i = 0; i < citations.length; i++) {\n        if (citations[i] >= i + 1) {\n            hIndex = i + 1;\n        } else {\n            break;\n        }\n    }\n    \n    return hIndex;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function hIndex(citations: number[]): number {\n    citations.sort((a, b) => b - a);\n    let hIndex = 0;\n    for (let i = 0; i < citations.length; i++) {\n        if (citations[i] > hIndex) {\n            hIndex++;\n        } else {\n            break;\n        }\n    }\n    return hIndex;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $citations\n     * @return Integer\n     */\n    function hIndex($citations) {\n        sort($citations);\n        $n = count($citations);\n        $left = 0;\n        $right = $n - 1;\n        $hIndex = 0;\n        \n        while($left <= $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            if($citations[$mid] >= $n - $mid) {\n                $hIndex = $n - $mid;\n                $right = $mid - 1;\n            } else {\n                $left = $mid + 1;\n            }\n        }\n        \n        return $hIndex;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func hIndex(_ citations: [Int]) -> Int {\n        let n = citations.count\n        var bucket = Array(repeating: 0, count: n + 1)\n        \n        for citation in citations {\n            if citation >= n {\n                bucket[n] += 1\n            } else {\n                bucket[citation] += 1\n            }\n        }\n        \n        var count = 0\n        for i in stride(from: n, through: 0, by: -1) {\n            count += bucket[i]\n            if count >= i {\n                return i\n            }\n        }\n        \n        return 0\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun hIndex(citations: IntArray): Int {\n        citations.sort()\n        var hIndex = 0\n        var i = 0\n        while (i < citations.size && citations[citations.size - 1 - i] > i) {\n            hIndex++\n            i++\n        }\n        return hIndex\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int hIndex(List<int> citations) {\n    citations.sort((a, b) => b - a);\n    int h = 0;\n    for (int i = 0; i < citations.length; i++) {\n      if (citations[i] > h) {\n        h++;\n      } else {\n        break;\n      }\n    }\n    return h;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func hIndex(citations []int) int {\n    n := len(citations)\n    count := make([]int, n+1)\n    \n    for _, c := range citations {\n        if c >= n {\n            count[n]++\n        } else {\n            count[c]++\n        }\n    }\n    \n    total := 0\n    for i := n; i >= 0; i-- {\n        total += count[i]\n        if total >= i {\n            return i\n        }\n    }\n    \n    return 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} citations\n# @return {Integer}\ndef h_index(citations)\n    citations.sort!\n    n = citations.length\n    h = 0\n    \n    for i in 0...n\n        if citations[i] >= n - i\n            return n - i\n        end\n    end\n    \n    return h\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def hIndex(citations: Array[Int]): Int = {\n        citations.sortWith(_ > _).zipWithIndex.foldLeft(0)((hIndex, citation) => {\n            val (c, i) = citation\n            if (c >= i + 1) Math.max(hIndex, i + 1) else hIndex\n        })\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn h_index(citations: Vec<i32>) -> i32 {\n        let n = citations.len();\n        let mut count = vec![0; n + 1];\n\n        for &citation in &citations {\n            if citation >= n as i32 {\n                count[n] += 1;\n            } else {\n                count[citation as usize] += 1;\n            }\n        }\n\n        let mut sum = 0;\n        for i in (0..=n).rev() {\n            sum += count[i];\n            if sum >= i {\n                return i as i32;\n            }\n        }\n\n        0\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec h_index(Citations :: [integer()]) -> integer().\nh_index(Citations) ->\n    lists:last([H || H <- lists:seq(0, length(Citations)), H =< lists:sum([1 || C <- Citations, C >= H])])."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you can determine the h-index by following these steps: Sort the citations in descending order, then iterate through them and find the point where the citation count is less than or equal to the paper index.\n\n# Explanation\n1. **Sorting**: First, sort the array of citation counts in descending order.\n2. **Counting**: Initialize a count `i` to zero, then iterate through each citation. For each citation, check if the citation count is greater than the index `i` (plus one, since indices are zero-based).\n3. **Check Condition**: If the citation count is greater than the index, increment the index counter. If the condition fails, the index counter will be the h-index.\n4. **Return Result**: Finally, return the value of `i` which represents the highest number of papers with citation counts that meet or exceed this index.\n\n# Pseudocode\n```\nfunction hIndex(citations):\n    # Sort the citations array in descending order\n    sort(citations in descending order)\n    \n    # Initialize the index counter `i`\n    i = 0\n    \n    # Iterate over the sorted citations\n    while i < length(citations) and citations[i] > i:\n        increment `i` by 1\n    \n    # Return the current value of `i` as the h-index\n    return i\n```\n\nThis pseudocode outlines the logic required to find the h-index given an array of citation counts.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-h-index"
    },
    {
        "name": "Integer To English Words",
        "site": "LeetCode",
        "href": "/solution/LeetCode-integer-to-english-words",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String numberToWords(int num) {\n        if (num == 0) {\n            return \"Zero\";\n        }\n\n        String[] lessThan20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n        String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n        String[] thousands = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\n        int i = 0;\n        String words = \"\";\n\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                words = helper(num % 1000, lessThan20, tens) + thousands[i] + \" \" + words;\n            }\n            num /= 1000;\n            i++;\n        }\n\n        return words.trim();\n    }\n\n    private String helper(int num, String[] lessThan20, String[] tens) {\n        if (num == 0) {\n            return \"\";\n        } else if (num < 20) {\n            return lessThan20[num] + \" \";\n        } else if (num < 100) {\n            return tens[num / 10] + \" \" + helper(num % 10, lessThan20, tens);\n        } else {\n            return lessThan20[num / 100] + \" Hundred \" + helper(num % 100, lessThan20, tens);\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"Zero\"\n        \n        LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def helper(n):\n            if n == 0:\n                return \"\"\n            elif n < 20:\n                return LESS_THAN_20[n] + \" \"\n            elif n < 100:\n                return TENS[n // 10] + \" \" + helper(n % 10)\n            else:\n                return LESS_THAN_20[n // 100] + \" Hundred \" + helper(n % 100)\n        \n        res = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                res = helper(num % 1000) + THOUSANDS[i] + \" \" + res\n            num //= 1000\n            i += 1\n        \n        return res.strip()"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string NumberToWords(int num) {\n        if (num == 0) return \"Zero\";\n\n        string[] belowTen = new string[] { \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" };\n        string[] belowTwenty = new string[] { \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" };\n        string[] belowHundred = new string[] { \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\n        \n        string[] units = new string[] { \"\", \"Thousand\", \"Million\", \"Billion\" };\n\n        int i = 0;\n        string words = \"\";\n\n        while (num > 0)\n        {\n            if (num % 1000 != 0)\n            {\n                words = Helper(num % 1000, belowTen, belowTwenty, belowHundred) + units[i] + \" \" + words;\n            }\n            num /= 1000;\n            i++;\n        }\n\n        return words.Trim();\n    }\n\n    private string Helper(int num, string[] belowTen, string[] belowTwenty, string[] belowHundred)\n    {\n        if (num == 0)\n        {\n            return \"\";\n        }\n        else if (num < 10)\n        {\n            return belowTen[num] + \" \";\n        }\n        else if (num < 20)\n        {\n            return belowTwenty[num] + \" \";\n        }\n        else if (num < 100)\n        {\n            return belowHundred[num / 10] + \" \" + Helper(num % 10, belowTen, belowTwenty, belowHundred);\n        }\n        else\n        {\n            return belowTen[num / 100] + \" Hundred \" + Helper(num % 100, belowTen, belowTwenty, belowHundred);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} num\n * @return {string}\n */\nvar numberToWords = function(num) {\n    if (num === 0) return \"Zero\";\n    const lessThan20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\n    const tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\n    const thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"];\n    \n    const toWords = (num) => {\n        if (num === 0) return \"\";\n        if (num < 20) return lessThan20[num];\n        if (num < 100) return tens[Math.floor(num/10)] + (num % 10 !== 0 ? \" \" + lessThan20[num % 10] : \"\");\n        return lessThan20[Math.floor(num/100)] + \" Hundred\" + (num % 100 !== 0 ? \" \" + toWords(num % 100) : \"\");\n    };\n    \n    let word = \"\", level = 0;\n    while (num > 0) {\n        const part = num % 1000;\n        if (part !== 0) {\n            word = toWords(part) + \" \" + thousands[level] + \" \" + word;\n        }\n        level++;\n        num = Math.floor(num / 1000);\n    }\n    \n    return word.trim();\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numberToWords(num: number): string {\n    if (num === 0) return \"Zero\";\n\n    const under20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\n    const tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\n    const thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"];\n\n    const getString = (num: number): string => {\n        if (num === 0) return \"\";\n        else if (num < 20) return under20[num] + \" \";\n        else if (num < 100) return tens[Math.floor(num / 10)] + \" \" + getString(num % 10);\n        else return under20[Math.floor(num / 100)] + \" Hundred \" + getString(num % 100);\n    };\n\n    let result = \"\";\n    let i = 0;\n\n    while (num > 0) {\n        if (num % 1000 !== 0) {\n            result = getString(num % 1000) + thousands[i] + \" \" + result;\n        }\n        num = Math.floor(num / 1000);\n        i++;\n    }\n\n    return result.trim();\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func numberToWords(_ num: Int) -> String {\n        if num == 0 {\n            return \"Zero\"\n        }\n        \n        let belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                           \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        let tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        let thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        func helper(_ n: Int) -> String {\n            if n == 0 {\n                return \"\"\n            } else if n < 20 {\n                return belowTwenty[n] + \" \"\n            } else if n < 100 {\n                return tens[n / 10] + \" \" + helper(n % 10)\n            } else {\n                return belowTwenty[n / 100] + \" Hundred \" + helper(n % 100)\n            }\n        }\n        \n        var res = \"\"\n        var i = 0\n        var number = num\n        \n        while number > 0 {\n            if number % 1000 != 0 {\n                res = helper(number % 1000) + thousands[i] + \" \" + res\n            }\n            number /= 1000\n            i += 1\n        }\n        \n        return res.trimmingCharacters(in: .whitespaces)\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String numberToWords(int num) {\n    if (num == 0) return \"Zero\";\n    return helper(num);\n  }\n\n  String helper(int num) {\n    List<String> belowTwenty = [\n      \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\n      \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n      \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\n    ];\n\n    List<String> tens = [\n      \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\",\n      \"Eighty\", \"Ninety\"\n    ];\n\n    if (num < 20) {\n      return belowTwenty[num];\n    } else if (num < 100) {\n      return tens[num ~/ 10] + (num % 10 == 0 ? \"\" : \" \" + helper(num % 10));\n    } else if (num < 1000) {\n      return belowTwenty[num ~/ 100] + \" Hundred\" +\n          (num % 100 == 0 ? \"\" : \" \" + helper(num % 100));\n    } else if (num < 1000000) {\n      return helper(num ~/ 1000) + \" Thousand\" + \n          (num % 1000 == 0 ? \"\" : \" \" + helper(num % 1000));\n    } else if (num < 1000000000) {\n      return helper(num ~/ 1000000) + \" Million\" + \n          (num % 1000000 == 0 ? \"\" : \" \" + helper(num % 1000000));\n    } else {\n      return helper(num ~/ 1000000000) + \" Billion\" + \n          (num % 1000000000 == 0 ? \"\" : \" \" + helper(num % 1000000000));\n    }\n  }\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} num\n# @return {String}\ndef number_to_words(num)\n    if num == 0\n        return \"Zero\"\n    end\n\n    less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n    i = 0\n    words = \"\"\n    \n    while num > 0\n        if (num % 1000) != 0\n            words = helper(num % 1000, less_than_20, tens) + thousands[i] + \" \" + words\n        end\n        num = num / 1000\n        i += 1\n    end\n\n    return words.strip\nend\n\ndef helper(num, less_than_20, tens)\n    if num == 0\n        return \"\"\n    elsif num < 20\n        return less_than_20[num] + \" \"\n    elsif num < 100\n        return tens[num/10] + \" \" + helper(num % 10, less_than_20, tens)\n    else\n        return less_than_20[num/100] + \" Hundred \" + helper(num % 100, less_than_20, tens)\n    end\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn number_to_words(num: i32) -> String {\n        if num == 0 {\n            return String::from(\"Zero\");\n        }\n\n        let less_than_20 = vec![\n            \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n            \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\n            \"Eighteen\", \"Nineteen\",\n        ];\n\n        let tens = vec![\n            \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\",\n        ];\n\n        let thousands = vec![\"\", \"Thousand\", \"Million\", \"Billion\"];\n\n        fn helper(num: i32, less_than_20: &Vec<&str>, tens: &Vec<&str>, thousands: &Vec<&str>) -> String {\n            if num == 0 {\n                return String::new();\n            } else if num < 20 {\n                return less_than_20[num as usize].to_string() + \" \";\n            } else if num < 100 {\n                return tens[(num / 10) as usize].to_string() + \" \" + &helper(num % 10, less_than_20, tens, thousands);\n            } else {\n                return less_than_20[(num / 100) as usize].to_string()\n                    + \" Hundred \"\n                    + &helper(num % 100, less_than_20, tens, thousands);\n            }\n        }\n\n        let mut result = String::new();\n        let mut i = 0;\n        let mut num = num;\n\n        while num > 0 {\n            if num % 1000 != 0 {\n                result = helper(num % 1000, &less_than_20, &tens, &thousands) + thousands[i] + \" \" + &result;\n            }\n            num /= 1000;\n            i += 1;\n        }\n\n        result.trim().to_string()\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a non-negative integer to its English words representation. We will break down the number into parts (units, thousands, millions, etc.) and convert each part to words, then combine them for the final output.\n\nHere's the methodology:\n\n1. **Basic Units Representation**:\n   - Define arrays for single digits (1-19) and tens (20, 30, ..., 90).\n   - These will help us convert numbers below 100 directly to words.\n\n2. **Handling Larger Groups**:\n   - Define an array for the thousands groups (Thousand, Million, Billion).\n   - For every 1000's group of the number, convert it to words and append the corresponding thousand group.\n\n3. **Helper Function**:\n   - Create a recursive `helper` function that converts a number less than 1000 to words.\n   - Use the helper function to process each 1000's segment of the original number.\n\n4. **Combining Results**:\n   - Iterate over the number, dividing it into 1000's segments.\n   - Combine the results from the helper function, adding the appropriate thousands group suffix.\n\nHere's the detailed Pseudocode:\n\n```pseudocode\n# Explanation\n# Convert each segment of the number (units, thousands, millions, etc.) to words.\n# Use arrays for numbers less than 20, tens, and thousands groups.\n# Use a helper function to handle numbers less than 1000.\n# Combine results and return the final string.\n\n# Pseudocode\n\nFUNCTION numberToWords(num):\n    IF num == 0:\n        RETURN \"Zero\"\n\n    # Arrays for number words\n    LESS_THAN_20 = [\"\", \"One\", \"Two\", ..., \"Nineteen\"]\n    TENS = [\"\", \"Ten\", \"Twenty\", ..., \"Ninety\"]\n    THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n    # Helper function to process numbers < 1000\n    FUNCTION helper(n):\n        IF n == 0:\n            RETURN \"\"\n        ELSE IF n < 20:\n            RETURN LESS_THAN_20[n] + \" \"\n        ELSE IF n < 100:\n            RETURN TENS[n // 10] + \" \" + helper(n % 10)\n        ELSE:\n            RETURN LESS_THAN_20[n // 100] + \" Hundred \" + helper(n % 100)\n\n    # Main logic for processing the number\n    res = \"\"\n    i = 0\n\n    WHILE num > 0:\n        IF num % 1000 != 0:\n            res = helper(num % 1000) + THOUSANDS[i] + \" \" + res\n        num = num // 1000\n        i += 1\n\n    RETURN res.strip()\n\n# The main function repeatedly processes the last three digits of the number, converts it to words using the \n# helper function, appends the appropriate thousands unit, and then moves on to the next three digits.\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-integer-to-english-words"
    },
    {
        "name": "Missing Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-missing-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n        return expectedSum - actualSum;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n        return expectedSum - actualSum;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        total = n * (n + 1) // 2\n        return total - sum(nums)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int missingNumber(int* nums, int numsSize) {\n    int total = numsSize * (numsSize + 1) / 2;\n    for (int i = 0; i < numsSize; i++) {\n        total -= nums[i];\n    }\n    return total;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MissingNumber(int[] nums) {\n        int n = nums.Length;\n        int sum = n * (n + 1) / 2;\n        foreach (int num in nums) {\n            sum -= num;\n        }\n        return sum;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function(nums) {\n    let n = nums.length;\n    let totalSum = (n * (n + 1)) / 2;\n    let currentSum = nums.reduce((acc, num) => acc + num, 0);\n    return totalSum - currentSum;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function missingNumber(nums: number[]): number {\n    const n = nums.length;\n    let expectedSum = (n * (n + 1)) / 2;\n    let actualSum = nums.reduce((acc, num) => acc + num, 0);\n    return expectedSum - actualSum;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function missingNumber($nums) {\n        $n = count($nums);\n        $expectedSum = $n * ($n + 1) / 2;\n        $actualSum = array_sum($nums);\n        return $expectedSum - $actualSum;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func missingNumber(_ nums: [Int]) -> Int {\n        let n = nums.count\n        var sum = n * (n + 1) / 2\n        \n        for num in nums {\n            sum -= num\n        }\n        \n        return sum\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun missingNumber(nums: IntArray): Int {\n        var sum = nums.size * (nums.size + 1) / 2\n        for (num in nums) {\n            sum -= num\n        }\n        return sum\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int missingNumber(List<int> nums) {\n    int n = nums.length;\n    int totalSum = n * (n + 1) ~/ 2;\n    int sum = nums.fold(0, (prev, element) => prev + element);\n    return totalSum - sum;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func missingNumber(nums []int) int {\n    n := len(nums)\n    expectedSum := n * (n + 1) / 2\n    actualSum := 0\n\n    for _, num := range nums {\n        actualSum += num\n    }\n\n    return expectedSum - actualSum\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef missing_number(nums)\n    n = nums.length\n    total_sum = n * (n + 1) / 2\n    nums_sum = nums.sum\n    return total_sum - nums_sum\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def missingNumber(nums: Array[Int]): Int = {\n        val n = nums.length\n        val expectedSum = n * (n + 1) / 2\n        val actualSum = nums.sum\n        expectedSum - actualSum\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn missing_number(nums: Vec<i32>) -> i32 {\n        let n = nums.len() as i32;\n        let expected_sum = n * (n + 1) / 2;\n        let sum: i32 = nums.iter().sum();\n        \n        expected_sum - sum\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec missing_number(Nums :: [integer()]) -> integer().\nmissing_number(Nums) ->\n    lists:nth(1, lists:seq(0, length(Nums)) -- Nums).\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec missing_number(nums :: [integer]) :: integer\n  def missing_number(nums) do\n    n = length(nums)\n    expected_sum = div(n * (n + 1), 2)\n    actual_sum = Enum.sum(nums)\n    expected_sum - actual_sum\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a mathematical approach to determine the missing number in the array. The idea is to calculate the sum of the first \\( n \\) natural numbers and then subtract the sum of the elements in the given array from this total. The difference will be the missing number.\n\n## # Explanation:\n1. Calculate the length of the array \\( n \\).\n2. Compute the sum of the first \\( n \\) natural numbers using the formula: \\(\\text{sum\\_of\\_first\\_n\\_numbers} = \\frac{n \\times (n + 1)}{2}\\).\n3. Calculate the sum of the numbers present in the provided array.\n4. The missing number is the difference between the sum of the first \\( n \\) natural numbers and the sum of the numbers in the array.\n\n## # Pseudocode:\n```\nfunction missingNumber(nums):\n    n = length of nums\n    sum_of_first_n_numbers = n * (n + 1) / 2\n    sum_of_nums = sum of all elements in nums\n    missing_number = sum_of_first_n_numbers - sum_of_nums\n    return missing_number\n```\n\nThis approach ensures an O(n) runtime complexity and uses O(1) extra space, satisfying the constraints given in the problem statement.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-missing-number"
    },
    {
        "name": "Ugly Number Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-ugly-number-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> ugly(n);\n        ugly[0] = 1;\n        int idx2 = 0, idx3 = 0, idx5 = 0;\n        int factor2 = 2, factor3 = 3, factor5 = 5;\n        \n        for (int i = 1; i < n; i++) {\n            int minFactor = min({factor2, factor3, factor5});\n            ugly[i] = minFactor;\n            \n            if (factor2 == minFactor) factor2 = 2 * ugly[++idx2];\n            if (factor3 == minFactor) factor3 = 3 * ugly[++idx3];\n            if (factor5 == minFactor) factor5 = 5 * ugly[++idx5];\n        }\n        \n        return ugly[n - 1];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int nthUglyNumber(int n) {\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        int index2 = 0, index3 = 0, index5 = 0;\n        int factor2 = 2, factor3 = 3, factor5 = 5;\n\n        for (int i = 1; i < n; i++) {\n            int min = Math.min(Math.min(factor2, factor3), factor5);\n            ugly[i] = min;\n\n            if (factor2 == min) {\n                factor2 = 2 * ugly[++index2];\n            }\n            if (factor3 == min) {\n                factor3 = 3 * ugly[++index3];\n            }\n            if (factor5 == min) {\n                factor5 = 5 * ugly[++index5];\n            }\n        }\n\n        return ugly[n - 1];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def nthUglyNumber(self, n):\n        ugly = [1]\n        i2, i3, i5 = 0, 0, 0\n        while len(ugly) < n:\n            next_ugly = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)\n            ugly.append(next_ugly)\n            if next_ugly == ugly[i2] * 2:\n                i2 += 1\n            if next_ugly == ugly[i3] * 3:\n                i3 += 1\n            if next_ugly == ugly[i5] * 5:\n                i5 += 1\n        return ugly[-1]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int nthUglyNumber(int n) {\n    int ugly[n];\n    ugly[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n    int next_multiple_of_2 = 2;\n    int next_multiple_of_3 = 3;\n    int next_multiple_of_5 = 5;\n    int next_ugly_no = 1;\n    \n    for (int i = 1; i < n; i++) {\n        next_ugly_no = next_multiple_of_2 < next_multiple_of_3 ? (next_multiple_of_2 < next_multiple_of_5 ? next_multiple_of_2 : next_multiple_of_5) : (next_multiple_of_3 < next_multiple_of_5 ? next_multiple_of_3 : next_multiple_of_5);\n        ugly[i] = next_ugly_no;\n        \n        if (next_ugly_no == next_multiple_of_2) {\n            i2++;\n            next_multiple_of_2 = ugly[i2] * 2;\n        }\n            \n        if (next_ugly_no == next_multiple_of_3) {\n            i3++;\n            next_multiple_of_3 = ugly[i3] * 3;\n        }\n            \n        if (next_ugly_no == next_multiple_of_5) {\n            i5++;\n            next_multiple_of_5 = ugly[i5] * 5;\n        }\n    }\n    \n    return next_ugly_no;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NthUglyNumber(int n) {\n        if(n<=0) return 0;\n        \n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        int index2 = 0, index3 = 0, index5 = 0;\n        int factor2 = 2, factor3 = 3, factor5 = 5;\n        \n        for(int i=1; i<n; i++){\n            int min = Math.Min(Math.Min(factor2, factor3), factor5);\n            ugly[i] = min;\n            \n            if(factor2 == min) factor2 = 2 * ugly[++index2];\n            if(factor3 == min) factor3 = 3 * ugly[++index3];\n            if(factor5 == min) factor5 = 5 * ugly[++index5];\n        }\n        \n        return ugly[n-1];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    let ugly = [1];\n    let index2 = 0, index3 = 0, index5 = 0;\n    \n    while (ugly.length < n) {\n        let next = Math.min(ugly[index2] * 2, ugly[index3] * 3, ugly[index5] * 5);\n        ugly.push(next);\n        \n        if (next === ugly[index2] * 2) index2++;\n        if (next === ugly[index3] * 3) index3++;\n        if (next === ugly[index5] * 5) index5++;\n    }\n    \n    return ugly[n - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function nthUglyNumber(n: number): number {\n    const dp: number[] = new Array(n);\n    dp[0] = 1;\n    \n    let p2 = 0, p3 = 0, p5 = 0;\n    \n    for (let i = 1; i < n; i++) {\n        dp[i] = Math.min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5);\n        \n        if (dp[i] === dp[p2] * 2) {\n            p2++;\n        }\n        if (dp[i] === dp[p3] * 3) {\n            p3++;\n        }\n        if (dp[i] === dp[p5] * 5) {\n            p5++;\n        }\n    }\n    \n    return dp[n - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     */\n    function nthUglyNumber($n) {\n        $ugly = [1];\n        $i2 = $i3 = $i5 = 0;\n\n        while(count($ugly) < $n) {\n            $next = min($ugly[$i2] * 2, $ugly[$i3] * 3, $ugly[$i5] * 5);\n            $ugly[] = $next;\n\n            if ($next == $ugly[$i2] * 2) $i2++;\n            if ($next == $ugly[$i3] * 3) $i3++;\n            if ($next == $ugly[$i5] * 5) $i5++;\n        }\n\n        return $ugly[$n - 1];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func nthUglyNumber(_ n: Int) -> Int {\n        var ugly = [1]\n        var i = 0, j = 0, k = 0\n        \n        while ugly.count < n {\n            let num2 = ugly[i] * 2\n            let num3 = ugly[j] * 3\n            let num5 = ugly[k] * 5\n            \n            let nextUgly = min(num2, num3, num5)\n            ugly.append(nextUgly)\n            \n            if nextUgly == num2 {\n                i += 1\n            }\n            if nextUgly == num3 {\n                j += 1\n            }\n            if nextUgly == num5 {\n                k += 1\n            }\n        }\n        \n        return ugly[n - 1]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun nthUglyNumber(n: Int): Int {\n        var ugly = IntArray(n)\n        ugly[0] = 1\n\n        var i2 = 0\n        var i3 = 0\n        var i5 = 0\n\n        var next_multiple_of_2 = 2\n        var next_multiple_of_3 = 3\n        var next_multiple_of_5 = 5\n\n        for (i in 1 until n) {\n            val min = minOf(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5)\n            ugly[i] = min\n\n            if (min == next_multiple_of_2) {\n                i2++\n                next_multiple_of_2 = ugly[i2] * 2\n            }\n\n            if (min == next_multiple_of_3) {\n                i3++\n                next_multiple_of_3 = ugly[i3] * 3\n            }\n\n            if (min == next_multiple_of_5) {\n                i5++\n                next_multiple_of_5 = ugly[i5] * 5\n            }\n        }\n\n        return ugly[n - 1]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int nthUglyNumber(int n) {\n    List<int> ugly = List.filled(n, 0);\n    ugly[0] = 1;\n    int idx2 = 0, idx3 = 0, idx5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = [factor2, factor3, factor5].reduce((value, element) => value > element ? element : value);\n      ugly[i] = min;\n\n      if (min == factor2) {\n        idx2++;\n        factor2 = ugly[idx2] * 2;\n      }\n      if (min == factor3) {\n        idx3++;\n        factor3 = ugly[idx3] * 3;\n      }\n      if (min == factor5) {\n        idx5++;\n        factor5 = ugly[idx5] * 5;\n      }\n    }\n\n    return ugly[n - 1];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func nthUglyNumber(n int) int {\n    ugly := make([]int, n)\n    ugly[0] = 1\n    i2, i3, i5 := 0, 0, 0\n\n    for i := 1; i < n; i++ {\n        ugly[i] = min(ugly[i2]*2, min(ugly[i3]*3, ugly[i5]*5))\n        \n        if ugly[i] == ugly[i2]*2 {\n            i2++\n        }\n        if ugly[i] == ugly[i3]*3 {\n            i3++\n        }\n        if ugly[i] == ugly[i5]*5 {\n            i5++\n        }\n    }\n    \n    return ugly[n-1]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef nth_ugly_number(n)\n    ugly = [1]\n    p2 = p3 = p5 = 0\n    while ugly.length < n\n        next_ugly = [ugly[p2] * 2, ugly[p3] * 3, ugly[p5] * 5].min\n        ugly << next_ugly\n        p2 += 1 if ugly[p2] * 2 <= next_ugly\n        p3 += 1 if ugly[p3] * 3 <= next_ugly\n        p5 += 1 if ugly[p5] * 5 <= next_ugly\n    end\n    ugly.last\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def nthUglyNumber(n: Int): Int = {\n        var ugly = Array.ofDim[Int](n)\n        ugly(0) = 1\n        var idx2 = 0\n        var idx3 = 0\n        var idx5 = 0\n\n        for (i <- 1 until n) {\n            val next2 = ugly(idx2) * 2\n            val next3 = ugly(idx3) * 3\n            val next5 = ugly(idx5) * 5\n\n            val nextUgly = next2.min(next3).min(next5)\n            ugly(i) = nextUgly\n\n            if (nextUgly == next2) idx2 += 1\n            if (nextUgly == next3) idx3 += 1\n            if (nextUgly == next5) idx5 += 1\n        }\n\n        ugly(n - 1)\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (nth-ugly-number n)\n  (-> exact-integer? exact-integer?)\n  (define (ugly? k)\n    (or (= k 1)\n        (and (zero? (remainder k 2)) (ugly? (quotient k 2)))\n        (and (zero? (remainder k 3)) (ugly? (quotient k 3)))\n        (and (zero? (remainder k 5)) (ugly? (quotient k 5))))\n    )\n  \n  (let loop ([count 1] [current 1])\n    (cond\n      [(= count n) current]\n      [(ugly? (add1 current)) (loop (add1 count) (add1 current))]\n      [else (loop count (add1 current))]\n      )\n    )\n  )\n  "
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, one approach is to generate all the ugly numbers in a sequence until the nth ugly number is found. By definition, an ugly number's only prime factors are 2, 3, and 5. Starting with the smallest ugly number, which is 1, we iteratively generate the next potential ugly numbers by multiplying the existing ugly numbers by 2, 3, and 5, and then selecting the smallest new number while avoiding duplicates.\n\nTo break this down further:\n\n1. We start with an initial list containing the first ugly number `[1]`.\n2. Use three pointers, `i2`, `i3`, and `i5`, initialized to 0, representing indices for the next multiplication with 2, 3, and 5 respectively.\n3. In a loop, until we generate `n` ugly numbers:\n   - Calculate the next potential ugly number by taking the minimum of (ugly number at `i2` * 2, ugly number at `i3` * 3, and ugly number at `i5` * 5).\n   - Append this new ugly number to the list.\n   - Increment the respective pointer(s) if the new ugly number equals the value obtained by multiplying with 2, 3, or 5 respectively.\n\nNow, let's see the pseudocode for this approach.\n\n### Pseudocode\n```plaintext\n# Pseudocode for finding the nth ugly number\n\n# Initialize the list of ugly numbers with the first ugly number\nugly_numbers = [1]\nn = input_value (the nth number to find)\n\n# Initialize pointers for multiples of 2, 3, and 5 \ni2, i3, i5 = 0, 0, 0\n\n# Loop until we have n ugly numbers\nwhile len(ugly_numbers) < n:\n    # Determine the next ugly number by taking the minimum of the next multiples of 2, 3, and 5\n    next_ugly = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n    \n    # Append the new ugly number to the list\n    ugly_numbers.append(next_ugly)\n    \n    # Increment the pointer for the factor that matched the next_ugly\n    if next_ugly == ugly_numbers[i2] * 2:\n        i2 += 1\n    if next_ugly == ugly_numbers[i3] * 3:\n        i3 += 1\n    if next_ugly == ugly_numbers[i5] * 5:\n        i5 += 1\n\n# The nth ugly number is the last element in the ugly_numbers list\nreturn ugly_numbers[-1]\n```\n\nThis pseudocode outlines the method for efficiently finding the nth ugly number by leveraging the properties of numbers whose only prime factors are 2, 3, and 5.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-ugly-number-ii"
    },
    {
        "name": "Sliding Window Maximum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sliding-window-maximum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> result;\n        deque<int> dq;\n        \n        for (int i = 0; i < nums.size(); ++i) {\n            while (!dq.empty() && dq.front() < i - k + 1) {\n                dq.pop_front();\n            }\n            \n            while (!dq.empty() && nums[dq.back()] < nums[i]) {\n                dq.pop_back();\n            }\n            \n            dq.push_back(i);\n            if (i >= k - 1) {\n                result.push_back(nums[dq.front()]);\n            }\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || k <= 0) {\n            return new int[0];\n        }\n        \n        int n = nums.length;\n        int[] result = new int[n - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>();\n        \n        for (int i = 0; i < n; i++) {\n            while (!deque.isEmpty() && deque.peek() < i - k + 1) {\n                deque.poll();\n            }\n            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offer(i);\n            if (i - k + 1 >= 0) {\n                result[i - k + 1] = nums[deque.peek()];\n            }\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        from collections import deque\n        if not nums:\n            return []\n        \n        result = []\n        window = deque()\n        \n        for i, num in enumerate(nums):\n            while window and nums[window[-1]] < num:\n                window.pop()\n            \n            window.append(i)\n            \n            if window[0] == i - k:\n                window.popleft()\n            \n            if i >= k - 1:\n                result.append(nums[window[0]])\n        \n        return result"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a function that returns the maximum values in each sliding window of size `k` as it moves from left to right across the provided array of integers.\n\n## # Explanation\n1. **Data Structures**: Utilize a deque (double-ended queue) to store the indices of useful elements within the current window.\n2. **Monotonic Deque**: Maintain a decreasing order of values in the deque, ensuring the deque contains the indices of elements in such a way that the maximum element in the current window is always at the front.\n3. **Sliding the Window**: As you move the window from left to right, ensure you remove indices that fall out of the current window and discard indices from the back of the deque while they represent values smaller than the current element, since these smaller values can never replace the current element as maximum.\n4. **Adding Results**: Once the window starts covering `k` elements, record the maximum (the element at the front of the deque) for each window position.\n\n## # Pseudocode\n\n```\nfunction maxSlidingWindow(nums, k):\n    # Initialize deque to store indices of useful elements within current window.\n    window = deque()\n    result = []  # List to store the results (max in each window)\n\n    for i in range(length of nums):\n        # Remove elements that are out of this window\n        if window is not empty and window[0] == i - k:\n            remove element from the front of the window\n        \n        # Remove all elements smaller than the currently being added element (maintain decreasing order)\n        while window is not empty and nums[window[-1]] < nums[i]:\n            remove element from the back of the window\n        \n        # Add current element at the back of the deque\n        append i to window\n        \n        # Add the maximum for this window (when i >= k-1)\n        if i >= k - 1:\n            append nums[window[0]] to result\n    \n    return result\n```\n\nThis pseudocode outlines the steps required to manage the sliding window and efficiently extract the maximum value for each window position using a deque data structure.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sliding-window-maximum"
    },
    {
        "name": "Trips And Users",
        "site": "LeetCode",
        "href": "/solution/LeetCode-trips-and-users",
        "languages": [
            {
                "name": "MS SQL Server",
                "abbreviation_for_prism_styles": "sql",
                "code": "/* Write your T-SQL query statement below */\n\nWITH CountCancellation AS (\n    SELECT request_at, \n           SUM(CASE WHEN status LIKE 'cancelled_%' THEN 1 ELSE 0 END) AS cancelled_requests,\n           COUNT(*) AS total_requests\n    FROM Trips t\n    JOIN Users uc ON t.client_id = uc.users_id AND uc.banned = 'No'\n    JOIN Users ud ON t.driver_id = ud.users_id AND ud.banned = 'No'\n    WHERE request_at BETWEEN '2013-10-01' AND '2013-10-03'\n    GROUP BY request_at\n)\nSELECT request_at AS Day, \n       ROUND(CAST(cancelled_requests AS FLOAT) / NULLIF(total_requests, 0), 2) AS 'Cancellation Rate'\nFROM CountCancellation;\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to calculate the daily cancellation rate of trips involving unbanned users. Below, we break down the solution into a detailed explanation and pseudocode.\n\n# Explanation\n\n1. **Joining Tables**: We start by joining the `Trips` table with the `Users` table twice - once for the `client_id` and once for the `driver_id`. This allows us to filter out any trips that involve banned users.\n  \n2. **Filtering Dates**: We limit our data to the specified dates: between \"2013-10-01\" and \"2013-10-03\".\n\n3. **Counting Requests**: For each day, we count the total number of requests and the number of cancelled requests (either by the driver or the client).\n\n4. **Calculating Cancellation Rate**: We compute the cancellation rate by dividing the number of cancelled requests by the total number of requests for each day. This result should be rounded to two decimal points.\n\n# Pseudocode\n\n1. Define a function to join tables and apply filters.\n2. Aggregate daily trip counts and cancellation counts.\n3. Calculate and format the cancellation rate for each day.\n\n```plaintext\n# Pseudocode\n\n# Step 1: Join the tables to filter out banned users\nCreate a join between the Trips table (`t`) and the Users table (`uc`) for clients\n  ON t.client_id = uc.users_id AND uc.banned = 'No'\nCreate another join between the joined table and the Users table (`ud`) for drivers\n  ON t.driver_id = ud.users_id AND ud.banned = 'No'\n\n# Step 2: Filter based on the date range\nFilter the joined table to only include trips where `request_at` is between '2013-10-01' and '2013-10-03'\n\n# Step 3: Aggregate the data\nFor each date (`request_at`):\n  Calculate `cancelled_requests` as the count of trips where `status` is in ('cancelled_by_driver', 'cancelled_by_client')\n  Calculate `total_requests` as the total count of trips\n\n# Step 4: Calculate the cancellation rate\nFor each `request_at`:\n  If `total_requests` == 0:\n    Set `cancellation_rate` to 0.00\n  Else:\n    Compute `cancellation_rate` as `cancelled_requests / total_requests`\n    Round `cancellation_rate` to two decimal places\n\n# Step 5: Return the result as a table with columns:\n# - Day (request_at)\n# - Cancellation Rate (cancellation_rate)\n```\n\nWith this structured approach and the provided pseudocode, you can implement the solution in SQL or any suitable programming language, ensuring that the logic captures and processes the data correctly to determine the cancellation rates.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-trips-and-users"
    },
    {
        "name": "Single Number Iii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-single-number-iii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "#include <vector>\n\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        // XOR all numbers to find the XOR of the two single numbers.\n        int xorResult = 0;\n        for (int num : nums) {\n            xorResult ^= num;\n        }\n        \n        // Find the rightmost set bit in the XOR result.\n        int rightmostSetBit = 1;\n        while ((rightmostSetBit & xorResult) == 0) {\n            rightmostSetBit <<= 1;\n        }\n        \n        // Partition the numbers based on the rightmost set bit and XOR them separately.\n        int num1 = 0, num2 = 0;\n        for (int num : nums) {\n            if ((num & rightmostSetBit) == 0) {\n                num1 ^= num;\n            } else {\n                num2 ^= num;\n            }\n        }\n        \n        return {num1, num2};\n    }\n};\n  "
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        int diff = 0;\n        for (int num : nums) {\n            diff ^= num;\n        }\n        \n        diff &= -diff;\n        \n        int[] result = new int[2];\n        for (int num : nums) {\n            if ((num & diff) == 0) {\n                result[0] ^= num;\n            } else {\n                result[1] ^= num;\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        xor_result = 0\n        for num in nums:\n            xor_result ^= num\n        \n        mask = 1\n        while mask & xor_result == 0:\n            mask <<= 1\n        \n        num1 = 0\n        num2 = 0\n        for num in nums:\n            if mask & num:\n                num1 ^= num\n            else:\n                num2 ^= num\n        \n        return [num1, num2]"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar singleNumber = function(nums) {\n    let xor = 0;\n    for (let num of nums) {\n        xor ^= num;\n    }\n    \n    let diff = xor & -xor;\n    let result = [0, 0];\n    \n    for (let num of nums) {\n        if ((num & diff) === 0) {\n            result[0] ^= num;\n        } else {\n            result[1] ^= num;\n        }\n    }\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function singleNumber(nums: number[]): number[] {\n    let xor = 0;\n    for (const num of nums) {\n        xor ^= num;\n    }\n    \n    const diff = xor & -xor;\n    let result = [0, 0];\n    \n    for (const num of nums) {\n        if ((num & diff) === 0) {\n            result[0] ^= num;\n        } else {\n            result[1] ^= num;\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function singleNumber($nums) {\n        $xor = 0;\n        foreach ($nums as $num) {\n            $xor ^= $num;\n        }\n        \n        $mask = 1;\n        while (($mask & $xor) == 0) {\n            $mask <<= 1;\n        }\n        \n        $num1 = 0;\n        $num2 = 0;\n        \n        foreach ($nums as $num) {\n            if (($num & $mask) == 0) {\n                $num1 ^= $num;\n            } else {\n                $num2 ^= $num;\n            }\n        }\n        \n        return [$num1, $num2];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func singleNumber(_ nums: [Int]) -> [Int] {\n        var xor = 0\n        for num in nums {\n            xor ^= num\n        }\n        \n        let lowBit = xor & -xor\n        \n        var result: [Int] = [0, 0]\n        \n        for num in nums {\n            if (num & lowBit) == 0 {\n                result[0] ^= num\n            } else {\n                result[1] ^= num\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun singleNumber(nums: IntArray): IntArray {\n        var diff = 0\n        for (num in nums) {\n            diff = diff.xor(num)\n        }\n        \n        diff = diff.and(-diff)\n        \n        var result = intArrayOf(0, 0)\n        for (num in nums) {\n            if ((num and diff) == 0) {\n                result[0] = result[0].xor(num)\n            } else {\n                result[1] = result[1].xor(num)\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> singleNumber(List<int> nums) {\n    int xorResult = 0;\n    for (int num in nums) {\n      xorResult ^= num;\n    }\n    \n    int mask = 1;\n    while ((xorResult & mask) == 0) {\n      mask <<= 1;\n    }\n    \n    int num1 = 0, num2 = 0;\n    for (int num in nums) {\n      if ((num & mask) == 0) {\n        num1 ^= num;\n      } else {\n        num2 ^= num;\n      }\n    }\n    \n    return [num1, num2];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func singleNumber(nums []int) []int {\n    xor := 0\n    for _, num := range nums {\n        xor ^= num\n    }\n    diff := xor & (-xor)\n    res := make([]int, 2)\n    for _, num := range nums {\n        if (num & diff) == 0 {\n            res[0] ^= num\n        } else {\n            res[1] ^= num\n        }\n    }\n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef single_number(nums)\n    xor = 0\n    for num in nums\n        xor ^= num\n    end\n    \n    mask = 1\n    while (xor & mask) == 0\n        mask <<= 1\n    end\n    \n    a = 0\n    b = 0\n    for num in nums\n        if (num & mask) == 0\n            a ^= num\n        else\n            b ^= num\n        end\n    end\n    \n    return [a, b]\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def singleNumber(nums: Array[Int]): Array[Int] = {\n        val xorOfTwoNums = nums.reduce(_ ^ _)\n        val diffBit = xorOfTwoNums & (-xorOfTwoNums)\n        var res = Array(0, 0)\n        \n        for (num <- nums) {\n            if ((num & diffBit) == 0) {\n                res(0) ^= num\n            } else {\n                res(1) ^= num\n            }\n        }\n        \n        res\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> Vec<i32> {\n        let mut xor = 0;\n        for &num in &nums {\n            xor ^= num;\n        }\n        \n        let rightmost_set_bit = xor & -xor;\n        let mut res = vec![0; 2];\n        \n        for &num in &nums {\n            if (num & rightmost_set_bit) == 0 {\n                res[0] ^= num;\n            } else {\n                res[1] ^= num;\n            }\n        }\n        \n        res\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec single_number(Nums :: [integer()]) -> [integer()].\nsingle_number(Nums) ->\n    {A, B} = lists:foldl(\n        fun(X, {A, B}) ->\n            {A bxor X, B}\n        end, {0, 0}, Nums),\n    \n    Mask = A band (-A),\n    \n    {Res1, Res2} = lists:foldl(\n        fun(X, {A, B}) ->\n            if X band Mask =:= 0 -> {A bxor X, B};\n               true -> {A, B bxor X}\n            end\n        end, {0, 0}, Nums),\n    \n    [Res1, Res2].\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to identify the two elements in an array that appear exactly once while all other elements appear exactly twice. The solution should have linear runtime complexity and use only constant extra space.\n\n# Explanation\n1. **XOR Operation Insight**: When you XOR all the elements in the array, the result will be the XOR of the two unique numbers because the identical elements will cancel each other out.\n2. **Finding the Differentiating Bit**: By isolating the rightmost bit where these two unique numbers differ, you can divide all elements into two groups - one group with this bit set and another without it.\n3. **Final XOR in Groups**: XORing the numbers in each of these groups will isolate the two unique numbers.\n\n# Pseudocode\n\n```\nfunction findSingleNumbers(nums):\n    // Step 1: XOR all elements to get xor_result\n    xor_result = 0\n    for num in nums:\n        xor_result = xor_result XOR num\n\n    // Step 2: Find a mask that indicates the first differing bit\n    mask = 1\n    while (xor_result AND mask) == 0:\n        mask = mask << 1\n\n    // Step 3: Divide numbers into two groups based on the mask bit and XOR within groups\n    num1 = 0\n    num2 = 0\n    for num in nums:\n        if num AND mask:\n            num1 = num1 XOR num\n        else:\n            num2 = num2 XOR num\n\n    // Step 4: Return the two unique numbers\n    return [num1, num2]\n```\n\nThis pseudocode ensures a linear time complexity \\(O(n)\\) and constant space complexity \\(O(1)\\) solution by utilizing the properties of the XOR operation effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-single-number-iii"
    },
    {
        "name": "Add Digits",
        "site": "LeetCode",
        "href": "/solution/LeetCode-add-digits",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int addDigits(int num) {\n        if (num == 0) return 0;\n        if (num % 9 == 0) return 9;\n        return num % 9;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int addDigits(int num) {\n        return 1 + (num - 1) % 9;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        return num % 9"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int AddDigits(int num) {\n        if (num == 0)\n            return 0;\n        else if (num % 9 == 0)\n            return 9;\n        else\n            return num % 9;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} num\n * @return {number}\n */\nvar addDigits = function(num) {\n    return 1 + (num - 1) % 9;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function addDigits(num: number): number {\n    return 1 + (num - 1) % 9;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $num\n     * @return Integer\n     */\n    function addDigits($num) {\n        if ($num == 0) {\n            return 0;\n        } elseif ($num % 9 == 0) {\n            return 9;\n        } else {\n            return $num % 9;\n        }\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func addDigits(_ num: Int) -> Int {\n        if num == 0 {\n            return 0\n        } else if num % 9 == 0 {\n            return 9\n        } else {\n            return num % 9\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun addDigits(num: Int): Int {\n        if (num == 0) return 0\n        return 1 + (num - 1) % 9\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int addDigits(int num) {\n    if (num == 0) {\n      return 0;\n    } else if (num % 9 == 0) {\n      return 9;\n    } else {\n      return num % 9;\n    }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func addDigits(num int) int {\n    if num == 0 {\n        return 0\n    } else if num % 9 == 0 {\n        return 9\n    } else {\n        return num % 9\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} num\n# @return {Integer}\ndef add_digits(num)\n    return num == 0 ? 0 : 1 + (num - 1) % 9\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def addDigits(num: Int): Int = {\n        if (num == 0) {\n            0\n        } else if (num % 9 == 0) {\n            9\n        } else {\n            num % 9\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn add_digits(num: i32) -> i32 {\n        if num == 0 {\n            return 0;\n        } else if num % 9 == 0 {\n            return 9;\n        } else {\n            return num % 9;\n        }\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (add-digits num)\n  (-> exact-integer? exact-integer?)\n  (if (= num 0)\n      0\n      (if (= (remainder num 9) 0)\n          9\n          (remainder num 9))\n      )\n  )"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec add_digits(Num :: integer()) -> integer().\nadd_digits(Num) ->\n    case Num rem 9 of\n        0 when Num > 0 -> 9;\n        Digit -> Digit\n    end."
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec add_digits(num :: integer) :: integer\n  def add_digits(num) do\n    if num == 0 do\n      0\n    else\n      rem(num - 1, 9) + 1\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use the concept known as the digital root, which allows us to find the final single-digit sum without repeatedly looping over the digits. Here is a step-by-step explanation and pseudocode to solve the problem.\n\n# Explanation\n\n1. **Understanding the Problem:**\n   - Given an integer `num`, repeatedly add its digits until the result is a single digit.\n   - For example, if `num` is 38, the process is: \n     - 38 -> 3 + 8 = 11\n     - 11 -> 1 + 1 = 2\n   - The answer is 2.\n\n2. **Digital Root Concept:** \n   - The digital root of a non-negative integer is the single-digit value obtained by an iterative process of summing digits. The efficient way to compute this without iterative loops involves the properties of numbers in modulo operation:\n     - If `num` is 0, the result is 0.\n     - If `num` is a multiple of 9, the result is 9.\n     - Otherwise, the result is `num % 9`.\n\n3. **Handling Edge Cases:**\n   - If `num` is 0, we simply return 0.\n\n4. **Complexity and Constraints:**\n   - The solution should work in O(1) time complexity as specified in the follow-up section.\n\n# Pseudocode\n\nBelow is the pseudocode to implement the solution:\n\n```\nfunction addDigits(num):\n    # If the input number is 0, return 0\n    if num == 0:\n        return 0\n    \n    # If the number is exactly divisible by 9, return 9\n    if num % 9 == 0:\n        return 9\n    \n    # Otherwise return the remainder when num is divided by 9\n    return num % 9\n```\n\nThis pseudocode outlines the efficient mathematical approach to solve the problem in constant time without using loops or recursion. The approach leverages properties of number theory to directly compute the single-digit result.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-add-digits"
    },
    {
        "name": "Binary Tree Paths",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-tree-paths",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> paths;\n        if (root == nullptr) {\n            return paths;\n        }\n        binaryTreePathsDFS(root, \"\", paths);\n        return paths;\n    }\n    \n    void binaryTreePathsDFS(TreeNode* node, string path, vector<string>& paths) {\n        if (node->left == nullptr && node->right == nullptr) {\n            paths.push_back(path + to_string(node->val));\n            return;\n        }\n        if (node->left != nullptr) {\n            binaryTreePathsDFS(node->left, path + to_string(node->val) + \"->\", paths);\n        }\n        if (node->right != nullptr) {\n            binaryTreePathsDFS(node->right, path + to_string(node->val) + \"->\", paths);\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> paths = new ArrayList<>();\n        if (root != null) {\n            dfs(root, \"\", paths);\n        }\n        return paths;\n    }\n    \n    private void dfs(TreeNode node, String path, List<String> paths) {\n        if (node.left == null && node.right == null) {\n            paths.add(path + node.val);\n            return;\n        } \n        \n        if (node.left != null) {\n            dfs(node.left, path + node.val + \"->\", paths);\n        }\n        \n        if (node.right != null) {\n            dfs(node.right, path + node.val + \"->\", paths);\n        }\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nvoid binaryTreePathsHelper(struct TreeNode* node, char* path, int pathLen, char** result, int* returnSize) {\n    if (node == NULL) {\n        return;\n    }\n    \n    pathLen += sprintf(path + pathLen, \"%d\", node->val);\n    \n    if (node->left == NULL && node->right == NULL) {\n        path[pathLen] = '\\0';\n        result[(*returnSize)++] = strdup(path);\n        return;\n    } else {\n        pathLen += sprintf(path + pathLen, \"->\");\n        binaryTreePathsHelper(node->left, path, pathLen, result, returnSize);\n        binaryTreePathsHelper(node->right, path, pathLen, result, returnSize);\n    }\n}\n\nchar **binaryTreePaths(struct TreeNode* root, int* returnSize) {\n    char* path = (char*)malloc(1000*sizeof(char)); // Max length assumed\n    char** result = (char**)malloc(1000*sizeof(char*));\n    *returnSize = 0;\n    binaryTreePathsHelper(root, path, 0, result, returnSize);\n    free(path);\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public IList<string> BinaryTreePaths(TreeNode root) {\n        IList<string> paths = new List<string>();\n        if(root == null) return paths;\n        \n        TraverseTree(root, \"\", paths);\n        return paths;\n    }\n    \n    private void TraverseTree(TreeNode node, string pathSoFar, IList<string> paths) {\n        if(node == null) return;\n        \n        pathSoFar += node.val.ToString();\n        \n        if(node.left == null && node.right == null) {\n            paths.Add(pathSoFar);\n        } else {\n            pathSoFar += \"->\";\n            TraverseTree(node.left, pathSoFar, paths);\n            TraverseTree(node.right, pathSoFar, paths);\n        }\n    }\n}\n  "
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "const binaryTreePaths = function(root) {\n    const paths = [];\n    \n    const constructPaths = function(node, path) {\n        if (node) {\n            path += node.val.toString();\n            if (node.left === null && node.right === null) {\n                paths.push(path);\n            } else {\n                path += '->';\n                constructPaths(node.left, path);\n                constructPaths(node.right, path);\n            }\n        }\n    };\n    \n    constructPaths(root, '');\n    \n    return paths;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val)\n *         this.left = (left === undefined ? null : left)\n *         this.right = (right === undefined ? null : right)\n *     }\n * }\n */\n\nfunction binaryTreePaths(root: TreeNode | null): string[] {\n    const paths: string[] = [];\n    \n    const buildPath = (node: TreeNode, path: string) => {\n        if (!node) return;\n        \n        path += node.val.toString();\n        if (!node.left && !node.right) {\n            paths.push(path);\n        } else {\n            path += '->';\n            buildPath(node.left, path);\n            buildPath(node.right, path);\n        }\n    }\n    \n    buildPath(root, '');\n    return paths;\n}\n  "
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @return String[]\n     */\n    function binaryTreePaths($root) {\n        $paths = [];\n        $this->dfs($root, \"\", $paths);\n        return $paths;\n    }\n    \n    function dfs($node, $path, &$paths) {\n        if ($node) {\n            $path .= $node->val;\n            if (!$node->left && !$node->right) {\n                $paths[] = $path;\n            } else {\n                $path .= \"->\";\n                $this->dfs($node->left, $path, $paths);\n                $this->dfs($node->right, $path, $paths);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun binaryTreePaths(root: TreeNode?): List<String> {\n        val paths = mutableListOf<String>()\n        if (root == null) {\n            return paths\n        }\n        dfs(root, \"\", paths)\n        return paths\n    }\n    \n    private fun dfs(node: TreeNode, path: String, paths: MutableList<String>) {\n        if (node.left == null && node.right == null) {\n            paths.add(path + node.`val`)\n            return\n        }\n        if (node.left != null) {\n            dfs(node.left!!, \"$path${node.`val`}->\", paths)\n        }\n        if (node.right != null) {\n            dfs(node.right!!, \"$path${node.`val`}->\", paths)\n        }\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \nfunc binaryTreePaths(root *TreeNode) []string {\n    var paths []string\n    if root == nil {\n        return paths\n    }\n    \n    var dfs func(node *TreeNode, path string)\n    dfs = func(node *TreeNode, path string) {\n        if node == nil {\n            return\n        }\n        path += strconv.Itoa(node.Val)\n        if node.Left == nil && node.Right == nil {\n            paths = append(paths, path)\n        } else {\n            path += \"->\"\n            dfs(node.Left, path)\n            dfs(node.Right, path)\n        }\n    }\n    \n    dfs(root, \"\")\n    \n    return paths\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class TreeNode\n    attr_accessor :val, :left, :right\n    def initialize(val = 0, left = nil, right = nil)\n        @val = val\n        @left = left\n        @right = right\n    end\nend\n\ndef binary_tree_paths(root)\n    paths = []\n    \n    def dfs(node, path, paths)\n        return if node.nil?\n        \n        path += \"#{node.val}\"\n        \n        if node.left.nil? && node.right.nil?\n            paths << path\n        else\n            path += \"->\"\n            dfs(node.left, path, paths)\n            dfs(node.right, path, paths)\n        end\n    end\n    \n    dfs(root, \"\", paths)\n    return paths\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def binaryTreePaths(root: TreeNode): List[String] = {\n        def paths(node: TreeNode, path: String): List[String] = {\n            if (node == null) {\n                List()\n            } else if (node.left == null && node.right == null) {\n                List(path + node.value)\n            } else {\n                paths(node.left, path + node.value + \"->\") ::: paths(node.right, path + node.value + \"->\")\n            }\n        }\n        \n        paths(root, \"\").toList\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse a given binary tree and collect all root-to-leaf paths. \n\n# Explanation\n\n1. **Input Representation**: The input is the root node of a binary tree. Each node contains a value and references to its left and right child nodes.\n2. **Output Requirements**: We need to return a list of all root-to-leaf paths. Each path should be formatted as a string where node values are connected with '->'.\n3. **Constraints**: Since node values are between -100 and 100 and there are up to 100 nodes, the solution should efficiently handle this range of inputs.\n\n# Strategy\n\nWe will use a Depth-First Search (DFS) approach to explore each path from the root to the leaves. During the traversal:\n- Accumulate the path as a string.\n- When a leaf node is encountered (i.e., a node with no children), add the path to the result list.\n\nHere\u2019s the step-by-step plan:\n\n1. **Base Case**: If the root is `None`, return an empty list since there are no paths.\n2. **DFS Traversal**:\n    - Start from the root, and for each node:\n        - Append the node\u2019s value to the current path string.\n        - If both left and right children are `None`, it\u2019s a leaf node. Add the current path to the result list.\n        - Otherwise, continue the traversal for left and right child nodes by updating the path accordingly.\n3. **Return the result list containing all paths from root to leaves.**\n\n# Pseudocode\n\n```\nfunction binaryTreePaths(root):\n    if root is None:\n        return []\n    \n    paths = []\n    \n    function constructPaths(node, path):\n        if node is not None:\n            path += str(node.val)\n            if node.left is None and node.right is None:\n                paths.append(path)  # it's a leaf, add the path to the result list\n            else:\n                path += '->'  # not a leaf, extend the path\n                constructPaths(node.left, path)\n                constructPaths(node.right, path)\n    \n    constructPaths(root, \"\")\n    return paths\n```\n\nThis pseudocode outlines the high-level logic required for solving the given challenge. Each step is focused on correctly accumulating paths from the root to each leaf node using a DFS traversal strategy.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-tree-paths"
    },
    {
        "name": "Valid Anagram",
        "site": "LeetCode",
        "href": "/solution/LeetCode-valid-anagram",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        \n        unordered_map<char, int> freq;\n        \n        for (char c : s) {\n            freq[c]++;\n        }\n        \n        for (char c : t) {\n            if (freq.find(c) == freq.end() || freq[c] == 0) {\n                return false;\n            }\n            freq[c]--;\n        }\n        \n        return true;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        \n        int[] count = new int[26];\n        \n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        \n        for (int num : count) {\n            if (num != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        \n        return sorted(s) == sorted(t)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isAnagram(char* s, char* t) {\n    int s_len = strlen(s);\n    int t_len = strlen(t);\n    \n    if (s_len != t_len) {\n        return false;\n    }\n    \n    int char_count[26] = {0};\n    \n    for (int i = 0; i < s_len; i++) {\n        char_count[s[i] - 'a']++;\n        char_count[t[i] - 'a']--;\n    }\n    \n    for (int i = 0; i < 26; i++) {\n        if (char_count[i] != 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsAnagram(string s, string t) {\n        if (s.Length != t.Length)\n            return false;\n\n        int[] count = new int[26];\n\n        for (int i = 0; i < s.Length; i++)\n        {\n            count[s[i] - 'a']++;\n            count[t[i] - 'a']--;\n        }\n\n        foreach (var c in count)\n        {\n            if (c != 0)\n                return false;\n        }\n\n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isAnagram = (s, t) => {\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    const sMap = new Map();\n    const tMap = new Map();\n    \n    for (let char of s) {\n        sMap.set(char, sMap.get(char) + 1 || 1);\n    }\n    \n    for (let char of t) {\n        tMap.set(char, tMap.get(char) + 1 || 1);\n    }\n    \n    for (let [key, value] of sMap) {\n        if (tMap.get(key) !== value) {\n            return false;\n        }\n    }\n    \n    return true;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isAnagram(s: string, t: string): boolean {\n    if (s.length !== t.length) {\n        return false;\n    }\n\n    const sMap: Map<string, number> = new Map();\n    const tMap: Map<string, number> = new Map();\n\n    for (let i = 0; i < s.length; i++) {\n        sMap.set(s[i], (sMap.get(s[i]) || 0) + 1);\n        tMap.set(t[i], (tMap.get(t[i]) || 0) + 1);\n    }\n\n    for (const [key, value] of sMap) {\n        if (tMap.get(key) !== value) {\n            return false;\n        }\n    }\n\n    return true;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Boolean\n     */\n    function isAnagram($s, $t) {\n        if (strlen($s) != strlen($t)) {\n            return false;\n        }\n        \n        $sArr = str_split($s);\n        $tArr = str_split($t);\n        \n        sort($sArr);\n        sort($tArr);\n        \n        return $sArr == $tArr;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isAnagram(_ s: String, _ t: String) -> Bool {\n        if s.count != t.count {\n            return false\n        }\n        \n        var sFreq = Array(repeating: 0, count: 26)\n        var tFreq = Array(repeating: 0, count: 26)\n        \n        for char in s {\n            let index = Int(char.asciiValue! - 97)\n            sFreq[index] += 1\n        }\n        \n        for char in t {\n            let index = Int(char.asciiValue! - 97)\n            tFreq[index] += 1\n        }\n        \n        return sFreq == tFreq\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isAnagram(s: String, t: String): Boolean {\n        if (s.length != t.length) return false\n        val sArray = s.toCharArray()\n        val tArray = t.toCharArray()\n        sArray.sort()\n        tArray.sort()\n        return sArray.contentEquals(tArray)\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isAnagram(String s, String t) {\n      if (s.length != t.length) {\n          return false;\n      }\n      \n      Map<int, int> count = {};\n      \n      for (int i = 0; i < s.length; i++) {\n          count[s.runes.elementAt(i)] = (count[s.runes.elementAt(i)] ?? 0) + 1;\n          count[t.runes.elementAt(i)] = (count[t.runes.elementAt(i)] ?? 0) - 1;\n      }\n      \n      for (int value in count.values) {\n          if (value != 0) {\n              return false;\n          }\n      }\n      \n      return true;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isAnagram(s string, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n\n    sFreq := make(map[rune]int)\n    tFreq := make(map[rune]int)\n\n    for _, char := range s {\n        sFreq[char]++\n    }\n\n    for _, char := range t {\n        tFreq[char]++\n    }\n\n    for char, freq := range sFreq {\n        if tFreq[char] != freq {\n            return false\n        }\n    }\n\n    return true\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {String} t\n# @return {Boolean}\ndef is_anagram(s, t)\n    return false if s.length != t.length\n    \n    s.chars.sort == t.chars.sort\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isAnagram(s: String, t: String): Boolean = {\n        s.sorted == t.sorted\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_anagram(s: String, t: String) -> bool {\n        if s.len() != t.len() {\n            return false;\n        }\n        \n        let mut s_chars: Vec<char> = s.chars().collect();\n        let mut t_chars: Vec<char> = t.chars().collect();\n        \n        s_chars.sort();\n        t_chars.sort();\n        \n        for i in 0..s_chars.len() {\n            if s_chars[i] != t_chars[i] {\n                return false;\n            }\n        }\n        \n        true\n    }\n}"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec is_anagram(s :: String.t, t :: String.t) :: boolean\n  def is_anagram(s, t) do\n    Enum.sort(String.graphemes(s)) == Enum.sort(String.graphemes(t))\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if one string is an anagram of another by rearranging the letters.\n\n### # Explanation:\n1. **Definition Check**: An anagram is a rearrangement of letters of one word to form another word, using all the original letters exactly once.\n2. **Length Check**: If the two strings, \\( s \\) and \\( t \\), are of different lengths, they can't be anagrams.\n3. **Sorting Check**: By sorting the characters of both strings and comparing them, we can determine if they are anagrams.\n4. **Edge Cases**: Consider constraints (both strings contain only lowercase English letters) and handle any empty string scenarios.\n\n### # Pseudocode:\n```plaintext\n# Function to check if two strings are anagrams\nfunction isAnagram(s, t):\n    # If lengths of s and t are different, return False\n    if length(s) != length(t):\n        return False\n\n    # Sort both strings\n    sorted_s = sort(s)\n    sorted_t = sort(t)\n\n    # Compare sorted versions of s and t\n    if sorted_s == sorted_t:\n        return True\n    else:\n        return False\n\n# Additional edge cases handling for Unicode characters\n# (Assuming inputs might be expanded to include Unicode characters in follow-up)\nfunction isUnicodeAnagram(s, t):\n    # Normalize strings to Unicode NFC form (canonical composition)\n    normalized_s = normalize(s, \"NFC\")\n    normalized_t = normalize(t, \"NFC\")\n\n    # Proceed with the isAnagram process on the normalized strings\n    return isAnagram(normalized_s, normalized_t)\n```\n\n### Explanation:\n1. **Function** `isAnagram(s, t)`:\n   - Check if the lengths of `s` and `t` are equal. If not, they can't be anagrams.\n   - Sort both strings and compare the sorted versions.\n   - Return `True` if sorted versions match, otherwise `False`.\n\n2. **Handling Unicode Characters**:\n   - Normalize both strings using Unicode normalization forms like NFC (Normalization Form C) to ensure equivalent characters have a unique representation.\n   - Apply the same `isAnagram` logic to these normalized strings.\n\nThis methodology ensures that the solution is both simple and efficient, adhering to the given constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-valid-anagram"
    },
    {
        "name": "Different Ways To Add Parentheses",
        "site": "LeetCode",
        "href": "/solution/LeetCode-different-ways-to-add-parentheses",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> diffWaysToCompute(string expression) {\n        vector<int> res;\n        for (int i = 0; i < expression.size(); i++) {\n            char c = expression[i];\n            if (c == '+' || c == '-' || c == '*') {\n                vector<int> left = diffWaysToCompute(expression.substr(0, i));\n                vector<int> right = diffWaysToCompute(expression.substr(i + 1));\n                for (int l : left) {\n                    for (int r : right) {\n                        if (c == '+') {\n                            res.push_back(l + r);\n                        } else if (c == '-') {\n                            res.push_back(l - r);\n                        } else {\n                            res.push_back(l * r);\n                        }\n                    }\n                }\n            }\n        }\n        if (res.empty()) {\n            res.push_back(stoi(expression));\n        }\n        return res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Solution {\n    Map<String, List<Integer>> memo = new HashMap<>();\n\n    public List<Integer> diffWaysToCompute(String input) {\n        if (memo.containsKey(input)) {\n            return memo.get(input);\n        }\n\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c == '+' || c == '-' || c == '*') {\n                List<Integer> leftPart = diffWaysToCompute(input.substring(0, i));\n                List<Integer> rightPart = diffWaysToCompute(input.substring(i + 1));\n\n                for (int left : leftPart) {\n                    for (int right : rightPart) {\n                        if (c == '+') {\n                            result.add(left + right);\n                        } else if (c == '-') {\n                            result.add(left - right);\n                        } else if (c == '*') {\n                            result.add(left * right);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (result.isEmpty()) {\n            result.add(Integer.parseInt(input));\n        }\n\n        memo.put(input, result);\n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def diffWaysToCompute(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: List[int]\n        \"\"\"\n        def compute(left, right, op):\n            results = []\n            for l in left:\n                for r in right:\n                    if op == '+':\n                        results.append(l + r)\n                    elif op == '-':\n                        results.append(l - r)\n                    elif op == '*':\n                        results.append(l * r)\n            return results\n        \n        if expression.isdigit():\n            return [int(expression)]\n        \n        results = []\n        for i in range(len(expression)):\n            if expression[i] in ['+', '-', '*']:\n                left = self.diffWaysToCompute(expression[:i])\n                right = self.diffWaysToCompute(expression[i+1:])\n                \n                results.extend(compute(left, right, expression[i]))\n        \n        return results"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> DiffWaysToCompute(string expression) {\n        var result = new List<int>();\n        for (int i = 0; i < expression.Length; i++) {\n            char c = expression[i];\n            if (c == '+' || c == '-' || c == '*') {\n                string part1 = expression.Substring(0, i);\n                string part2 = expression.Substring(i + 1);\n                var part1Res = DiffWaysToCompute(part1);\n                var part2Res = DiffWaysToCompute(part2);\n                foreach (var p1 in part1Res) {\n                    foreach (var p2 in part2Res) {\n                        switch (c) {\n                            case '+':\n                                result.Add(p1 + p2);\n                                break;\n                            case '-':\n                                result.Add(p1 - p2);\n                                break;\n                            case '*':\n                                result.Add(p1 * p2);\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        if (result.Count == 0) {\n            result.Add(int.Parse(expression));\n        }\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} expression\n * @return {number[]}\n */\nvar diffWaysToCompute = function(expression) {\n    const memo = new Map();\n    \n    const compute = (expression) => {\n        if (memo.has(expression)) return memo.get(expression);\n        \n        const result = [];\n        \n        for (let i = 0; i < expression.length; i++) {\n            const char = expression[i];\n            if (char === '+' || char === '-' || char === '*') {\n                const left = compute(expression.substring(0, i));\n                const right = compute(expression.substring(i + 1));\n                \n                for (const l of left) {\n                    for (const r of right) {\n                        if (char === '+') {\n                            result.push(l + r);\n                        } else if (char === '-') {\n                            result.push(l - r);\n                        } else if (char === '*') {\n                            result.push(l * r);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (result.length === 0) {\n            result.push(parseInt(expression));\n        }\n        \n        memo.set(expression, result);\n        return result;\n    }\n    \n    return compute(expression);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function diffWaysToCompute(expression: string): number[] {\n    const memo: Map<string, number[]> = new Map();\n\n    const compute = (exp: string): number[] => {\n      if (memo.has(exp)) return memo.get(exp)!;\n  \n      const result: number[] = [];\n      for (let i = 0; i < exp.length; i++) {\n        const char = exp[i];\n        if (char === '+' || char === '-' || char === '*') {\n          const left = compute(exp.slice(0, i));\n          const right = compute(exp.slice(i + 1));\n          for (const num1 of left) {\n            for (const num2 of right) {\n              if (char === '+') {\n                result.push(num1 + num2);\n              } else if (char === '-') {\n                result.push(num1 - num2);\n              } else if (char === '*') {\n                result.push(num1 * num2);\n              }\n            }\n          }\n        }\n      }\n  \n      if (result.length === 0) {\n        result.push(parseInt(exp));\n      }\n  \n      memo.set(exp, result);\n      return result;\n    };\n  \n    return compute(expression);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $expression\n     * @return Integer[]\n     */\n    function diffWaysToCompute($expression) {\n        $output = [];\n        \n        if (is_numeric($expression)) {\n            return [$expression];\n        }\n        \n        for ($i = 0; $i < strlen($expression); $i++) {\n            $char = $expression[$i];\n            \n            if ($char == '+' || $char == '-' || $char == '*') {\n                $leftPart = $this->diffWaysToCompute(substr($expression, 0, $i));\n                $rightPart = $this->diffWaysToCompute(substr($expression, $i + 1));\n                \n                foreach ($leftPart as $left) {\n                    foreach ($rightPart as $right) {\n                        switch ($char) {\n                            case '+': $output[] = $left + $right; break;\n                            case '-': $output[] = $left - $right; break;\n                            case '*': $output[] = $left * $right; break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return empty($output) ? [(int)$expression] : $output;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func diffWaysToCompute(_ expression: String) -> [Int] {\n        var memo = [String: [Int]]()\n        \n        func compute(_ expr: String) -> [Int] {\n            if let cached = memo[expr] {\n                return cached\n            }\n            \n            var result = [Int]()\n            for (index, char) in expr.enumerated() {\n                if char == \"+\" || char == \"-\" || char == \"*\" {\n                    let leftPart = compute(String(expr[..<expr.index(expr.startIndex, offsetBy: index)]))\n                    let rightPart = compute(String(expr[expr.index(expr.startIndex, offsetBy: index + 1)...]))\n                    \n                    for left in leftPart {\n                        for right in rightPart {\n                            if char == \"+\" {\n                                result.append(left + right)\n                            } else if char == \"-\" {\n                                result.append(left - right)\n                            } else if char == \"*\" {\n                                result.append(left * right)\n                            }\n                        }\n                    }\n                }\n            }\n            \n            if result.isEmpty {\n                result.append(Int(expr)!)\n            }\n            \n            memo[expr] = result\n            return result\n        }\n        \n        return compute(expression)\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "import java.util.*\n\nclass Solution {\n    fun diffWaysToCompute(expression: String): List<Int> {\n        val result = mutableListOf<Int>()\n\n        for (i in expression.indices) {\n            val c = expression[i]\n            if (c == '+' || c == '-' || c == '*') {\n                val leftPart = diffWaysToCompute(expression.substring(0, i))\n                val rightPart = diffWaysToCompute(expression.substring(i + 1))\n\n                for (left in leftPart) {\n                    for (right in rightPart) {\n                        when (c) {\n                            '+' -> result.add(left + right)\n                            '-' -> result.add(left - right)\n                            '*' -> result.add(left * right)\n                        }\n                    }\n                }\n            }\n        }\n\n        if (result.isEmpty()) {\n            result.add(expression.toInt())\n        }\n\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> diffWaysToCompute(String expression) {\n    List<int> res = [];\n    for (int i = 0; i < expression.length; i++) {\n      if (expression[i] == '+' || expression[i] == '-' || expression[i] == '*') {\n        List<int> leftPart = diffWaysToCompute(expression.substring(0, i));\n        List<int> rightPart = diffWaysToCompute(expression.substring(i + 1));\n        for (int left in leftPart) {\n          for (int right in rightPart) {\n            if (expression[i] == '+') {\n              res.add(left + right);\n            } else if (expression[i] == '-') {\n              res.add(left - right);\n            } else {\n              res.add(left * right);\n            }\n          }\n        }\n      }\n    }\n    if (res.isEmpty) {\n      res.add(int.parse(expression));\n    }\n    return res;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "import \"strconv\"\n\nfunc diffWaysToCompute(expression string) []int {\n    var res []int\n    for i := 0; i < len(expression); i++ {\n        if expression[i] == '+' || expression[i] == '-' || expression[i] == '*' {\n            left := diffWaysToCompute(expression[:i])\n            right := diffWaysToCompute(expression[i+1:])\n            for _, l := range left {\n                for _, r := range right {\n                    var val int\n                    switch expression[i] {\n                    case '+':\n                        val = l + r\n                    case '-':\n                        val = l - r\n                    case '*':\n                        val = l * r\n                    }\n                    res = append(res, val)\n                }\n            }\n        }\n    }\n    if len(res) == 0 {\n        num, _ := strconv.Atoi(expression)\n        res = append(res, num)\n    }\n    return res\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} expression\n# @return {Integer[]}\ndef diff_ways_to_compute(expression)\n    def compute(left, right, op)\n        case op\n        when '+'\n            return left + right\n        when '-'\n            return left - right\n        when '*'\n            return left * right\n        end\n    end\n    \n    if expression.match(/\\D/).nil?\n        return [expression.to_i]\n    end\n    \n    result = []\n    \n    (0...expression.length).each do |i|\n        if ['+', '-', '*'].include?(expression[i])\n            left_parts = diff_ways_to_compute(expression[0...i])\n            right_parts = diff_ways_to_compute(expression[(i+1)..-1])\n            \n            left_parts.each do |left|\n                right_parts.each do |right|\n                    result << compute(left, right, expression[i])\n                end\n            end\n        end\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def diffWaysToCompute(expression: String): List[Int] = {\n        def compute(left: List[Int], right: List[Int], op: Char): List[Int] = {\n            for {\n                x <- left\n                y <- right\n            } yield {\n                op match {\n                    case '+' => x + y\n                    case '-' => x - y\n                    case '*' => x * y\n                }\n            }\n        }\n        \n        if (expression.forall(_.isDigit)) List(expression.toInt)\n        else {\n            (for {\n                (c, i) <- expression.zipWithIndex if !c.isDigit\n            } yield {\n                val leftPart = diffWaysToCompute(expression.substring(0, i))\n                val rightPart = diffWaysToCompute(expression.substring(i + 1))\n                compute(leftPart, rightPart, c)\n            }).flatten.toList\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn diff_ways_to_compute(expression: String) -> Vec<i32> {\n        \n        fn helper(input: &str, memo: &mut std::collections::HashMap<String, Vec<i32>>) -> Vec<i32> {\n            if let Some(result) = memo.get(input) {\n                return result.clone();\n            }\n            \n            let mut result = Vec::new();\n            let chars: Vec<char> = input.chars().collect();\n            \n            for (i, &c) in chars.iter().enumerate() {\n                if c == '+' || c == '-' || c == '*' {\n                    let left = helper(&input[..i], memo);\n                    let right = helper(&input[i+1..], memo);\n                    \n                    for &l in &left {\n                        for &r in &right {\n                            if c == '+' {\n                                result.push(l + r);\n                            } else if c == '-' {\n                                result.push(l - r);\n                            } else if c == '*' {\n                                result.push(l * r);\n                            }\n                        }\n                    }\n                }\n            }\n            \n            if result.is_empty() {\n                result.push(input.parse().unwrap());\n            }\n            \n            memo.insert(input.to_string(), result.clone());\n            \n            result\n        }\n        \n        let mut memo = std::collections::HashMap::new();\n        helper(&expression, &mut memo)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to find all the possible results from computing different ways to group numbers and operators in the given expression. The solution involves using a divide-and-conquer approach to recursively break down the expression and compute the results for each possible grouping.\n\n### # Explanation\n1. **Divide and Conquer**: Recursively divide the expression at each operator to compute the results of the left and right subexpressions.\n2. **Compute Results**: Depending on the operator, compute the result for each combination of results from the left and right subarrays.\n   - If the operator is `+`, add the results.\n   - If the operator is `-`, subtract the results.\n   - If the operator is `*`, multiply the results.\n3. **Base Case**: If the expression contains only a digit, return it as a single-element list.\n4. **Combine Results**: Merge results from the left and right parts using the specified operator, then collect all possible results.\n\n### # Pseudocode\n```\nfunction diffWaysToCompute(expression):\n    function compute(left, right, operator):\n        results = []\n        for each l in left:\n            for each r in right:\n                if operator is '+':\n                    results.append(l + r)\n                else if operator is '-':\n                    results.append(l - r)\n                else if operator is '*':\n                    results.append(l * r)\n        return results\n\n    if expression is a digit:\n        return [int(expression)]\n\n    results = []\n    for i from 0 to length of expression:\n        if expression[i] is an operator ('+', '-', '*'):\n            left_results = diffWaysToCompute(expression[0:i])\n            right_results = diffWaysToCompute(expression[i+1:])\n\n            combined_results = compute(left_results, right_results, expression[i])\n            extend results with combined_results\n\n    return results\n```\n\nIn the pseudocode:\n- The `diffWaysToCompute` function handles the main logic. It checks the base case first to determine if the expression is a single number. If so, it converts and returns it as a list.\n- The function then iterates through the expression to find operators. For each operator, it splits the expression into left and right subexpressions and recursively computes possible results for each part using the `compute` helper function.\n- The `compute` helper function takes two lists of results and an operator, then it combines the results according to the operator and returns the merged list.\n\nWith this approach, you will be able to find all possible results from different ways to group numbers and operators in the given expression.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-different-ways-to-add-parentheses"
    },
    {
        "name": "Search A 2D Matrix Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-search-a-2d-matrix-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        if (m == 0) return false;\n        int n = matrix[0].size();\n        \n        int row = 0, col = n - 1;\n        while (row < m && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] < target) {\n                row++;\n            } else {\n                col--;\n            }\n        }\n        \n        return false;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        \n        int row = 0;\n        int col = matrix[0].length - 1;\n        \n        while (row < matrix.length && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] < target) {\n                row++;\n            } else {\n                col--;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def searchMatrix(self, matrix, target):\n        if not matrix or not matrix[0]:\n            return False\n        \n        row = 0\n        col = len(matrix[0]) - 1\n        \n        while row < len(matrix) and col >= 0:\n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                row += 1\n            else:\n                col -= 1\n        \n        return False\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\n    int row = 0;\n    int col = *matrixColSize - 1;\n    \n    while (row < matrixSize && col >= 0) {\n        if (matrix[row][col] == target) {\n            return true;\n        } else if (matrix[row][col] < target) {\n            row++;\n        } else {\n            col--;\n        }\n    }\n    \n    return false;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool SearchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0) {\n            return false;\n        }\n        \n        int row = 0;\n        int col = matrix[0].Length - 1;\n        \n        while (row < matrix.Length && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] < target) {\n                row++;\n            } else {\n                col--;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nconst searchMatrix = function(matrix, target) {\n    let row = 0;\n    let col = matrix[0].length - 1;\n    \n    while (row < matrix.length && col >= 0) {\n        if (matrix[row][col] === target) {\n            return true;\n        } else if (matrix[row][col] < target) {\n            row++;\n        } else {\n            col--;\n        }\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function searchMatrix(matrix: number[][], target: number): boolean {\n    let row = 0;\n    let col = matrix[0].length - 1;\n    \n    while (row < matrix.length && col >= 0) {\n        if (matrix[row][col] === target) {\n            return true;\n        } else if (matrix[row][col] < target) {\n            row++;\n        } else {\n            col--;\n        }\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $matrix\n     */\n    function searchMatrix($matrix, $target) {\n        $rows = count($matrix);\n        if ($rows == 0) {\n            return false;\n        }\n        $cols = count($matrix[0]);\n        $row = 0;\n        $col = $cols - 1;\n        \n        while ($row < $rows && $col >= 0) {\n            if ($matrix[$row][$col] == $target) {\n                return true;\n            } elseif ($matrix[$row][$col] < $target) {\n                $row++;\n            } else {\n                $col--;\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n        guard !matrix.isEmpty else {\n            return false\n        }\n        \n        var row = 0\n        var col = matrix[0].count - 1\n        \n        while row < matrix.count, col >= 0 {\n            if matrix[row][col] == target {\n                return true\n            } else if matrix[row][col] < target {\n                row += 1\n            } else {\n                col -= 1\n            }\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\n        var row = matrix.size - 1\n        var col = 0\n        \n        while (row >= 0 && col < matrix[0].size) {\n            when {\n                matrix[row][col] == target -> return true\n                matrix[row][col] < target -> col++\n                else -> row--\n            }\n        }\n        \n        return false\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func searchMatrix(matrix [][]int, target int) bool {\n    if len(matrix) == 0 || len(matrix[0]) == 0 {\n        return false\n    }\n    \n    row, col := 0, len(matrix[0])-1\n    \n    for row < len(matrix) && col >= 0 {\n        if matrix[row][col] == target {\n            return true\n        } else if matrix[row][col] < target {\n            row++\n        } else {\n            col--\n        }\n    }\n    \n    return false\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @param {Integer} target\n# @return {Boolean}\ndef search_matrix(matrix, target)\n    row = 0\n    col = matrix[0].length - 1\n    \n    while row < matrix.length && col >= 0\n        if matrix[row][col] == target\n            return true\n        elsif matrix[row][col] > target\n            col -= 1\n        else\n            row += 1\n        end\n    end\n    \n    return false\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def searchMatrix(matrix: Array[Array[Int]], target: Int): Boolean = {\n        if (matrix.isEmpty || matrix(0).isEmpty) {\n            return false\n        }\n        \n        var row = 0\n        var col = matrix(0).length - 1\n        \n        while (row < matrix.length && col >= 0) {\n            if (matrix(row)(col) == target) {\n                return true\n            } else if (matrix(row)(col) < target) {\n                row += 1\n            } else {\n                col -= 1\n            }\n        }\n        \n        false\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        let mut row = 0;\n        let mut col = matrix[0].len() as i32 - 1;\n        \n        while row < matrix.len() as i32 && col >= 0 {\n            if matrix[row as usize][col as usize] == target {\n                return true;\n            } else if matrix[row as usize][col as usize] > target {\n                col -= 1;\n            } else {\n                row += 1;\n            }\n        }\n        \n        false\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to search for a specific target value within a 2D matrix with certain sorting properties. The matrix is sorted such that each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom.\n\n# Explanation\n1. **Starting Point:** Start the search from the top-right corner of the matrix.\n2. **Move Strategies:**\n   - If the current element is equal to the target, return `True`.\n   - If the current element is less than the target, move down to the next row.\n   - If the current element is greater than the target, move left to the previous column.\n3. **Termination Condition:** The search continues until the indices are out of bounds, indicating the target is not present in the matrix.\n\nThis approach works efficiently because it leverages the matrix's sorted properties to eliminate rows or columns at each step.\n\n# Pseudocode\n```text\nfunction searchMatrix(matrix, target):\n    if matrix is empty or matrix[0] is empty:\n        return False\n\n    row = 0\n    col = length of matrix[0] - 1  # Start at the top-right corner\n\n    while row < length of matrix and col >= 0:\n        if matrix[row][col] == target:\n            return True  # Found the target\n        else if matrix[row][col] < target:\n            row += 1  # Move down to the next row\n        else:\n            col -= 1  # Move left to the previous column\n\n    return False  # Target not found in the matrix\n```\n\nThis pseudocode outlines the logic for searching the target within the 2D matrix. It uses a while loop to navigate through the matrix efficiently, adjusting the row and column indices based on the comparison between the current element and the target value.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-search-a-2d-matrix-ii"
    },
    {
        "name": "Lowest Common Ancestor Of A Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-lowest-common-ancestor-of-a-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode* left;\n *     TreeNode* right;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n        \n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n        \n        if (left && right) {\n            return root;\n        }\n        \n        return left ? left : right;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        \n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        \n        if (left != null && right != null) {\n            return root;\n        } else if (left != null) {\n            return left;\n        } else {\n            return right;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        if root is None or root == p or root == q:\n            return root\n        \n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        \n        if left is None:\n            return right\n        elif right is None:\n            return left\n        else:\n            return root\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root == NULL || root == p || root == q) {\n        return root;\n    }\n    \n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\n    \n    if (left != NULL && right != NULL) {\n        return root;\n    } else if (left != NULL) {\n        return left;\n    } else {\n        return right;\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        \n        TreeNode left = LowestCommonAncestor(root.left, p, q);\n        TreeNode right = LowestCommonAncestor(root.right, p, q);\n        \n        if (left == null) {\n            return right;\n        } else if (right == null) {\n            return left;\n        } else {\n            return root;\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\nvar lowestCommonAncestor = function(root, p, q) {\n    if (!root || root === p || root === q) {\n        return root;\n    }\n    \n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n    \n    if (left && right) {\n        return root;\n    }\n    \n    return left || right;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the Lowest Common Ancestor (LCA) of two given nodes in a binary tree. The solution involves a depth-first search (DFS) strategy for finding the nodes in the tree and checking their ancestry.\n\n# Explanation\n- We start from the root of the binary tree.\n- If the root itself is either `p` or `q`, then the root is the LCA.\n- We recursively check the left and right subtrees for the LCA of `p` and `q`.\n- If both left and right subtrees return non-null values, it means `p` and `q` are found in different subtrees, and thus the root node is their LCA.\n- If only one subtree returns a non-null value, that subtree contains both `p` and `q`, and thus its root is the LCA.\n\n# Pseudocode\n```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        if root is None:\n            return None\n        \n        # If the root is one of p or q\n        if root == p or root == q:\n            return root\n        \n        # Recursively check the left and right subtrees\n        left_lca = self.lowestCommonAncestor(root.left, p, q)\n        right_lca = self.lowestCommonAncestor(root.right, p, q)\n        \n        # If both left and right calls return non-null, root is the LCA\n        if left_lca and right_lca:\n            return root\n        \n        # Otherwise, return the non-null result\n        return left_lca if left_lca is not None else right_lca\n```\n\nThis approach ensures a time complexity of O(N), where N is the number of nodes in the tree, as each node is visited once. The space complexity is also O(N) due to the recursive stack usage.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-lowest-common-ancestor-of-a-binary-tree"
    },
    {
        "name": "Product Of Array Except Self",
        "site": "LeetCode",
        "href": "/solution/LeetCode-product-of-array-except-self",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> output(n, 1);\n        \n        int leftProduct = 1;\n        for (int i = 0; i < n; i++) {\n            output[i] *= leftProduct;\n            leftProduct *= nums[i];\n        }\n        \n        int rightProduct = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            output[i] *= rightProduct;\n            rightProduct *= nums[i];\n        }\n        \n        return output;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] output = new int[n];\n        int leftProduct = 1;\n        for (int i = 0; i < n; i++) {\n            output[i] = leftProduct;\n            leftProduct *= nums[i];\n        }\n        int rightProduct = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            output[i] *= rightProduct;\n            rightProduct *= nums[i];\n        }\n        return output;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def productExceptSelf(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        output = [1] * n\n        left = 1\n        right = 1\n        \n        for i in range(n):\n            output[i] *= left\n            left *= nums[i]\n        \n        for i in range(n-1, -1, -1):\n            output[i] *= right\n            right *= nums[i]\n        \n        return output"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* productExceptSelf(int* nums, int numsSize, int* returnSize){\n    int* result = (int*)malloc(numsSize * sizeof(int));\n    \n    if(nums == NULL || numsSize == 0) {\n        *returnSize = 0;\n        return result;\n    }\n    \n    int* left = (int*)malloc(numsSize * sizeof(int));\n    int* right = (int*)malloc(numsSize * sizeof(int));\n    \n    left[0] = 1;\n    right[numsSize - 1] = 1;\n    \n    for(int i = 1; i < numsSize; i++) {\n        left[i] = left[i - 1] * nums[i - 1];\n    }\n    \n    for(int i = numsSize - 2; i >= 0; i--) {\n        right[i] = right[i + 1] * nums[i + 1];\n    }\n    \n    for(int i = 0; i < numsSize; i++) {\n        result[i] = left[i] * right[i];\n    }\n    \n    *returnSize = numsSize;\n    \n    free(left);\n    free(right);\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] ProductExceptSelf(int[] nums) {\n        int n = nums.Length;\n        int[] result = new int[n];\n        \n        result[0] = 1;\n        for (int i = 1; i < n; i++) {\n            result[i] = result[i - 1] * nums[i - 1];\n        }\n        \n        int right = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] *= right;\n            right *= nums[i];\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function(nums) {\n    const n = nums.length;\n    const output = new Array(n).fill(1);\n    \n    let leftProduct = 1;\n    for (let i = 0; i < n; i++) {\n        output[i] *= leftProduct;\n        leftProduct *= nums[i];\n    }\n    \n    let rightProduct = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        output[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n    \n    return output;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function productExceptSelf(nums: number[]): number[] \n{\n    const n = nums.length;\n    const output: number[] = [];\n    \n    let leftProduct = 1;\n    for (let i = 0; i < n; i++) {\n        output[i] = leftProduct;\n        leftProduct *= nums[i];\n    }\n    \n    let rightProduct = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        output[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n    \n    return output;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function productExceptSelf($nums) {\n        $n = count($nums);\n        $output = array_fill(0, $n, 1);\n        \n        $leftProduct = 1;\n        for ($i = 0; $i < $n; $i++) {\n            $output[$i] *= $leftProduct;\n            $leftProduct *= $nums[$i];\n        }\n        \n        $rightProduct = 1;\n        for ($i = $n - 1; $i >= 0; $i--) {\n            $output[$i] *= $rightProduct;\n            $rightProduct *= $nums[$i];\n        }\n        \n        return $output;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\n        var output = [Int](repeating: 1, count: nums.count)\n        \n        var leftProduct = 1\n        for i in 0..<nums.count {\n            output[i] *= leftProduct\n            leftProduct *= nums[i]\n        }\n        \n        var rightProduct = 1\n        for i in stride(from: nums.count - 1, through: 0, by: -1) {\n            output[i] *= rightProduct\n            rightProduct *= nums[i]\n        }\n        \n        return output\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun productExceptSelf(nums: IntArray): IntArray {\n        val n = nums.size\n        val output = IntArray(n) { 1 }\n        \n        var leftProduct = 1\n        for (i in 0 until n) {\n            output[i] *= leftProduct\n            leftProduct *= nums[i]\n        }\n        \n        var rightProduct = 1\n        for (i in n - 1 downTo 0) {\n            output[i] *= rightProduct\n            rightProduct *= nums[i]\n        }\n        \n        return output\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> productExceptSelf(List<int> nums) {\n    int n = nums.length;\n    List<int> output = List.filled(n, 1);\n\n    int leftProduct = 1;\n    for (int i = 0; i < n; i++) {\n      output[i] *= leftProduct;\n      leftProduct *= nums[i];\n    }\n\n    int rightProduct = 1;\n    for (int i = n - 1; i >= 0; i--) {\n      output[i] *= rightProduct;\n      rightProduct *= nums[i];\n    }\n\n    return output;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func productExceptSelf(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n\n    // Calculate the product of all elements to the left of each element\n    leftProduct := 1\n    for i := 0; i < n; i++ {\n        result[i] = leftProduct\n        leftProduct *= nums[i]\n    }\n\n    // Calculate the product of all elements to the right of each element\n    rightProduct := 1\n    for i := n - 1; i >= 0; i-- {\n        result[i] *= rightProduct\n        rightProduct *= nums[i]\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef product_except_self(nums)\n    n = nums.length\n    result = Array.new(n, 1)\n    \n    left_product = 1\n    (0...n).each do |i|\n        result[i] *= left_product\n        left_product *= nums[i]\n    end\n    \n    right_product = 1\n    (n-1).downto(0).each do |i|\n        result[i] *= right_product\n        right_product *= nums[i]\n    end\n    \n    return result\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def productExceptSelf(nums: Array[Int]): Array[Int] = {\n        val n = nums.length\n        val result = new Array[Int](n)\n        \n        var productLeft = 1\n        for (i <- 0 until n) {\n            result(i) = productLeft\n            productLeft *= nums(i)\n        }\n        \n        var productRight = 1\n        for (i <- n - 1 to 0 by -1) {\n            result(i) *= productRight\n            productRight *= nums(i)\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        let mut output = vec![1; n];\n        \n        let mut left_product = 1;\n        for i in 0..n {\n            output[i] *= left_product;\n            left_product *= nums[i];\n        }\n        \n        let mut right_product = 1;\n        for i in (0..n).rev() {\n            output[i] *= right_product;\n            right_product *= nums[i];\n        }\n        \n        output\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to calculate the product of all the elements in the array except the element at the current index without using the division operation. We also need the algorithm to run in O(n) time complexity. Let's break down the steps and logic required to achieve this:\n\n### # Explanation\n1. **Initial Setup**: We initialize an array `output` of the same length as the input array `nums`, and fill it with 1s. This array will eventually be returned as our result.\n\n2. **Left Pass**: We traverse the `nums` array from left to right. During this pass, we use a variable `left` to keep track of the product of all elements to the left of the current element. As we progress, we multiply each element in the `output` array with the current value of `left`, then update `left` to include the product of the current element in `nums`.\n\n3. **Right Pass**: After the left pass is complete, we traverse the `nums` array from right to left. We use a variable `right` to keep track of the product of all elements to the right of the current element. Similarly, we multiply each element in the `output` array with the current value of `right`, then update `right` to include the product of the current element in `nums`.\n\n4. **Result**: At the end of both passes, the `output` array will contain the required products.\n\n### # Pseudocode\n```\n# Function to compute the product of array except self\ndef productExceptSelf(nums):\n    # Step 1: Initialize variables\n    n = len(nums)\n    output = [1] * n\n    left = 1\n    right = 1\n\n    # Step 2: Left pass\n    for i in range(n):\n        output[i] *= left\n        left *= nums[i]\n\n    # Step 3: Right pass\n    for i in range(n-1, -1, -1):\n        output[i] *= right\n        right *= nums[i]\n\n    # Step 4: Return result\n    return output\n```\n\nThis pseudocode will correctly compute the product of all elements except the current one for each position in the array `nums` in O(n) time complexity without using division and only using a constant amount of extra space.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-product-of-array-except-self"
    },
    {
        "name": "Delete Node In A Linked List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-delete-node-in-a-linked-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n \nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nvoid deleteNode(struct ListNode* node) {\n    struct ListNode* temp = node->next;\n    node->val = temp->val;\n    node->next = temp->next;\n    free(temp);\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\nvar deleteNode = function(node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction deleteNode(node: ListNode | null): void {\n    if (node && node.next) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public ListNode $next = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *     }\n * }\n */\n\nclass Solution {\n\n    /**\n     * @param ListNode $node\n     * @return NULL\n     */\n    function deleteNode($node) {\n        $node->val = $node->next->val;\n        $node->next = $node->next->next;\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc deleteNode(node *ListNode) {\n    node.Val = node.Next.Val\n    node.Next = node.Next.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class ListNode\n    attr_accessor :val, :next\n    def initialize(val)\n        @val = val\n        @next = nil\n    end\nend\n\ndef delete_node(node)\n    node.val = node.next.val\n    node.next = node.next.next\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n */\n\nobject Solution {\n    def deleteNode(node: ListNode): Unit = {\n        node.x = node.next.x\n        node.next = node.next.next\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to delete a given node from a singly linked list without having access to the head node. The given node will not be the last node of the list. \n\n# Explanation:\n1. Since you are not given access to the head of the list, you cannot traverse the list from the start. Instead, you are given the node to be deleted directly.\n2. To \"delete\" this node, copy the value from the next node into the given node.\n3. Update the given node's next pointer to skip over the next node, effectively removing it from the list.\n4. This approach is possible due to the guarantee that the node to delete is not the last node in the list.\n\nIn summary, this method replaces the content of the node to be deleted with the content of its next node, and then bypasses the next node.\n\n# Pseudocode:\n```\n# Define the ListNode class\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Function to delete a node\ndef deleteNode(node):\n    # Set the value of the node to the value of the next node\n    node.val = node.next.val\n    # Set the next pointer of the node to the next pointer of the next node\n    node.next = node.next.next\n```\n\nExplanation:\n- Define a class `ListNode` to represent a node in the linked list.\n- In the `deleteNode` function, copy the value of the next node to the current node.\n- Update the current node's next pointer to skip the next node, which effectively removes the next node from the linked list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-delete-node-in-a-linked-list"
    },
    {
        "name": "Palindrome Linked List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-palindrome-linked-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if (!head || !head->next) {\n            return true;\n        }\n        \n        ListNode *slow = head, *fast = head;\n        \n        while (fast->next && fast->next->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        slow->next = reverseList(slow->next);\n        slow = slow->next;\n        \n        while (slow) {\n            if (head->val != slow->val) {\n                return false;\n            }\n            head = head->next;\n            slow = slow->next;\n        }\n        \n        return true;\n    }\n    \n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        \n        while (head) {\n            ListNode* next = head->next;\n            head->next = prev;\n            prev = head;\n            head = next;\n        }\n        \n        return prev;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) {\n            return true;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        slow.next = reverseList(slow.next);\n        slow = slow.next;\n        \n        while (slow != null) {\n            if (head.val != slow.val) {\n                return false;\n            }\n            head = head.next;\n            slow = slow.next;\n        }\n        \n        return true;\n    }\n    \n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        while (head != null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nbool isPalindrome(struct ListNode* head){\n    if (head == NULL || head->next == NULL) {\n        return true;\n    }\n    \n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n    \n    while (fast->next != NULL && fast->next->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    struct ListNode* secondHalf = slow->next;\n    slow->next = NULL;\n    \n    struct ListNode* prev = NULL;\n    struct ListNode* curr = secondHalf;\n    struct ListNode* next = NULL;\n    \n    while (curr != NULL) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    \n    struct ListNode* p1 = head;\n    struct ListNode* p2 = prev;\n    \n    while (p1 != NULL && p2 != NULL) {\n        if (p1->val != p2->val) {\n            return false;\n        }\n        p1 = p1->next;\n        p2 = p2->next;\n    }\n    \n    return true;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public bool IsPalindrome(ListNode head) {\n        if (head == null || head.next == null)\n            return true;\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        slow.next = ReverseList(slow.next);\n        slow = slow.next;\n        \n        while (slow != null) {\n            if (head.val != slow.val)\n                return false;\n            head = head.next;\n            slow = slow.next;\n        }\n        \n        return true;\n    }\n    \n    public ListNode ReverseList(ListNode head) {\n        ListNode prev = null;\n        \n        while (head != null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        \n        return prev;\n    }\n}\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nvar isPalindrome = function(head) {\n    if (head === null) {\n        return true;\n    }\n\n    let slow = head;\n    let fast = head;\n\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let prev = null;\n    let current = slow;\n\n    while (current !== null) {\n        const temp = current.next;\n        current.next = prev;\n        prev = current;\n        current = temp;\n    }\n\n    let left = head;\n    let right = prev;\n\n    while (right !== null) {\n        if (left.val !== right.val) {\n            return false;\n        }\n        left = left.next;\n        right = right.next;\n    }\n\n    return true;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next? : ListNode) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction isPalindrome(head: ListNode | null): boolean {\n    if (!head || !head.next) {\n        return true;\n    }\n\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let prev = null;\n    let current = slow;\n\n    while(current) {\n        const next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n\n    let left = head;\n    let right = prev;\n\n    while(right) {\n        if (left.val !== right.val) {\n            return false;\n        }\n        left = left.next;\n        right = right.next;\n    }\n\n    return true;\n};\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class ListNode\n    attr_accessor :val, :next\n    def initialize(val = 0, _next = nil)\n        @val = val\n        @next = _next\n    end\nend\n\ndef is_palindrome(head)\n    return true if head.nil?\n    \n    values = []\n    current = head\n    \n    while !current.nil?\n        values << current.val\n        current = current.next\n    end\n    \n    values == values.reverse\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var x: Int = _x\n *   var next: ListNode = _next\n * }\n */\nobject Solution {\n    def isPalindrome(head: ListNode): Boolean = {\n        def reverse(node: ListNode): ListNode = {\n            var prev: ListNode = null\n            var current = node\n            while (current != null) {\n                val nextTemp = current.next\n                current.next = prev\n                prev = current\n                current = nextTemp\n            }\n            prev\n        }\n        \n        def findMiddle(node: ListNode): ListNode = {\n            var slow = node\n            var fast = node\n            while (fast != null && fast.next != null) {\n                slow = slow.next\n                fast = fast.next.next\n            }\n            slow\n        }\n        \n        def compareLists(l1: ListNode, l2: ListNode): Boolean = {\n            var p1 = l1\n            var p2 = l2\n            while (p1 != null && p2 != null) {\n                if (p1.x != p2.x) return false\n                p1 = p1.next\n                p2 = p2.next\n            }\n            true\n        }\n        \n        val mid = findMiddle(head)\n        val reversed = reverse(mid)\n        compareLists(head, reversed)\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\nimpl Solution {\n    pub fn is_palindrome(head: Option<Box<ListNode>>) -> bool {\n        let mut nums = vec![];\n        let mut current = head;\n        while let Some(node) = current {\n            nums.push(node.val);\n            current = node.next;\n        }\n        let mut i = 0;\n        let mut j = nums.len() - 1;\n        while i < j {\n            if nums[i] != nums[j] {\n                return false;\n            }\n            i += 1;\n            j -= 1;\n        }\n        true\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine whether a given singly linked list is a palindrome.\n\n# Explanation\n\n1. **Definition:**\n   A palindrome is a sequence that reads the same forward and backward. For a linked list, this means the sequence of node values should be identical when traversed from the head to the end and from the end back to the head.\n\n2. **Strategy:**\n   To verify if the linked list is a palindrome with O(n) time complexity and O(1) space complexity, we can follow these steps:\n   \n   - Use two pointers, `slow` and `fast`, to find the middle of the linked list. `slow` will move one step at a time while `fast` will move two steps at a time.\n   - Reverse the second half of the linked list.\n   - Compare the first half and the reversed second half node by node.\n   - Restore the list to its original form if needed (optional).\n\n3. **Steps:**\n   - Initialize two pointers, `slow` and `fast`, both starting at the head of the list.\n   - Move `slow` by one node and `fast` by two nodes until `fast` reaches the end. `slow` will be at the middle of the list.\n   - Reverse the linked list starting from `slow`.\n   - Initialize two pointers, one starting from the head (`left`) and another starting from the node where the reversed half begins (`right`).\n   - Compare values of nodes pointed by `left` and `right`. If any value mismatch occurs, return `false`.\n   - If the loop completes without mismatches, return `true`.\n\n# Pseudocode\n\n```\nfunction isPalindrome(head):\n    if head is null:\n        return true\n    \n    slow = head\n    fast = head\n\n    # Find the middle of the list\n    while fast is not null and fast.next is not null:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half of the list\n    prev = null\n    current = slow\n    while current is not null:\n        temp = current.next\n        current.next = prev\n        prev = current\n        current = temp\n\n    # Compare the first half and the reversed second half\n    left = head\n    right = prev\n    while right is not null:\n        if left.val != right.val:\n            return false\n        left = left.next\n        right = right.next\n\n    return true\n```\n\nThis methodology ensures we handle the palindrome check in linear time while maintaining constant space complexity, which is optimal for this problem.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-palindrome-linked-list"
    },
    {
        "name": "Lowest Common Ancestor Of A Binary Search Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-lowest-common-ancestor-of-a-binary-search-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root->val > p->val && root->val > q->val) {\n            return lowestCommonAncestor(root->left, p, q);\n        } else if (root->val < p->val && root->val < q->val) {\n            return lowestCommonAncestor(root->right, p, q);\n        } else {\n            return root;\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root.val > p.val && root.val > q.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        } else if (root.val < p.val && root.val < q.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        } else {\n            return root;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        if root.val > p.val and root.val > q.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        elif root.val < p.val and root.val < q.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        else:\n            return root\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root->val > p->val && root->val > q->val)\n        return lowestCommonAncestor(root->left, p, q);\n    else if (root->val < p->val && root->val < q->val)\n        return lowestCommonAncestor(root->right, p, q);\n    else\n        return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root.val > p.val && root.val > q.val) {\n            return LowestCommonAncestor(root.left, p, q);\n        } else if (root.val < p.val && root.val < q.val) {\n            return LowestCommonAncestor(root.right, p, q);\n        } else {\n            return root;\n        }\n    }\n}\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\nvar lowestCommonAncestor = function(root, p, q) {\n    if ((root.val - p.val) * (root.val - q.val) <= 0) return root;\n    return lowestCommonAncestor(root.val < p.val ? root.right : root.left, p, q);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n    if (!root || root === p || root === q) {\n        return root;\n    }\n    \n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n    \n    if (left && right) {\n        return root;\n    }\n    \n    return left || right;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n    /**\n     * @param TreeNode $root\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return TreeNode\n     */\n    function lowestCommonAncestor($root, $p, $q) {\n        if ($root->val < $p->val && $root->val < $q->val) {\n            return $this->lowestCommonAncestor($root->right, $p, $q);\n        } elseif ($root->val > $p->val && $root->val > $q->val) {\n            return $this->lowestCommonAncestor($root->left, $p, $q);\n        } else {\n            return $root;\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\n\nclass Solution {\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\n        var ancestor: TreeNode? = root\n        while true {\n            if p!.val < ancestor!.val && q!.val < ancestor!.val {\n                ancestor = ancestor!.left\n            } else if p!.val > ancestor!.val && q!.val > ancestor!.val {\n                ancestor = ancestor!.right\n            } else {\n                return ancestor\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root.Val > p.Val && root.Val > q.Val {\n        return lowestCommonAncestor(root.Left, p, q)\n    } else if root.Val < p.Val && root.Val < q.Val {\n        return lowestCommonAncestor(root.Right, p, q)\n    } else {\n        return root\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class TreeNode\n    attr_accessor :val, :left, :right\n    def initialize(val)\n        @val = val\n        @left = nil\n        @right = nil\n    end\nend\n\ndef lowest_common_ancestor(root, p, q)\n    return root if root.val == p.val || root.val == q.val\n    \n    if root.val > p.val && root.val > q.val\n        return lowest_common_ancestor(root.left, p, q)\n    elsif root.val < p.val && root.val < q.val\n        return lowest_common_ancestor(root.right, p, q)\n    else\n        return root\n    end\nend"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the Lowest Common Ancestor (LCA) of two nodes in a Binary Search Tree (BST). The BST property simplifies this task as it ensures that nodes in the left subtree are smaller than the root and nodes in the right subtree are larger.\n\n## Explanation\n\n1. **Binary Search Tree Properties**: In a BST, nodes on the left of any node are smaller, and nodes on the right are larger. This property helps us navigate the tree efficiently.\n \n2. **LCA Definition**: The LCA of two nodes \\( p \\) and \\( q \\) is the deepest (lowest) node that is an ancestor of both \\( p \\) and \\( q \\).\n\n3. **Approach**:\n    - If both \\( p \\) and \\( q \\) are smaller than the current node, the LCA is in the left subtree.\n    - If both \\( p \\) and \\( q \\) are larger than the current node, the LCA is in the right subtree.\n    - If \\( p \\) and \\( q \\) are on different sides of the current node (or one of them is equal to the current node), the current node is their LCA.\n\n## Pseudocode\n\n1. **Initialize Function**:\n    - Define a function `lowestCommonAncestor` that takes the root, \\( p \\), and \\( q \\).\n    \n2. **Recursive Function**:\n    - If `root` is `None`, return `None`.\n    - If the value of `root` is greater than both `p.val` and `q.val`, the LCA is in the left subtree.\n    - If the value of `root` is less than both `p.val` and `q.val`, the LCA is in the right subtree.\n    - Otherwise, `root` is the LCA because \\( p \\) and \\( q \\) are on either side of `root` or one of them is equal to `root`.\n\n```pseudocode\n# Pseudocode\n\n# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        if root is None:\n            return None\n\n        # Check if both p and q are smaller than root\n        if root.val > p.val and root.val > q.val:\n            # LCA is in the left subtree\n            return self.lowestCommonAncestor(root.left, p, q) \n        \n        # Check if both p and q are larger than root\n        elif root.val < p.val and root.val < q.val:\n            # LCA is in the right subtree\n            return self.lowestCommonAncestor(root.right, p, q)\n        \n        # Either p or q is on one side and the root is the LCA\n        else:\n            return root\n```\n\nThis pseudocode efficiently determines the LCA by leveraging the properties of the BST, ensuring an optimal time complexity of \\(O(h)\\), where \\(h\\) is the height of the tree.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-lowest-common-ancestor-of-a-binary-search-tree"
    },
    {
        "name": "Contains Duplicate Iii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-contains-duplicate-iii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\n        set<long> window;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i > indexDiff) {\n                window.erase(nums[i - indexDiff - 1]);\n            }\n            auto it = window.lower_bound((long)nums[i] - valueDiff);\n            if (it != window.end() && *it <= (long)nums[i] + valueDiff) {\n                return true;\n            }\n            window.insert(nums[i]);\n        }\n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\n        TreeSet<Integer> set = new TreeSet<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            Integer floor = set.floor(nums[i] + valueDiff);\n            Integer ceiling = set.ceiling(nums[i] - valueDiff);\n            \n            if ((floor != null && floor >= nums[i]) || (ceiling != null && ceiling <= nums[i])) {\n                return true;\n            }\n            \n            set.add(nums[i]);\n            \n            if (i >= indexDiff) {\n                set.remove(nums[i - indexDiff]);\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        if indexDiff <= 0:\n            return False\n        \n        seen = {}\n        \n        for i in range(len(nums)):\n            if i > indexDiff:\n                del seen[nums[i - indexDiff - 1] // (valueDiff + 1)]\n            \n            bucket = nums[i] // (valueDiff + 1)\n            \n            for key in [bucket, bucket - 1, bucket + 1]:\n                if key in seen and abs(nums[i] - seen[key]) <= valueDiff:\n                    return True\n            \n            seen[bucket] = nums[i]\n        \n        return False\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool containsNearbyAlmostDuplicate(int* nums, int \nnumsSize, int indexDiff, int valueDiff) {\n    if (nums == NULL || numsSize <= 1) {\n        return false;\n    }\n    \n    for (int i = 0; i < numsSize; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            if (abs(i - j) <= indexDiff && abs(nums[i] - nums[j]) <= valueDiff) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\n        SortedSet<long> set = new SortedSet<long>();\n        for (int i = 0; i < nums.Length; i++) {\n            if (i > indexDiff) {\n                set.Remove(nums[i - indexDiff - 1]);\n            }\n            var index = set.GetViewBetween((long)nums[i] - valueDiff, (long)nums[i] + valueDiff).GetEnumerator();\n            if (index.MoveNext()) {\n                return true;\n            }\n            set.Add(nums[i]);\n        }\n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} indexDiff\n * @param {number} valueDiff\n * @return {boolean}\n */\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\n    const set = new Set();\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = Math.max(0, i - indexDiff); j < i; j++) {\n            if (Math.abs(nums[i] - nums[j]) <= valueDiff) {\n                return true;\n            }\n        }\n        for (let j = i + 1; j <= Math.min(i + indexDiff, nums.length - 1); j++) {\n            if (Math.abs(nums[i] - nums[j]) <= valueDiff) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can utilize a combination of a bucket sort algorithm and a sliding window technique. We aim to find if there exists a pair of indices \\( i \\) and \\( j \\) that satisfies the given conditions using these methods.\n\n## Explanation\n1. **Bucket Sort**: \n   - We will map each element in `nums` to a 'bucket'.\n   - A bucket represents a range of values. By dividing the value of the element by `(valueDiff + 1)`, we determine the bucket it falls into.\n2. **Sliding Window**:\n   - As we traverse through the list, we maintain a sliding window of elements up to `indexDiff`.\n   - If an element is outside this window (defined by `indexDiff`), it is removed from the bucket.\n3. **Neighboring Buckets**:\n   - For each element, apart from its own bucket, we also check the neighboring buckets because there might be a number within the `valueDiff` range in an adjacent bucket.\n\n## Pseudocode\n```pseudocode\nfunction containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff):\n    if indexDiff <= 0:\n        return False\n\n    # Dictionary to store the elements in their respective buckets\n    seen = {}\n\n    for i = 0 to len(nums) - 1:\n        # Remove the element that is out of the window\n        if i > indexDiff:\n            remove_bucket = nums[i - indexDiff - 1] // (valueDiff + 1)\n            delete seen[remove_bucket]\n\n        # Determine the current bucket for nums[i]\n        bucket = nums[i] // (valueDiff + 1)\n\n        # Check the current bucket and neighboring buckets\n        for key in [bucket, bucket - 1, bucket + 1]:\n            if key in seen and abs(nums[i] - seen[key]) <= valueDiff:\n                return True\n\n        # Store the current element in its bucket\n        seen[bucket] = nums[i]\n\n    return False\n```\nThese steps should help solve the problem efficiently, keeping the time complexity manageable. By ensuring elements are properly bucketed and maintaining a sliding window, we make sure the constraints of the problem are suitably addressed.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-contains-duplicate-iii"
    },
    {
        "name": "Number Of Digit One",
        "site": "LeetCode",
        "href": "/solution/LeetCode-number-of-digit-one",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        int count = 0;\n        for (long long i = 1; i <= n; i *= 10) {\n            long long divider = i * 10;\n            count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n        }\n        return count;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int countDigitOne(int n) {\n        int count = 0;\n        for (long i = 1; i <= n; i *= 10) {\n            long divider = i * 10;\n            count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n        }\n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def countDigitOne(self, n):\n        ones, m = 0, 1\n        while m <= n:\n            ones += (n // (m * 10)) * m + min(max(n % (m * 10) - m + 1, 0), m)\n            m *= 10\n        return ones"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int countDigitOne(int n) {\n    int count = 0;\n    for (long long i = 1; i <= n; i *= 10) {\n        long long divider = i * 10;\n        count += (n / divider) * i + fmin(fmax(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var countDigitOne = function(n) {\n    let count = 0;\n    for (let i = 1; i <= n; i *= 10) {\n        let divider = i * 10;\n\n        count += Math.floor(n / divider) * i + // full 1s from 1 - 9, 10 - 19, etc.\n                 Math.min(Math.max(n % divider - i + 1, 0), i); // partial 1s at the end\n    }\n    return count;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "var countDigitOne = function(n: number): number {\n    let count = 0;\n    for (let i = 1; i <= n; i *= 10) {\n        let divider = i * 10;\n        \n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    \n    return count;\n};"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn count_digit_one(n: i32) -> i32 {\n        let n = n as i64;\n        let mut count = 0;\n        let mut i = 1;\n        \n        while i <= n {\n            let divider = i * 10;\n            count += (n / divider) * i + std::cmp::min(i.max(0), std::cmp::max(0, n % divider - i + 1));\n            i *= 10;\n        }\n        \n        count as i32\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "count_digit_one(N) ->\n    count_digit_one(N, 1, 1, 0).\n\ncount_digit_one(0, _, _, Count) ->\n    Count;\ncount_digit_one(N, Mul, Base, Count) when N >= Base ->\n    Next = (N div (Base * 10)) * Base +\n            min(Base, max(0, N rem (Base * 10) - Base + 1)),\n    count_digit_one(N, Mul*10, Base*10, Count + Next);\ncount_digit_one(N, Mul, Base, Count) when N < Base ->\n    Count.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to count the total number of digit '1' appearing in all non-negative integers less than or equal to a given integer `n`.\n\n# Explanation\n\n1. **Initialization**:\n   - Start with variables `ones` to count the number of digit '1's, and `m` to represent the current place value we are examining (units, tens, hundreds, etc.).\n\n2. **Iteration Through Place Values**:\n   - Iterate over the place values (1, 10, 100, etc.) using a while loop. Continue the loop as long as `m` is less than or equal to `n`.\n\n3. **Calculation of '1's Frequency**:\n   - At each place value `m`, compute how many complete cycles (each of `m * 10` range) fit into `n` and the number of '1's contributed by these cycles. This is given by `(n // (m * 10)) * m`.\n   - Account for the remaining numbers from incomplete cycle at current place. This is given by `min(max(n % (m * 10) - m + 1, 0), m)`.\n   - Add these two quantities to `ones` and move to the next place value by multiplying `m` by 10.\n\n4. **Return Result**:\n   - After processing all place values, `ones` will contain the total count of digit '1's and we return it.\n\n# Pseudocode\n\n```\nfunction countDigitOne(n):\n    ones = 0\n    m = 1\n    \n    while m <= n:\n        # Number of complete cycles of (m*10) in n\n        complete_cycles = n // (m * 10) * m\n        # Remaining number in the current cycle that may contain '1's\n        remainder = min(max(n % (m * 10) - m + 1, 0), m)\n        \n        # Update ones count\n        ones += complete_cycles + remainder\n        \n        # Move to the next place value\n        m *= 10\n        \n    return ones\n```\n\nThis method ensures that we systematically count the '1's in each digit place without generating all numbers up to `n`, making it a highly efficient solution suitable even for large values close to \\(10^9\\).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-number-of-digit-one"
    },
    {
        "name": "Rectangle Area",
        "site": "LeetCode",
        "href": "/solution/LeetCode-rectangle-area",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int area1 = (ax2 - ax1) * (ay2 - ay1);\n        int area2 = (bx2 - bx1) * (by2 - by1);\n        \n        int overlapWidth = min(ax2, bx2) - max(ax1, bx1);\n        int overlapHeight = min(ay2, by2) - max(ay1, by1);\n        int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);\n        \n        return area1 + area2 - overlapArea;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int areaA = (ax2 - ax1) * (ay2 - ay1);\n        int areaB = (bx2 - bx1) * (by2 - by1);\n        \n        int overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n        int overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n        \n        int overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n        \n        return areaA + areaB - overlapArea;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n        area_a = (ax2 - ax1) * (ay2 - ay1)\n        area_b = (bx2 - bx1) * (by2 - by1)\n        \n        overlap_width = min(ax2, bx2) - max(ax1, bx1)\n        overlap_height = min(ay2, by2) - max(ay1, by1)\n        overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n        \n        return area_a + area_b - overlap_area"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n    int overlapWidth = fmin(ax2, bx2) - fmax(ax1, bx1);\n    int overlapHeight = fmin(ay2, by2) - fmax(ay1, by1);\n    int overlapArea = fmax(overlapWidth, 0) * fmax(overlapHeight, 0);\n    return area1 + area2 - overlapArea;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int ComputeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int areaA = Math.Abs(ax1 - ax2) * Math.Abs(ay1 - ay2);\n        int areaB = Math.Abs(bx1 - bx2) * Math.Abs(by1 - by2);\n        \n        int overlapWidth = Math.Max(0, Math.Min(ax2, bx2) - Math.Max(ax1, bx1));\n        int overlapHeight = Math.Max(0, Math.Min(ay2, by2) - Math.Max(ay1, by1));\n        int overlapArea = overlapWidth * overlapHeight;\n        \n        return areaA + areaB - overlapArea;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} ax1\n * @param {number} ay1\n * @param {number} ax2\n * @param {number} ay2\n * @param {number} bx1\n * @param {number} by1\n * @param {number} bx2\n * @param {number} by2\n * @return {number}\n */\nconst computeArea = (ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) => {\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\n    const area2 = (bx2 - bx1) * (by2 - by1);\n    \n    const overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    const overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n    const overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n    \n    return area1 + area2 - overlapArea;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function computeArea(ax1: number, ay1: number, ax2: number, ay2: number, bx1: number, by1: number, bx2: number, by2: number): number {\n    const areaA = (ax2 - ax1) * (ay2 - ay1);\n    const areaB = (bx2 - bx1) * (by2 - by1);\n    \n    const overlapWidth = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1));\n    const overlapHeight = Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));\n    const overlapArea = overlapWidth * overlapHeight;\n    \n    return areaA + areaB - overlapArea;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $ax1\n     * @param Integer $ay1\n     * @param Integer $ax2\n     * @param Integer $ay2\n     * @param Integer $bx1\n     * @param Integer $by1\n     * @param Integer $bx2\n     * @param Integer $by2\n     * @return Integer\n     */\n    function computeArea($ax1, $ay1, $ax2, $ay2, $bx1, $by1, $bx2, $by2) {\n        $areaA = abs($ax2 - $ax1) * abs($ay2 - $ay1);\n        $areaB = abs($bx2 - $bx1) * abs($by2 - $by1);\n        \n        $overlapX = max(0, min($ax2, $bx2) - max($ax1, $bx1));\n        $overlapY = max(0, min($ay2, $by2) - max($ay1, $by1));\n        $overlapArea = $overlapX * $overlapY;\n        \n        return $areaA + $areaB - $overlapArea;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func computeArea(_ ax1: Int, _ ay1: Int, _ ax2: Int, _ ay2: Int, _ bx1: Int, _ by1: Int, _ bx2: Int, _ by2: Int) -> Int {\n        let totalArea = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1)\n        let overlapWidth = max(0, min(ax2, bx2) - max(ax1, bx1))\n        let overlapHeight = max(0, min(ay2, by2) - max(ay1, by1))\n        let overlapArea = overlapWidth * overlapHeight\n        return totalArea - overlapArea\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun computeArea(ax1: Int, ay1: Int, ax2: Int, ay2: Int, bx1: Int, by1: Int, bx2: Int, by2: Int): Int {\n        val area1 = (ax2 - ax1) * (ay2 - ay1)\n        val area2 = (bx2 - bx1) * (by2 - by1)\n        \n        val overlapWidth = minOf(ax2, bx2) - maxOf(ax1, bx1)\n        val overlapHeight = minOf(ay2, by2) - maxOf(ay1, by1)\n        val overlapArea = maxOf(0, overlapWidth) * maxOf(0, overlapHeight)\n        \n        return area1 + area2 - overlapArea\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int areaA = (ax2 - ax1) * (ay2 - ay1);\n    int areaB = (bx2 - bx1) * (by2 - by1);\n    \n    int overlapWidth = min(ax2, bx2) - max(ax1, bx1);\n    int overlapHeight = min(ay2, by2) - max(ay1, by1);\n    int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);\n    \n    return areaA + areaB - overlapArea;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func computeArea(ax1 int, ay1 int, ax2 int, ay2 int, bx1 int, by1 int, bx2 int, by2 int) int {\n    area1 := (ax2 - ax1) * (ay2 - ay1)\n    area2 := (bx2 - bx1) * (by2 - by1)\n\n    overlapWidth := min(ax2, bx2) - max(ax1, bx1)\n    overlapHeight := min(ay2, by2) - max(ay1, by1)\n\n    overlapArea := 0\n    if overlapWidth > 0 && overlapHeight > 0 {\n        overlapArea = overlapWidth * overlapHeight\n    }\n\n    return area1 + area2 - overlapArea\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} ax1\n# @param {Integer} ay1\n# @param {Integer} ax2\n# @param {Integer} ay2\n# @param {Integer} bx1\n# @param {Integer} by1\n# @param {Integer} bx2\n# @param {Integer} by2\n# @return {Integer}\ndef compute_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)\n    area_a = (ax2 - ax1) * (ay2 - ay1)\n    area_b = (bx2 - bx1) * (by2 - by1)\n  \n    x_overlap = [0, [ax2, bx2].min - [ax1, bx1].max].max\n    y_overlap = [0, [ay2, by2].min - [ay1, by1].max].max\n    overlap = x_overlap * y_overlap\n  \n    total_area = area_a + area_b - overlap\n  \n    total_area\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def computeArea(ax1: Int, ay1: Int, ax2: Int, ay2: Int, bx1: Int, by1: Int, bx2: Int, by2: Int): Int = {\n        val areaA = (ax2 - ax1) * (ay2 - ay1)\n        val areaB = (bx2 - bx1) * (by2 - by1)\n        \n        val overlapWidth = math.max(0, math.min(ax2, bx2) - math.max(ax1, bx1))\n        val overlapHeight = math.max(0, math.min(ay2, by2) - math.max(ay1, by1))\n        \n        val overlapArea = overlapWidth * overlapHeight\n        \n        areaA + areaB - overlapArea\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn compute_area(ax1: i32, ay1: i32, ax2: i32, ay2: i32, bx1: i32, by1: i32, bx2: i32, by2: i32) -> i32 {\n        let overlap_width = (ax2.min(bx2) - ax1.max(bx1)).max(0);\n        let overlap_height = (ay2.min(by2) - ay1.max(by1)).max(0);\n        let area1 = (ax2 - ax1) * (ay2 - ay1);\n        let area2 = (bx2 - bx1) * (by2 - by1);\n        let overlap_area = overlap_width * overlap_height;\n        area1 + area2 - overlap_area\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec compute_area(Ax1 :: integer(), Ay1 :: integer(), Ax2 :: integer(), Ay2 :: integer(), Bx1 :: integer(), By1 :: integer(), Bx2 :: integer(), By2 :: integer()) -> integer().\ncompute_area(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2) ->\n    Rect1Area = abs(Ax2 - Ax1) * abs(Ay2 - Ay1),\n    Rect2Area = abs(Bx2 - Bx1) * abs(By2 - By1),\n    OverlapX = max(0, min(Ax2, Bx2) - max(Ax1, Bx1)),\n    OverlapY = max(0, min(Ay2, By2) - max(Ay1, By1)),\n    OverlapArea = OverlapX * OverlapY,\n    TotalArea = Rect1Area + Rect2Area - OverlapArea.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec compute_area(ax1 :: integer, ay1 :: integer, ax2 :: integer, ay2 :: integer, bx1 :: integer, by1 :: integer, bx2 :: integer, by2 :: integer) :: integer\n  def compute_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) do\n    total_area = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1)\n    overlap_area =\n      if ax2 <= bx1 or bx2 <= ax1 or ay2 <= by1 or by2 <= ay1 do\n        0\n      else\n        overlap_width = min(ax2, bx2) - max(ax1, bx1)\n        overlap_height = min(ay2, by2) - max(ay1, by1)\n        overlap_width * overlap_height\n      end\n    total_area - overlap_area\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to calculate the area of two rectangles, taking into account their possible overlap.\n\n# Explanation\n1. **Calculate Individual Areas**: Compute the area of each rectangle independently using the formula:\n   \\[\n   \\text{Area} = (\\text{width}) \\times (\\text{height})\n   \\]\n   For rectangle A with coordinates \\((ax1, ay1)\\) and \\((ax2, ay2)\\), the width is \\((ax2 - ax1)\\) and the height is \\((ay2 - ay1)\\). Similarly, compute for rectangle B.\n\n2. **Calculate Overlapping Area**: Determine the overlap. The overlap will have a width and height defined by the intersecting region of the two rectangles.\n   - The overlap width is:\n     \\[\n     \\text{overlap\\_width} = \\min(ax2, bx2) - \\max(ax1, bx1)\n     \\]\n   - The overlap height is:\n     \\[\n     \\text{overlap\\_height} = \\min(ay2, by2) - \\max(ay1, by1)\n     \\]\n   - If there is no overlap, the values will be non-positive. Use `max` with 0 to handle this.\n\n3. **Total Area Calculation**: Sum the areas of the two rectangles and then subtract the overlapping area to avoid double-counting the area.\n\n# Pseudocode\n```\nfunction computeArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    # Calculate area of rectangle A\n    area_a = (ax2 - ax1) * (ay2 - ay1)\n    \n    # Calculate area of rectangle B\n    area_b = (bx2 - bx1) * (by2 - by1)\n    \n    # Calculate the width and height of the overlapping region\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n    \n    # Calculate overlapping area (ensure non-negative values)\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n    \n    # Compute the total area\n    total_area = area_a + area_b - overlap_area\n    \n    return total_area\n```\n\nThis pseudocode outlines the process for computing the total area covered by the two rectangles, considering any possible overlap.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-rectangle-area"
    },
    {
        "name": "Maximal Square",
        "site": "LeetCode",
        "href": "/solution/LeetCode-maximal-square",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        int maxLength = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = matrix[i][j] - '0';\n                } else if (matrix[i][j] == '1') {\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n                }\n                maxLength = max(maxLength, dp[i][j]);\n            }\n        }\n        return maxLength * maxLength;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int[][] dp = new int[m][n];\n        int max = 0;\n        \n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(i == 0 || j == 0) {\n                    dp[i][j] = matrix[i][j] - '0';\n                    max = Math.max(max, dp[i][j]);\n                } else if(matrix[i][j] == '1') {\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n                    max = Math.max(max, dp[i][j]);\n                }\n            }\n        }\n        \n        return max * max;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maximalSquare(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n        \n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n        max_side = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == \"1\":\n                    dp[i][j] = 1\n                    if i > 0 and j > 0:\n                        dp[i][j] += min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                    max_side = max(max_side, dp[i][j])\n        \n        return max_side * max_side"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int min(int a, int b, int c) {\n    int min = a;\n    if (b < min) min = b;\n    if (c < min) min = c;\n    return min;\n}\n\nint maximalSquare(char** matrix, int matrixSize, int* matrixColSize) {\n    if (matrixSize == 0 || *matrixColSize == 0) return 0;\n\n    int maxSide = 0;\n    int rows = matrixSize;\n    int cols = *matrixColSize;\n    int dp[rows][cols];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dp[i][j] = matrix[i][j] - '0';\n            if (dp[i][j] == 1) {\n                maxSide = 1;\n            }\n        }\n    }\n\n    for (int i = 1; i < rows; i++) {\n        for (int j = 1; j < cols; j++) {\n            if (dp[i][j] == 1) {\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;\n                if (dp[i][j] > maxSide) {\n                    maxSide = dp[i][j];\n                }\n            }\n        }\n    }\n\n    return maxSide * maxSide;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaximalSquare(char[][] matrix) {\n        if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0)\n            return 0;\n\n        int m = matrix.Length;\n        int n = matrix[0].Length;\n        int[][] dp = new int[m][];\n        int maxLength = 0;\n\n        for (int i = 0; i < m; i++) {\n            dp[i] = new int[n];\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = matrix[i][j] - '0';\n                } else if (matrix[i][j] == '1') {\n                    dp[i][j] = Math.Min(dp[i - 1][j], Math.Min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\n                }\n                maxLength = Math.Max(maxLength, dp[i][j]);\n            }\n        }\n\n        return maxLength * maxLength;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalSquare = function(matrix) {\n    if (matrix.length === 0) return 0;\n    \n    let m = matrix.length, n = matrix[0].length;\n    let dp = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0));\n    let maxLen = 0;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i-1][j-1] === '1') {\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\n                maxLen = Math.max(maxLen, dp[i][j]);\n            }\n        }\n    }\n    \n    return maxLen * maxLen;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maximalSquare(matrix: string[][]): number {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    let maxSide = 0;\n\n    const dp: number[][] = Array(rows)\n        .fill(0)\n        .map(() => Array(cols).fill(0));\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (matrix[i][j] === '1') {\n                if (i === 0 || j === 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                }\n                maxSide = Math.max(maxSide, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSide * maxSide;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $matrix\n     *\n     * @return Integer\n     */\n    function maximalSquare($matrix) {\n         $max = 0;\n        $rows = count($matrix);\n        $cols = count($matrix[0]);\n        \n         $dp = array_fill(0, $rows + 1, array_fill(0, $cols + 1, 0));\n        \n         for($i = 1; $i <= $rows; $i++) {\n            for($j = 1; $j <= $cols; $j++) {\n                if($matrix[$i-1][$j-1] == '1') {\n                    $dp[$i][$j] = 1 + min($dp[$i-1][$j], $dp[$i][$j-1], $dp[$i-1][$j-1]);\n                    $max = max($max, $dp[$i][$j]);\n                }\n            }\n        }\n        \n        return $max * $max;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maximalSquare(_ matrix: [[Character]]) -> Int {\n        var m = matrix.count\n        var n = matrix[0].count\n        var dp = [[Int]](repeating: [Int](repeating: 0, count: n), count: m)\n        var maxSize = 0\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                dp[i][j] = matrix[i][j].wholeNumberValue ?? 0\n                if i > 0 && j > 0 && dp[i][j] == 1 {\n                    dp[i][j] += min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n                }\n                maxSize = max(maxSize, dp[i][j])\n            }\n        }\n        \n        return maxSize * maxSize\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maximalSquare(matrix: Array<CharArray>): Int {\n        if (matrix.isEmpty()) return 0\n        \n        val m = matrix.size\n        val n = matrix[0].size\n        var maxSide = 0\n        val dp = Array(m) { IntArray(n) }\n        \n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                if (matrix[i][j] == '1') {\n                    if (i == 0 || j == 0) {\n                        dp[i][j] = 1\n                    } else {\n                        dp[i][j] = minOf(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                    }\n                    maxSide = maxOf(maxSide, dp[i][j])\n                }\n            }\n        }\n        \n        return maxSide * maxSide\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maximalSquare(List<List<String>> matrix) {\n    if (matrix.isEmpty) return 0;\n    \n    int m = matrix.length;\n    int n = matrix[0].length;\n    \n    List<List<int>> dp = List.generate(m, (_) => List.filled(n, 0));\n    int maxSide = 0;\n    \n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (matrix[i][j] == \"1\") {\n          if (i == 0 || j == 0) {\n            dp[i][j] = 1;\n          } else {\n            dp[i][j] = 1 + \n              min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]));\n          }\n          maxSide = max(maxSide, dp[i][j]);\n        }\n      }\n    }\n    \n    return maxSide * maxSide;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maximalSquare(matrix [][]byte) int {\n    if len(matrix) == 0 || len(matrix[0]) == 0 {\n        return 0\n    }\n    \n    m := len(matrix)\n    n := len(matrix[0])\n    dp := make([][]int, m+1)\n    for i := 0; i <= m; i++ {\n        dp[i] = make([]int, n+1)\n    }\n    \n    maxSquare := 0\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            if matrix[i-1][j-1] == '1' {\n                dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))\n                maxSquare = max(maxSquare, dp[i][j]*dp[i][j])\n            }\n        }\n    }\n    \n    return maxSquare\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[][]} matrix\n# @return {Integer}\ndef maximal_square(matrix)\n    return 0 if matrix.empty? || matrix[0].empty?\n    \n    m = matrix.length\n    n = matrix[0].length\n    dp = Array.new(m) { Array.new(n, 0) }\n\n    max_side = 0\n    (0..m-1).each do |i|\n        (0..n-1).each do |j|\n            if matrix[i][j] == '1'\n                if i == 0 || j == 0\n                    dp[i][j] = 1\n                else\n                    dp[i][j] = [dp[i-1][j], dp[i][j-1], dp[i-1][j-1]].min + 1\n                end\n                max_side = [max_side, dp[i][j]].max\n            end\n        end\n    end\n\n    max_square = max_side * max_side\n    return max_square\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maximalSquare(matrix: Array[Array[Char]]): Int = {\n        if (matrix.isEmpty) return 0\n        val m = matrix.length\n        val n = matrix(0).length\n        val dp = Array.ofDim[Int](m, n)\n        var maxLen = 0\n\n        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n                if (i == 0 || j == 0) {\n                    dp(i)(j) = matrix(i)(j) - '0'\n                } else if (matrix(i)(j) == '1') {\n                    dp(i)(j) = 1 + dp(i-1)(j).min(dp(i)(j-1).min(dp(i-1)(j-1)))\n                }\n                maxLen = maxLen.max(dp(i)(j))\n            }\n        }\n\n        maxLen * maxLen\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\n        if matrix.is_empty() || matrix[0].is_empty() {\n            return 0;\n        }\n        \n        let m = matrix.len();\n        let n = matrix[0].len();\n        let mut dp = vec![vec![0; n+1]; m+1];\n        let mut max_side = 0;\n        \n        for i in 1..=m {\n            for j in 1..=n {\n                if matrix[i-1][j-1] == '1' {\n                    dp[i][j] = 1 + dp[i-1][j-1].min(dp[i-1][j].min(dp[i][j-1]));\n                    max_side = max_side.max(dp[i][j]);\n                }\n            }\n        }\n        \n        max_side * max_side\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to locate the largest square containing only 1's within a given binary matrix and return its area.\n\n# Explanation\n1. **Matrix Check**: Ensure the matrix is non-empty.\n2. **Initialization**: Use a dynamic programming (DP) approach by initializing a DP table of the same dimensions as the input matrix. Each cell in the DP table will store the size of the largest square whose bottom-right corner is at that cell.\n3. **DP Table Update**: Iterate over each cell in the matrix:\n   - If a cell contains '1', update the corresponding DP cell. Check the top, left, and top-left neighboring cells to determine the size of the largest possible square ending at the current cell.\n   - Update the maximum side length of the square found during the iteration.\n4. **Result Computation**: The area of the largest square will be the square of the maximum side length found.\n\n# Pseudocode\n```pseudocode\nfunction maximalSquare(matrix):\n    if matrix is empty:\n        return 0\n    \n    rows = length of matrix\n    cols = length of matrix[0]\n    \n    // Initialize the DP table\n    dp_table = create 2D array with dimensions rows x cols filled with 0\n    \n    max_side_length = 0\n    \n    // Iterate over each cell in the matrix\n    for i from 0 to rows-1:\n        for j from 0 to cols-1:\n            if matrix[i][j] == '1':\n                dp_table[i][j] = 1\n                if i > 0 and j > 0:\n                    dp_table[i][j] += minimum(dp_table[i-1][j], dp_table[i][j-1], dp_table[i-1][j-1])\n                    \n                max_side_length = maximum(max_side_length, dp_table[i][j])\n    \n    // The area is the square of the side length\n    return max_side_length * max_side_length\n```\n\nThis algorithm runs in O(m * n) time complexity where m and n are the dimensions of the matrix, as it processes each cell once. The space complexity is also O(m * n) due to the extra DP table used for computation.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-maximal-square"
    },
    {
        "name": "Invert Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-invert-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr) return nullptr;\n        TreeNode* temp = root->left;\n        root->left = invertTree(root->right);\n        root->right = invertTree(temp);\n        return root;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        \n        TreeNode left = invertTree(root.left);\n        TreeNode right = invertTree(root.right);\n        \n        root.left = right;\n        root.right = left;\n        \n        return root;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def invertTree(self, root):\n        if not root:\n            return None\n        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n        return root"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* invertTree(struct TreeNode* root){\n    if(root == NULL){\n        return NULL;\n    }\n    \n    struct TreeNode* temp = root->left;\n    root->left = invertTree(root->right);\n    root->right = invertTree(temp);\n    \n    return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode InvertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        \n        TreeNode temp = root.left;\n        root.left = InvertTree(root.right);\n        root.right = InvertTree(temp);\n        \n        return root;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\nvar invertTree = function(root) {\n    if (!root) {\n        return null;\n    }\n    \n    const temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    \n    return root;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number;\n *     left: TreeNode | null;\n *     right: TreeNode | null;\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val === undefined ? 0 : val);\n *         this.left = (left === undefined ? null : left);\n *         this.right = (right === undefined ? null : right);\n *     }\n * }\n */\nfunction invertTree(root: TreeNode | null): TreeNode | null {\n    if (!root) {\n        return null;\n    }\n    \n    const temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n    \n    return root;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) {\n *         $this->val = $value;\n *     }\n * }\n */\nclass Solution {\n    \n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function invertTree($root) {\n        if ($root === null) {\n            return null;\n        }\n        \n        $temp = $root->left;\n        $root->left = $this->invertTree($root->right);\n        $root->right = $this->invertTree($temp);\n        \n        return $root;\n    }\n}\n\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func invertTree(_ root: TreeNode?) -> TreeNode? {\n        if root == nil {\n            return nil\n        }\n        \n        let left = invertTree(root!.left)\n        let right = invertTree(root!.right)\n        \n        root!.left = right\n        root!.right = left\n        \n        return root\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun invertTree(root: TreeNode?): TreeNode? {\n        if (root == null) {\n            return null\n        }\n        \n        val left = invertTree(root.left)\n        val right = invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc invertTree(root *TreeNode) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    \n    left := invertTree(root.Left)\n    right := invertTree(root.Right)\n    \n    root.Left = right\n    root.Right = left\n    \n    return root\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n\ndef invert_tree(root)\n    return nil if root.nil?\n    \n    temp = root.left\n    root.left = invert_tree(root.right)\n    root.right = invert_tree(temp)\n    \n    root\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        match root {\n            Some(node) => {\n                let left = Solution::invert_tree(node.borrow().left.clone());\n                let right = Solution::invert_tree(node.borrow().right.clone());\n                node.borrow_mut().left = right;\n                node.borrow_mut().right = left;\n                Some(node)\n            }\n            None => None,\n        }\n    }\n}\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | \ninvert_tree(null) -> null;\ninvert_tree(#tree_node{left = Left, right = Right} = Node) ->\n    Node#tree_node{left = invert_tree(Right), right = invert_tree(Left)}.\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to invert a binary tree. Inverting a binary tree means swapping the left and right children of each node in the tree.\n\n# Explanation\n1. **Base Case**: If the root is `None` (i.e., the tree is empty), return `None`.\n2. **Recursive Case**: If the root is not `None`, recursively invert the left and right subtrees.\n3. **Swap**: After the subtrees are inverted, swap the left and right children of the current root.\n4. **Return**: Return the current root with its left and right children swapped.\n\n# Pseudocode\n```\nclass Solution:\n    def invertTree(self, root):\n        # Base case: if the tree is empty, return None\n        if not root:\n            return None\n        \n        # Recursive case: invert the left and right subtrees\n        left_inverted = self.invertTree(root.right)\n        right_inverted = self.invertTree(root.left)\n        \n        # Swap the left and right subtrees\n        root.left = left_inverted\n        root.right = right_inverted\n        \n        # Return the root\n        return root\n```\n\nThe pseudocode above outlines the steps required to invert the binary tree by recursively inverting and then swapping the left and right subtrees for each node.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-invert-binary-tree"
    },
    {
        "name": "Implement Queue Using Stacks",
        "site": "LeetCode",
        "href": "/solution/LeetCode-implement-queue-using-stacks",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class MyQueue {\npublic:\n    stack<int> in, out;\n\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        in.push(x);\n    }\n\n    int pop() {\n        if (out.empty()) {\n            while (!in.empty()) {\n                out.push(in.top());\n                in.pop();\n            }\n        }\n        int front = out.top();\n        out.pop();\n        return front;\n    }\n\n    int peek() {\n        if (out.empty()) {\n            while (!in.empty()) {\n                out.push(in.top());\n                in.pop();\n            }\n        }\n        return out.top();\n    }\n\n    bool empty() {\n        return in.empty() && out.empty();\n    }\n};\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class MyQueue {\n    private Stack<Integer> inputStack;\n    private Stack<Integer> outputStack;\n    \n    public MyQueue() {\n        inputStack = new Stack<>();\n        outputStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inputStack.push(x);\n    }\n    \n    public int pop() {\n        if (outputStack.isEmpty()) {\n            while (!inputStack.isEmpty()) {\n                outputStack.push(inputStack.pop());\n            }\n        }\n        return outputStack.pop();\n    }\n    \n    public int peek() {\n        if (outputStack.isEmpty()) {\n            while (!inputStack.isEmpty()) {\n                outputStack.push(inputStack.pop());\n            }\n        }\n        return outputStack.peek();\n    }\n    \n    public boolean empty() {\n        return inputStack.isEmpty() && outputStack.isEmpty();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class MyQueue(object):\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n\n    def pop(self):\n        return self.stack1.pop()\n\n    def peek(self):\n        return self.stack1[-1]\n\n    def empty(self):\n        return not self.stack1\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class MyQueue {\n    private Stack<int> inputStack;\n    private Stack<int> outputStack;\n\n    public MyQueue() {\n        inputStack = new Stack<int>();\n        outputStack = new Stack<int>();\n    }\n\n    public void Push(int x) {\n        inputStack.Push(x);\n    }\n\n    public int Pop() {\n        if (outputStack.Count == 0) {\n            while (inputStack.Count > 0) {\n                outputStack.Push(inputStack.Pop());\n            }\n        }\n        return outputStack.Pop();\n    }\n\n    public int Peek() {\n        if (outputStack.Count == 0) {\n            while (inputStack.Count > 0) {\n                outputStack.Push(inputStack.Pop());\n            }\n        }\n        return outputStack.Peek();\n    }\n\n    public bool Empty() {\n        return inputStack.Count == 0 && outputStack.Count == 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class MyQueue {\n    stack1: number[];\n    stack2: number[];\n\n    constructor() {\n        this.stack1 = [];\n        this.stack2 = [];\n    }\n\n    push(x: number): void {\n        this.stack1.push(x);\n    }\n\n    private shiftStacks(): void {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop() as number);\n            }\n        }\n    }\n\n    pop(): number {\n        this.shiftStacks();\n        return this.stack2.pop() as number;\n    }\n\n    peek(): number {\n        this.shiftStacks();\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty(): boolean {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class MyQueue {\n    private $stack1;\n    private $stack2;\n\n    function __construct() {\n        $this->stack1 = [];\n        $this->stack2 = [];\n    }\n\n    function push($x) {\n        array_push($this->stack1, $x);\n    }\n\n    function pop() {\n        if (empty($this->stack2)) {\n            while (!empty($this->stack1)) {\n                array_push($this->stack2, array_pop($this->stack1));\n            }\n        }\n        return array_pop($this->stack2);\n    }\n\n    function peek() {\n        if (empty($this->stack2)) {\n            while (!empty($this->stack1)) {\n                array_push($this->stack2, array_pop($this->stack1));\n            }\n        }\n        return end($this->stack2);\n    }\n\n    function empty() {\n        return empty($this->stack1) && empty($this->stack2);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class MyQueue {\n    var inputStack: [Int]\n    var outputStack: [Int]\n\n    init() {\n        inputStack = []\n        outputStack = []\n    }\n    \n    func push(_ x: Int) {\n        inputStack.append(x)\n    }\n    \n    func pop() -> Int {\n        if outputStack.isEmpty {\n            while let element = inputStack.popLast() {\n                outputStack.append(element)\n            }\n        }\n        return outputStack.popLast() ?? -1\n    }\n    \n    func peek() -> Int {\n        if outputStack.isEmpty {\n            while let element = inputStack.popLast() {\n                outputStack.append(element)\n            }\n        }\n        return outputStack.last ?? -1\n    }\n    \n    func empty() -> Bool {\n        return inputStack.isEmpty && outputStack.isEmpty\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class MyQueue() {\n    private val stack1 = mutableListOf<Int>()\n    private val stack2 = mutableListOf<Int>()\n\n    fun push(x: Int) {\n        while (stack1.isNotEmpty()) {\n            stack2.add(stack1.removeAt(stack1.size - 1))\n        }\n        stack1.add(x)\n        while (stack2.isNotEmpty()) {\n            stack1.add(stack2.removeAt(stack2.size - 1))\n        }\n    }\n\n    fun pop(): Int {\n        return stack1.removeAt(stack1.size - 1)\n    }\n\n    fun peek(): Int {\n        return stack1[stack1.size - 1]\n    }\n\n    fun empty(): Boolean {\n        return stack1.isEmpty()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class MyQueue {\n  late List<int> stack1;\n  late List<int> stack2;\n\n  MyQueue() {\n    stack1 = [];\n    stack2 = [];\n  }\n\n  void push(int x) {\n    stack1.add(x);\n  }\n\n  int pop() {\n    if (stack2.isEmpty) {\n      while (stack1.isNotEmpty) {\n        stack2.add(stack1.removeLast());\n      }\n    }\n    return stack2.removeLast();\n  }\n\n  int peek() {\n    if (stack2.isEmpty) {\n      while (stack1.isNotEmpty) {\n        stack2.add(stack1.removeLast());\n      }\n    }\n    return stack2.last;\n  }\n\n  bool empty() {\n    return stack1.isEmpty && stack2.isEmpty;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "type MyQueue struct {\n    inStack  []int\n    outStack []int\n}\n\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\nfunc (this *MyQueue) Push(x int) {\n    this.inStack = append(this.inStack, x)\n}\n\nfunc (this *MyQueue) shiftStacks() {\n    if len(this.outStack) == 0 {\n        for len(this.inStack) > 0 {\n            this.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\n            this.inStack = this.inStack[:len(this.inStack)-1]\n        }\n    }\n}\n\nfunc (this *MyQueue) Pop() int {\n    this.shiftStacks()\n    val := this.outStack[len(this.outStack)-1]\n    this.outStack = this.outStack[:len(this.outStack)-1]\n    return val\n}\n\nfunc (this *MyQueue) Peek() int {\n    this.shiftStacks()\n    return this.outStack[len(this.outStack)-1]\n}\n\nfunc (this *MyQueue) Empty() bool {\n    return len(this.inStack) == 0 && len(this.outStack) == 0\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "class MyQueue() {\n    private var stack1 = List[Int]()\n    private var stack2 = List[Int]()\n\n    def push(x: Int): Unit = {\n        stack1 = x :: stack1\n    }\n\n    def pop(): Int = {\n        if (stack2.isEmpty) {\n            while (stack1.nonEmpty) {\n                stack2 = stack1.head :: stack2\n                stack1 = stack1.tail\n            }\n        }\n        val res = stack2.head\n        stack2 = stack2.tail\n        res\n    }\n\n    def peek(): Int = {\n        if (stack2.isEmpty) {\n            while (stack1.nonEmpty) {\n                stack2 = stack1.head :: stack2\n                stack1 = stack1.tail\n            }\n        }\n        stack2.head\n    }\n\n    def empty(): Boolean = {\n        stack1.isEmpty && stack2.isEmpty\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "struct MyQueue {\n    s1: Vec<i32>,\n    s2: Vec<i32>,\n}\n\nimpl MyQueue {\n    fn new() -> Self {\n        Self {\n            s1: Vec::new(),\n            s2: Vec::new(),\n        }\n    }\n\n    fn push(&mut self, x: i32) {\n        self.s1.push(x);\n    }\n\n    fn pop(&mut self) -> i32 {\n        if self.s2.is_empty() {\n            while let Some(val) = self.s1.pop() {\n                self.s2.push(val);\n            }\n        }\n        self.s2.pop().unwrap()\n    }\n\n    fn peek(&mut self) -> i32 {\n        if self.s2.is_empty() {\n            while let Some(val) = self.s1.pop() {\n                self.s2.push(val);\n            }\n        }\n        *self.s2.last().unwrap()\n    }\n\n    fn empty(&self) -> bool {\n        self.s1.is_empty() && self.s2.is_empty()\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a queue using two stacks. This involves emulating the queue's FIFO behavior with the LIFO nature of stacks.\n\n# Explanation\n\n1. **Data Structures Required:**\n    - We will use two stacks (stack1 and stack2) to manage the queue operations.\n\n2. **Push Operation:**\n    - When a new element is pushed into the queue, we first move all elements from stack1 to stack2.\n    - We then push the new element onto stack1.\n    - Lastly, we move all elements back from stack2 to stack1. This way, the new element is at the bottom of stack1, preserving the FIFO order.\n\n3. **Pop Operation:**\n    - To remove the front element, we simply pop the top element from stack1.\n\n4. **Peek Operation:**\n    - To retrieve the front element without removing it, we return the top element of stack1.\n\n5. **Empty Operation:**\n    - To check if the queue is empty, we check if stack1 is empty.\n\n# Pseudocode\n\n```pseudocode\nclass MyQueue:\n    # Initialize the queue\n    function __init__():\n        stack1 = []  # Primary stack to hold elements in queue order\n        stack2 = []  # Auxiliary stack used during push operations\n\n    # Add an element to the back of the queue\n    function push(x):\n        while stack1 is not empty:\n            stack2.append(stack1.pop())\n        stack1.append(x)\n        while stack2 is not empty:\n            stack1.append(stack2.pop())\n\n    # Remove and return the element from the front of the queue\n    function pop() -> int:\n        return stack1.pop()\n\n    # Return the element at the front of the queue without removing it\n    function peek() -> int:\n        return stack1[-1]\n\n    # Return true if the queue is empty, false otherwise\n    function empty() -> bool:\n        return length of stack1 == 0\n```\n\nThis pseudocode details how to implement each queue operation using only the fundamental operations provided by a stack. By manipulating two stacks in this manner, the queue's FIFO behavior is maintained.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-implement-queue-using-stacks"
    },
    {
        "name": "Power Of Two",
        "site": "LeetCode",
        "href": "/solution/LeetCode-power-of-two",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if (n <= 0) {\n            return false;\n        }\n        return (n & (n - 1)) == 0;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        return n & (n - 1) == 0"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsPowerOfTwo(int n) {\n        if (n <= 0) {\n            return false;\n        }\n        \n        return (n & (n - 1)) == 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst isPowerOfTwo = (n) => {\n    return n > 0 && (n & (n - 1)) === 0;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isPowerOfTwo(n: number): boolean {\n    return n > 0 && (n & (n - 1)) === 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     */\n    function isPowerOfTwo($n) {\n        return $n > 0 && ($n & ($n - 1)) == 0;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isPowerOfTwo(_ n: Int) -> Bool {\n        return n > 0 && (n & (n - 1)) == 0\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isPowerOfTwo(n: Int): Boolean {\n        if (n <= 0) return false\n        return n and (n - 1) == 0\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isPowerOfTwo(int n) {\n      return n > 0 && (n & (n - 1)) == 0;\n      }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isPowerOfTwo(n int) bool {\n    return n > 0 && n&(n-1) == 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Boolean}\ndef is_power_of_two(n)\n    n > 0 && (n & (n - 1)) == 0\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isPowerOfTwo(n: Int): Boolean = {\n        n > 0 && (n & (n - 1)) == 0\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_power_of_two(n: i32) -> bool {\n        if n <= 0 {\n            return false;\n        }\n        \n        n & (n - 1) == 0\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec is_power_of_two(N :: integer()) -> boolean().\nis_power_of_two(N) ->\n    if\n        N =:= 0 -> false;\n        N band (N - 1) =:= 0 -> true;\n        true -> false\n    end."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll need to determine if a given integer \\( n \\) is a power of two. A number is a power of two if there exists an integer \\( x \\) such that \\( n = 2^x \\).\n\n# Explanation\nThe key property of numbers that are powers of two is that they have exactly one bit set to '1' in their binary representation. For example:\n- \\( 1 : 0001 \\)\n- \\( 2 : 0010 \\)\n- \\( 4 : 0100 \\)\n- \\( 8 : 1000 \\)\n\nA useful bit manipulation trick we can use is that for any power of two number \\( n \\), the expression \\( n \\& (n - 1) \\) will result in zero. This works because:\n- \\( n \\) in binary has a single '1' followed by '0's.\n- \\( (n - 1) \\) will have all bits flipped after the single '1'.\n\nFor example, consider \\( n = 8 \\):\n- \\( n = 1000 \\)\n- \\( n - 1 = 0111 \\)\n- \\( n \\& (n - 1) = 1000 \\& 0111 = 0000 \\)\n\nUsing this property, we can check if \\( n \\) is a power of two efficiently without using loops or recursion.\n\n# Pseudocode\nLet's write the pseudocode based on the above explanation:\n\n```\nFunction isPowerOfTwo(n: Integer) -> Boolean:\n    # Check if n is less than or equal to 0\n    If n <= 0:\n        Return False\n    \n    # If n is a power of two, n & (n - 1) should be 0\n    Return n & (n - 1) == 0\n```\n\nThis approach ensures that we only perform a couple of operations regardless of the value of \\( n \\), making it very efficient with a constant time complexity \\( O(1) \\).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-power-of-two"
    },
    {
        "name": "Kth Smallest Element In A Bst",
        "site": "LeetCode",
        "href": "/solution/LeetCode-kth-smallest-element-in-a-bst",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> st;\n        TreeNode* current = root;\n        int count = 0;\n        \n        while (current != nullptr || !st.empty()) {\n            while (current != nullptr) {\n                st.push(current);\n                current = current->left;\n            }\n            current = st.top();\n            st.pop();\n            count++;\n            if (count == k) {\n                return current->val;\n            }\n            current = current->right;\n        }\n        \n        return -1; // Just to handle the case when k is out of range\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode current = root;\n        int count = 0;\n        int result = 0;\n        \n        while (current != null || !stack.isEmpty()) {\n            while (current != null) {\n                stack.push(current);\n                current = current.left;\n            }\n            current = stack.pop();\n            count++;\n            if (count == k) {\n                result = current.val;\n                break;\n            }\n            current = current.right;\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n\nclass Solution(object):\n    def kthSmallest(self, root, k):\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if k == 0:\n                return root.val\n            root = root.right\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nvoid inorder(struct TreeNode* root, int k, int* count, int* result) {\n    if (root == NULL) {\n        return;\n    }\n    inorder(root->left, k, count, result);\n    (*count)++;\n    if (*count == k) {\n        *result = root->val;\n        return;\n    }\n    inorder(root->right, k, count, result);\n}\n\nint kthSmallest(struct TreeNode* root, int k) {\n    int count = 0;\n    int result = 0;\n    inorder(root, k, &count, &result);\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        while (true) {\n            while (root != null) {\n                stack.Push(root);\n                root = root.left;\n            }\n            root = stack.Pop();\n            if (--k == 0) {\n                return root.val;\n            }\n            root = root.right;\n        }\n    }\n}\n\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\n\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(root, k) {\n    let sortedValues = [];\n    \n    const inorderTraversal = (node) => {\n        if (node === null) {\n            return;\n        }\n        \n        inorderTraversal(node.left);\n        sortedValues.push(node.val);\n        inorderTraversal(node.right);\n    }\n    \n    inorderTraversal(root);\n    \n    return sortedValues[k - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?, right?) {\n *         this.val = (val === undefined ? 0 : val)\n *         this.left = (left === undefined ? null : left)\n *         this.right = (right === undefined ? null : right)\n *     }\n * }\n */\n\nfunction kthSmallest(root: TreeNode | null, k: number): number {\n    const stack: TreeNode[] = [];\n    let current: TreeNode | null = root;\n    let count = 0;\n    \n    while (current || stack.length > 0) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n        \n        current = stack.pop();\n        count++;\n        if (count === k) {\n            return current.val;\n        }\n        \n        current = current.right;\n    }\n    \n    return -1;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n\n    /**\n     * Definition for a binary tree node.\n     * class TreeNode {\n     *     public $val = null;\n     *     public $left = null;\n     *     public $right = null;\n     *     function __construct($value) {\n     *         $this->val = $value;\n     *     }\n     * }\n     */\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $k\n     * @return Integer\n     */\n    function kthSmallest($root, $k) {\n        $stack = [];\n        while (true) {\n            while ($root != null) {\n                $stack[] = $root;\n                $root = $root->left;\n            }\n            $root = array_pop($stack);\n            $k--;\n            if ($k == 0) {\n                return $root->val;\n            }\n            $root = $root->right;\n        }\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n        var result = 0\n        var count = 0\n        \n        func inorderTraversal(_ node: TreeNode?) {\n            guard let node = node else { return }\n            inorderTraversal(node.left)\n            count += 1\n            if count == k {\n                result = node.val\n                return\n            }\n            inorderTraversal(node.right)\n        }\n        \n        inorderTraversal(root)\n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun kthSmallest(root: TreeNode?, k: Int): Int {\n        val inorder = mutableListOf<Int>()\n        inorderTraversal(root, inorder)\n        return inorder[k - 1]\n    }\n\n    fun inorderTraversal(node: TreeNode?, inorder: MutableList<Int>) {\n        if (node == null) return\n        inorderTraversal(node.left, inorder)\n        inorder.add(node.`val`)\n        inorderTraversal(node.right, inorder)\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "// Definition for a binary tree node.\n// type TreeNode struct {\n//     Val int\n//     Left *TreeNode\n//     Right *TreeNode\n// }\n\nfunc kthSmallest(root *TreeNode, k int) int {\n    stack := []*TreeNode{}\n    \n    for {\n        for root != nil {\n            stack = append(stack, root)\n            root = root.Left\n        }\n        \n        root = stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        \n        k--\n        if k == 0 {\n            return root.Val\n        }\n        \n        root = root.Right\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef kth_smallest(root, k)\n    result = []\n    stack = []\n    node = root\n    \n    while !node.nil? || !stack.empty?\n        while !node.nil?\n            stack.push(node)\n            node = node.left\n        end\n        \n        node = stack.pop\n        result.push(node.val)\n        return result[k-1] if result.length == k\n        \n        node = node.right\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode \n= null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n  def kthSmallest(root: TreeNode, k: Int): Int = {\n    def inorderTraversal(node: TreeNode, nums: List[Int]): List[Int] = {\n      if (node == null) return nums\n      inorderTraversal(node.left, node.value :: inorderTraversal(node.right, nums))\n    }\n\n    val inorder = inorderTraversal(root, List[Int]())\n    inorder(k - 1)\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the kth smallest element in a binary search tree (BST). This can be efficiently done using an in-order traversal, which visits the nodes in ascending order for a BST.\n\n## Explanation\n\n1. **Traverse the Tree:** We use an in-order traversal to visit the nodes in ascending order.\n2. **Use a Stack for Iteration:** Instead of recursion, we use a stack to keep track of nodes.\n3. **Counting Until k:** We decrement `k` each time we visit a node. When `k` becomes zero, we have found the kth smallest element.\n\nAn in-order traversal starts with the leftmost node (the smallest), and proceeds to the root, then to the right sub-tree. Using a stack helps manage the traversal iteratively.\n\n## Pseudocode\n\n```pseudo\n# Definition for a binary tree node\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n\nfunction kthSmallest(TreeNode root, integer k):\n    # Initialize an empty stack\n    stack <- []\n\n    while True:\n        # Traverse to the leftmost node\n        while root is not null:\n            stack.push(root)\n            root <- root.left\n        \n        # Pop the node from the stack\n        root <- stack.pop()\n\n        # Decrement k (we have visited one more node)\n        k <- k - 1\n\n        # If k is zero, this is the kth smallest node\n        if k == 0:\n            return root.val\n        \n        # Move to the right subtree\n        root <- root.right\n```\n\nThis pseudocode succinctly outlines how the solution iterates through the tree iteratively while keeping track of the number of nodes visited to determine when the kth smallest node is found.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-kth-smallest-element-in-a-bst"
    },
    {
        "name": "Majority Element Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-majority-element-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        vector<int> result;\n        int num1 = -1, num2 = -1, count1 = 0, count2 = 0;\n        \n        for (int num : nums) {\n            if (num == num1) {\n                count1++;\n            } else if (num == num2) {\n                count2++;\n            } else if (count1 == 0) {\n                num1 = num;\n                count1 = 1;\n            } else if (count2 == 0) {\n                num2 = num;\n                count2 = 1;\n            } else {\n                count1--;\n                count2--;\n            }\n        }\n        \n        count1 = count2 = 0;\n        for (int num : nums) {\n            if (num == num1) {\n                count1++;\n            } else if (num == num2) {\n                count2++;\n            }\n        }\n        \n        if (count1 > nums.size() / 3) {\n            result.push_back(num1);\n        }\n        if (count2 > nums.size() / 3) {\n            result.push_back(num2);\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        \n        int num1 = 0, num2 = 0, count1 = 0, count2 = 0;\n        \n        for (int num : nums) {\n            if (num == num1) {\n                count1++;\n            } else if (num == num2) {\n                count2++;\n            } else if (count1 == 0) {\n                num1 = num;\n                count1++;\n            } else if (count2 == 0) {\n                num2 = num;\n                count2++;\n            } else {\n                count1--;\n                count2--;\n            }\n        }\n        \n        count1 = 0;\n        count2 = 0;\n        \n        for (int num : nums) {\n            if (num == num1) {\n                count1++;\n            } else if (num == num2) {\n                count2++;\n            }\n        }\n        \n        if (count1 > nums.length / 3) {\n            result.add(num1);\n        }\n        if (count2 > nums.length / 3) {\n            result.add(num2);\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        count1, count2, candidate1, candidate2 = 0, 0, 0, 1\n        \n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        \n        return [n for n in (candidate1, candidate2) if nums.count(n) > len(nums) // 3]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* majorityElement(int* nums, int numsSize, int* returnSize){\n    int candidate1 = 0, candidate2 = 0;\n    int count1 = 0, count2 = 0;\n    \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == candidate1) {\n            count1++;\n        } else if (nums[i] == candidate2) {\n            count2++;\n        } else if (count1 == 0) {\n            candidate1 = nums[i];\n            count1 = 1;\n        } else if (count2 == 0) {\n            candidate2 = nums[i];\n            count2 = 1;\n        } else {\n            count1--;\n            count2--;\n        }\n    }\n    \n    count1 = 0;\n    count2 = 0;\n    \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == candidate1) {\n            count1++;\n        } else if (nums[i] == candidate2) {\n            count2++;\n        }\n    }\n    \n    *returnSize = 0;\n    if (count1 > numsSize / 3) (*returnSize)++;\n    if (count2 > numsSize / 3 && candidate1 != candidate2) (*returnSize)++;\n    \n    int* res = (int*)malloc(sizeof(int) * (*returnSize));\n    int index = 0;\n    \n    if (count1 > numsSize / 3) res[index++] = candidate1;\n    if (count2 > numsSize / 3 && candidate1 != candidate2) res[index++] = candidate2;\n    \n    return res;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> MajorityElement(int[] nums) {\n        List<int> result = new List<int>();\n        if (nums == null || nums.Length == 0) {\n            return result;\n        }\n        \n        int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;\n        \n        foreach (int num in nums) {\n            if (num == candidate1) {\n                count1++;\n            } else if (num == candidate2) {\n                count2++;\n            } else if (count1 == 0) {\n                candidate1 = num;\n                count1 = 1;\n            } else if (count2 == 0) {\n                candidate2 = num;\n                count2 = 1;\n            } else {\n                count1--;\n                count2--;\n            }\n        }\n        \n        count1 = 0;\n        count2 = 0;\n        \n        foreach (int num in nums) {\n            if (num == candidate1) {\n                count1++;\n            } else if (num == candidate2) {\n                count2++;\n            }\n        }\n        \n        if (count1 > nums.Length / 3) {\n            result.Add(candidate1);\n        }\n        \n        if (count2 > nums.Length / 3) {\n            result.Add(candidate2);\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar majorityElement = function(nums) {\n    let count1 = 0, count2 = 0;\n    let candidate1, candidate2;\n    \n    for (let num of nums) {\n        if (num === candidate1) {\n            count1++;\n        } else if (num === candidate2) {\n            count2++;\n        } else if (count1 === 0) {\n            candidate1 = num;\n            count1 = 1;\n        } else if (count2 === 0) {\n            candidate2 = num;\n            count2 = 1;\n        } else {\n            count1--;\n            count2--;\n        }\n    }\n    \n    count1 = 0;\n    count2 = 0;\n    \n    for (let num of nums) {\n        if (num === candidate1) {\n            count1++;\n        } else if (num === candidate2) {\n            count2++;\n        }\n    }\n    \n    const result = [];\n    if (count1 > nums.length / 3) {\n        result.push(candidate1);\n    }\n    if (count2 > nums.length / 3) {\n        result.push(candidate2);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function majorityElement(nums: number[]): number[] {\n    const threshold = Math.floor(nums.length / 3);\n    const countMap: Map<number, number> = new Map();\n\n    for (const num of nums) {\n        countMap.set(num, (countMap.get(num) || 0) + 1);\n    }\n\n    const result: number[] = [];\n    for (const [num, count] of countMap) {\n        if (count > threshold) {\n            result.push(num);\n        }\n    }\n\n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function majorityElement($nums) {\n        $count = [];\n\n        foreach ($nums as $num) {\n            if (isset($count[$num])) {\n                $count[$num]++;\n            } else {\n                $count[$num] = 1;\n            }\n        }\n\n        $result = [];\n        $threshold = floor(count($nums) / 3);\n\n        foreach ($count as $num => $freq) {\n            if ($freq > $threshold) {\n                $result[] = $num;\n            }\n        }\n\n        return $result;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func majorityElement(_ nums: [Int]) -> [Int] {\n        var num1: Int?\n        var num2: Int?\n        var count1 = 0\n        var count2 = 0\n        \n        for num in nums {\n            if let num1 = num1, num == num1 {\n                count1 += 1\n            } else if let num2 = num2, num == num2 {\n                count2 += 1\n            } else if count1 == 0 {\n                num1 = num\n                count1 = 1\n            } else if count2 == 0 {\n                num2 = num\n                count2 = 1\n            } else {\n                count1 -= 1\n                count2 -= 1\n            }\n        }\n        \n        count1 = 0\n        count2 = 0\n        for num in nums {\n            if num == num1 {\n                count1 += 1\n            } else if num == num2 {\n                count2 += 1\n            }\n        }\n        \n        var result: [Int] = []\n        if count1 > nums.count/3 {\n            result.append(num1!)\n        }\n        if count2 > nums.count/3 {\n            result.append(num2!)\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun majorityElement(nums: IntArray): List<Int> {\n        val result = mutableListOf<Int>()\n        var candidate1: Int? = null\n        var count1 = 0\n        var candidate2: Int? = null\n        var count2 = 0\n        \n        for (num in nums) {\n            when {\n                candidate1 == num -> count1++\n                candidate2 == num -> count2++\n                count1 == 0 -> {\n                    candidate1 = num\n                    count1 = 1\n                }\n                count2 == 0 -> {\n                    candidate2 = num\n                    count2 = 1\n                }\n                else -> {\n                    count1--\n                    count2--\n                }\n            }\n        }\n        \n        count1 = 0\n        count2 = 0\n        \n        for (num in nums) {\n            if (num == candidate1) count1++\n            else if (num == candidate2) count2++\n        }\n        \n        if (count1 > nums.size / 3) result.add(candidate1!!)\n        if (count2 > nums.size / 3) result.add(candidate2!!)\n        \n        return result\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> majorityElement(List<int> nums) {\n    List<int> result = [];\n    if (nums.isEmpty) {\n      return result;\n    }\n    int num1 = nums[0];\n    int count1 = 0;\n    int num2 = nums[0];\n    int count2 = 0;\n\n    for (int num in nums) {\n      if (num == num1) {\n        count1++;\n      } else if (num == num2) {\n        count2++;\n      } else if (count1 == 0) {\n        num1 = num;\n        count1 = 1;\n      } else if (count2 == 0) {\n        num2 = num;\n        count2 = 1;\n      } else {\n        count1--;\n        count2--;\n      }\n    }\n\n    count1 = count2 = 0;\n    for (int num in nums) {\n      if (num == num1) {\n        count1++;\n      } else if (num == num2) {\n        count2++;\n      }\n    }\n\n    if (count1 > nums.length ~/ 3) {\n      result.add(num1);\n    }\n    if (count2 > nums.length ~/ 3) {\n      result.add(num2);\n    }\n\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func majorityElement(nums []int) []int {\n    var num1, num2, count1, count2 int\n\n    for _, num := range nums {\n        if num == num1 {\n            count1++\n        } else if num == num2 {\n            count2++\n        } else if count1 == 0 {\n            num1 = num\n            count1++\n        } else if count2 == 0 {\n            num2 = num\n            count2++\n        } else {\n            count1--\n            count2--\n        }\n    }\n\n    count1 = 0\n    count2 = 0\n    for _, num := range nums {\n        if num == num1 {\n            count1++\n        } else if num == num2 {\n            count2++\n        }\n    }\n\n    result := make([]int, 0)\n    if count1 > len(nums)/3 {\n        result = append(result, num1)\n    }\n    if count2 > len(nums)/3 {\n        result = append(result, num2)\n    }\n\n    return result\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef majority_element(nums)\n    count1, count2, candidate1, candidate2 = 0, 0, 0, 1\n    \n    nums.each do |num|\n        if num == candidate1\n            count1 += 1\n        elsif num == candidate2\n            count2 += 1\n        elsif count1 == 0\n            candidate1 = num\n            count1 = 1\n        elsif count2 == 0\n            candidate2 = num\n            count2 = 1\n        else\n            count1 -= 1\n            count2 -= 1\n        end\n    end\n    \n    count1, count2 = 0, 0\n    nums.each do |num|\n        count1 += 1 if num == candidate1\n        count2 += 1 if num == candidate2\n    end\n    \n    result = []\n    result << candidate1 if count1 > nums.length / 3\n    result << candidate2 if count2 > nums.length / 3\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def majorityElement(nums: Array[Int]): List[Int]  = {\n        var count1 = 0\n        var count2 = 0\n        var candidate1 = 0\n        var candidate2 = 1\n\n        for (num <- nums) {\n            if (num == candidate1) {\n                count1 += 1\n            } else if (num == candidate2) {\n                count2 += 1\n            } else if (count1 == 0) {\n                candidate1 = num\n                count1 = 1\n            } else if (count2 == 0) {\n                candidate2 = num\n                count2 = 1\n            } else {\n                count1 -= 1\n                count2 -= 1\n            }\n        }\n\n        count1 = 0\n        count2 = 0\n\n        for (num <- nums) {\n            if (num == candidate1) {\n                count1 += 1\n            } else if (num == candidate2) {\n                count2 += 1\n            }\n        }\n\n        val result = scala.collection.mutable.ListBuffer[Int]()\n        if (count1 > nums.length / 3) {\n            result += candidate1\n        }\n        if (count2 > nums.length / 3) {\n            result += candidate2\n        }\n\n        result.toList\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn majority_element(nums: Vec<i32>) -> Vec<i32> {\n        let mut count1 = 0;\n        let mut count2 = 0;\n        let mut candidate1 = 0;\n        let mut candidate2 = 1;\n        \n        for &num in nums.iter() {\n            if candidate1 == num {\n                count1 += 1;\n            } else if candidate2 == num {\n                count2 += 1;\n            } else if count1 == 0 {\n                candidate1 = num;\n                count1 = 1;\n            } else if count2 == 0 {\n                candidate2 = num;\n                count2 = 1;\n            } else {\n                count1 -= 1;\n                count2 -= 1;\n            }\n        }\n        \n        count1 = 0;\n        count2 = 0;\n        \n        for &num in nums.iter() {\n            if num == candidate1 {\n                count1 += 1;\n            } else if num == candidate2 {\n                count2 += 1;\n            }\n        }\n        \n        let mut result = Vec::new();\n        if count1 > nums.len() / 3 {\n            result.push(candidate1);\n        }\n        if count2 > nums.len() / 3 {\n            result.push(candidate2);\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (majority-element nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  (define count (make-hash))\n  (define threshold (quotient (length nums) 3))\n  (for ([num nums])\n    (hash-update! count num add1 0))\n  (for/list ([key (in-hash-keys count)]\n             #:when (> (hash-ref count key) threshold))\n    key) )"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec majority_element(nums :: [integer]) :: [integer]\n  def majority_element(nums) do\n    n = length(nums)\n    threshold = div(n, 3)\n    \n    nums\n    |> Enum.reduce(%{}, fn num, acc ->\n      Map.update(acc, num, 1, &(&1 + 1))\n    end)\n    |> Enum.filter(fn {_num, count} -> count > threshold end)\n    |> Enum.map(fn {num, _count} -> num end)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find all elements in the given array that appear more than \u230a n/3 \u230b times. The solution provided gives us a Python implementation, which we will break down into an explanation and pseudocode sections.\n\n# Explanation\n1. **Count Variables**: Declare variables `count1`, `count2`, `candidate1`, and `candidate2`. These will help us track two potential majority elements and their counts.\n2. **First Pass**: Iterate through the array and update the counts and potential candidates. If a number matches one of the candidates, its corresponding count is incremented. If a candidate\u2019s count drops to zero, that candidate is replaced.\n3. **Second Pass**: After identifying the two potential candidates, count their actual occurrences in the array. Return those that appear more than \u230a n/3 \u230b times as the result.\n\n# Pseudocode\n```\nfunction majorityElement(nums):\n    if (length of nums is 0):\n        return []\n    \n    // Initialize counts and candidates\n    count1 = 0\n    count2 = 0\n    candidate1 = 0\n    candidate2 = 1\n    \n    // First pass to find potential candidates\n    for each num in nums:\n        if (num == candidate1):\n            count1 += 1\n        else if (num == candidate2):\n            count2 += 1\n        else if (count1 == 0):\n            candidate1 = num\n            count1 = 1\n        else if (count2 == 0):\n            candidate2 = num\n            count2 = 1\n        else:\n            count1 -= 1\n            count2 -= 1\n    \n    // Validate counts of the potential candidates\n    result = []\n    if (nums.count(candidate1) > length of nums // 3):\n        append candidate1 to result\n    if (nums.count(candidate2) > length of nums // 3):\n        append candidate2 to result\n    \n    return result\n```\n\nThis pseudocode outlines the steps to solve the problem in linear time and constant space, meeting the problem requirements efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-majority-element-ii"
    },
    {
        "name": "Summary Ranges",
        "site": "LeetCode",
        "href": "/solution/LeetCode-summary-ranges",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> result;\n        if (nums.empty()) {\n            return result;\n        }\n        \n        int start = nums[0];\n        int end = nums[0];\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] == end + 1) {\n                end = nums[i];\n            } else {\n                if (start == end) {\n                    result.push_back(to_string(start));\n                } else {\n                    result.push_back(to_string(start) + \"->\" + to_string(end));\n                }\n                start = nums[i];\n                end = nums[i];\n            }\n        }\n        \n        if (start == end) {\n            result.push_back(to_string(start));\n        } else {\n            result.push_back(to_string(start) + \"->\" + to_string(end));\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        \n        int start = nums[0];\n        int end = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == end + 1) {\n                end = nums[i];\n            } else {\n                if (start == end) {\n                    result.add(String.valueOf(start));\n                } else {\n                    result.add(start + \"->\" + end);\n                }\n                start = end = nums[i];\n            }\n        }\n\n        if (start == end) {\n            result.add(String.valueOf(start));\n        } else {\n            result.add(start + \"->\" + end);\n        }\n\n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        if not nums:\n            return []\n        \n        result = []\n        start = end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    result.append(str(start))\n                else:\n                    result.append(str(start) + \"->\" + str(end))\n                start = end = nums[i]\n        \n        if start == end:\n            result.append(str(start))\n        else:\n            result.append(str(start) + \"->\" + str(end))\n        \n        return result\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume \ncaller calls free().\n */\n\nchar ** summaryRanges(int* nums, int numsSize, int* returnSize){\n    if(numsSize == 0){\n        *returnSize = 0;\n        return NULL;\n    }\n    \n    char **result = (char **)malloc(numsSize * sizeof(char *));\n    *returnSize = 0;\n    \n    for(int i = 0; i < numsSize; i++){\n        int start = nums[i];\n        \n        while(i + 1 < numsSize && nums[i + 1] == nums[i] + 1){\n            i++;\n        }\n        \n        if(start == nums[i]){\n            result[*returnSize] = (char *)malloc(20 * sizeof(char));\n            sprintf(result[*returnSize], \"%d\", start);\n        }else{\n            result[*returnSize] = (char *)malloc(40 * sizeof(char));\n            sprintf(result[*returnSize], \"%d->%d\", start, nums[i]);\n        }\n        \n        (*returnSize)++;\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> SummaryRanges(int[] nums) {\n        IList<string> result = new List<string>();\n        \n        for (int i = 0; i < nums.Length; i++) {\n            int start = nums[i];\n            while (i + 1 < nums.Length && nums[i + 1] == nums[i] + 1) {\n                i++;\n            }\n            int end = nums[i];\n            result.Add(start == end ? start.ToString() : start + \"->\" + end);\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {string[]}\n */\nconst summaryRanges = (nums) => {\n    const ranges = [];\n    for (let i = 0; i < nums.length; i++) {\n        let start = nums[i];\n        while (i + 1 < nums.length && nums[i + 1] - nums[i] === 1) {\n            i++;\n        }\n        if (start !== nums[i]) {\n            ranges.push(`${start}->${nums[i]}`);\n        } else {\n            ranges.push(`${start}`);\n        }\n    }\n    return ranges;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function summaryRanges(nums: number[]): string[] {\n    const result: string[] = [];\n    let start = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i + 1] !== nums[i] + 1) {\n            if (start === i) {\n                result.push(nums[start].toString());\n            } else {\n                result.push(`${nums[start]}->${nums[i]}`);\n            }\n            start = i + 1;\n        }\n    }\n    \n    return result;\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return String[]\n     */\n    function summaryRanges($nums) {\n        $result = array();\n        $count = count($nums);\n        \n        if ($count == 0) {\n            return $result;\n        }\n        \n        $start = $nums[0];\n        $end = $nums[0];\n        \n        for ($i = 1; $i < $count; $i++) {\n            if ($nums[$i] == $end + 1) {\n                $end = $nums[$i];\n            } else {\n                if ($start == $end) {\n                    $result[] = strval($start);\n                } else {\n                    $result[] = $start . '->' . $end;\n                }\n                \n                $start = $nums[$i];\n                $end = $nums[$i];\n            }\n        }\n        \n        if ($start == $end) {\n            $result[] = strval($start);\n        } else {\n            $result[] = $start . '->' . $end;\n        }\n        \n        return $result;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func summaryRanges(_ nums: [Int]) -> [String] {\n        var result = [String]()\n        var start = 0\n        var end = 0\n        \n        while end < nums.count {\n            if end + 1 < nums.count && nums[end + 1] - nums[end] == 1 {\n                end += 1\n            } else {\n                if start == end {\n                    result.append(\"\\(nums[start])\")\n                } else {\n                    result.append(\"\\(nums[start])->\\(nums[end])\")\n                }\n                end += 1\n                start = end\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun summaryRanges(nums: IntArray): List<String> {\n        val result = mutableListOf<String>()\n        var start = 0\n        var end = 0\n        \n        while (end < nums.size) {\n            while (end + 1 < nums.size && nums[end + 1] == nums[end] + 1) {\n                end++\n            }\n            \n            if (start == end) {\n                result.add(nums[start].toString())\n            } else {\n                result.add(\"${nums[start]}->${nums[end]}\")\n            }\n            \n            end++\n            start = end\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> summaryRanges(List<int> nums) {\n    List<String> result = [];\n    for (int i = 0; i < nums.length; i++) {\n      int start = nums[i];\n      while (i + 1 < nums.length && nums[i + 1] - nums[i] == 1) {\n        i++;\n      }\n      int end = nums[i];\n      result.add(start == end ? '$start' : '$start->$end');\n    }\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func summaryRanges(nums []int) []string {\n    if len(nums) == 0 {\n        return []string{}\n    }\n\n    var result []string\n    start, end := nums[0], nums[0]\n\n    for i := 1; i < len(nums); i++ {\n        if nums[i] == end+1 {\n            end = nums[i]\n        } else {\n            if start == end {\n                result = append(result, strconv.Itoa(start))\n            } else {\n                result = append(result, fmt.Sprintf(\"%d->%d\", start, end))\n            }\n            start, end = nums[i], nums[i]\n        }\n    }\n\n    if start == end {\n        result = append(result, strconv.Itoa(start))\n    } else {\n        result = append(result, fmt.Sprintf(\"%d->%d\", start, end))\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {String[]}\ndef summary_ranges(nums)\n    return [] if nums.empty?\n    \n    ranges = []\n    start = nums[0]\n    nums.each_with_index do |num, idx|\n        if num + 1 != nums[idx + 1]\n            if start != num\n                ranges << \"#{start}->#{num}\"\n            else\n                ranges << \"#{start}\"\n            end\n            start = nums[idx + 1]\n        end\n    end\n    \n    ranges\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def summaryRanges(nums: Array[Int]): List[String] = {\n        var result = List[String]()\n        var i = 0\n        while (i < nums.length) {\n            var start = nums(i)\n            while (i + 1 < nums.length && nums(i + 1) - nums(i) == 1) {\n                i += 1\n            }\n            if (start != nums(i)) {\n                result = result :+ s\"$start->${nums(i)}\"\n            } else {\n                result = result :+ s\"$start\"\n            }\n            i += 1\n        }\n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\n        let mut result: Vec<String> = Vec::new();\n        let mut i = 0;\n        \n        while i < nums.len() {\n            let start = nums[i];\n            while i + 1 < nums.len() && nums[i + 1] == nums[i] + 1 {\n                i += 1;\n            }\n            if start != nums[i] {\n                result.push(format!(\"{}->{}\", start, nums[i]));\n            } else {\n                result.push(nums[i].to_string());\n            }\n            i += 1;\n        }\n        \n        result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse the sorted unique integer array and group contiguous ranges, producing output in the specified format.\n\n# Explanation\n1. **Initialization**:\n   - Check if the input list `nums` is empty. If so, return an empty list.\n   - Initialize an empty list `result` to store the range strings.\n   - Set both `start` and `end` to the first element of `nums`.\n\n2. **Traversal**:\n   - Iterate through the list starting from the second element.\n   - If the current element is exactly one more than the `end`, extend the current range by updating the `end`.\n   - If not, it means the current range is over; add the current range to the `result` and reset both `start` and `end` to the current element.\n\n3. **Wrap-up**:\n   - After the loop, add the last range to the `result`.\n\n4. **Output**:\n   - Return the `result` list containing all the ranges in the specified format.\n\n# Pseudocode\n```\nFUNCTION summaryRanges(nums):\n    IF nums IS empty:\n        RETURN []\n    \n    result = []\n    start = nums[0]\n    end = nums[0]\n    \n    FOR i FROM 1 TO len(nums) - 1:\n        IF nums[i] == end + 1:\n            end = nums[i]\n        ELSE:\n            IF start == end:\n                result.ADD(convert_to_string(start))\n            ELSE:\n                result.ADD(convert_to_range_string(start, end))\n            start = nums[i]\n            end = nums[i]\n    \n    IF start == end:\n        result.ADD(convert_to_string(start))\n    ELSE:\n        result.ADD(convert_to_range_string(start, end))\n    \n    RETURN result\n\nFUNCTION convert_to_string(x):\n    RETURN str(x)\n    \nFUNCTION convert_to_range_string(x, y):\n    RETURN str(x) + \"->\" + str(y)\n```\nThis pseudocode outlines the step-by-step approach to solve the problem, where:\n- `convert_to_string(x)` formats a single number.\n- `convert_to_range_string(x, y)` formats a range.\n\nThe main function `summaryRanges` processes the list to form ranges by checking the continuity of each number and creating the desired range strings for the output.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-summary-ranges"
    },
    {
        "name": "Basic Calculator Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-basic-calculator-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int calculate(string s) {\n        int num = 0;\n        char sign = '+';\n        stack<int> st;\n        for (int i = 0; i < s.length(); i++) {\n            if (isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n            }\n            if ((!isdigit(s[i]) && s[i] != ' ') || i == s.length() - 1) {\n                if (sign == '+') {\n                    st.push(num);\n                } else if (sign == '-') {\n                    st.push(-num);\n                } else if (sign == '*') {\n                    int prev = st.top();\n                    st.pop();\n                    st.push(prev * num);\n                } else if (sign == '/') {\n                    int prev = st.top();\n                    st.pop();\n                    st.push(prev / num);\n                }\n                sign = s[i];\n                num = 0;\n            }\n        }\n        int total = 0;\n        while (!st.empty()) {\n            total += st.top();\n            st.pop();\n        }\n        return total;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int calculate(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        \n        Stack<Integer> stack = new Stack<>();\n        int num = 0;\n        char sign = '+';\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                num = num * 10 + (c - '0');\n            }\n            if ((!Character.isDigit(c) && c != ' ') || i == s.length() - 1) {\n                if (sign == '+') {\n                    stack.push(num);\n                } else if (sign == '-') {\n                    stack.push(-num);\n                } else if (sign == '*') {\n                    stack.push(stack.pop() * num);\n                } else if (sign == '/') {\n                    stack.push(stack.pop() / num);\n                }\n                sign = c;\n                num = 0;\n            }\n        }\n        \n        int result = 0;\n        for (int numToAdd : stack) {\n            result += numToAdd;\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def calculate(self, s):\n        stack = []\n        num = 0\n        sign = \"+\"\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if (not s[i].isdigit() and s[i] != \" \") or i == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    top = stack.pop()\n                    if top < 0:\n                        stack.append(-(-top//num))\n                    else:\n                        stack.append(top // num)\n                sign = s[i]\n                num = 0\n        return sum(stack)"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Calculate(string s) {\n        int result = 0;\n        int num = 0;\n        char sign = '+';\n        Stack<int> stack = new Stack<int>();\n\n        for (int i = 0; i < s.Length; i++) {\n            if (char.IsDigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n            }\n            if ((!char.IsDigit(s[i]) && ' ' != s[i]) || i == s.Length - 1) {\n                if (sign == '+') {\n                    stack.Push(num);\n                } else if (sign == '-') {\n                    stack.Push(-num);\n                } else if (sign == '*') {\n                    stack.Push(stack.Pop() * num);\n                } else if (sign == '/') {\n                    stack.Push(stack.Pop() / num);\n                }\n                sign = s[i];\n                num = 0;\n            }\n        }\n\n        foreach (int item in stack) {\n            result += item;\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function calculate(s: string): number {\n    const stack: number[] = [];\n    let num = 0;\n    let sign = '+';\n\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n\n        if (!isNaN(Number(char)) && char !== ' ') {\n            num = num * 10 + Number(char);\n        }\n\n        if (isNaN(Number(char)) || i === s.length - 1) {\n            if (sign === '+') {\n                stack.push(num);\n            } else if (sign === '-') {\n                stack.push(-num);\n            } else if (sign === '*') {\n                stack.push(stack.pop() * num);\n            } else if (sign === '/') {\n                stack.push(Math.trunc(stack.pop() / num));\n            }\n\n            sign = char;\n            num = 0;\n        }\n    }\n\n    return stack.reduce((acc, curr) => acc + curr, 0);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function calculate($s) {\n        $len = strlen($s);\n        $stack = [];\n        $num = 0;\n        $sign = '+';\n        for ($i = 0; $i < $len; $i++) {\n            if (is_numeric($s[$i])) {\n                $num = $num * 10 + intval($s[$i]);\n            }\n            if ((!is_numeric($s[$i]) && $s[$i] !== ' ') || $i === $len - 1) {\n                if ($sign === '+') {\n                    array_push($stack, $num);\n                } elseif ($sign === '-') {\n                    array_push($stack, -$num);\n                } elseif ($sign === '*') {\n                    $stack[count($stack) - 1] *= $num;\n                } elseif ($sign === '/') {\n                    $stack[count($stack) - 1] = intdiv($stack[count($stack) - 1], $num);\n                }\n                $sign = $s[$i];\n                $num = 0;\n            }\n        }\n        return array_sum($stack);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func calculate(_ s: String) -> Int {\n        var stack = [Int]()\n        var num = 0\n        var sign = \"+\"\n        \n        for (index, char) in s.enumerated() {\n            if let digit = char.wholeNumberValue {\n                num = num * 10 + digit\n            }\n            \n            if !char.isNumber && char != \" \" || index == s.count - 1 {\n                switch sign {\n                    case \"+\":\n                        stack.append(num)\n                    case \"-\":\n                        stack.append(-num)\n                    case \"*\":\n                        stack.append(stack.removeLast() * num)\n                    case \"/\":\n                        stack.append(stack.removeLast() / num)\n                    default:\n                        break\n                }\n                \n                sign = String(char)\n                num = 0\n            }\n        }\n        \n        return stack.reduce(0, +)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun calculate(s: String): Int {\n        if(s.isEmpty()) return 0\n        \n        var num = 0\n        var stack = mutableListOf<Int>()\n        var sign = '+'\n        \n        for(i in s.indices) {\n            if(s[i].isDigit()) {\n                num = num * 10 + (s[i] - '0')\n            }\n            if((!s[i].isDigit() && s[i] != ' ') || i == s.length - 1) {\n                when(sign) {\n                    '+' -> stack.add(num)\n                    '-' -> stack.add(-num)\n                    '*' -> stack[stack.size-1] = stack[stack.size-1] * num\n                    '/' -> stack[stack.size-1] = stack[stack.size-1] / num\n                }\n                sign = s[i]\n                num = 0\n            }\n        }\n        \n        return stack.sum()\n    }\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef calculate(s)\n    stack = []\n    num = 0\n    sign = '+'\n    s.chars.each_with_index do |char, i|\n        num = num * 10 + char.to_i if char.match?(/\\d/)\n        if ('+-*/'.include?(char) || i == s.length - 1)\n            case sign\n            when '+'\n                stack.push(num)\n            when '-'\n                stack.push(-num)\n            when '*'\n                stack.push(stack.pop * num)\n            when '/'\n                pop_num = stack.pop\n                if pop_num.negative?\n                    stack.push(-((-pop_num) / num))\n                else\n                    stack.push(pop_num / num)\n                end\n            end\n            num = 0\n            sign = char\n        end\n    end\n    stack.sum\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def calculate(s: String): Int = {\n        var stack = List.empty[Int]\n        var num = 0\n        var sign = '+'\n        \n        for (i <- 0 until s.length) {\n            val c = s(i)\n            \n            if (Character.isDigit(c)) {\n                num = num * 10 + (c - '0')\n            }\n            \n            if ((!Character.isDigit(c) && c != ' ') || i == s.length - 1) {\n                sign match {\n                    case '+' => stack = num :: stack\n                    case '-' => stack = -num :: stack\n                    case '*' => stack = stack.head * num :: stack.tail\n                    case '/' => stack = stack.head / num :: stack.tail\n                }\n                \n                num = 0\n                sign = c\n            }\n        }\n        \n        stack.sum\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn calculate(s: String) -> i32 {\n        let mut stack = Vec::new();\n        let chars: Vec<char> = s.chars().filter(|c| *c != ' ').collect();\n        let mut num = 0;\n        let mut sign = '+';\n\n        for (i, &c) in chars.iter().enumerate() {\n            if c.is_digit(10) {\n                num = num * 10 + c.to_digit(10).unwrap() as i32;\n            }\n            if !c.is_digit(10) || i == chars.len() - 1 {\n                match sign {\n                    '+' => stack.push(num),\n                    '-' => stack.push(-num),\n                    '*' => {\n                        let prev = stack.pop().unwrap();\n                        stack.push(prev * num);\n                    }\n                    '/' => {\n                        let prev = stack.pop().unwrap();\n                        stack.push(prev / num);\n                    }\n                    _ => {}\n                }\n                sign = c;\n                num = 0;\n            }\n        }\n\n        stack.iter().sum()\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to evaluate a given arithmetic expression represented as a string. The goal is to implement an algorithm that directly computes the result without using any built-in functions that evaluate expressions like `eval()`.\n\n# Explanation\n\n1. **Initialize variables**:\n   - A stack to keep track of intermediate results.\n   - A variable `num` to build numbers from the digits.\n   - A variable `sign` to keep track of the last seen operator (initialized to `+`).\n\n2. **Iterate through the string**:\n   - If the character is a digit, update `num` to include this digit.\n   - If the character is an operator or the end of the string is reached, perform the following based on the current `sign`:\n     - If the sign is '+', push `num` onto the stack.\n     - If the sign is '-', push `-num` onto the stack.\n     - If the sign is '*', pop the top of the stack, multiply it by `num`, and push the result back onto the stack.\n     - If the sign is '/', pop the top of the stack, divide it by `num` (truncating towards zero), and push the result back onto the stack.\n   - Update `sign` to the current character and reset `num` to 0 after processing the number.\n\n3. **Summation**:\n   - The final result is the sum of the numbers in the stack after processing the entire string.\n\n# Pseudocode\n\n```pseudocode\nFUNCTION calculate(s: STRING) RETURNS INTEGER\n    stack = []\n    num = 0\n    sign = \"+\"\n    \n    FOR i = 0 TO LENGTH OF s - 1\n        IF s[i] IS DIGIT\n            num = num * 10 + INTEGER VALUE OF s[i]\n\n        IF s[i] IS NOT DIGIT AND s[i] IS NOT SPACE OR i IS LAST INDEX\n            IF sign IS \"+\"\n                stack.push(num)\n            ELSE IF sign IS \"-\"\n                stack.push(-num)\n            ELSE IF sign IS \"*\"\n                stack.push(stack.pop() * num)\n            ELSE IF sign IS \"/\"\n                top = stack.pop()\n                IF top < 0\n                    stack.push(-(-top // num))  # Truncate towards zero\n                ELSE\n                    stack.push(top // num)\n            \n            sign = s[i]\n            num = 0\n    \n    RETURN SUM OF ELEMENTS IN stack\nEND FUNCTION\n```\n\nBy following this algorithm, we can accurately evaluate the given arithmetic expression as a string while adhering to the constraints and requirements of the problem.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-basic-calculator-ii"
    },
    {
        "name": "Remove Linked List Elements",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-linked-list-elements",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* current = dummy;\n        \n        while(current->next) {\n            if(current->next->val == val) {\n                ListNode* temp = current->next;\n                current->next = current->next->next;\n                delete temp;\n            } else {\n                current = current->next;\n            }\n        }\n        \n        return dummy->next;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        while (head != null && head.val == val) {\n            head = head.next;\n        }\n        ListNode current = head;\n        while (current != null && current.next != null) {\n            if (current.next.val == val) {\n                current.next = current.next.next;\n            } else {\n                current = current.next;\n            }\n        }\n        return head;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeElements(struct ListNode* head, int val){\n    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    dummy->next = head;\n    struct ListNode* current = dummy;\n    while(current->next){\n        if(current->next->val == val){\n            struct ListNode* temp = current->next;\n            current->next = current->next->next;\n            free(temp);\n        } else {\n            current = current->next;\n        }\n    }\n    return dummy->next;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode RemoveElements(ListNode head, int val) {\n        while (head != null && head.val == val) {\n            head = head.next;\n        }\n        ListNode current = head;\n        while (current != null && current.next != null) {\n            if (current.next.val == val) {\n                current.next = current.next.next;\n            } else {\n                current = current.next;\n            }\n        }\n        return head;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nvar removeElements = function(head, val) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n    \n    while(current.next !== null) {\n        if(current.next.val === val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    \n    return dummy.next;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction removeElements(head: ListNode | null, val: number): ListNode | null {\n    while (head !== null && head.val === val) {\n        head = head.next;\n    }\n    \n    let current = head;\n    while (current !== null && current.next !== null) {\n        if (current.next.val === val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    \n    return head;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @param Integer $val\n     * @return ListNode\n     */\n    function removeElements($head, $val) {\n        $dummy = new ListNode(0);\n        $dummy->next = $head;\n        $current = $dummy;\n        \n        while($current->next != null) {\n            if($current->next->val == $val) {\n                $current->next = $current->next->next;\n            } else {\n                $current = $current->next;\n            }\n        }\n        \n        return $dummy->next;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\n\nclass Solution {\n    func removeElements(_ head: ListNode?, _ val: Int) -> ListNode? {\n        var dummy = ListNode(0)\n        dummy.next = head\n        var current: ListNode? = dummy\n        \n        while current?.next != nil {\n            if current?.next?.val == val {\n                current?.next = current?.next?.next\n            } else {\n                current = current?.next\n            }\n        }\n        \n        return dummy.next\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun removeElements(head: ListNode?, `val`: Int): ListNode? {\n        var dummy = ListNode(-1)\n        dummy.next = head\n        var current = dummy\n        while (current.next != null) {\n            if (current.next!!.`val` == `val`) {\n                current.next = current.next!!.next\n            } else {\n                current = current.next!!\n            }\n        }\n        return dummy.next\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\nfunc removeElements(head *ListNode, val int) *ListNode {\n    dummy := &ListNode{Val: 0, Next: head}\n    prev := dummy\n    current := head\n    \n    for current != nil {\n        if current.Val == val {\n            prev.Next = current.Next\n        } else {\n            prev = current\n        }\n        current = current.Next\n    }\n    \n    return dummy.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#     end\n# end\n\ndef remove_elements(head, val)\n    dummy = ListNode.new(0)\n    dummy.next = head\n    current = dummy\n\n    while !current.next.nil?\n        if current.next.val == val\n            current.next = current.next.next\n        else\n            current = current.next\n        end\n    end\n\n    return dummy.next\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = \n * null) {\n * var next: ListNode = _next\n * var x: Int = _x\n * }\n */\n\nobject Solution {\n  def removeElements(head: ListNode, `val`: Int): ListNode = {\n    var dummy = new ListNode()\n    dummy.next = head\n    var current = dummy\n\n    while (current.next != null) {\n      if (current.next.x == `val`) {\n        current.next = current.next.next\n      } else {\n        current = current.next\n      }\n    }\n\n    return dummy.next\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll follow a methodology to iterate through the linked list and remove all nodes with the specified value efficiently.\n\n## # Explanation\n1. **Initialization**: We will use a dummy node to simplify the edge cases where the head needs to be removed. The dummy node will point to the original head of the list.\n2. **Iteration**: Use a pointer `current` that starts at the dummy node. While `current.next` is not `null`, if `current.next.val` is equal to `val`, we skip the next node by setting `current.next` to `current.next.next`. If it is not equal, we simply move `current` to `current.next`.\n3. **Return**: Finally, return `dummy.next` which points to the possibly new head of the list (considering that the original head might have been removed).\n\n## # Pseudocode\n```\nfunction removeElements(head, val):\n    # Initialize a dummy node that points to the head\n    dummy = ListNode(0)\n    dummy.next = head\n\n    # Initialize current to dummy\n    current = dummy\n\n    # Iterate through the list\n    while current.next is not null:\n        # If the value of the next node is equal to val, skip it\n        if current.next.val == val:\n            current.next = current.next.next\n        else:\n            current = current.next\n\n    # Return the new head of the list\n    return dummy.next\n```\n\nThis pseudocode effectively describes the methodology to remove all the nodes with the specified value from the linked list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-linked-list-elements"
    },
    {
        "name": "Implement Stack Using Queues",
        "site": "LeetCode",
        "href": "/solution/LeetCode-implement-stack-using-queues",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class MyStack {\n    Queue<Integer> queue;\n    \n    public MyStack() {\n        queue = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        Queue<Integer> temp = new LinkedList<>();\n        temp.add(x);\n        while (!queue.isEmpty()) {\n            temp.add(queue.poll());\n        }\n        queue = temp;\n    }\n    \n    public int pop() {\n        return queue.poll();\n    }\n    \n    public int top() {\n        return queue.peek();\n    }\n    \n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class MyStack(object):\n    def __init__(self):\n        self.queue = []\n\n    def push(self, x):\n        self.queue.append(x)\n        for _ in range(len(self.queue) - 1):\n            self.queue.append(self.queue.pop(0))\n\n    def pop(self):\n        return self.queue.pop(0)\n\n    def top(self):\n        return self.queue[0]\n\n    def empty(self):\n        return len(self.queue) == 0\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "typedef struct {\n    int front;\n    int rear;\n    int size;\n    int* array;\n} MyStack;\n\nMyStack* myStackCreate() {\n    MyStack* stack = (MyStack*)malloc(sizeof(MyStack));\n    stack->front = 0;\n    stack->rear = -1;\n    stack->size = 0;\n    stack->array = (int*)malloc(100 * sizeof(int));\n    return stack;\n}\n\nvoid myStackPush(MyStack* obj, int x) {\n    obj->rear = (obj->rear + 1) % 100;\n    obj->array[obj->rear] = x;\n    obj->size++;\n}\n\nint myStackPop(MyStack* obj) {\n    int val = obj->array[obj->rear];\n    obj->rear = (obj->rear - 1 + 100) % 100;\n    obj->size--;\n    return val;\n}\n\nint myStackTop(MyStack* obj) {\n    return obj->array[obj->rear];\n}\n\nbool myStackEmpty(MyStack* obj) {\n    return obj->size == 0;\n}\n\nvoid myStackFree(MyStack* obj) {\n    free(obj->array);\n    free(obj);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class MyStack {\n    private Queue<int> queue;\n\n    public MyStack() {\n        queue = new Queue<int>();\n    }\n\n    public void Push(int x) {\n        queue.Enqueue(x);\n        int size = queue.Count;\n        while (size > 1) {\n            queue.Enqueue(queue.Dequeue());\n            size--;\n        }\n    }\n\n    public int Pop() {\n        return queue.Dequeue();\n    }\n\n    public int Top() {\n        return queue.Peek();\n    }\n\n    public bool Empty() {\n        return queue.Count == 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var MyStack = function() {\n    this.queue = [];\n};\n\nMyStack.prototype.push = function(x) {\n    const tempQueue = [];\n    tempQueue.push(x);\n    while (this.queue.length > 0) {\n        tempQueue.push(this.queue.shift());\n    }\n    this.queue = tempQueue;\n};\n\nMyStack.prototype.pop = function() {\n    return this.queue.shift();\n};\n\nMyStack.prototype.top = function() {\n    return this.queue[0];\n};\n\nMyStack.prototype.empty = function() {\n    return this.queue.length === 0;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class MyStack {\n    private queue: number[];\n\n    constructor() {\n        this.queue = [];\n    }\n\n    push(x: number): void {\n        this.queue.push(x);\n    }\n\n    pop(): number {\n        return this.queue.pop();\n    }\n\n    top(): number {\n        return this.queue[this.queue.length - 1];\n    }\n\n    empty(): boolean {\n        return this.queue.length === 0;\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class MyStack {\n    private $queue;\n\n    function __construct() {\n        $this->queue = new SplQueue();\n    }\n\n    function push($x) {\n        $this->queue->enqueue($x);\n        $size = $this->queue->count();\n        while ($size > 1) {\n            $this->queue->enqueue($this->queue->dequeue());\n            $size--;\n        }\n    }\n\n    function pop() {\n        return $this->queue->dequeue();\n    }\n\n    function top() {\n        return $this->queue->bottom();\n    }\n\n    function empty() {\n        return $this->queue->isEmpty();\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class MyStack {\n    var queue: [Int]\n    \n    init() {\n        queue = [Int]()\n    }\n    \n    func push(_ x: Int) {\n        queue.append(x)\n        for _ in 0..<queue.count-1 {\n            queue.append(queue.removeFirst())\n        }\n    }\n    \n    func pop() -> Int {\n        return queue.removeFirst()\n    }\n    \n    func top() -> Int {\n        return queue.first!\n    }\n    \n    func empty() -> Bool {\n        return queue.isEmpty\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class MyStack {\n  List<int> queue = [];\n\n  void push(int x) {\n    queue.add(x);\n  }\n\n  int pop() {\n    int size = queue.length;\n    for (int i = 0; i < size - 1; i++) {\n      queue.add(queue.removeAt(0));\n    }\n    return queue.removeAt(0);\n  }\n\n  int top() {\n    return queue.last;\n  }\n\n  bool empty() {\n    return queue.isEmpty;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "type MyStack struct {\n    queue []int\n}\n\nfunc Constructor() MyStack {\n    return MyStack{}\n}\n\nfunc (stack *MyStack) Push(x int) {\n    stack.queue = append(stack.queue, x)\n    n := len(stack.queue)\n    for i := 0; i < n-1; i++ {\n        stack.queue = append(stack.queue, stack.queue[0])\n        stack.queue = stack.queue[1:]\n    }\n}\n\nfunc (stack *MyStack) Pop() int {\n    res := stack.queue[0]\n    stack.queue = stack.queue[1:]\n    return res\n}\n\nfunc (stack *MyStack) Top() int {\n    return stack.queue[0]\n}\n\nfunc (stack *MyStack) Empty() bool {\n    return len(stack.queue) == 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class MyStack\n    def initialize()\n        @queue = []\n    end\n\n    def push(x)\n        @queue << x\n    end\n\n    def pop()\n        @queue.pop\n    end\n\n    def top()\n        @queue.last\n    end\n\n    def empty()\n        @queue.empty?\n    end\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::collections::VecDeque;\n\nstruct MyStack {\n    queue: VecDeque<i32>,\n}\n\nimpl MyStack {\n    fn new() -> Self {\n        MyStack {\n            queue: VecDeque::new(),\n        }\n    }\n    \n    fn push(&mut self, x: i32) {\n        self.queue.push_back(x);\n        let mut size = self.queue.len() as i32;\n        while size > 1 {\n            let front = self.queue.pop_front().unwrap();\n            self.queue.push_back(front);\n            size -= 1;\n        }\n    }\n    \n    fn pop(&mut self) -> i32 {\n        self.queue.pop_front().unwrap()\n    }\n    \n    fn top(&self) -> i32 {\n        *self.queue.front().unwrap()\n    }\n    \n    fn empty(&self) -> bool {\n        self.queue.is_empty()\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will create a stack using two queues and implement the required operations such as `push`, `pop`, `top`, and `empty`.\n\n# Explanation\n\n1. **push(x)**: This operation adds an element to the top of the stack. We achieve this by appending the element to the primary queue and then transferring all the previous elements from the primary queue to the secondary queue. This way, the last added element will always be at the front of the primary queue.\n\n2. **pop()**: This operation removes the element from the top of the stack, which is the front element of the primary queue.\n\n3. **top()**: This operation returns the element at the top of the stack, which is the front element of the primary queue without removing it.\n\n4. **empty()**: This operation checks if the stack is empty by checking the size of the primary queue.\n\n# Pseudocode\n\n```\nclass MyStack:\n    def __init__(self):\n        # Initialize the primary queue\n        self.queue = []\n\n    def push(self, x):\n        # Step 1: Add the element to the primary queue\n        self.queue.append(x)\n\n        # Step 2: Rotate the queue so the last element is at the front\n        for i in range(len(self.queue) - 1):\n            self.queue.append(self.queue.pop(0))\n\n    def pop(self):\n        # Remove the front element which represents the top of the stack\n        return self.queue.pop(0)\n\n    def top(self):\n        # Return the front element which represents the top of the stack\n        return self.queue[0]\n\n    def empty(self):\n        # Return True if the primary queue is empty, otherwise False\n        return len(self.queue) == 0\n```\n\nHere, we use a single list to simulate the queue and utilize its operations to match the behavior of a stack. This way, we implement the stack functionalities using only allowed queue operations.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-implement-stack-using-queues"
    },
    {
        "name": "Reverse Linked List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reverse-linked-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(nullptr) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        \n        while (curr != nullptr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        \n        return prev;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def reverseList(self, head):\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* reverseList(struct ListNode* head){\n    struct ListNode *prev = NULL;\n    struct ListNode *current = head;\n    struct ListNode *next = NULL;\n    \n    while(current != NULL){\n        next = current->next;\n        current->next = prev;\n        prev = current;\n        current = next;\n    }\n    \n    return prev;\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n function reverseList(head: ListNode | null): ListNode | null {\n    let prev: ListNode | null = null;\n    let current: ListNode | null = head;\n    \n    while (current !== null) {\n        const nextTemp: ListNode | null = current.next;\n        current.next = prev;\n        prev = current;\n        current = nextTemp;\n    }\n    \n    return prev;\n}\n  "
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n    \n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function reverseList($head) {\n        $prev = null;\n        $current = $head;\n        while ($current != null) {\n            $nextNode = $current->next;\n            $current->next = $prev;\n            $prev = $current;\n            $current = $nextNode;\n        }\n        return $prev;\n    }\n}\n\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { val = 0; next = nil }\n *     public init(_ val: Int) { self.val = val; next = nil }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next }\n * }\n */\nclass Solution {\n    func reverseList(_ head: ListNode?) -> ListNode? {\n        var prev: ListNode? = nil\n        var current = head\n        \n        while let node = current {\n            let nextTemp = node.next\n            node.next = prev\n            prev = node\n            current = nextTemp\n        }\n        \n        return prev\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    current := head\n    for current != nil {\n        nextTemp := current.Next\n        current.Next = prev\n        prev = current\n        current = nextTemp\n    }\n    return prev\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n\ndef reverse_list(head)\n    prev = nil\n    current = head\n    \n    while current != nil\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    end\n    \n    return prev\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n * }\n */\nobject Solution {\n    def reverseList(head: ListNode): ListNode = {\n        var prev: ListNode = null\n        var curr: ListNode = head\n        while (curr != null) {\n            val nextTemp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nextTemp\n        }\n        prev\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>,\n// }\nimpl Solution {\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut prev = None;\n        let mut current = head;\n        \n        while let Some(mut inner) = current {\n            let next = inner.next.take();\n            inner.next = prev.take();\n            prev = Some(inner);\n            current = next;\n        }\n        \n        prev\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to reverse a singly linked list. This can be accomplished using two primary methods: iteratively or recursively. Below are the explanations and pseudocode for both approaches.\n\n# Explanation\n\n## Iterative Approach\n1. Initialize two pointers: `prev` set to `None` and `curr` set to `head`.\n2. Traverse the list using a while loop until `curr` becomes `None`.\n3. For each node, store the reference to the next node.\n4. Change the `next` pointer of the current node to point to the previous node (`prev`).\n5. Move the `prev` pointer to the current node.\n6. Move the `curr` pointer to the next node (stored previously).\n7. After the loop, `prev` will point to the new head of the reversed list.\n\n## Recursive Approach\n1. Define a base case: if `head` is `None` or `head.next` is `None`, return `head`.\n2. Recursively call the function on the next element in the list.\n3. Set the next node's next pointer to the current node to reverse the pointer.\n4. Set the current node's next pointer to `None` to break the old link.\n5. Return the new head of the reversed list obtained from the recursive call.\n\n# Pseudocode\n\n## Iterative Approach\n\n```\n# Pseudocode for iterative approach\n\nfunction reverseList(head):\n    prev = None\n    curr = head\n\n    while curr is not None:\n        next_temp = curr.next    # Store the next node\n        curr.next = prev         # Reverse the link\n        prev = curr              # Move prev to current node\n        curr = next_temp         # Move to the next node\n    \n    return prev                  # Prev will be the new head of the reversed list\n```\n\n## Recursive Approach\n\n```\n# Pseudocode for recursive approach\n\nfunction reverseList(head):\n    # Base case: if head is null or only one node, it's already reversed\n    if head is None or head.next is None:\n        return head\n    \n    # Recursively reverse the rest of the list\n    new_head = reverseList(head.next)\n    \n    # Reverse the link of the current head\n    head.next.next = head\n    head.next = None\n    \n    return new_head\n```\n\nBoth approaches effectively reverse the singly linked list and can be used depending on the developer\u2019s preference or specific constraints of the problem (e.g., stack depth limitations for the recursive approach).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reverse-linked-list"
    },
    {
        "name": "Isomorphic Strings",
        "site": "LeetCode",
        "href": "/solution/LeetCode-isomorphic-strings",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n\n        unordered_map<char, char> sMap;\n        unordered_map<char, char> tMap;\n\n        for (int i = 0; i < s.size(); i++) {\n            if (sMap.find(s[i]) != sMap.end()) {\n                if (sMap[s[i]] != t[i]) {\n                    return false;\n                }\n            } else {\n                sMap[s[i]] = t[i];\n            }\n\n            if (tMap.find(t[i]) != tMap.end()) {\n                if (tMap[t[i]] != s[i]) {\n                    return false;\n                }\n            } else {\n                tMap[t[i]] = s[i];\n            }\n        }\n        \n        return true;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if(s.length() != t.length()) {\n            return false;\n        }\n        \n        Map<Character, Character> mapS = new HashMap<>();\n        Map<Character, Character> mapT = new HashMap<>();\n        \n        for(int i = 0; i < s.length(); i++) {\n            char charS = s.charAt(i);\n            char charT = t.charAt(i);\n            \n            if(mapS.containsKey(charS)) {\n                if(mapS.get(charS) != charT) {\n                    return false;\n                }\n            } else {\n                mapS.put(charS, charT);\n            }\n            \n            if(mapT.containsKey(charT)) {\n                if(mapT.get(charT) != charS) {\n                    return false;\n                }\n            } else {\n                mapT.put(charT, charS);\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        \n        mapping_s = {}\n        mapping_t = {}\n        \n        for char_s, char_t in zip(s, t):\n            if char_s not in mapping_s:\n                mapping_s[char_s] = char_t\n            else:\n                if mapping_s[char_s] != char_t:\n                    return False\n            \n            if char_t not in mapping_t:\n                mapping_t[char_t] = char_s\n            else:\n                if mapping_t[char_t] != char_s:\n                    return False\n                \n        return True"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isIsomorphic(char* s, char* t) {\n    if (!s || !t) {\n        return false;\n    }\n    \n    int s_len = strlen(s);\n    int t_len = strlen(t);\n    \n    if (s_len != t_len) {\n        return false;\n    }\n    \n    char map_s[256] = {0};\n    char map_t[256] = {0};\n    \n    for (int i = 0; i < s_len; i++) {\n        if (map_s[s[i]] != map_t[t[i]]) {\n            return false;\n        }\n        \n        map_s[s[i]] = i + 1;\n        map_t[t[i]] = i + 1;\n    }\n    \n    return true;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsIsomorphic(string s, string t) {\n        if(s.Length != t.Length)\n            return false;\n        \n        Dictionary<char, char> sToT = new Dictionary<char, char>();\n        Dictionary<char, char> tToS = new Dictionary<char, char>();\n        \n        for(int i = 0; i < s.Length; i++){\n            char sChar = s[i];\n            char tChar = t[i];\n            \n            if(!sToT.ContainsKey(sChar)){\n                sToT[sChar] = tChar;\n            }\n            else{\n                if(sToT[sChar] != tChar)\n                    return false;\n            }\n            \n            if(!tToS.ContainsKey(tChar)){\n                tToS[tChar] = sChar;\n            }\n            else{\n                if(tToS[tChar] != sChar)\n                    return false;\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isIsomorphic = (s, t) => {\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    const mapS = new Map();\n    const mapT = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        if (!mapS.has(s[i])) {\n            mapS.set(s[i], t[i]);\n        } else {\n            if (mapS.get(s[i]) !== t[i]) {\n                return false;\n            }\n        }\n        \n        if (!mapT.has(t[i])) {\n            mapT.set(t[i], s[i]);\n        } else {\n            if (mapT.get(t[i]) !== s[i]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isIsomorphic(s: string, t: string): boolean \n{\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    const mapS = new Map();\n    const mapT = new Map();\n    \n    for (let i = 0; i < s.length; i++) {\n        const charS = s[i];\n        const charT = t[i];\n        \n        if (mapS.has(charS)) {\n            if (mapS.get(charS) !== charT) {\n                return false;\n            }\n        } else {\n            mapS.set(charS, charT);\n        }\n        \n        if (mapT.has(charT)) {\n            if (mapT.get(charT) !== charS) {\n                return false;\n            }\n        } else {\n            mapT.set(charT, charS);\n        }\n    }\n    \n    return true;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Boolean\n     */\n    function isIsomorphic($s, $t) {\n        $map_s = [];\n        $map_t = [];\n        \n        for($i = 0; $i < strlen($s); $i++) {\n            $char_s = $s[$i];\n            $char_t = $t[$i];\n            \n            if((isset($map_s[$char_s]) && $map_s[$char_s] != $char_t) || (isset($map_t[$char_t]) && $map_t[$char_t] != $char_s)) {\n                return false;\n            }\n            \n            $map_s[$char_s] = $char_t;\n            $map_t[$char_t] = $char_s;\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isIsomorphic(_ s: String, _ t: String) -> Bool {\n        var sMap = [Character: Character]()\n        var tMap = [Character: Character]()\n        \n        for i in 0..<s.count {\n            let sChar = s[s.index(s.startIndex, offsetBy: i)]\n            let tChar = t[t.index(t.startIndex, offsetBy: i)]\n            \n            if let sMapped = sMap[sChar] {\n                if sMapped != tChar {\n                    return false\n                }\n            } else {\n                sMap[sChar] = tChar\n            }\n            \n            if let tMapped = tMap[tChar] {\n                if tMapped != sChar {\n                    return false\n                }\n            } else {\n                tMap[tChar] = sChar\n            }\n        }\n        \n        return true\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isIsomorphic(s: String, t: String): Boolean {\n        if(s.length != t.length) {\n            return false\n        }\n        \n        val mapST = mutableMapOf<Char, Char>()\n        val mapTS = mutableMapOf<Char, Char>()\n        \n        for(i in s.indices) {\n            val charS = s[i]\n            val charT = t[i]\n            \n            if(mapST.containsKey(charS)) {\n                if(mapST[charS] != charT) {\n                    return false\n                }\n            } else {\n                mapST[charS] = charT\n            }\n            \n            if(mapTS.containsKey(charT)) {\n                if(mapTS[charT] != charS) {\n                    return false\n                }\n            } else {\n                mapTS[charT] = charS\n            }\n        }\n        \n        return true\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isIsomorphic(String s, String t) {\n      if (s.length != t.length) {\n        return false;\n      }\n      \n      Map<String, String> sMap = {};\n      Map<String, String> tMap = {};\n      \n      for (int i = 0; i < s.length; i++) {\n        if (sMap.containsKey(s[i])) {\n          if (sMap[s[i]] != t[i]) {\n            return false;\n          }\n        } else {\n          sMap[s[i]] = t[i];\n        }\n        \n        if (tMap.containsKey(t[i])) {\n          if (tMap[t[i]] != s[i]) {\n            return false;\n          }\n        } else {\n          tMap[t[i]] = s[i];\n        }\n      }\n      \n      return true;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isIsomorphic(s string, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    mappingST := make(map[byte]byte)\n    mappingTS := make(map[byte]byte)\n    \n    for i := 0; i < len(s); i++ {\n        charS := s[i]\n        charT := t[i]\n        \n        if prevS, found := mappingST[charS]; found {\n            if prevS != charT {\n                return false\n            }\n        } else {\n            mappingST[charS] = charT\n        }\n        \n        if prevT, found := mappingTS[charT]; found {\n            if prevT != charS {\n                return false\n            }\n        } else {\n            mappingTS[charT] = charS\n        }\n    }\n    \n    return true\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {String} t\n# @return {Boolean}\ndef is_isomorphic(s, t)\n    return false if s.length != t.length\n    \n    s_map = {}\n    t_map = {}\n    \n    (0..s.length - 1).each do |i|\n        s_char = s[i]\n        t_char = t[i]\n        \n        if s_map[s_char]\n            return false if s_map[s_char] != t_char\n        else\n            s_map[s_char] = t_char\n        end\n        \n        if t_map[t_char]\n            return false if t_map[t_char] != s_char\n        else\n            t_map[t_char] = s_char\n        end\n    end\n    \n    return true\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to determine if two given strings `s` and `t` are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`, with each character from `s` mapping to exactly one character from `t` and vice versa, preserving the order of characters.\n\n# Explanation\n1. **Check Lengths**: First, if the lengths of `s` and `t` are not the same, they cannot be isomorphic.\n2. **Mapping Characters**: We need to create two mappings - one for characters in `s` to characters in `t` and another for characters in `t` to characters in `s`.\n3. **Iterate and Compare**: Iterate through both strings character by character. For each pair of characters `(char_s, char_t)`:\n   - If `char_s` is not already mapped to some character in `t`, then map `char_s` to `char_t`.\n   - If `char_s` is already mapped to a different character in `t`, return `False`.\n   - Similarly, ensure that `char_t` from `t` maps back to the correct character in `s`.\n4. **Return True if Valid**: If we successfully create the mappings without conflicting rules, return `True`.\n\n# Pseudocode\n```\nfunction isIsomorphic(s, t):\n    if length of s is not equal to length of t:\n        return False\n\n    mapping_s_to_t = {}\n    mapping_t_to_s = {}\n    \n    for i from 0 to length of s - 1:\n        char_s = s[i]\n        char_t = t[i]\n        \n        if char_s not in mapping_s_to_t:\n            mapping_s_to_t[char_s] = char_t\n        else:\n            if mapping_s_to_t[char_s] != char_t:\n                return False\n        \n        if char_t not in mapping_t_to_s:\n            mapping_t_to_s[char_t] = char_s\n        else:\n            if mapping_t_to_s[char_t] != char_s:\n                return False\n    \n    return True\n```\nThis pseudocode ensures that each character from `s` maps to exactly one character from `t` and vice versa, thereby checking if the strings are isomorphic.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-isomorphic-strings"
    },
    {
        "name": "Count Primes",
        "site": "LeetCode",
        "href": "/solution/LeetCode-count-primes",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int countPrimes(int n) {\n        if (n <= 2) return 0;\n        \n        vector<bool> isPrime(n, true);\n        isPrime[0] = false;\n        isPrime[1] = false;\n        \n        for (int i = 2; i * i < n; ++i) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        return count(isPrime.begin(), isPrime.end(), true);\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int countPrimes(int n) {\n        if (n <= 2) {\n            return 0;\n        }\n        \n        boolean[] isPrime = new boolean[n];\n        int count = 0;\n        \n        for (int i = 2; i < n; i++) {\n            if (!isPrime[i]) {\n                count++;\n                for (int j = 2; i * j < n; j++) {\n                    isPrime[i * j] = true;\n                }\n            }\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def countPrimes(self, n):\n        if n < 2:\n            return 0\n        \n        is_prime = [True] * n\n        is_prime[0] = is_prime[1] = False\n        \n        for i in range(2, int(n ** 0.5) + 1):\n            if is_prime[i]:\n                is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i])\n                \n        return sum(is_prime)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int countPrimes(int n) {\n    if (n <= 2) {\n        return 0;\n    }\n    \n    int count = 0;\n    int *isPrime = (int*)malloc(sizeof(int) * n);\n    memset(isPrime, 1, sizeof(int) * n);\n\n    for (int i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = 0;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; i++) {\n        if (isPrime[i]) {\n            count++;\n        }\n    }\n\n    free(isPrime);\n    return count;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int CountPrimes(int n) {\n        if(n <= 2) return 0;\n        \n        bool[] isPrime = new bool[n];\n        for(int i = 2; i < n; i++){\n            isPrime[i] = true;\n        }\n        \n        for(int i = 2; i * i < n; i++){\n            if(!isPrime[i]) continue;\n            for(int j = i * i; j < n; j += i){\n                isPrime[j] = false;\n            }\n        }\n        \n        int count = 0;\n        for(int i = 2; i < n; i++){\n            if(isPrime[i]){\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nconst countPrimes = (n) => {\n    if (n <= 2) return 0;\n    \n    const isPrime = new Array(n).fill(true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    \n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    \n    return isPrime.filter((val) => val).length;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function countPrimes(n: number): number {\n    if (n <= 2) {\n        return 0;\n    }\n\n    const isPrime = new Array(n).fill(true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n\n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    return isPrime.filter((prime) => prime).length;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     */\n    function countPrimes($n) {\n        if ($n <= 2) return 0;\n        \n        $isPrime = array_fill(0, $n, true);\n        $isPrime[0] = $isPrime[1] = false;\n        \n        for ($i = 2; $i * $i < $n; $i++) {\n            if ($isPrime[$i]) {\n                for ($j = $i * $i; $j < $n; $j += $i) {\n                    $isPrime[$j] = false;\n                }\n            }\n        }\n        \n        return count(array_filter($isPrime));\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func countPrimes(_ n: Int) -> Int {\n        guard n > 2 else {\n            return 0\n        }\n        \n        var isPrime = [Bool](repeating: true, count: n)\n        isPrime[0] = false\n        isPrime[1] = false\n        \n        var count = 0\n        \n        for i in 2..<n {\n            if isPrime[i] {\n                count += 1\n                var j = 2\n                while i * j < n {\n                    isPrime[i * j] = false\n                    j += 1\n                }\n            }\n        }\n        \n        return count\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    \n    fun countPrimes(n: Int): Int {\n        var count = 0\n        for (i in 2 until n) {\n            if (isPrime(i)) {\n                count++\n            }\n        }\n        return count\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int countPrimes(int n) {\n    if (n <= 2) return 0;\n\n    List<bool> isPrime = List.filled(n, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n\n    for (int i = 2; i * i < n; i++) {\n      if (isPrime[i]) {\n        for (int j = i * i; j < n; j += i) {\n          isPrime[j] = false;\n        }\n      }\n    }\n\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n      if (isPrime[i]) count++;\n    }\n\n    return count;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func countPrimes(n int) int {\n    if n <= 2 {\n        return 0\n    }\n\n    isPrime := make([]bool, n)\n    count := 0\n\n    for i := 2; i*i < n; i++ {\n        if isPrime[i] {\n            continue\n        }\n\n        for j := i * i; j < n; j += i {\n            isPrime[j] = true\n        }\n    }\n\n    for i := 2; i < n; i++ {\n        if !isPrime[i] {\n            count++\n        }\n    }\n\n    return count\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of counting the number of prime numbers strictly less than a given integer `n`, we can leverage the Sieve of Eratosthenes algorithm, which is an efficient way to find all primes smaller than a given number. Below is the methodology and pseudocode to achieve it.\n\n# Explanation\n\n1. **Initial Checks**:\n   - If `n` is less than 2, there are no prime numbers less than `n`, so return 0.\n\n2. **Setup a Boolean Array**:\n   - Create a boolean array `is_prime` of size `n` where each index indicates if the number corresponding to that index is a prime.\n\n3. **Mark Non-Primes**:\n   - Initialize the array by setting `is_prime[0]` and `is_prime[1]` to `False` because 0 and 1 are not prime numbers.\n   - Use a loop to iterate from 2 up to the square root of `n`. For each index `i` that is still marked as `True`, mark all of its multiples as `False` starting from `i*i` to `n`.\n\n4. **Count Primes**:\n   - Finally, sum up all the `True` values in the `is_prime` array. The result will be the count of prime numbers less than `n`.\n\n# Pseudocode\n\n```\nfunction countPrimes(n):\n    if n < 2:\n        return 0\n    \n    # Initialize an array of boolean values\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, sqrt(n) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of True values which represent prime numbers\n    return sum(is_prime)\n```\n\nThis pseudocode outlines a clear method to solve the problem using the Sieve of Eratosthenes, ensuring efficiency appropriate for larger values of `n` up to `5 * 10^6`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-count-primes"
    },
    {
        "name": "Peeking Iterator",
        "site": "LeetCode",
        "href": "/solution/LeetCode-peeking-iterator",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class PeekingIterator : public Iterator {\nprivate:\n    bool peeked;\n    int peek_val;\npublic:\n    PeekingIterator(const vector<int>& nums) : Iterator(nums), peeked(false) {}\n\n    int peek() {\n        if (!peeked) {\n            peek_val = Iterator::next();\n            peeked = true;\n        }\n        return peek_val;\n    }\n\n    int next() {\n        if (peeked) {\n            peeked = false;\n            return peek_val;\n        }\n        return Iterator::next();\n    }\n\n    bool hasNext() const {\n        return peeked || Iterator::hasNext();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "// Java Iterator interface reference:\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iterator;\n    private Integer nextElement;\n\n    public PeekingIterator(Iterator<Integer> iterator) {\n        this.iterator = iterator;\n        if (iterator.hasNext()) {\n            nextElement = iterator.next();\n        }\n    }\n\n    // Returns the next element in the iteration without advancing the iterator.\n    public Integer peek() {\n        return nextElement;\n    }\n\n    // hasNext() and next() should behave the same as in the Iterator interface.\n    // Override them if needed.\n    @Override\n    public Integer next() {\n        Integer res = nextElement;\n        nextElement = iterator.hasNext() ? iterator.next() : null;\n        return res;\n    }\n\n     @Override\n    public boolean hasNext() {\n        return nextElement != null;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class PeekingIterator:\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self.peeked_value = None\n\n    def peek(self):\n        if self.peeked_value is None:\n            self.peeked_value = self.iterator.next()\n        return self.peeked_value\n\n    def next(self):\n        if self.peeked_value is not None:\n            result = self.peeked_value\n            self.peeked_value = None\n            return result\n        return self.iterator.next()\n\n    def hasNext(self):\n        return self.peeked_value is not None or self.iterator.hasNext()\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/*\n *  struct Iterator {\n *      // Returns true if the iteration has more elements.\n *      bool (*hasNext)();\n *\n *      // Returns the next element in the iteration.\n *      int (*next)();\n *  };\n */\nstruct PeekingIterator {\n    struct Iterator* iter;\n    int next_val;\n    bool has_next;\n};\n\nstruct PeekingIterator* Constructor(struct Iterator* iter) {\n    struct PeekingIterator* peek_iter = (struct PeekingIterator*)malloc(sizeof(struct PeekingIterator));\n    peek_iter->iter = iter;\n    peek_iter->has_next = iter->hasNext();\n    if (peek_iter->has_next) {\n        peek_iter->next_val = iter->next();\n    }\n    return peek_iter;\n}\n\nint peek(struct PeekingIterator* obj) {\n    return obj->next_val;\n}\n\nint next(struct PeekingIterator* obj) {\n    int res = obj->next_val;\n    obj->has_next = obj->iter->hasNext();\n    if (obj->has_next) {\n        obj->next_val = obj->iter->next();\n    }\n    return res;\n}\n\nbool hasNext(struct PeekingIterator* obj) {\n    return obj->has_next;\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll implement a `PeekingIterator` class that provides a peeking capability in addition to the standard `next` and `hasNext` methods. The detailed steps are outlined below.\n\n### # Explanation\nHere's how we will approach the implementation:\n\n1. **Initialization (`__init__`)**:\n    - Store the provided iterator.\n    - Initialize a variable to keep track of the next value to be peeked (`peeked_value`), which will be initially set to `None`.\n\n2. **peek() method**:\n    - This method returns the next element without advancing the iterator.\n    - If `peeked_value` is `None`, it fetches the next element from the iterator and stores it in `peeked_value`.\n    - If `peeked_value` is already set, it simply returns this value.\n\n3. **next() method**:\n    - This method returns the next element and advances the iterator.\n    - If `peeked_value` is `None`, it calls the iterator's `next` method.\n    - If `peeked_value` is set, it returns this value and resets `peeked_value` to `None`.\n\n4. **hasNext() method**:\n    - This method checks if there are still elements left to iterate.\n    - It returns `True` if `peeked_value` is set or if the iterator's `hasNext` method returns `True`.\n\n### # Pseudocode\n\n```\nclass PeekingIterator:\n    \n    # Initialization method\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self.peeked_value = None\n\n    # Peek method\n    def peek(self):\n        if self.peeked_value is None:\n            self.peeked_value = self.iterator.next()\n        return self.peeked_value\n\n    # Next method\n    def next(self):\n        if self.peeked_value is not None:\n            result = self.peeked_value\n            self.peeked_value = None\n            return result\n        return self.iterator.next()\n\n    # hasNext method\n    def hasNext(self):\n        return self.peeked_value is not None or self.iterator.hasNext()\n```\n\nWith this pseudocode ready, we can now implement the `PeekingIterator` class in our preferred programming language following the structure and logic detailed above.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-peeking-iterator"
    },
    {
        "name": "Move Zeroes",
        "site": "LeetCode",
        "href": "/solution/LeetCode-move-zeroes",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int pos = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != 0) {\n                swap(nums[i], nums[pos]);\n                pos++;\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int nonZeroIdx = 0;\n        \n        for (int num : nums) {\n            if (num != 0) {\n                nums[nonZeroIdx++] = num;\n            }\n        }\n        \n        while (nonZeroIdx < nums.length) {\n            nums[nonZeroIdx++] = 0;\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place \n        instead.\n        \"\"\"\n        zero_count = 0\n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] == 0:\n                zero_count += 1\n            else:\n                nums[i-zero_count] = nums[i]\n        \n        for i in range(n - zero_count, n):\n            nums[i] = 0\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void moveZeroes(int* nums, int numsSize) {\n    int nonZeroIndex = 0;\n    \n    for(int i = 0; i < numsSize; i++) {\n        if(nums[i] != 0) {\n            nums[nonZeroIndex] = nums[i];\n            if(i != nonZeroIndex) {\n                nums[i] = 0;\n            }\n            nonZeroIndex++;\n        }\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void MoveZeroes(int[] nums) {\n        int nonZeroIndex = 0;\n        \n        // Move all non-zero elements to the front of the array\n        for (int i = 0; i < nums.Length; i++) {\n            if (nums[i] != 0) {\n                nums[nonZeroIndex] = nums[i];\n                nonZeroIndex++;\n            }\n        }\n        \n        // Fill the rest of the array with zeros\n        for (int i = nonZeroIndex; i < nums.Length; i++) {\n            nums[i] = 0;\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function(nums) {\n    let nonZeroPointer = 0;\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            let temp = nums[nonZeroPointer];\n            nums[nonZeroPointer] = nums[i];\n            nums[i] = temp;\n            nonZeroPointer++;\n        }\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify nums in-place instead.\n */\nfunction moveZeroes(nums: number[]): void {\n    let nonZeroIdx = 0;\n    \n    for(let i = 0; i < nums.length; i++) {\n        if(nums[i] !== 0) {\n            [nums[nonZeroIdx], nums[i]] = [nums[i], nums[nonZeroIdx]];\n            nonZeroIdx++;\n        }\n    }\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return NULL\n     */\n    function moveZeroes(&$nums) {\n        $nonZeroIndex = 0;\n        for ($i = 0; $i < count($nums); $i++) {\n            if ($nums[$i] != 0) {\n                $temp = $nums[$nonZeroIndex];\n                $nums[$nonZeroIndex] = $nums[$i];\n                $nums[$i] = $temp;\n                $nonZeroIndex++;\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func moveZeroes(_ nums: inout [Int]) {\n        var nonZeroIndex = 0\n        \n        for num in nums {\n            if num != 0 {\n                nums[nonZeroIndex] = num\n                nonZeroIndex += 1\n            }\n        }\n        \n        while nonZeroIndex < nums.count {\n            nums[nonZeroIndex] = 0\n            nonZeroIndex += 1\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void moveZeroes(List<int> nums) {\n    int nonZeroIndex = 0;\n    \n    for (int i = 0; i < nums.length; i++) {\n      if (nums[i] != 0) {\n        nums[nonZeroIndex] = nums[i];\n        if (i != nonZeroIndex) {\n          nums[i] = 0;\n        }\n        nonZeroIndex++;\n      }\n    }\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func moveZeroes(nums []int) {\n    if len(nums) == 0 {\n        return\n    }\n    \n    insertPos := 0\n    for _, num := range nums {\n        if num != 0 {\n            nums[insertPos] = num\n            insertPos++\n        }\n    }\n    \n    for i := insertPos; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @return {Void} Do not return anything, modify nums in-place instead.\ndef move_zeroes(nums)\n    zero_count = nums.count(0)\n    nums.delete(0)\n    zero_count.times { nums << 0 }\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def moveZeroes(nums: Array[Int]): Unit = {\n        var nonZeroIdx = 0\n        for (i <- nums.indices) {\n            if (nums(i) != 0) {\n                val temp = nums(nonZeroIdx)\n                nums(nonZeroIdx) = nums(i)\n                nums(i) = temp\n                nonZeroIdx += 1\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn move_zeroes(nums: &mut Vec<i32>) {\n        let mut count = 0;\n        \n        for i in 0..nums.len() {\n            if nums[i] != 0 {\n                nums.swap(i, count);\n                count += 1;\n            }\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to move all zeros in the given array to the end while maintaining the relative order of the non-zero elements. The entire operation must be done in-place without creating a copy of the array. \n\n# Explanation\n1. First, we need to determine how many zeros are present in the array.\n2. Iterate through the array. For each non-zero element, place it at the correct position by accounting for the number of zeros encountered so far.\n3. After processing all elements, fill the end of the array with zeros based on the counted number of zeros.\n\n# Pseudocode\n1. Initialize `zero_count` to 0.\n2. Get the length `n` of the array `nums`.\n3. Iterate over `i` from 0 to `n-1`:\n    - If `nums[i]` is zero:\n        - Increment `zero_count`\n    - Else:\n        - Move `nums[i]` to `nums[i - zero_count]`\n4. Iterate over `i` from `n - zero_count` to `n-1`:\n    - Set `nums[i]` to 0\n\nBy following the pseudocode, we effectively move all zeros to the end of the array while keeping the relative order of the non-zero elements intact.\n\nHere is the pseudocode for the described procedure:\n\n```\n# Pseudocode\n\ninitialize zero_count to 0\ninitialize n to length of nums\n\nfor i from 0 to n-1 do:\n    if nums[i] is 0 then:\n        increment zero_count by 1\n    else:\n        set nums[i - zero_count] to nums[i]\n\nfor i from n - zero_count to n-1 do:\n    set nums[i] to 0\n```\n\nBy following these steps, we can solve the problem efficiently with minimized operations. The key is to modify the array in-place without creating additional copies.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-move-zeroes"
    },
    {
        "name": "Find The Duplicate Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-the-duplicate-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int slow = nums[0];\n        int fast = nums[0];\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while(slow != fast);\n        \n        fast = nums[0];\n        while(slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        \n        return slow;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = nums[0];\n        int fast = nums[0];\n        \n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        \n        slow = nums[0];\n        \n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        \n        return slow;\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can employ Floyd's Tortoise and Hare (Cycle Detection) algorithm to find the duplicate number. This method ensures that we can achieve the solution in linear runtime complexity and constant extra space without modifying the input array.\n\n## Explanation\n\n1. **Cycle Detection**:\n    - Treat the problem as a cycle detection problem in a linked list.\n    - Utilize two pointers, a slow pointer and a fast pointer, which traverse the array at different speeds.\n    - The slow pointer moves one step at a time, while the fast pointer moves two steps at a time.\n    - If there's a cycle, these two pointers will eventually meet inside the cycle.\n\n2. **Finding the Duplicate**:\n    - Once the two pointers meet within the cycle, reset one pointer to the start of the array.\n    - Move both pointers at the same speed (one step at a time) until they meet again.\n    - The meeting point will be the duplicate number.\n\n## Pseudocode\n\n```pseudocode\n# Pseudocode for finding the duplicate number\nfunction findDuplicate(nums):\n    # Initialize two pointers\n    slow = nums[0]\n    fast = nums[0]\n\n    # Move pointers to find the meeting point in the cycle\n    do:\n        slow = nums[slow]  # Move slow pointer by one step\n        fast = nums[nums[fast]]  # Move fast pointer by two steps\n    while slow != fast\n\n    # Reset one pointer to the start\n    fast = nums[0]\n\n    # Move both pointers at the same speed to find the duplicate\n    while slow != fast:\n        slow = nums[slow]  # Move slow pointer by one step\n        fast = nums[fast]  # Move fast pointer by one step\n\n    # The meeting point is the duplicate number\n    return slow\n```\n\nThis pseudocode effectively translates the methodology described in the explanation to an actionable plan. By using Floyd's Tortoise and Hare algorithm, we ensure that the solution is both space-efficient (constant extra space) and time-efficient (linear runtime complexity).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-the-duplicate-number"
    },
    {
        "name": "Find Median From Data Stream",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-median-from-data-stream",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class MedianFinder {\npublic:\n    priority_queue<int> maxHeap;\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n\n    MedianFinder() {\n    }\n\n    void addNum(int num) {\n        if (maxHeap.empty() || num <= maxHeap.top()) {\n            maxHeap.push(num);\n        } else {\n            minHeap.push(num);\n        }\n\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n        } else if (minHeap.size() > maxHeap.size()) {\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n        }\n    }\n\n    double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return maxHeap.top();\n        }\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class MedianFinder {\n    PriorityQueue<Integer> minHeap;\n    PriorityQueue<Integer> maxHeap;\n\n    public MedianFinder() {\n        minHeap = new PriorityQueue<>();\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    }\n\n    public void addNum(int num) {\n        maxHeap.offer(num);\n        minHeap.offer(maxHeap.poll());\n\n        if (maxHeap.size() < minHeap.size()) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        } else {\n            return maxHeap.peek();\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "import heapq\n\nclass MedianFinder(object):\n\n    def __init__(self):\n        self.small = []  # max heap\n        self.large = []  # min heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -heapq.heappushpop(self.large, num))\n        if len(self.large) < len(self.small):\n            heapq.heappush(self.large, -heapq.heappop(self.small))\n\n    def findMedian(self):\n        if len(self.large) > len(self.small):\n            return float(self.large[0])\n        return (self.large[0] - self.small[0]) / 2.0\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class MedianFinder {\n    private readonly List<int> _nums;\n\n    public MedianFinder() {\n        _nums = new List<int>();\n    }\n\n    public void AddNum(int num) {\n        _nums.Add(num);\n        _nums.Sort();\n    }\n\n    public double FindMedian() {\n        int n = _nums.Count;\n        if (n % 2 == 0) {\n            return (_nums[n / 2 - 1] + _nums[n / 2]) / 2.0;\n        } else {\n            return _nums[n / 2];\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a data structure approach involving two heaps: a max-heap for the lower half of the numbers and a min-heap for the upper half. This allows us to efficiently maintain the median as we dynamically add numbers.\n\n# Explanation\n\n1. **Initialization**:\n   - Use two heaps: `small` (a max-heap) and `large` (a min-heap).\n   - In Python, `heapq` only supports min-heaps. To simulate a max-heap, we push the negative values.\n\n2. **Adding Numbers**:\n   - When a new number is added, push it into the `large` heap.\n   - Balance the heaps so that the size difference between `small` and `large` is at most one.\n   - If `large` has more elements than `small`, move the smallest element from `large` to `small`.\n\n3. **Finding the Median**:\n   - If the total number of elements is odd, the median is the top of the `large` heap.\n   - If even, the median is the average of the tops of both `small` and `large` heaps.\n\n# Pseudocode\n\n```\nclass MedianFinder:\n\n    function __init__():\n        initialize small_heap as an empty max-heap\n        initialize large_heap as an empty min-heap\n\n    function addNum(num: int):\n        push the num into the large_heap\n        push the smallest element of large_heap into small_heap\n        if size of large_heap < size of small_heap:\n            move the largest element of small_heap back to large_heap\n\n    function findMedian() -> float:\n        if size of large_heap is greater than size of small_heap:\n            return the top value of large_heap as float\n        else:\n            return the average of tops of large_heap and small_heap as float\n```\n\nThis logic ensures that both the insertion and median finding operations are efficient, handling up to 50,000 operations as per the problem constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-median-from-data-stream"
    },
    {
        "name": "Game Of Life",
        "site": "LeetCode",
        "href": "/solution/LeetCode-game-of-life",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void gameOfLife(vector<vector<int>>& board) {\n        vector<vector<int>> copyBoard = board;\n        int m = board.size();\n        int n = board[0].size();\n        \n        vector<pair<int, int>> directions = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int liveNeighbors = 0;\n                for (auto dir : directions) {\n                    int x = i + dir.first;\n                    int y = j + dir.second;\n                    if (x >= 0 && x < m && y >= 0 && y < n && copyBoard[x][y] == 1) {\n                        liveNeighbors++;\n                    }\n                }\n                \n                if (copyBoard[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[i][j] = 0;\n                } else if (copyBoard[i][j] == 0 && liveNeighbors == 3) {\n                    board[i][j] = 1;\n                }\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void gameOfLife(int[][] board) {\n        int m = board.length;\n        int n = board[0].length;\n        int[][] temp = new int[m][n];\n        \n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int liveNeighbors = 0;\n                \n                for (int[] dir : directions) {\n                    int newRow = i + dir[0];\n                    int newCol = j + dir[1];\n                    \n                    if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {\n                        liveNeighbors++;\n                    }\n                }\n                \n                if (board[i][j] == 1) {\n                    if (liveNeighbors < 2 || liveNeighbors > 3) {\n                        temp[i][j] = 0;\n                    } else {\n                        temp[i][j] = 1;\n                    }\n                } else {\n                    if (liveNeighbors == 3) {\n                        temp[i][j] = 1;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                board[i][j] = temp[i][j];\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: None Do not return anything, modify board in-place \n        instead.\n        \"\"\"\n        neighbors = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = 0\n                \n                for neighbor in neighbors:\n                    x = i + neighbor[0]\n                    y = j + neighbor[1]\n                    \n                    if 0 <= x < rows and 0 <= y < cols and abs(board[x][y]) == 1:\n                        live_neighbors += 1\n                \n                if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3):\n                    board[i][j] = -1\n                if board[i][j] == 0 and live_neighbors == 3:\n                    board[i][j] = 2\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] > 0:\n                    board[i][j] = 1\n                else:\n                    board[i][j] = 0\n                "
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "void gameOfLife(int** board, int boardSize, int* boardColSize) {\n    int m = boardSize;\n    int n = *boardColSize;\n    \n    int dirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int liveNeighbors = 0;\n            for (int k = 0; k < 8; k++) {\n                int x = i + dirs[k][0];\n                int y = j + dirs[k][1];\n                if (x >= 0 && x < m && y >= 0 && y < n && (board[x][y] == 1 || board[x][y] == 2)) {\n                    liveNeighbors++;\n                }\n            }\n            \n            if (board[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                board[i][j] = 2;\n            }\n            if (board[i][j] == 0 && liveNeighbors == 3) {\n                board[i][j] = 3;\n            }\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            board[i][j] %= 2;\n        }\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void GameOfLife(int[][] board) {\n        int m = board.Length;\n        int n = board[0].Length;\n\n        int[][] copyBoard = new int[m][];\n        for (int i = 0; i < m; i++) {\n            copyBoard[i] = new int[n];\n            Array.Copy(board[i], copyBoard[i], n);\n        }\n\n        int[] dirX = {0, 1, 0, -1, 1, 1, -1, -1};\n        int[] dirY = {1, 0, -1, 0, 1, -1, 1, -1};\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int liveNeighbors = 0;\n\n                for (int k = 0; k < 8; k++) {\n                    int newX = i + dirX[k];\n                    int newY = j + dirY[k];\n\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && copyBoard[newX][newY] == 1) {\n                        liveNeighbors++;\n                    }\n                }\n\n                if (copyBoard[i][j] == 1) {\n                    if (liveNeighbors < 2 || liveNeighbors > 3) {\n                        board[i][j] = 0;\n                    }\n                } else {\n                    if (liveNeighbors == 3) {\n                        board[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} board\n * @return {void} Do not return anything, modify board in-place \ninstead.\n */\nvar gameOfLife = function(board) {\n    const rows = board.length;\n    const cols = board[0].length;\n\n    const directions = [\n        [-1, -1], [-1, 0], [-1, 1],\n        [0, -1], [0, 1],\n        [1, -1], [1, 0], [1, 1]\n    ];\n\n    const isValid = (r, c) => {\n        return r >= 0 && r < rows && c >= 0 && c < cols;\n    };\n\n    const getLiveNeighbors = (r, c) => {\n        let liveNeighbors = 0;\n        \n        for (const [dr, dc] of directions) {\n            const newRow = r + dr;\n            const newCol = c + dc;\n            \n            if (isValid(newRow, newCol) && (board[newRow][newCol] === 1 || board[newRow][newCol] === 2)) {\n                liveNeighbors++;\n            }\n        }\n        \n        return liveNeighbors;\n    };\n\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            const liveNeighbors = getLiveNeighbors(r, c);\n            \n            if (board[r][c] === 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                board[r][c] = 2; // Next state dead\n            }\n            \n            if (board[r][c] === 0 && liveNeighbors === 3) {\n                board[r][c] = 3; // Next state alive\n            }\n        }\n    }\n\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            board[r][c] %= 2;\n        }\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify board in-place instead.\n */\nfunction gameOfLife(board: number[][]): void {\n    const directions = [\n        [0, 1],\n        [0, -1],\n        [1, 0],\n        [-1, 0],\n        [1, 1],\n        [1, -1],\n        [-1, 1],\n        [-1, -1]\n    ];\n\n    const rows = board.length;\n    const cols = board[0].length;\n\n    const copyBoard = JSON.parse(JSON.stringify(board));\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            let liveNeighbors = 0;\n\n            for (const [dx, dy] of directions) {\n                const x = i + dx;\n                const y = j + dy;\n\n                if (x >= 0 && x < rows && y >= 0 && y < cols && copyBoard[x][y] === 1) {\n                    liveNeighbors++;\n                }\n            }\n\n            if (copyBoard[i][j] === 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                board[i][j] = 0;\n            }\n\n            if (copyBoard[i][j] === 0 && liveNeighbors === 3) {\n                board[i][j] = 1;\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $board\n     * @return NULL\n     */\n    function gameOfLife(&$board) {\n        $directions = [\n            [-1, -1], [-1, 0], [-1, 1],\n            [0, -1],           [0, 1],\n            [1, -1],  [1, 0],  [1, 1]\n        ];\n        \n        $m = count($board);\n        $n = count($board[0]);\n        \n        $copy = $board;\n        \n        for ($i = 0; $i < $m; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                $liveNeighbors = 0;\n                \n                foreach ($directions as $dir) {\n                    $ni = $i + $dir[0];\n                    $nj = $j + $dir[1];\n                    \n                    if ($ni >= 0 && $ni < $m && $nj >= 0 && $nj < $n && $copy[$ni][$nj] == 1) {\n                        $liveNeighbors++;\n                    }\n                }\n                \n                if ($copy[$i][$j] == 1) {\n                    if ($liveNeighbors < 2 || $liveNeighbors > 3) {\n                        $board[$i][$j] = 0;\n                    }\n                } else {\n                    if ($liveNeighbors == 3) {\n                        $board[$i][$j] = 1;\n                    }\n                }\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func gameOfLife(_ board: inout [[Int]]) {\n        let m = board.count\n        let n = board[0].count\n        \n        let directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,-1), (1,-1), (-1,1)]\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                var liveNeighbors = 0\n                \n                for dir in directions {\n                    let x = i + dir.0\n                    let y = j + dir.1\n                    \n                    if x >= 0 && x < m && y >= 0 && y < n && (board[x][y] == 1 || board[x][y] == 2) {\n                        liveNeighbors += 1\n                    }\n                }\n                \n                if board[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3) {\n                    board[i][j] = 2\n                }\n                \n                if board[i][j] == 0 && liveNeighbors == 3 {\n                    board[i][j] = 3\n                }\n            }\n        }\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                if board[i][j] == 2 {\n                    board[i][j] = 0\n                } else if board[i][j] == 3 {\n                    board[i][j] = 1\n                }\n            }\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun gameOfLife(board: Array<IntArray>): Unit {\n        val rows = board.size\n        val cols = board[0].size\n\n        val directions = arrayOf(intArrayOf(-1, -1), intArrayOf(-1, 0), intArrayOf(-1, 1), intArrayOf(0, -1), \n            intArrayOf(0, 1), intArrayOf(1, -1), intArrayOf(1, 0), intArrayOf(1, 1))\n\n        for (i in 0 until rows) {\n            for (j in 0 until cols) {\n                var liveNeighbors = 0\n\n                for (dir in directions) {\n                    val newRow = i + dir[0]\n                    val newCol = j + dir[1]\n\n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && (board[newRow][newCol] == 1 || board[newRow][newCol] == -1)) {\n                        liveNeighbors++\n                    }\n                }\n\n                if (board[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[i][j] = -1\n                }\n                \n                if (board[i][j] == 0 && liveNeighbors == 3) {\n                    board[i][j] = 2\n                }\n            }\n        }\n\n        for (i in 0 until rows) {\n            for (j in 0 until cols) {\n                if (board[i][j] == -1) {\n                    board[i][j] = 0\n                } else if (board[i][j] == 2) {\n                    board[i][j] = 1\n                }\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void gameOfLife(List<List<int>> board) {\n    List<List<int>> copyBoard = List.generate(board.length, (index) => List<int>.filled(board[0].length, 0));\n\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[0].length; j++) {\n        int liveNeighbours = _countLiveNeighbours(board, i, j);\n\n        if (board[i][j] == 1) {\n          if (liveNeighbours < 2 || liveNeighbours > 3) {\n            copyBoard[i][j] = 0;\n          } else {\n            copyBoard[i][j] = 1;\n          }\n        } else {\n          if (liveNeighbours == 3) {\n            copyBoard[i][j] = 1;\n          } else {\n            copyBoard[i][j] = 0;\n          }\n        }\n      }\n    }\n\n    for (int i = 0; i < board.length; i++) {\n      for (int j = 0; j < board[0].length; j++) {\n        board[i][j] = copyBoard[i][j];\n      }\n    }\n  }\n\n  int _countLiveNeighbours(List<List<int>> board, int row, int col) {\n    int count = 0;\n    List<List<int>> directions = [\n      [-1, -1], [-1, 0], [-1, 1],\n      [0, -1], [0, 1],\n      [1, -1], [1, 0], [1, 1]\n    ];\n\n    for (var dir in directions) {\n      int newRow = row + dir[0];\n      int newCol = col + dir[1];\n\n      if (newRow >= 0 && newRow < board.length && newCol >= 0 && newCol < board[0].length) {\n        if (board[newRow][newCol] == 1) {\n          count++;\n        }\n      }\n    }\n\n    return count;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func gameOfLife(board [][]int) {\n    if len(board) == 0 || len(board[0]) == 0 {\n        return\n    }\n\n    m, n := len(board), len(board[0])\n    directions := []int{-1, 0, 1}\n\n    getNextState := func(i, j int) int {\n        liveNeighbours := 0\n        for _, dx := range directions {\n            for _, dy := range directions {\n                if dx == 0 && dy == 0 {\n                    continue\n                }\n                newRow, newCol := i+dx, j+dy\n                if newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && (board[newRow][newCol] == 1 || board[newRow][newCol] == 2) {\n                    liveNeighbours++\n                }\n            }\n        }\n\n        if board[i][j] == 1 {\n            if liveNeighbours < 2 || liveNeighbours > 3 {\n                return 2\n            }\n        } else {\n            if liveNeighbours == 3 {\n                return -1\n            }\n        }\n\n        return board[i][j]\n    }\n\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            board[i][j] = getNextState(i, j)\n        }\n    }\n\n    for i := 0; i < m; i++ {\n        for j := 0; j < n; j++ {\n            if board[i][j] == -1 {\n                board[i][j] = 1\n            } else if board[i][j] == 2 {\n                board[i][j] = 0\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def gameOfLife(board: Array[Array[Int]]): Unit = {\n        val m = board.length\n        val n = board(0).length\n\n        val directions = List((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))\n\n        def countLiveNeighbors(x: Int, y: Int): Int = {\n            var count = 0\n            for ((dx, dy) <- directions) {\n                val newX = x + dx\n                val newY = y + dy\n                if (newX >= 0 && newX < m && newY >= 0 && newY < n && (board(newX)(newY) == 1 || board(newX)(newY) == -1))\n                    count += 1\n            }\n            count\n        }\n\n        for (i <- 0 until m; j <- 0 until n) {\n            val liveNeighbors = countLiveNeighbors(i, j)\n            if (board(i)(j) == 1 && (liveNeighbors < 2 || liveNeighbors > 3))\n                board(i)(j) = -1\n            if (board(i)(j) == 0 && liveNeighbors == 3)\n                board(i)(j) = 2\n        }\n\n        for (i <- 0 until m; j <- 0 until n) {\n            if (board(i)(j) == -1)\n                board(i)(j) = 0\n            if (board(i)(j) == 2)\n                board(i)(j) = 1\n        }\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn game_of_life(board: &mut Vec<Vec<i32>>) {\n        let m = board.len();\n        let n = board[0].len();\n        \n        let mut new_board = vec![vec![0; n]; m];\n        \n        let directions = vec![-1, 0, 1];\n        \n        for i in 0..m {\n            for j in 0..n {\n                let mut live_neighbors = 0;\n                \n                for &di in directions.iter() {\n                    for &dj in directions.iter() {\n                        if di == 0 && dj == 0 {\n                            continue;\n                        }\n                        \n                        let ni = i as i32 + di;\n                        let nj = j as i32 + dj;\n                        \n                        if ni >= 0 && ni < m as i32 && nj >= 0 && nj < n as i32 {\n                            live_neighbors += board[ni as usize][nj as usize];\n                        }\n                    }\n                }\n                \n                if board[i][j] == 1 {\n                    if live_neighbors < 2 || live_neighbors > 3 {\n                        new_board[i][j] = 0;\n                    } else {\n                        new_board[i][j] = 1;\n                    }\n                } else {\n                    if live_neighbors == 3 {\n                        new_board[i][j] = 1;\n                    } else {\n                        new_board[i][j] = 0;\n                    }\n                }\n            }\n        }\n        \n        *board = new_board;\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to simulate the next state of the Game of Life based on current cell states and their neighbors' states. The solution involves modifying the board in-place to ensure all updates are simultaneous.\n\n# Explanation\n1. **Understanding Rules**: Each cell's state in the next generation depends on the number of live neighbors.\n   - Live cell (< 2 live neighbors) \u2794 Dies (under-population).\n   - Live cell (2 or 3 live neighbors) \u2794 Lives.\n   - Live cell (> 3 live neighbors) \u2794 Dies (over-population).\n   - Dead cell (exactly 3 live neighbors) \u2794 Becomes live (reproduction).\n   \n2. **In-Place Update**: To avoid using extra space, we use temporary markers.\n   - `-1` indicates a live cell that will die.\n   - `2` indicates a dead cell that will become live.\n\n3. **Processing Each Cell**:\n   - Iterate through each cell and count its live neighbors.\n   - Apply the rules and mark cells with appropriate temporary markers.\n   \n4. **Final Update**: Convert all temporary markers to their final states by iterating through the board again.\n\n# Pseudocode\n```\nfunction gameOfLife(board)\n    neighbors = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]\n    rows = length(board)\n    cols = length(board[0])\n    \n    # Step 1: Apply the rules and mark cells with temporary markers\n    for i from 0 to rows - 1\n        for j from 0 to cols - 1\n            live_neighbors = 0\n            \n            # Count live neighbors\n            for neighbor in neighbors\n                x = i + neighbor[0]\n                y = j + neighbor[1]\n                if 0 <= x < rows and 0 <= y < cols and abs(board[x][y]) == 1\n                    live_neighbors += 1\n            \n            # Apply rules\n            if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3)\n                board[i][j] = -1 # Mark as dead\n            if board[i][j] == 0 and live_neighbors == 3\n                board[i][j] = 2  # Mark as live\n    \n    # Step 2: Finalize the next state\n    for i from 0 to rows - 1\n        for j from 0 to cols - 1\n            if board[i][j] > 0\n                board[i][j] = 1  # Live cell\n            else\n                board[i][j] = 0  # Dead cell\n```\n\nThis pseudocode encompasses all necessary steps to transform the board in place while ensuring that the updates are simultaneous.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-game-of-life"
    },
    {
        "name": "Word Pattern",
        "site": "LeetCode",
        "href": "/solution/LeetCode-word-pattern",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        unordered_map<char, string> charToWord;\n        unordered_map<string, char> wordToChar;\n        istringstream iss(s);\n        string word;\n        int i = 0;\n        while (iss >> word) {\n            if (i == pattern.length() || charToWord.count(pattern[i]) && charToWord[pattern[i]] != word || wordToChar.count(word) && wordToChar[word] != pattern[i]) {\n                return false;\n            }\n            charToWord[pattern[i]] = word;\n            wordToChar[word] = pattern[i];\n            i++;\n        }\n        return i == pattern.length();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        String[] words = s.split(\" \");\n        if (pattern.length() != words.length) {\n            return false;\n        }\n\n        Map<Character, String> map = new HashMap<>();\n        Set<String> wordSet = new HashSet<>();\n        \n        for (int i = 0; i < pattern.length(); i++) {\n            char c = pattern.charAt(i);\n            String word = words[i];\n            \n            if (map.containsKey(c)) {\n                if (!map.get(c).equals(word)) {\n                    return false;\n                }\n            } else {\n                if (wordSet.contains(word)) {\n                    return false;\n                }\n                \n                map.put(c, word);\n                wordSet.add(word);\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_word_map = {}\n        word_char_map = {}\n        \n        for char, word in zip(pattern, words):\n            if char in char_word_map:\n                if char_word_map[char] != word:\n                    return False\n            else:\n                char_word_map[char] = word\n            \n            if word in word_char_map:\n                if word_char_map[word] != char:\n                    return False\n            else:\n                word_char_map[word] = char\n        \n        return True\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool WordPattern(string pattern, string s) {\n        string[] words = s.Split(' ');\n        if (pattern.Length != words.Length)\n            return false;\n        \n        Dictionary<char, string> patternMap = new Dictionary<char, string>();\n        HashSet<string> wordSet = new HashSet<string>();\n        \n        for (int i = 0; i < pattern.Length; i++) {\n            char ch = pattern[i];\n            string word = words[i];\n            \n            if (!patternMap.ContainsKey(ch)) {\n                if (wordSet.Contains(word))\n                    return false;\n                \n                patternMap[ch] = word;\n                wordSet.Add(word);\n            } else {\n                if (patternMap[ch] != word)\n                    return false;\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} pattern\n * @param {string} s\n * @return {boolean}\n */\nvar wordPattern = function(pattern, s) {\n    const patternArr = pattern.split('');\n    const sArr = s.split(' ');\n\n    if (patternArr.length !== sArr.length) {\n        return false;\n    }\n\n    const map = new Map();\n    const set = new Set();\n\n    for (let i = 0; i < patternArr.length; i++) {\n        const char = patternArr[i];\n        const word = sArr[i];\n\n        if (!map.has(char)) {\n            if (set.has(word)) {\n                return false;\n            }\n            map.set(char, word);\n            set.add(word);\n        } else {\n            if (map.get(char) !== word) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function wordPattern(pattern: string, s: string): boolean {\n    const patternArr = pattern.split('');\n    const sArr = s.split(' ');\n\n    if (patternArr.length !== sArr.length) {\n        return false;\n    }\n\n    const patternMap = new Map<string, string>();\n    const wordMap = new Map<string, string>();\n\n    for (let i = 0; i < patternArr.length; i++) {\n        const patternChar = patternArr[i];\n        const word = sArr[i];\n\n        if (patternMap.has(patternChar)) {\n            if (patternMap.get(patternChar) !== word) {\n                return false;\n            }\n        } else {\n            patternMap.set(patternChar, word);\n        }\n\n        if (wordMap.has(word)) {\n            if (wordMap.get(word) !== patternChar) {\n                return false;\n            }\n        } else {\n            wordMap.set(word, patternChar);\n        }\n    }\n\n    return true;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $pattern\n     * @param String $s\n     * @return Boolean\n     */\n    function wordPattern($pattern, $s) {\n        $patternArr = str_split($pattern);\n        $words = explode(' ', $s);\n        \n        if (count($patternArr) !== count($words)) {\n            return false;\n        }\n        \n        $map = [];\n        $reverseMap = [];\n        \n        for ($i = 0; $i < count($patternArr); $i++) {\n            $char = $patternArr[$i];\n            $word = $words[$i];\n            \n            if (isset($map[$char])) {\n                if ($map[$char] !== $word) {\n                    return false;\n                }\n            } else {\n                $map[$char] = $word;\n            }\n            \n            if (isset($reverseMap[$word])) {\n                if ($reverseMap[$word] !== $char) {\n                    return false;\n                }\n            } else {\n                $reverseMap[$word] = $char;\n            }\n        }\n        \n        return true;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func wordPattern(_ pattern: String, _ s: String) -> Bool {\n        let words = s.components(separatedBy: \" \")\n        if pattern.count != words.count {\n            return false\n        }\n        \n        var charToStringMap: [Character: String] = [:]\n        var stringToCharMap: [String: Character] = [:]\n        \n        for (index, char) in pattern.enumerated() {\n            let word = words[index]\n            if let mappedWord = charToStringMap[char], mappedWord != word {\n                return false\n            }\n            \n            if let mappedChar = stringToCharMap[word], mappedChar != char {\n                return false\n            }\n            \n            charToStringMap[char] = word\n            stringToCharMap[word] = char\n        }\n        \n        return true\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun wordPattern(pattern: String, s: String): Boolean {\n        val words = s.split(\" \")\n        if (pattern.length != words.size) return false\n        \n        val mapCharToWord = HashMap<Char, String>()\n        val mapWordToChar = HashMap<String, Char>()\n        \n        for (i in pattern.indices) {\n            val char = pattern[i]\n            val word = words[i]\n            if (mapCharToWord.containsKey(char)) {\n                if (mapCharToWord[char] != word) return false\n            } else {\n                if (mapWordToChar.containsKey(word)) return false\n                mapCharToWord[char] = word\n                mapWordToChar[word] = char\n            }\n        }\n        \n        return true\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool wordPattern(String pattern, String s) {\n    List<String> words = s.split(' ');\n    if (pattern.length != words.length) {\n      return false;\n    }\n    \n    Map<String, String> patternMap = {};\n    Map<String, String> wordMap = {};\n    \n    for (int i = 0; i < pattern.length; i++) {\n      String letter = pattern[i];\n      String word = words[i];\n      \n      if (!patternMap.containsKey(letter) && !wordMap.containsKey(word)) {\n        patternMap[letter] = word;\n        wordMap[word] = letter;\n      } else {\n        if (patternMap[letter] != word || wordMap[word] != letter) {\n          return false;\n        }\n      }\n    }\n    \n    return true;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func wordPattern(pattern string, s string) bool {\n    words := strings.Split(s, \" \")\n\n    if len(pattern) != len(words) {\n        return false\n    }\n\n    patternMap := make(map[byte]string)\n    wordMap := make(map[string]byte)\n\n    for i := 0; i < len(pattern); i++ {\n        p := pattern[i]\n        w := words[i]\n\n        if _, ok := patternMap[p]; !ok {\n            patternMap[p] = w\n        } else {\n            if patternMap[p] != w {\n                return false\n            }\n        }\n\n        if _, ok := wordMap[w]; !ok {\n            wordMap[w] = p\n        } else {\n            if wordMap[w] != p {\n                return false\n            }\n        }\n    }\n\n    return true\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} pattern\n# @param {String} s\n# @return {Boolean}\ndef word_pattern(pattern, s)\n    pattern = pattern.split('')\n    words = s.split(' ')\n    \n    return false if pattern.length != words.length\n    \n    pattern_map = {}\n    word_map = {}\n    \n    pattern.each_with_index do |char, index|\n        if pattern_map[char]\n            return false if pattern_map[char] != words[index]\n        else\n            pattern_map[char] = words[index]\n        end\n        \n        if word_map[words[index]]\n            return false if word_map[words[index]] != char\n        else\n            word_map[words[index]] = char\n        end\n    end\n    \n    return true\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn word_pattern(pattern: String, s: String) -> bool {\n        let pattern_chars: Vec<char> = pattern.chars().collect();\n        let words: Vec<&str> = s.split_whitespace().collect();\n        \n        if pattern_chars.len() != words.len() {\n            return false;\n        }\n        \n        let mut pattern_map: HashMap<char, &str> = HashMap::new();\n        let mut word_map: HashMap<&str, char> = HashMap::new();\n        \n        for i in 0..pattern_chars.len() {\n            if let Some(&mapped_word) = pattern_map.get(&pattern_chars[i]) {\n                if mapped_word != words[i] {\n                    return false;\n                }\n            }\n            if let Some(&mapped_char) = word_map.get(&words[i]) {\n                if mapped_char != pattern_chars[i] {\n                    return false;\n                }\n            }\n            pattern_map.insert(pattern_chars[i], words[i]);\n            word_map.insert(words[i], pattern_chars[i]);\n        }\n        \n        true\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if there is a bijection between characters in the pattern and words in the string `s`. This means each character in the pattern should correspond to a unique word in `s`, and vice versa.\n\n# Explanation\n\n1. **Split the String**: First, we split the string `s` into individual words.\n2. **Check Lengths**: Ensure that the number of words in `s` matches the length of the pattern. If not, return `False`.\n3. **Mapping Between Pattern and Words**: Use two dictionaries to create mappings from:\n   - Character in the pattern to the corresponding word.\n   - Word to the corresponding character in the pattern.\n   \n4. **Validation**:\n   - Traverse each character in the pattern along with the corresponding word.\n   - For each character and word pair:\n     - Check if the character already has a mapped word and if it's the same as the current word.\n     - Similarly, check if the word already has a mapped character and if it matches the current character.\n     - If any of the mappings are inconsistent, return `False`.\n   \n5. **Return True If All Checks Pass**: If all characters and words are consistently mapped throughout the traversal, return `True`.\n\n# Pseudocode\n\n```\nfunction wordPattern(pattern, s):\n    words = split(s, \" \")  # Split string s by spaces into words\n    \n    if length(pattern) != length(words):\n        return False  # The pattern and words must have the same length\n    \n    char_word_map = {}  # Initialize dictionary for pattern to word mapping\n    word_char_map = {}  # Initialize dictionary for word to pattern mapping\n    \n    for each (char, word) in zip(pattern, words):\n        if char exists in char_word_map:\n            if char_word_map[char] != word:\n                return False  # Mismatch in mapping\n        else:\n            char_word_map[char] = word  # Create new mapping\n\n        if word exists in word_char_map:\n            if word_char_map[word] != char:\n                return False  # Mismatch in mapping\n        else:\n            word_char_map[word] = char  # Create new mapping\n            \n    return True\n```\n\nThis pseudocode outlines how to consistently map pattern characters to words and validate the given conditions. By traversing the pattern and the words in `s` concurrently and ensuring a consistency in the mappings, we can determine if the string `s` follows the given pattern.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-word-pattern"
    },
    {
        "name": "Nim Game",
        "site": "LeetCode",
        "href": "/solution/LeetCode-nim-game",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool canWinNim(int n) {\n        return n % 4 != 0;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean canWinNim(int n) {\n        return n % 4 != 0;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool CanWinNim(int n) {\n        return n % 4 != 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar canWinNim = function(n) {\n    return n % 4 !== 0;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function canWinNim(n: number): boolean {\n    return n % 4 !== 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Boolean\n     */\n    function canWinNim($n) {\n        return $n % 4 != 0;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func canWinNim(_ n: Int) -> Bool {\n        return n % 4 != 0\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun canWinNim(n: Int): Boolean {\n        return n % 4 != 0\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool canWinNim(int n) {\n      return n % 4 != 0;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func canWinNim(n int) bool {\n    return n%4 != 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Boolean}\ndef can_win_nim(n)\n    return n % 4 != 0\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def canWinNim(n: Int): Boolean = {\n        n % 4 != 0\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn can_win_nim(n: i32) -> bool {\n        n % 4 != 0\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (can-win-nim n)\n  (-> exact-integer? boolean?)\n  (if (= (modulo n 4) 0)\n      #f\n      #t))"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec can_win_nim(N :: integer()) -> boolean().\ncan_win_nim(N) ->\n    N rem 4 /= 0."
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec can_win_nim(n :: integer) :: boolean\n  def can_win_nim(n) do\n    rem(n, 4) != 0\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to determine if you can win the Nim Game given a certain number of stones in the heap, assuming both players play optimally.\n\n# Explanation\n\n1. **Understanding the Game**:\n   - There is a heap of stones, and you can remove 1 to 3 stones on your turn.\n   - The player who removes the last stone wins the game.\n   - You and your friend take turns, and you go first.\n\n2. **Key Insight**:\n   - If the number of stones, `n`, is a multiple of 4, you will always lose if the opponent plays optimally.\n   - This is because no matter how many stones you remove (1, 2 or 3), your opponent can always adjust their move to ensure that the total number of stones removed by both players in two turns sums up to 4. This cycle will continue until you are forced to take the last stone.\n\n3. **Optimal Strategy**:\n   - Therefore, the only way to win is if `n` is not a multiple of 4. In this case, you can always ensure that by the end of your turn, the number of stones remaining is a multiple of 4 for your opponent's turn.\n\n# Pseudocode\n\nHere's the pseudocode for the solution:\n\n```\nfunction canWinNim(n):\n    # Check if n is a multiple of 4\n    if n % 4 == 0:\n        return false\n    else:\n        return true\n```\n\nThis method uses a simple modulo operation to determine if `n` is a multiple of 4. If it is, return `false` meaning you cannot win. Otherwise, return `true` meaning you can win.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-nim-game"
    },
    {
        "name": "Bulls And Cows",
        "site": "LeetCode",
        "href": "/solution/LeetCode-bulls-and-cows",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string getHint(string secret, string guess) {\n        int bulls = 0, cows = 0;\n        unordered_map<char, int> secretFreq, guessFreq;\n\n        for (int i = 0; i < secret.size(); i++) {\n            if (secret[i] == guess[i]) {\n                bulls++;\n            } else {\n                secretFreq[secret[i]]++;\n                guessFreq[guess[i]]++;\n            }\n        }\n\n        for (auto& p : secretFreq) {\n            cows += min(p.second, guessFreq[p.first]);\n        }\n\n        return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String getHint(String secret, String guess) {\n        int bulls = 0;\n        int cows = 0;\n        \n        int[] secretCount = new int[10];\n        int[] guessCount = new int[10];\n        \n        for (int i = 0; i < secret.length(); i++) {\n            char s = secret.charAt(i);\n            char g = guess.charAt(i);\n            if (s == g) {\n                bulls++;\n            } else {\n                secretCount[s - '0']++;\n                guessCount[g - '0']++;\n            }\n        }\n        \n        for (int i = 0; i < 10; i++) {\n            cows += Math.min(secretCount[i], guessCount[i]);\n        }\n        \n        return bulls + \"A\" + cows + \"B\";\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string GetHint(string secret, string guess) {\n        int bulls = 0, cows = 0;\n        int[] counts = new int[10];\n        \n        for (int i = 0; i < secret.Length; i++) {\n            if (secret[i] == guess[i]) {\n                bulls++;\n            } else {\n                if (counts[secret[i] - '0'] < 0) cows++;\n                if (counts[guess[i] - '0'] > 0) cows++;\n                counts[secret[i] - '0']++;\n                counts[guess[i] - '0']--;\n            }\n        }\n        \n        return bulls + \"A\" + cows + \"B\";\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} secret\n * @param {string} guess\n * @return {string}\n */\nvar getHint = function(secret, guess) {\n    let bulls = 0;\n    let cows = 0;\n    const secretFreq = new Array(10).fill(0);\n    const guessFreq = new Array(10).fill(0);\n    \n    for (let i = 0; i < secret.length; i++) {\n        if (secret[i] === guess[i]) {\n            bulls++;\n        } else {\n            secretFreq[parseInt(secret[i])]++;\n            guessFreq[parseInt(guess[i])]++;\n        }\n    }\n    \n    for (let i = 0; i < 10; i++) {\n        cows += Math.min(secretFreq[i], guessFreq[i]);\n    }\n    \n    return `${bulls}A${cows}B`;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function getHint(secret: string, guess: string): string {\n    let bulls = 0;\n    let cows = 0;\n    const secretCount = new Array(10).fill(0);\n    const guessCount = new Array(10).fill(0);\n    \n    for (let i = 0; i < secret.length; i++) {\n        if (secret[i] === guess[i]) {\n            bulls++;\n        } else {\n            secretCount[parseInt(secret[i])]++;\n            guessCount[parseInt(guess[i])]++;\n        }\n    }\n    \n    for (let i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n    \n    return `${bulls}A${cows}B`;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $secret\n     * @param String $guess\n     * @return String\n     */\n    function getHint($secret, $guess) {\n        $bulls = 0;\n        $cows = 0;\n        $secretMap = [];\n        $guessMap = [];\n\n        for ($i = 0; $i < strlen($secret); $i++) {\n            if ($secret[$i] === $guess[$i]) {\n                $bulls++;\n            } else {\n                if (!isset($secretMap[$secret[$i]])) {\n                    $secretMap[$secret[$i]] = 0;\n                }\n                $secretMap[$secret[$i]]++;\n                \n                if (!isset($guessMap[$guess[$i]])) {\n                    $guessMap[$guess[$i]] = 0;\n                }\n                $guessMap[$guess[$i]]++;\n            }\n        }\n        \n        foreach ($secretMap as $digit => $count) {\n            if (isset($guessMap[$digit])) {\n                $cows += min($guessMap[$digit], $count);\n            }\n        }\n\n        return $bulls . 'A' . $cows . 'B';\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func getHint(_ secret: String, _ guess: String) -> String {\n        var bulls = 0\n        var cows = 0\n        var nums = Array(repeating: 0, count: 10)\n        \n        for i in 0..<secret.count {\n            let s = secret[secret.index(secret.startIndex, offsetBy: i)]\n            let g = guess[guess.index(guess.startIndex, offsetBy: i)]\n            \n            if s == g {\n                bulls += 1\n            } else {\n                if nums[Int(s.asciiValue!) - 48] < 0 { cows += 1 }\n                if nums[Int(g.asciiValue!) - 48] > 0 { cows += 1 }\n                nums[Int(s.asciiValue!) - 48] += 1\n                nums[Int(g.asciiValue!) - 48] -= 1\n            }\n        }\n        \n        return \"\\(bulls)A\\(cows)B\"\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun getHint(secret: String, guess: String): String {\n        var bulls = 0\n        var cows = 0\n        val secretDigits = IntArray(10)\n        val guessDigits = IntArray(10)\n        \n        for (i in secret.indices) {\n            val s = secret[i]\n            val g = guess[i]\n            if (s == g) {\n                bulls++\n            } else {\n                secretDigits[s - '0']++\n                guessDigits[g - '0']++\n            }\n        }\n        \n        for (i in 0 until 10) {\n            cows += min(secretDigits[i], guessDigits[i])\n        }\n        \n        return \"${bulls}A${cows}B\"\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func getHint(secret string, guess string) string {\n    bulls := 0\n    cows := 0\n    counts := make([]int, 10)\n\n    for i := 0; i < len(secret); i++ {\n        s := secret[i] - '0'\n        g := guess[i] - '0'\n        if s == g {\n            bulls++\n        } else {\n            if counts[s] < 0 {\n                cows++\n            }\n            if counts[g] > 0 {\n                cows++\n            }\n            counts[s]++\n            counts[g]--\n        }\n    }\n\n    return fmt.Sprintf(\"%dA%dB\", bulls, cows)\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to compare two strings, `secret` and `guess`, and determine the number of \"bulls\" (correct digits in the correct positions) and \"cows\" (correct digits but in incorrect positions).\n\n# Explanation\n1. We initialize two counters, `bulls` and `cows`, to zero.\n2. We also maintain two frequency arrays to keep track of the digits in the `secret` and `guess` strings that are not bulls.\n3. We iterate through the characters in the `secret` and `guess` strings. If the characters at the same position are identical, we increment the `bulls` counter.\n4. If they are not identical, we update the frequency arrays to count the occurrences of these non-matching digits.\n5. After the first pass, we compare the frequency arrays to count the `cows` by taking the minimum count for each digit from the two arrays.\n6. Finally, we return the result in the format \"xAyB\", where x is the number of bulls and y is the number of cows.\n\n# Pseudocode\n```\nfunction getHint(secret, guess):\n    bulls = 0\n    cows = 0\n    secretFreq = array of 10 zeros\n    guessFreq = array of 10 zeros\n    \n    for i from 0 to length(secret) - 1:\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secretFreq[integer value of secret[i]] += 1\n            guessFreq[integer value of guess[i]] += 1\n    \n    for i from 0 to 9:\n        cows += minimum(secretFreq[i], guessFreq[i])\n    \n    return bulls + \"A\" + cows + \"B\"\n```\nThis pseudocode covers all the steps needed to compare the `secret` and `guess` strings and compute the number of bulls and cows, ensuring correctness by systematically counting and comparing each character's position and occurrences.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-bulls-and-cows"
    },
    {
        "name": "Serialize And Deserialize Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-serialize-and-deserialize-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if(root == NULL) {\n            return \"null\";\n        }\n        \n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right);\n    }\n    \n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        stringstream ss(data);\n        return deserializeHelper(ss);\n    }\n    \nprivate:\n    TreeNode* deserializeHelper(stringstream& ss) {\n        string str;\n        getline(ss, str, ',');\n        \n        if(str == \"null\") {\n            return NULL;\n        } else {\n            TreeNode* root = new TreeNode(stoi(str));\n            root->left = deserializeHelper(ss);\n            root->right = deserializeHelper(ss);\n            return root;\n        }\n    }\n};\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Codec {\n    function serialize($root) {\n        if ($root === null) {\n            return \"null,\";\n        }\n        \n        $leftSerialized = $this->serialize($root->left);\n        $rightSerialized = $this->serialize($root->right);\n        \n        return $root->val . \",\" . $leftSerialized . $rightSerialized;\n    }\n    \n    function deserialize($data) {\n        $queue = explode(\",\", $data);\n        return $this->buildTree($queue);\n    }\n    \n    function buildTree(&$queue) {\n        $val = array_shift($queue);\n        \n        if ($val === \"null\") {\n            return null;\n        }\n        \n        $node = new TreeNode($val);\n        $node->left = $this->buildTree($queue);\n        $node->right = $this->buildTree($queue);\n        \n        return $node;\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Codec() {\n    // Encodes a URL to a shortened URL.\n    fun serialize(root: TreeNode?): String {\n        if (root == null) {\n            return \"null\"\n        }\n        \n        val leftSerialized = serialize(root.left)\n        val rightSerialized = serialize(root.right)\n        \n        return \"${root.`val`},$leftSerialized,$rightSerialized\"\n    }\n    \n    // Decodes your encoded data to tree.\n    fun deserialize(data: String): TreeNode? {\n        val dataList = data.split(\",\")\n        val queue: Queue<String> = LinkedList(dataList)\n        return deserializeHelper(queue)\n    }\n    \n    private fun deserializeHelper(queue: Queue<String>): TreeNode? {\n        val value = queue.poll()\n        if (value == \"null\") {\n            return null\n        }\n        \n        val node = TreeNode(value.toInt())\n        node.left = deserializeHelper(queue)\n        node.right = deserializeHelper(queue)\n        \n        return node\n    }\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nclass Codec {\n    // Encodes a list of strings to a single string.\n    def serialize(root: TreeNode): String = {\n        if (root == null) return \"null\"\n        \n        val leftSerialized = serialize(root.left)\n        val rightSerialized = serialize(root.right)\n        \n        root.value.toString + \",\" + leftSerialized + \",\" + rightSerialized\n    }\n    \n    // Decodes a single string to a list of strings.\n    def deserialize(data: String): TreeNode = {\n        var queue = scala.collection.mutable.Queue[String](data.split(\",\"):_*)\n        \n        def helperDeserialize(): TreeNode = {\n            val value = queue.dequeue()\n            if (value == \"null\") return null\n            \n            val node = new TreeNode(value.toInt)\n            node.left = helperDeserialize()\n            node.right = helperDeserialize()\n            \n            node\n        }\n        \n        helperDeserialize()\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we use a Tree serialization and deserialization methodology. Serialization is converting a data structure, such as a binary tree, into a format that can be easily stored or transmitted and then rebuilt later. Deserialization is the reverse process \u2014 converting the stored format back into the original data structure.\n\n# Explanation\n\n1. **Serialization**:\n    - Use a Depth-First Search (DFS) approach (preferably Pre-order Traversal) to serialize the tree.\n    - Traverse each node, recording its value.\n    - For each null node (a leaf's child), record a sentinel value like \"null\".\n    - Use a separator (e.g., comma) to separate node values in the serialized string.\n\n2. **Deserialization**:\n    - Split the serialized string by the separator to get a list of node values.\n    - Use a helper function to recursively build the tree by iterating through this list.\n    - Rebuild the tree recursively by reading each value and creating nodes, assigning left and right children as appropriate.\n\n# Pseudocode\n\n```\n# Class definition for TreeNode\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Serialize and Deserialize class\nclass Codec:\n    # Encodes a tree to a single string.\n    def serialize(self, root):\n        # Helper function to perform DFS and record node values\n        def dfs(node):\n            if not node:\n                return \"null,\"\n            return str(node.val) + \",\" + dfs(node.left) + dfs(node.right)\n        \n        # Initiate DFS traversal from root\n        return dfs(root)\n    \n    # Decodes your encoded data to tree.\n    def deserialize(self, data):\n        # Split the serialized data by commas\n        values = data.split(',')\n        \n        # Helper function to build the tree recursively\n        def build_tree():\n            val = values.pop(0)\n            if val == \"null\":\n                return None\n            node = TreeNode(int(val))\n            node.left = build_tree()\n            node.right = build_tree()\n            return node\n        \n        # Start building the tree from the list of values\n        return build_tree()\n\n# Example Usage\n# codec = Codec()\n# tree = codec.deserialize(codec.serialize(root))\n```\n\nIn this pseudocode:\n- The `serialize` function uses a DFS approach to convert the tree into a string.\n- The `deserialize` function breaks the string back into elements and then reconstructs the tree using recursive calls.\n- The `TreeNode` class describes the structure of a tree node. \n\nThis pseudocode ensures the tree can be accurately serialized to a string and that string can be deserialized back to the original tree structure.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-serialize-and-deserialize-binary-tree"
    },
    {
        "name": "Longest Increasing Subsequence",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-increasing-subsequence",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        \n        return *max_element(dp.begin(), dp.end());\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        if (n == 0) {\n            return 0;\n        }\n        \n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        \n        int maxLength = 1;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLength = Math.max(maxLength, dp[i]);\n        }\n        \n        return maxLength;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def lengthOfLIS(self, nums):\n        if not nums:\n            return 0\n        \n        dp = [1] * len(nums)\n        \n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int lengthOfLIS(int* nums, int numsSize) {\n    if (numsSize == 0) {\n        return 0;\n    }\n    \n    int dp[numsSize];\n    int len = 1;\n    dp[0] = nums[0];\n    \n    for (int i = 1; i < numsSize; i++) {\n        if (nums[i] > dp[len - 1]) {\n            dp[len] = nums[i];\n            len++;\n        } else {\n            int left = 0, right = len - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (dp[mid] < nums[i]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            dp[right] = nums[i];\n        }\n    }\n    \n    return len;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LengthOfLIS(int[] nums) {\n        int n = nums.Length;\n        int[] dp = new int[n];\n        \n        Array.Fill(dp, 1);\n        \n        for(int i = 1; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                if(nums[i] > nums[j]) {\n                    dp[i] = Math.Max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        \n        return dp.Max();\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n    \n    let dp = new Array(nums.length).fill(1);\n    let maxLen = 1;\n    \n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        maxLen = Math.max(maxLen, dp[i]);\n    }\n    \n    return maxLen;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function lengthOfLIS(nums: number[]): number {\n    const dp: number[] = new Array(nums.length).fill(1);\n\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n\n    return Math.max(...dp);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function lengthOfLIS($nums) {\n        $n = count($nums);\n        $dp = array_fill(0, $n, 1);\n        \n        for ($i = 1; $i < $n; $i++) {\n            for ($j = 0; $j < $i; $j++) {\n                if ($nums[$i] > $nums[$j]) {\n                    $dp[$i] = max($dp[$i], $dp[$j] + 1);\n                }\n            }\n        }\n        \n        return max($dp);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func lengthOfLIS(_ nums: [Int]) -> Int {\n        if nums.isEmpty {\n            return 0\n        }\n        \n        var dp = [Int](repeating: 1, count: nums.count)\n        var maxLength = 1\n        \n        for i in 0..<nums.count {\n            for j in 0..<i {\n                if nums[i] > nums[j] {\n                    dp[i] = max(dp[i], dp[j] + 1)\n                }\n            }\n            maxLength = max(maxLength, dp[i])\n        }\n        \n        return maxLength\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun lengthOfLIS(nums: IntArray): Int {\n        if (nums.isEmpty()) return 0\n        val dp = IntArray(nums.size) { 1 }\n        var maxLen = 1\n        for (i in 1 until nums.size) {\n            for (j in 0 until i) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = maxOf(dp[i], dp[j] + 1)\n                }\n            }\n            maxLen = maxOf(maxLen, dp[i])\n        }\n        return maxLen\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int lengthOfLIS(List<int> nums) {\n    if (nums.isEmpty) return 0;\n    \n    List<int> dp = List.filled(nums.length, 1);\n    int maxLength = 1;\n    \n    for (int i = 1; i < nums.length; i++) {\n      for (int j = 0; j < i; j++) {\n        if (nums[i] > nums[j]) {\n          dp[i] = dp[i].compareTo(dp[j] + 1) > 0 ? dp[i] : dp[j] + 1;\n        }\n      }\n      maxLength = maxLength.compareTo(dp[i]) > 0 ? maxLength : dp[i];\n    }\n    \n    return maxLength;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func lengthOfLIS(nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([]int, n)\n    for i := range dp {\n        dp[i] = 1\n    }\n\n    maxLength := 1\n    for i := 1; i < n; i++ {\n        for j := 0; j < i; j++ {\n            if nums[i] > nums[j] {\n                dp[i] = max(dp[i], dp[j]+1)\n            }\n        }\n        maxLength = max(maxLength, dp[i])\n    }\n\n    return maxLength\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef length_of_lis(nums)\n    return 0 if nums.empty?\n    \n    dp = Array.new(nums.length, 1)\n    \n    (1...nums.length).each do |i|\n        (0...i).each do |j|\n            if nums[i] > nums[j]\n                dp[i] = [dp[i], dp[j] + 1].max\n            end\n        end\n    end\n    \n    dp.max\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def lengthOfLIS(nums: Array[Int]): Int = {\n        val dp = new Array[Int](nums.length)\n        var len = 0\n        for (num <- nums) {\n            var left = 0\n            var right = len\n            while (left < right) {\n                val mid = left + (right - left) / 2\n                if (dp(mid) < num) {\n                    left = mid + 1\n                } else {\n                    right = mid\n                }\n            }\n            dp(left) = num\n            if (left == len) {\n                len += 1\n            }\n        }\n        len\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn length_of_lis(nums: Vec<i32>) -> i32 {\n        let mut dp = vec![1; nums.len()];\n        \n        for i in 0..nums.len() {\n            for j in 0..i {\n                if nums[i] > nums[j] {\n                    dp[i] = dp[i].max(dp[j] + 1);\n                }\n            }\n        }\n        \n        *dp.iter().max().unwrap_or(&0)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the length of the longest strictly increasing subsequence in a given integer array. We'll explain the approach and provide pseudocode for better understanding.\n\n## Explanation\n\n1. **Initialization**: \n   - If the array is empty, return 0.\n   - Initialize a `dp` array where `dp[i]` represents the length of the longest increasing subsequence ending with `nums[i]`. Initially, each element in `dp` is 1 because the smallest increasing subsequence ending at any element is the element itself.\n\n2. **Dynamic Programming Update**:\n   - Iterate over each element from the second to the last.\n   - For each element at `i`, check all previous elements (`j` from 0 to i-1). If `nums[i]` is greater than `nums[j]`, it means `nums[i]` can extend the increasing subsequence ending at `nums[j]`. Therefore, update `dp[i]` as the maximum of its current value or `dp[j] + 1`.\n\n3. **Result**:\n   - The length of the longest increasing subsequence will be the maximum value in the `dp` array.\n\nHere is the pseudocode representation of the above logic:\n\n## Pseudocode\n\n```\nFUNCTION lengthOfLIS(nums):\n    IF nums IS EMPTY:\n        RETURN 0\n\n    # Step 1: Initialize the dp array with 1\n    dp = ARRAY OF 1's of length nums.LENGTH\n\n    # Step 2: Fill the dp array using the dynamic programming approach\n    FOR i FROM 1 TO nums.LENGTH - 1:\n        FOR j FROM 0 TO i - 1:\n            IF nums[i] > nums[j]:\n                dp[i] = MAX(dp[i], dp[j] + 1)\n\n    # Step 3: The result is the maximum value in the dp array\n    RETURN MAX(dp)\n```\n\nThis solution runs in O(n^2) time complexity, which is sufficient for the constraint where the length of `nums` can be up to 2500. The follow-up asks for a more efficient solution with O(n log n) time complexity, but this pseudocode provides a clear and understandable approach to solving the problem using dynamic programming.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-increasing-subsequence"
    },
    {
        "name": "Range Sum Query Mutable",
        "site": "LeetCode",
        "href": "/solution/LeetCode-range-sum-query-mutable",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class NumArray {\npublic:\n    NumArray(vector<int>& nums) {\n        data = nums;\n        int size = nums.size();\n        bit.resize(size + 1);\n        for (int i = 0; i < size; i++) {\n            updateBIT(i, nums[i]);\n        }\n    }\n    \n    void update(int index, int val) {\n        int diff = val - data[index];\n        data[index] = val;\n        updateBIT(index, diff);\n    }\n\n    int sumRange(int left, int right) {\n        return getSum(right) - getSum(left - 1);\n    }\n\nprivate:\n    vector<int> data;\n    vector<int> bit;\n\n    void updateBIT(int index, int val) {\n        index = index + 1;\n        while (index < bit.size()) {\n            bit[index] += val;\n            index += index & -index;\n        }\n    }\n\n    int getSum(int index) {\n        int sum = 0;\n        index = index + 1;\n        while (index > 0) {\n            sum += bit[index];\n            index -= index & -index;\n        }\n        return sum;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class NumArray {\n    private int[] nums;\n    private int[] BIT;\n    private int n;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n        this.n = nums.length;\n        this.BIT = new int[n + 1];\n        \n        for (int i = 0; i < n; i++) {\n            init(i, nums[i]);\n        }\n    }\n    \n    private void init(int i, int val) {\n        i++;\n        while (i <= n) {\n            BIT[i] += val;\n            i += i & -i;\n        }\n    }\n\n    public void update(int index, int val) {\n        int diff = val - nums[index];\n        nums[index] = val;\n        init(index, diff);\n    }\n    \n    private int query(int i) {\n        i++;\n        int sum = 0;\n        while (i > 0) {\n            sum += BIT[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    \n    public int sumRange(int left, int right) {\n        return query(right) - query(left - 1);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class NumArray(object):\n    def __init__(self, nums):\n        self.nums = nums\n        self.prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        for i in range(index + 1, len(self.prefix_sum)):\n            self.prefix_sum[i] += diff\n\n    def sumRange(self, left, right):\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class NumArray {\n    private int[] tree;\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n        int n = nums.Length;\n        tree = new int[n * 2];\n        BuildTree(nums);\n    }\n\n    public void Update(int index, int val) {\n        int diff = val - nums[index];\n        nums[index] = val;\n        index += tree.Length / 2;\n        tree[index] += diff;\n        while (index > 0) {\n            int left = index;\n            int right = index;\n            if (index % 2 == 0) {\n                right = index + 1;\n            } else {\n                left = index - 1;\n            }\n            tree[index / 2] = tree[left] + tree[right];\n            index /= 2;\n        }\n    }\n\n    public int SumRange(int left, int right) {\n        left += tree.Length / 2;\n        right += tree.Length / 2;\n        int sum = 0;\n        while (left <= right) {\n            if (left % 2 == 1) {\n                sum += tree[left];\n                left++;\n            }\n            if (right % 2 == 0) {\n                sum += tree[right];\n                right--;\n            }\n            left /= 2;\n            right /= 2;\n        }\n        return sum;\n    }\n\n    private void BuildTree(int[] nums) {\n        for (int i = 0; i < nums.Length; i++) {\n            tree[nums.Length + i] = nums[i];\n        }\n        for (int i = nums.Length - 1; i > 0; i--) {\n            tree[i] = tree[i * 2] + tree[i * 2 + 1];\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a `NumArray` class that efficiently handles the `update` and `sumRange` operations on an integer array. The key here is to maintain a data structure that allows efficient updates and range sum calculations.\n\n# Explanation\n\n1. **Initialization**: \n   - We initialize the object with the given integer array `nums`.\n   - We also create a prefix sum array `prefix_sum` where `prefix_sum[i]` stores the sum of elements from the beginning of `nums` up to index `i-1`.\n\n2. **Update Operation**:\n   - When updating, we compute the difference between the new value and the current value at the given index.\n   - We then update the prefix sums from the next index to the end of the array to reflect this change.\n\n3. **Sum Range Operation**:\n   - We compute the sum of elements between indices `left` and `right` by using the prefix sum array.\n   - The sum is simply `prefix_sum[right + 1] - prefix_sum[left]`.\n\n# Pseudocode\n```pseudocode\nclass NumArray:\n    def __init__(self, nums):\n        # Initialize the array with nums and create a prefix_sum array\n        self.nums = nums\n        self.prefix_sum = [0] * (len(nums) + 1)\n        \n        # Compute the prefix sums\n        for i from 0 to length(nums) - 1:\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\n\n    def update(index, val):\n        # Calculate the difference between the new value and the current value\n        diff = val - self.nums[index]\n        \n        # Update the current value in nums\n        self.nums[index] = val\n        \n        # Update the prefix sums to reflect this change\n        for i from index + 1 to length(self.prefix_sum) - 1:\n            self.prefix_sum[i] += diff\n\n    def sumRange(left, right):\n        # Return the sum of the range [left, right]\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n```\n\nThis pseudocode outlines how the `NumArray` class handles the specified operations efficiently using a prefix sum approach. The `update` operation ensures that the prefix sums are consistent after any modification, and the `sumRange` operation retrieves the sum in constant time.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-range-sum-query-mutable"
    },
    {
        "name": "Remove Invalid Parentheses",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-invalid-parentheses",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        \n        vector<string> result;\n        unordered_set<string> visited;\n        queue<string> q;\n        q.push(s);\n        visited.insert(s);\n        bool found = false;\n        \n        while (!q.empty()) {\n            string current = q.front();\n            q.pop();\n            \n            if (isValid(current)) {\n                result.push_back(current);\n                found = true;\n            }\n            \n            if (found) continue;\n            \n            for (int i = 0; i < current.length(); i++) {\n                if (current[i] != '(' && current[i] != ')') continue;\n                \n                string next = current.substr(0, i) + current.substr(i + 1);\n                \n                if (visited.find(next) == visited.end()) {\n                    q.push(next);\n                    visited.insert(next);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    bool isValid(string s) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '(') count++;\n            else if (c == ')') {\n                if (count == 0) return false;\n                count--;\n            }\n        }\n        return count == 0;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        List<String> result = new ArrayList<>();\n        if (s == null) {\n            return result;\n        }\n        \n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        boolean found = false;\n        \n        queue.offer(s);\n        visited.add(s);\n        \n        while (!queue.isEmpty()) {\n            s = queue.poll();\n            \n            if (isValid(s)) {\n                result.add(s);\n                found = true;\n            }\n            \n            if (found) {\n                continue;\n            }\n            \n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) != '(' && s.charAt(i) != ')') {\n                    continue;\n                }\n                \n                String newStr = s.substring(0, i) + s.substring(i + 1);\n                \n                if (!visited.contains(newStr)) {\n                    queue.offer(newStr);\n                    visited.add(newStr);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private boolean isValid(String s) {\n        int count = 0;\n        \n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                count++;\n            } else if (c == ')') {\n                count--;\n                if (count < 0) {\n                    return false;\n                }\n            }\n        }\n        \n        return count == 0;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        def isValid(s):\n            cnt = 0\n            for char in s:\n                if char == '(':\n                    cnt += 1\n                elif char == ')':\n                    cnt -= 1\n                    if cnt < 0:\n                        return False\n            return cnt == 0\n        \n        def dfs(s, start, left, right):\n            if left == 0 and right == 0:\n                if isValid(s):\n                    res.append(s)\n                return\n            \n            for i in range(start, len(s)):\n                if i > start and s[i] == s[i-1]:\n                    continue\n                \n                if right > 0 and s[i] == ')':\n                    dfs(s[:i] + s[i+1:], i, left, right-1)\n                \n                elif left > 0 and s[i] == '(':\n                    dfs(s[:i] + s[i+1:], i, left-1, right)\n        \n        left = 0\n        right = 0\n        for char in s:\n            if char == '(':\n                left += 1\n            elif char == ')':\n                if left > 0:\n                    left -= 1\n                else:\n                    right += 1\n        \n        res = []\n        dfs(s, 0, left, right)\n        return res"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> RemoveInvalidParentheses(string s) {\n        List<string> result = new List<string>();\n        HashSet<string> visited = new HashSet<string>();\n        Queue<string> queue = new Queue<string>();\n        bool found = false;\n        \n        queue.Enqueue(s);\n        visited.Add(s);\n        \n        while(queue.Count > 0 && !found){\n            int size = queue.Count;\n            for(int i = 0; i < size; i++){\n                string current = queue.Dequeue();\n                \n                if(IsValid(current)){\n                    result.Add(current);\n                    found = true;\n                }\n                \n                if(!found){\n                    for(int j = 0; j < current.Length; j++){\n                        if(current[j] != '(' && current[j] != ')') continue;\n                        \n                        string next = current.Substring(0, j) + current.Substring(j + 1);\n                        \n                        if(!visited.Contains(next)){\n                            visited.Add(next);\n                            queue.Enqueue(next);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private bool IsValid(string s){\n        int count = 0;\n        \n        foreach(char c in s){\n            if(c == '('){\n                count++;\n            } else if(c == ')'){\n                count--;\n                if(count < 0) return false;\n            }\n        }\n        \n        return count == 0;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function removeInvalidParentheses(s: string): string[] {\n    const result: string[] = [];\n\n    const isValid = (str: string): boolean => {\n        let count = 0;\n        for (let char of str) {\n            if (char === '(') {\n                count++;\n            } else if (char === ')') {\n                count--;\n                if (count < 0) return false;\n            }\n        }\n        return count === 0;\n    }\n\n    const dfs = (str: string, start: number, open: string, close: string): void => {\n        let count = 0;\n        for (let i = start; i < str.length; i++) {\n            if (str[i] === open) count++;\n            if (str[i] === close) count--;\n            if (count < 0) {\n                for (let j = 0; j <= i; j++) {\n                    if (str[j] === close && (j === 0 || str[j - 1] !== close)) {\n                        dfs(str.substring(0, j) + str.substring(j + 1), i, open, close);\n                    }\n                }\n                return;\n            }\n        }\n\n        const reversed = str.split('').reverse().join('');\n        if (open === '(') {\n            dfs(reversed, 0, close, open);\n        } else {\n            if (isValid(reversed) && !result.includes(reversed)) {\n                result.push(reversed);\n            }\n        }\n    }\n\n    dfs(s, 0, '(', ')');\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return String[]\n     */\n    function removeInvalidParentheses($s) {\n        $result = [];\n        \n        $this->dfs($s, 0, 0, ['(', ')'], $result);\n        \n        return $result;\n    }\n    \n    function dfs($s, $start, $lastToRemove, $par, &$result) {\n        $count = 0;\n        for ($i = $start; $i < strlen($s); $i++) {\n            if ($s[$i] == $par[0]) {\n                $count++;\n            } elseif ($s[$i] == $par[1]) {\n                $count--;\n            }\n            \n            if ($count < 0) {\n                for ($j = $lastToRemove; $j <= $i; $j++) {\n                    if ($s[$j] == $par[1] && ($j == $lastToRemove || $s[$j] != $s[$j - 1])) {\n                        $newStr = substr($s, 0, $j) . substr($s, $j + 1);\n                        $this->dfs($newStr, $i, $j, $par, $result);\n                    }\n                }\n                \n                return;\n            }\n        }\n        \n        $reversed = strrev($s);\n        \n        if ($par[0] == '(') {\n            $this->dfs($reversed, 0, 0, [')', '('], $result);\n        } else {\n            $result[] = $reversed;\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> removeInvalidParentheses(String s) {\n    List<String> result = [];\n\n    void dfs(int index, int leftCount, int rightCount, int leftRemoval, int rightRemoval, String current) {\n      if (index == s.length) {\n        if (leftCount == rightCount) {\n          if (leftRemoval == 0 && rightRemoval == 0) {\n            result.add(current);\n          }\n        }\n        return;\n      }\n\n      if (s[index] == '(') {\n        if (leftRemoval > 0) {\n          dfs(index + 1, leftCount, rightCount, leftRemoval - 1, rightRemoval, current);\n        }\n        dfs(index + 1, leftCount + 1, rightCount, leftRemoval, rightRemoval, current + '(');\n      } else if (s[index] == ')') {\n        if (rightRemoval > 0) {\n          dfs(index + 1, leftCount, rightCount, leftRemoval, rightRemoval - 1, current);\n        }\n        if (leftCount > rightCount) {\n          dfs(index + 1, leftCount, rightCount + 1, leftRemoval, rightRemoval, current + ')');\n        }\n      } else {\n        dfs(index + 1, leftCount, rightCount, leftRemoval, rightRemoval, current + s[index]);\n      }\n    }\n\n    int extraLeft = 0;\n    int extraRight = 0;\n\n    for (int i = 0; i < s.length; i++) {\n      if (s[i] == '(') {\n        extraLeft++;\n      } else if (s[i] == ')') {\n        if (extraLeft > 0) {\n          extraLeft--;\n        } else {\n          extraRight++;\n        }\n      }\n    }\n\n    dfs(0, 0, 0, extraLeft, extraRight, '');\n\n    return result.toSet().toList();\n  }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will employ a depth-first search (DFS) method combined with a validation function to remove the minimum number of invalid parentheses from a string and return valid strings.\n\n## Explanation\n1. **Count Invalid Parentheses**: First, count the number of invalid left '(' and right ')' parentheses which are needed to be removed to make the expression valid.\n2. **DFS Search**: Use a depth-first search algorithm to explore all possible strings by removing the invalid parentheses one by one.\n3. **Validate Each String**: Use a helper function to verify if a string with removed parentheses is valid.\n4. **Add Unique Valid Strings**: Store unique valid strings in the result list.\n\n## Pseudocode\n```\nFunction removeInvalidParentheses(s: String) -> List of Strings:\n    Function isValid(s: String) -> Boolean:\n        Initialize cnt to 0\n        For each char in s:\n            If char is '(': \n                Increment cnt\n            Else if char is ')': \n                Decrement cnt\n                If cnt < 0: \n                    Return False\n        Return cnt equals 0\n\n    Function dfs(s: String, start: Integer, left: Integer, right: Integer):\n        If left == 0 and right == 0:\n            If isValid(s):\n                Add s to res\n            Return\n        \n        For i from start to length of s:\n            If i > start and s[i] == s[i-1]:\n                Continue\n            \n            If right > 0 and s[i] == ')':\n                Call dfs(s[:i] + s[i+1:], i, left, right-1)\n            \n            Else if left > 0 and s[i] == '(':\n                Call dfs(s[:i] + s[i+1:], i, left-1, right)\n    \n    Initialize left to 0 and right to 0\n    For each char in s:\n        If char is '(':\n            Increment left\n        Else if char is ')':\n            If left > 0:\n                Decrement left\n            Else:\n                Increment right\n    \n    Initialize res to an empty list\n    Call dfs(s, 0, left, right)\n    Return res\n```\n\nThis pseudocode ensures we explore all avenues to remove invalid parentheses in an orderly fashion, filtering out duplicates and invalid strings to provide the desired output.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-invalid-parentheses"
    },
    {
        "name": "Range Sum Query Immutable",
        "site": "LeetCode",
        "href": "/solution/LeetCode-range-sum-query-immutable",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class NumArray {\npublic:\n    NumArray(vector<int>& nums) {\n        prefixSum.resize(nums.size() + 1, 0);\n        for (int i = 0; i < nums.size(); i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n    \n    int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n\nprivate:\n    vector<int> prefixSum;\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(left,right);\n */"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class NumArray(object):\n    def __init__(self, nums):\n        \n        self.prefix_sum = [0]\n        for num in nums:\n            self.prefix_sum.append(self.prefix_sum[-1] + num)\n\n    def sumRange(self, left, right):\n       \n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        prefixSum = new int[nums.Length + 1];\n        for (int i = 0; i < nums.Length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    public int SumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.SumRange(left,right);\n*/"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n */\nvar NumArray = function(nums) {\n    this.prefixSum = [0];\n    for (let i = 0; i < nums.length; i++) {\n        this.prefixSum[i + 1] = this.prefixSum[i] + nums[i];\n    }\n};\n\n/** \n * @param {number} left \n * @param {number} right\n * @return {number}\n */\nNumArray.prototype.sumRange = function(left, right) {\n    return this.prefixSum[right + 1] - this.prefixSum[left];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class NumArray {\n    nums: number[];\n    constructor(nums: number[]) {\n        this.nums = nums;\n    }\n    \n    sumRange(left: number, right: number): number {\n        let sum = 0;\n        for (let i = left; i <= right; i++) {\n            sum += this.nums[i];\n        }\n        return sum;\n    }\n}\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = new NumArray(nums);\n * var param_1 = obj.sumRange(left, right);\n */\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class NumArray {\n    private $prefixSum;\n\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        $n = count($nums);\n        $this->prefixSum = array_fill(0, $n, 0);\n\n        $this->prefixSum[0] = $nums[0];\n        for ($i = 1; $i < $n; $i++) {\n            $this->prefixSum[$i] = $this->prefixSum[$i - 1] + $nums[$i];\n        }\n    }\n\n    /**\n     * @param Integer $left\n     * @param Integer $right\n     * @return Integer\n     */\n    function sumRange($left, $right) {\n        if ($left == 0) {\n            return $this->prefixSum[$right];\n        } else {\n            return $this->prefixSum[$right] - $this->prefixSum[$left - 1];\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class NumArray {\n    private var prefixSum: [Int]\n\n    init(_ nums: [Int]) {\n        prefixSum = [0]\n        for num in nums {\n            prefixSum.append(prefixSum.last! + num)\n        }\n    }\n\n    func sumRange(_ left: Int, _ right: Int) -> Int {\n        return prefixSum[right + 1] - prefixSum[left]\n    }\n}\n/**\n * Your NumArray object will be instantiated and called as such:\n * let obj = NumArray(nums)\n */"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class NumArray(nums: IntArray) {\n    private val prefixSum: IntArray = IntArray(nums.size + 1)\n\n    init {\n        for (i in nums.indices) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i]\n        }\n    }\n\n    fun sumRange(left: Int, right: Int): Int {\n        return prefixSum[right + 1] - prefixSum[left]\n    }\n}\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = NumArray(nums)\n * var param_1 = obj.sumRange(left,right)\n */\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class NumArray {\n  late List<int> prefixSum;\n\n  NumArray(List<int> nums) {\n    prefixSum = List<int>.filled(nums.length, 0);\n    prefixSum[0] = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n      prefixSum[i] = prefixSum[i - 1] + nums[i];\n    }\n  }\n\n  int sumRange(int left, int right) {\n    if (left == 0) {\n      return prefixSum[right];\n    } else {\n      return prefixSum[right] - prefixSum[left - 1];\n    }\n  }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = NumArray(nums);\n * int param1 = obj.sumRange(left,right);\n */"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "type NumArray struct {\n    prefixSum []int\n}\n\nfunc Constructor(nums []int) NumArray {\n    prefixSum := make([]int, len(nums))\n    prefixSum[0] = nums[0]\n    for i := 1; i < len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    return NumArray{prefixSum}\n}\n\nfunc (this *NumArray) SumRange(left int, right int) int {\n    if left == 0 {\n        return this.prefixSum[right]\n    }\n    return this.prefixSum[right] - this.prefixSum[left-1]\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "class NumArray(_nums: Array[Int]) {\n    private val sum: Array[Int] = Array.fill(_nums.length + 1)(0)\n    for (i <- _nums.indices) {\n        sum(i + 1) = sum(i) + _nums(i)\n    }\n\n    def sumRange(left: Int, right: Int): Int = {\n        sum(right + 1) - sum(left)\n    }\n}\n/**\n * Your NumArray object will be instantiated and called as such:\n * val obj = new NumArray(nums)\n * val param_1 = obj.sumRange(left,right)\n */\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "struct NumArray {\n    prefix_sum: Vec<i32>,\n}\n\nimpl NumArray {\n    fn new(nums: Vec<i32>) -> Self {\n        let mut prefix_sum = vec![0];\n        let mut sum = 0;\n        for num in nums {\n            sum += num;\n            prefix_sum.push(sum);\n        }\n        NumArray { prefix_sum }\n    }\n\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\n        self.prefix_sum[right as usize + 1] - self.prefix_sum[left as usize]\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define num-array%\n  (class object%\n    (super-new)\n    ; nums : (listof exact-integer?)\n    (init-field\n      nums)\n    ; sum-range : exact-integer? exact-integer? -> exact-integer?\n    (define/public (sum-range left right)\n      (for/sum ([i (in-range left (add1 right))])\n        (list-ref nums i)))))\n;; Your num-array% object will be instantiated and called as such:\n;; (define obj (new num-array% [nums nums]))\n;; (define param_1 (send obj sum-range left right))"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to efficiently handle multiple range sum queries on an array of integers. Given the constraints of up to 10^4 elements and up to 10^4 query calls, a naive solution that computes the sum directly for each query would be too slow. Instead, we can use a prefix sum array to precompute partial sums, providing quick sum calculations for any given range.\n\nHere\u2019s the step-by-step approach to solving this problem:\n\n# Explanation\n\n1. **Initialization**: We initialize the `NumArray` class with an integer array `nums`.\n2. **Prefix Sum Array**: To allow efficient range sum queries, we construct a prefix sum array. The prefix sum array at index `i` contains the sum of elements from the start of the array to index `i-1`.\n3. **Prefix Sum Construction**: During initialization, we iterate through the `nums` array and construct the prefix sum array. This allows us to compute the sum of any subarray in constant time.\n4. **Sum Calculation**: For the `sumRange` method, to get the sum of elements from index `left` to `right`, we use the precomputed prefix sums. Specifically, the sum of elements from `left` to `right` is given by the difference between the prefix sums at `right + 1` and `left`.\n\n# Pseudocode\n\nHere is the pseudocode for the `NumArray` class:\n\n```plaintext\nClass NumArray:\n    # Constructor to initialize the object with the integer array nums\n    Function __init__(nums):\n        # Initialize prefix sum array with a 0 at the beginning\n        prefix_sum = [0]\n        \n        # Construct the prefix sum array\n        For each num in nums:\n            Append to prefix_sum (last element in prefix_sum + num)\n    \n    # Method to return the sum of elements between indices left and right\n    Function sumRange(left, right):\n        # Calculate and return the range sum using prefix sums\n        Return prefix_sum[right + 1] - prefix_sum[left]\n```\n\nUsing this methodology ensures that each sum range query is processed in constant time \\(O(1)\\) after an initial \\(O(n)\\) preprocessing step to construct the prefix sum array.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-range-sum-query-immutable"
    },
    {
        "name": "Range Sum Query 2D Immutable",
        "site": "LeetCode",
        "href": "/solution/LeetCode-range-sum-query-2d-immutable",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class NumMatrix {\npublic:\n    NumMatrix(vector<vector<int>>& matrix) {\n        if (matrix.empty() || matrix[0].empty()) return;\n        dp = vector<vector<int>>(matrix.size() + 1, vector<int>(matrix[0].size() + 1, 0));\n        for (int i = 1; i <= matrix.size(); i++) {\n            for (int j = 1; j <= matrix[0].size(); j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n    }\n\nprivate:\n    vector<vector<int>> dp;\n};\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class NumMatrix {\n    int[][] dp;\n\n    public NumMatrix(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\n    }\n}\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\n */\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class NumMatrix(object):\n    def __init__(self, matrix):\n        if not matrix:\n            return\n        m, n = len(matrix), len(matrix[0])\n        self.dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.dp[i][j] = matrix[i - 1][j - 1] + self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1]\n\n    def sumRegion(self, row1, col1, row2, col2):\n        return self.dp[row2 + 1][col2 + 1] - self.dp[row2 + 1][col1] - self.dp[row1][col2 + 1] + self.dp[row1][col1]\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n */\nvar NumMatrix = function(matrix) {\n    this.dp = [];\n    for (let i = 0; i < matrix.length; i++) {\n        this.dp[i] = [];\n        for (let j = 0; j < matrix[0].length; j++) {\n            if (i === 0 && j === 0) {\n                this.dp[i][j] = matrix[i][j];\n            } else if (i === 0) {\n                this.dp[i][j] = this.dp[i][j - 1] + matrix[i][j];\n            } else if (j === 0) {\n                this.dp[i][j] = this.dp[i - 1][j] + matrix[i][j];\n            } else {\n                this.dp[i][j] = this.dp[i - 1][j] + this.dp[i][j - 1] - this.dp[i - 1][j - 1] + matrix[i][j];\n            }\n        }\n    }\n};\n\n/** \n * @param {number} row1 \n * @param {number} col1 \n * @param {number} row2 \n * @param {number} col2\n * @return {number}\n */\nNumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {\n    if (row1 === 0 && col1 === 0) {\n        return this.dp[row2][col2];\n    } else if (row1 === 0) {\n        return this.dp[row2][col2] - this.dp[row2][col1 - 1];\n    } else if (col1 === 0) {\n        return this.dp[row2][col2] - this.dp[row1 - 1][col2];\n    } else {\n        return this.dp[row2][col2] - this.dp[row1 - 1][col2] - this.dp[row2][col1 - 1] + this.dp[row1 - 1][col1 - 1];\n    }\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class NumMatrix {\n    private $dp = [];\n\n    /**\n     * @param Integer[][] $matrix\n     */\n    function __construct($matrix) {\n        $m = count($matrix);\n        $n = count($matrix[0]);\n\n        $this->dp = array_fill(0, $m + 1, array_fill(0, $n + 1, 0));\n\n        for ($i = 1; $i <= $m; $i++) {\n            for ($j = 1; $j <= $n; $j++) {\n                $this->dp[$i][$j] = $this->dp[$i - 1][$j] + $this->dp[$i][$j - 1] - $this->dp[$i - 1][$j - 1] + $matrix[$i - 1][$j - 1];\n            }\n        }\n    }\n\n    /**\n     * @param Integer $row1\n     * @param Integer $col1\n     * @param Integer $row2\n     * @param Integer $col2\n     * @return Integer\n     */\n    function sumRegion($row1, $col1, $row2, $col2) {\n        return $this->dp[$row2 + 1][$col2 + 1] - $this->dp[$row1][$col2 + 1] - $this->dp[$row2 + 1][$col1] + $this->dp[$row1][$col1];\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class NumMatrix(matrix: Array<IntArray>) {\n    private val dp = Array(matrix.size + 1) { IntArray(matrix[0].size + 1) }\n\n    init {\n        for (i in matrix.indices) {\n            for (j in matrix[0].indices) {\n                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] - dp[i][j] + matrix[i][j]\n            }\n        }\n    }\n\n    fun sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int {\n        return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\n    }\n}\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class NumMatrix {\n  late List<List<int>> _matrix;\n  \n  NumMatrix(List<List<int>> matrix) {\n    _matrix = List<List<int>>.from(matrix);\n    for (int i = 0; i < _matrix.length; i++) {\n      for (int j = 1; j < _matrix[i].length; j++) {\n        _matrix[i][j] += _matrix[i][j - 1];\n      }\n    }\n  }\n  \n  int sumRegion(int row1, int col1, int row2, int col2) {\n    int sum = 0;\n    for (int i = row1; i <= row2; i++) {\n      sum += _matrix[i][col2] - (col1 > 0 ? _matrix[i][col1 - 1] : 0);\n    }\n    return sum;\n  }\n}\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = NumMatrix(matrix);\n * int param1 = obj.sumRegion(row1,col1,row2,col2);\n*/\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "type NumMatrix struct {\n    prefixSum [][]int\n}\n\nfunc Constructor(matrix [][]int) NumMatrix {\n    m, n := len(matrix), len(matrix[0])\n    prefixSum := make([][]int, m+1)\n    for i := 0; i <= m; i++ {\n        prefixSum[i] = make([]int, n+1)\n    }\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            prefixSum[i][j] = matrix[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1]\n        }\n    }\n    return NumMatrix{prefixSum: prefixSum}\n}\n\nfunc (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {\n    return this.prefixSum[row2+1][col2+1] - this.prefixSum[row1][col2+1] - this.prefixSum[row2+1][col1] + this.prefixSum[row1][col1]\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "class NumMatrix(_matrix: Array[Array[Int]]) {\n    private val dp: Array[Array[Int]] = {\n        if (_matrix.isEmpty || _matrix(0).isEmpty) Array.ofDim[Int](0, 0)\n        else {\n            val m = _matrix.length\n            val n = _matrix(0).length\n            val dp = Array.ofDim[Int](m + 1, n + 1)\n            for {\n                i <- 1 to m\n                j <- 1 to n\n            } dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1) - dp(i - 1)(j - 1) + _matrix(i - 1)(j - 1)\n            dp\n        }\n    }\n\n    def sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int = {\n        dp(row2 + 1)(col2 + 1) - dp(row1)(col2 + 1) - dp(row2 + 1)(col1) + dp(row1)(col1)\n    }\n}\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * val obj = new NumMatrix(matrix)\n * val param_1 = obj.sumRegion(row1,col1,row2,col2)\n */\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "struct NumMatrix {\n    prefix_sum: Vec<Vec<i32>>,\n}\n\nimpl NumMatrix {\n    fn new(matrix: Vec<Vec<i32>>) -> Self {\n        let mut prefix_sum = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\n        \n        for i in 1..=matrix.len() {\n            for j in 1..=matrix[0].len() {\n                prefix_sum[i][j] = matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1];\n            }\n        }\n        \n        NumMatrix { prefix_sum }\n    }\n    \n    fn sum_region(&self, row1: i32, col1: i32, row2: i32, col2: i32) -> i32 {\n        let row1 = row1 as usize;\n        let col1 = col1 as usize;\n        let row2 = row2 as usize + 1;\n        let col2 = col2 as usize + 1;\n        \n        self.prefix_sum[row2][col2] - self.prefix_sum[row2][col1] - self.prefix_sum[row1][col2] + self.prefix_sum[row1][col1]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a dynamic programming approach to precompute a sum matrix that allows us to efficiently calculate the sum of elements in any submatrix of the given matrix. This precomputation enables the `sumRegion` method to work in O(1) time complexity.\n\n# Explanation\n1. **Initialization**: When an object of NumMatrix is created, we initialize a 2D list `dp` with dimensions `(m+1) x (n+1)` where `m` and `n` are the dimensions of the input matrix. This `dp` list will be filled such that `dp[i][j]` represents the sum of the elements of the matrix from the top-left corner `(0,0)` to position `(i-1,j-1)`.\n2. **Filling dp matrix**: We fill the `dp` matrix using the formula:\n   ```\n   dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n   ```\n   This formula ensures that each cell in `dp` contains the cumulative sum from the top-left corner to that cell, minus the extra part that gets added twice.\n3. **Sum of submatrix**: To find the sum of elements inside any given submatrix from `(row1, col1)` to `(row2, col2)`, we can use the precomputed `dp` matrix:\n   ```\n   sumRegion(row1, col1, row2, col2) = dp[row2+1][col2+1] - dp[row1][col2+1] - dp[row2+1][col1] + dp[row1][col1]\n   ```\n   This subtraction and addition remove the overlapping areas added multiple times.\n\n# Pseudocode\n```plaintext\n# Pseudocode for the NumMatrix class and its methods.\n\nclass NumMatrix:\n    # Initialize with 2D matrix\n    method __init__(matrix):\n        if matrix is empty:\n            return\n        m, n = dimensions of matrix\n        initialize dp as a (m+1) x (n+1) matrix filled with 0\n        \n        for i from 1 to m:\n            for j from 1 to n:\n                dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n    \n    # Sum of region defined by (row1, col1) to (row2, col2)\n    method sumRegion(row1, col1, row2, col2):\n        return dp[row2+1][col2+1] - dp[row2+1][col1] - dp[row1][col2+1] + dp[row1][col1]\n```\n\nThis pseudocode follows the outlined methodology, ensuring efficient precomputation and O(1) time complexity for summing queried submatrix regions.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-range-sum-query-2d-immutable"
    },
    {
        "name": "Additive Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-additive-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isAdditiveNumber(string num) {\n        for(int i=1; i<=num.size()/2; i++){\n            for(int j=1; j<=(num.size()-i)/2; j++){\n                if(helper(num.substr(0, i), num.substr(i, j), num.substr(i+j))) return true;\n            }\n        }\n        return false;\n    }\n    \n    bool helper(string num1, string num2, string num){\n        if((num1.size() > 1 && num1[0] == '0') || (num2.size() > 1 && num2[0] == '0')) return false;\n        string sum = addStrings(num1, num2);\n        if(sum == num) return true;\n        if(num.size() <= sum.size() || sum.compare(num.substr(0, sum.size())) != 0) return false;\n        else return helper(num2, sum, num.substr(sum.size()));\n    }\n    \n    string addStrings(string num1, string num2){\n        string res = \"\";\n        int carry = 0;\n        int i = num1.size()-1;\n        int j = num2.size()-1;\n        while(i >= 0 || j >= 0 || carry > 0){\n            int x = (i >= 0) ? num1[i--]-'0' : 0;\n            int y = (j >= 0) ? num2[j--]-'0' : 0;\n            int sum = x + y + carry;\n            res = to_string(sum%10) + res;\n            carry = sum/10;\n        }\n        return res;\n    }\n};\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsAdditiveNumber(string num) {\n        for (int i = 1; i < num.Length; i++) {\n            for (int j = i + 1; j < num.Length; j++) {\n                string num1 = num.Substring(0, i);\n                string num2 = num.Substring(i, j - i);\n                if ((num1.Length > 1 && num1[0] == '0') || (num2.Length > 1 && num2[0] == '0')) continue;\n                \n                long n1 = long.Parse(num1);\n                long n2 = long.Parse(num2);\n                \n                if (IsAdditive(num, j, n1, n2)) return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private bool IsAdditive(string num, int index, long num1, long num2) {\n        if (index == num.Length) return true;\n        \n        long sum = num1 + num2;\n        string sumStr = sum.ToString();\n        if (index + sumStr.Length > num.Length || !num.Substring(index, sumStr.Length).Equals(sumStr)) return false;\n        \n        return IsAdditive(num, index + sumStr.Length, num2, sum);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} num\n * @return {boolean}\n */\nvar isAdditiveNumber = function(num) {\n    const isAdditive = (num, num1, num2) => {\n        if (num === '') return true;\n        if ((num1.length > 1 && num1[0] === '0') || (num2.length > 1 && num2[0] === '0')) return false;\n        const sum = (BigInt(num1) + BigInt(num2)).toString();\n        if (num.startsWith(sum)) {\n            return isAdditive(num.substring(sum.length), num2, sum);\n        }\n        return false;\n    };\n\n    for (let i = 1; i <= num.length / 2; i++) {\n        for (let j = 1; j <= (num.length - i) / 2; j++) {\n            const num1 = num.substring(0, i);\n            const num2 = num.substring(i, i + j);\n            if (isAdditive(num.substring(i + j), num1, num2)) return true;\n        }\n    }\n\n    return false;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isAdditiveNumber(num: string): boolean {\n    function isAdditive(index: number, num1: string, num2: string, remaining: string): boolean {\n        if (index === num.length) {\n            return remaining.length === 0;\n        }\n\n        if ((num1.length > 1 && num1[0] === '0') || (num2.length > 1 && num2[0] === '0')) {\n            return false;\n        }\n\n        const sum = (+num1) + (+num2);\n        const sumStr = sum.toString();\n\n        if (remaining.indexOf(sumStr) !== 0) {\n            return false;\n        }\n\n        return isAdditive(index + sumStr.length, num2, sumStr, remaining.substring(sumStr.length));\n    }\n\n    for (let i = 1; i <= num.length / 2; i++) {\n        for (let j = 1; j <= (num.length - i) / 2; j++) {\n            if (isAdditive(i + j, num.substring(0, i), num.substring(i, i + j), num.substring(i + j))) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isAdditiveNumber(num string) bool {\n    n := len(num)\n    for i := 1; i <= n/2; i++ {\n        for j := i + 1; j < n; j++ {\n            if num[0] == '0' && i > 1 {\n                break\n            }\n            if num[i] == '0' && j > i+1 {\n                break\n            }\n            if isValid(num[:i], num[i:j], num[j:]) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc isValid(num1, num2, num string) bool {\n    sum := addStrings(num1, num2)\n    if sum == num {\n        return true\n    }\n    if len(sum) >= len(num) || sum != num[:len(sum)] {\n        return false\n    }\n    return isValid(num2, sum, num[len(sum):])\n}\n\nfunc addStrings(num1, num2 string) string {\n    res := make([]byte, max(len(num1), len(num2))+1)\n    carry, idx := 0, len(res)-1\n    for i, j := len(num1)-1, len(num2)-1; i >= 0 || j >= 0 || carry > 0; i, j = i-1, j-1 {\n        if i >= 0 {\n            carry += int(num1[i] - '0')\n        }\n        if j >= 0 {\n            carry += int(num2[j] - '0')\n        }\n        res[idx] = byte(carry%10) + '0'\n        carry /= 10\n        idx--\n    }\n    return string(res[idx+1:])\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_additive_number(num: String) -> bool {\n        fn backtrack(num: &str, start: usize, first: i64, second: i64) -> bool {\n            if start == num.len() {\n                return true;\n            }\n            for i in start..num.len() {\n                if i > start && num.chars().nth(start) == Some('0') {\n                    break;\n                }\n                let cur_str = &num[start..=i];\n                let cur_num: i64 = match cur_str.parse() {\n                    Ok(num) => num,\n                    Err(_) => return false,\n                };\n                if (first == -1 || second == -1 || first + second == cur_num) && backtrack(num, i + 1, second, cur_num) {\n                    return true;\n                }\n            }\n            false\n        }\n\n        for i in 1..num.len() {\n            if i > 1 && num.chars().nth(0) == Some('0') {\n                break;\n            }\n            let first_str = &num[0..i];\n            let first: i64 = match first_str.parse() {\n                Ok(num) => num,\n                Err(_) => return false,\n            };\n\n            for j in i + 1..num.len() {\n                if j > i + 1 && num.chars().nth(i) == Some('0') {\n                    break;\n                }\n                let second_str = &num[i..j];\n                let second: i64 = match second_str.parse() {\n                    Ok(num) => num,\n                    Err(_) => return false,\n                };\n                if backtrack(&num, j, first, second) {\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine whether a given string of digits can form an additive sequence. Here is the methodology for resolving this challenge with an explanation and pseudocode.\n\n# Explanation\n\n1. **Initial Concept**: An additive sequence requires at least three numbers, and each subsequent number must be the sum of the preceding two numbers.\n2. **Substrings and Combinations**: We'll generate combinations of starting numbers from the string.\n3. **Recursive Check**: Check the remaining part of the string recursively to verify if the sequence can continue.\n4. **Leading Zeros**: Ensure that numbers do not have leading zeros.\n5. **Edge Case**: Handle very large numbers which can be managed via BigInt in some programming languages, ensuring that the addition operation handles overflow.\n\n# Pseudocode\n\n```\nFUNCTION isAdditiveNumber(num: STRING) -> BOOLEAN\n    FUNCTION isAdditive(num: STRING, num1: STRING, num2: STRING) -> BOOLEAN\n        IF num IS EMPTY\n            RETURN TRUE\n\n        IF num1 STARTS WITH '0' AND LENGTH OF num1 > 1 OR num2 STARTS WITH '0' AND LENGTH OF num2 > 1\n            RETURN FALSE\n\n        sum = STRING(BigInt(num1) + BigInt(num2))\n\n        IF num STARTS WITH sum\n            RETURN isAdditive(num[SLICED FROM LENGTH OF sum TO END], num2, sum)\n\n        RETURN FALSE\n\n    FOR i FROM 1 TO LENGTH OF num / 2\n        FOR j FROM 1 TO (LENGTH OF num - i) / 2\n            num1 = num[SLICED FROM 0 TO i]\n            num2 = num[SLICED FROM i TO i + j]\n            \n            IF isAdditive(num[SLICED FROM i + j TO END], num1, num2)\n                RETURN TRUE\n\n    RETURN FALSE\n```\n\n- The `isAdditiveNumber` function initiates by trying different combinations of the first two numbers in the sequence.\n- The nested function `isAdditive` checks if the rest of the string can form a valid additive sequence based on the provided starting numbers `num1` and `num2`.\n\nThis approach ensures we comprehensively check all possible partitions of the input string and verify if they form a valid additive sequence.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-additive-number"
    },
    {
        "name": "Super Ugly Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-super-ugly-number",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "import heapq\n\nclass Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        ugly = [1]\n        heap = [(p, 0, p) for p in primes]\n        heapq.heapify(heap)\n        \n        while len(ugly) < n:\n            val, idx, prime = heapq.heappop(heap)\n            if val > ugly[-1]:\n                ugly.append(val)\n            heapq.heappush(heap, (prime * ugly[idx], idx + 1, prime))\n        \n        return ugly[-1]\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int nthSuperUglyNumber(int n, int* primes, int primesSize) {\n    int ugly[n];\n    int index[primesSize];\n    int factors[primesSize];\n    \n    ugly[0] = 1;\n    \n    for (int i = 0; i < primesSize; i++) {\n        index[i] = 0;\n        factors[i] = primes[i];\n    }\n    \n    for (int i = 1; i < n; i++) {\n        int min_val = __INT_MAX__;\n        \n        for (int j = 0; j < primesSize; j++) {\n            min_val = factors[j] < min_val ? factors[j] : min_val;\n        }\n        \n        ugly[i] = min_val;\n        \n        for (int j = 0; j < primesSize; j++) {\n            if (min_val == factors[j]) {\n                index[j]++;\n                if (ugly[index[j]] <= INT_MAX / primes[j]) {\n                    factors[j] = ugly[index[j]] * primes[j];\n                } else {\n                    factors[j] = INT_MAX;\n                }\n            }\n        }\n    }\n    \n    return ugly[n - 1];\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var nthSuperUglyNumber = function(n, primes) {\n    let ugly = new Array(n).fill(0);\n    ugly[0] = 1;\n    \n    let pointer = new Array(primes.length).fill(0);\n    \n    for (let i = 1; i < n; i++) {\n        ugly[i] = Number.MAX_VALUE;\n        for (let j = 0; j < primes.length; j++) {\n            ugly[i] = Math.min(ugly[i], primes[j] * ugly[pointer[j]]);\n        }\n        \n        for (let j = 0; j < primes.length; j++) {\n            if (ugly[i] === primes[j] * ugly[pointer[j]]) {\n                pointer[j]++;\n            }\n        }\n    }\n    \n    return ugly[n - 1];\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function nthSuperUglyNumber(n: number, primes: number[]): number {\n    const dp = new Array(n).fill(0);\n    dp[0] = 1;\n    \n    const indices = new Array(primes.length).fill(0);\n    \n    for (let i = 1; i < n; i++) {\n        let min = Number.MAX_VALUE;\n        \n        for (let j = 0; j < primes.length; j++) {\n            min = Math.min(min, dp[indices[j]] * primes[j]);\n        }\n        \n        dp[i] = min;\n        \n        for (let j = 0; j < primes.length; j++) {\n            if (min === dp[indices[j]] * primes[j]) {\n                indices[j]++;\n            }\n        }\n    }\n    \n    return dp[n - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @param Integer[] $primes\n     * @return Integer\n     */\n    function nthSuperUglyNumber($n, $primes) {\n        $ugly = [1];\n        $idx = array_fill(0, count($primes), 0);\n        \n        while (count($ugly) < $n) {\n            $next = PHP_INT_MAX;\n            for ($i = 0; $i < count($primes); $i++) {\n                $next = min($next, $ugly[$idx[$i]] * $primes[$i]);\n            }\n            $ugly[] = $next;\n            \n            for ($i = 0; $i < count($primes); $i++) {\n                if ($ugly[$idx[$i]] * $primes[$i] == $next) {\n                    $idx[$i]++;\n                }\n            }\n        }\n        \n        return $ugly[$n - 1];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func nthSuperUglyNumber(_ n: Int, _ primes: [Int]) -> Int {\n        var ugly = [1]\n        var index = Array(repeating: 0, count: primes.count)\n\n        while ugly.count < n {\n            var next = Int.max\n            for i in 0..<primes.count {\n                next = min(next, primes[i] * ugly[index[i]])\n            }\n\n            for i in 0..<primes.count {\n                if next == primes[i] * ugly[index[i]] {\n                    index[i] += 1\n                }\n            }\n\n            ugly.append(next)\n        }\n\n        return ugly.last ?? 1\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int nthSuperUglyNumber(int n, List<int> primes) {\n    List<int> ugly = List.filled(n, 0);\n    ugly[0] = 1;\n    \n    List<int> indexes = List.filled(primes.length, 0);\n    \n    for (int i = 1; i < n; i++) {\n      int min = primes[0] * ugly[indexes[0]];\n      for (int j = 1; j < primes.length; j++) {\n        min = min < primes[j] * ugly[indexes[j]] ? min : primes[j] * ugly[indexes[j]];\n      }\n      \n      ugly[i] = min;\n      \n      for (int j = 0; j < primes.length; j++) {\n        if (min == primes[j] * ugly[indexes[j]]) {\n          indexes[j]++;\n        }\n      }\n    }\n    \n    return ugly[n - 1];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func nthSuperUglyNumber(n int, primes []int) int {\n    if n == 1 {\n        return 1\n    }\n\n    ugly := make([]int, n)\n    ugly[0] = 1\n\n    ptrs := make([]int, len(primes))\n\n    for i := 1; i < n; i++ {\n        ugly[i] = primes[0] * ugly[ptrs[0]]\n        for j := 1; j < len(primes); j++ {\n            ugly[i] = min(ugly[i], primes[j]*ugly[ptrs[j]])\n        }\n        for j := 0; j < len(primes); j++ {\n            if ugly[i] == primes[j]*ugly[ptrs[j]] {\n                ptrs[j]++\n            }\n        }\n    }\n\n    return ugly[n-1]\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer[]} primes\n# @return {Integer}\ndef nth_super_ugly_number(n, primes)\n    ugly = [1]\n    pointer = Array.new(primes.length, 0)\n    \n    while ugly.length < n\n        candidates = primes.map.with_index { |prime, i| ugly[pointer[i]] * prime }\n        min_val = candidates.min\n        \n        candidates.each_with_index do |candidate, i|\n            pointer[i] += 1 if candidate == min_val\n        end\n        \n        ugly << min_val\n    end\n    \n    return ugly.last\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate the nth super ugly number based on provided prime factors. This involves utilizing a min-heap to efficiently derive the next super ugly number.\n\n### # Explanation\n1. **Initialization**:\n    - Start with the first super ugly number, which is always 1.\n    - Initialize a min-heap with tuples: each prime from the list paired with index 0 and the prime itself. (These tuples will help track and generate new candidates for the next super ugly number).\n2. **Heap Operations**:\n    - Extract the smallest element from the heap.\n    - If this element is new (not the same as the last element in the ugly list), add it to the list of ugly numbers.\n    - Push a new candidate into the heap. This candidate is derived by multiplying the prime factor with the next ugly number in line.\n3. **Termination**:\n    - Continue the process until the nth super ugly number is determined.\n\n### # Pseudocode\n```\nfunction nthSuperUglyNumber(n, primes):\n    create an array 'ugly' initialized with [1]\n    create a min-heap 'heap' with elements (prime, 0, prime) for each prime in 'primes'\n    convert 'heap' into a heap structure\n    \n    while length of 'ugly' is less than n:\n        extract the smallest element (val, idx, prime) from 'heap'\n        if val is greater than the last element in 'ugly':\n            append val to 'ugly'\n        push (prime * ugly[idx+1], idx + 1, prime) back into the 'heap'\n    \n    return last element in 'ugly'\n```\nThis pseudocode follows the logic of maintaining a min-heap to dynamically generate the next super ugly number by leveraging given prime factors and previously generated super ugly numbers.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-super-ugly-number"
    },
    {
        "name": "Best Time To Buy And Sell Stock With Cooldown",
        "site": "LeetCode",
        "href": "/solution/LeetCode-best-time-to-buy-and-sell-stock-with-cooldown",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        if (n <= 1) {\n            return 0;\n        }\n        \n        int buy = -prices[0];\n        int sell = 0;\n        int cooldown = 0;\n        \n        for (int i = 1; i < n; i++) {\n            int prevBuy = buy;\n            buy = max(buy, cooldown - prices[i]);\n            cooldown = sell;\n            sell = max(sell, prevBuy + prices[i]);\n        }\n        \n        return sell;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if (n <= 1) {\n            return 0;\n        }\n        \n        int[] buy = new int[n];\n        int[] sell = new int[n];\n        \n        buy[0] = -prices[0];\n        buy[1] = Math.max(buy[0], -prices[1]);\n        sell[0] = 0;\n        sell[1] = Math.max(sell[0], buy[0] + prices[1]);\n        \n        for (int i = 2; i < n; i++) {\n            buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);\n            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\n        }\n        \n        return sell[n - 1];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        dp = [[0] * 2 for _ in range(n)]\n        \n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        \n        for i in range(1, n):\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n            dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\n        \n        return dp[n-1][0]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxProfit(int* prices, int pricesSize) {\n    if (pricesSize <= 1) {\n        return 0;\n    }\n    \n    int sold = 0, hold = -prices[0], rest = 0;\n    \n    for (int i = 1; i < pricesSize; i++) {\n        int prev_sold = sold;\n        sold = hold + prices[i];\n        hold = fmax(hold, rest - prices[i]);\n        rest = fmax(rest, prev_sold);\n    }\n    \n    return fmax(sold, rest);\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        if (prices == null || prices.Length == 0) {\n            return 0;\n        }\n        \n        int n = prices.Length;\n        int[] dp = new int[n];\n        \n        int buy = -prices[0];\n        int sell = 0;\n        int cooldown = 0;\n        \n        for (int i = 1; i < n; i++) {            \n            int prev_buy = buy;\n            buy = Math.Max(buy, cooldown - prices[i]);\n            cooldown = Math.Max(cooldown, sell);\n            sell = prev_buy + prices[i];\n            \n            dp[i] = Math.Max(dp[i - 1], sell);\n        }\n        \n        return dp[n - 1];\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let buy = -prices[0];\n    let sell = 0;\n    let cooldown = 0;\n    \n    for (let i = 1; i < prices.length; i++) {\n        let prevBuy = buy;\n        buy = Math.max(buy, cooldown - prices[i]);\n        cooldown = sell;\n        sell = Math.max(sell, prevBuy + prices[i]);\n    }\n    \n    return sell;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxProfit(prices: number[]): number {\n    const n = prices.length;\n    const dp: number[][] = new Array(n).fill(0).map(() => new Array(2).fill(0));\n\n    dp[0][0] = 0;\n    dp[0][1] = -prices[0];\n\n    for (let i = 1; i < n; i++) {\n        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n        dp[i][1] = Math.max(dp[i - 1][1], (i > 1 ? dp[i - 2][0] : 0) - prices[i]);\n    }\n\n    return dp[n - 1][0];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $prices\n     * @return Integer\n     */\n    function maxProfit($prices) {\n        $n = count($prices);\n        $dp = array_fill(0, $n, array_fill(0, 2, 0));\n        $dp[0][0] = 0;\n        $dp[0][1] = -$prices[0];\n\n        for ($i = 1; $i < $n; $i++) {\n            $dp[$i][0] = max($dp[$i - 1][0], $dp[$i - 1][1] + $prices[$i]);\n            $dp[$i][1] = max($dp[$i - 1][1], ($i > 1 ? $dp[$i - 2][0] : 0) - $prices[$i]);\n        }\n\n        return $dp[$n - 1][0];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxProfit(_ prices: [Int]) -> Int {\n        if prices.count < 2 {\n            return 0\n        }\n        \n        var buy = Array(repeating: 0, count: prices.count)\n        var sell = Array(repeating: 0, count: prices.count)\n        var cooldown = Array(repeating: 0, count: prices.count)\n        \n        buy[0] = -prices[0]\n        \n        for i in 1..<prices.count {\n            buy[i] = max(cooldown[i-1] - prices[i], buy[i-1])\n            sell[i] = buy[i-1] + prices[i]\n            cooldown[i] = max(cooldown[i-1], sell[i-1])\n        }\n        \n        return max(sell.last!, cooldown.last!)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxProfit(prices: IntArray): Int {\n        if (prices.isEmpty()) {\n            return 0\n        }\n        \n        var buy = -prices[0]\n        var sell = 0\n        var cooldown = 0\n        \n        for (i in 1 until prices.size) {\n            val newBuy = maxOf(buy, cooldown - prices[i])\n            val newSell = maxOf(sell, buy + prices[i])\n            val newCooldown = maxOf(cooldown, sell)\n            \n            buy = newBuy\n            sell = newSell\n            cooldown = newCooldown\n        }\n        \n        return sell\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxProfit(prices []int) int {\n    if len(prices) <= 1 {\n        return 0\n    }\n    \n    dp := make([][2]int, len(prices))\n    dp[0][0] = 0\n    dp[0][1] = -prices[0]\n    dp[1][0] = max(dp[0][0], dp[0][1]+prices[1])\n    dp[1][1] = max(dp[0][1], dp[0][0]-prices[1])\n\n    for i := 2; i < len(prices); i++ {\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])\n        dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])\n    }\n    \n    return dp[len(prices)-1][0]\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} prices\n# @return {Integer}\ndef max_profit(prices)\n    n = prices.length\n    return 0 if n <= 1\n    \n    buy = Array.new(n, 0)\n    sell = Array.new(n, 0)\n    cooldown = Array.new(n, 0)\n    \n    buy[0] = -prices[0]\n    \n    (1...n).each do |i|\n        if i == 1\n            buy[i] = [buy[i - 1], -prices[i]].max\n        else\n            buy[i] = [buy[i - 1], cooldown[i - 1] - prices[i]].max\n        end\n        sell[i] = [sell[i - 1], buy[i - 1] + prices[i]].max\n        cooldown[i] = [cooldown[i - 1], sell[i - 1]].max\n    end\n    \n    [sell[n - 1], cooldown[n - 1]].max\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxProfit(prices: Array[Int]): Int = {\n        if (prices.isEmpty) return 0\n\n        var hold = -prices(0)\n        var sell = 0\n        var cooldown = 0\n\n        for (i <- 1 until prices.length) {\n            val prevHold = hold\n            hold = math.max(hold, cooldown - prices(i))\n            cooldown = sell\n            sell = math.max(sell, prevHold + prices(i))\n        }\n\n        return sell\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let n = prices.len();\n        if n < 2 {\n            return 0;\n        }\n\n        let mut dp = vec![vec![0; 2]; n];\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        dp[1][0] = dp[0][0].max(dp[0][1] + prices[1]);\n        dp[1][1] = dp[0][1].max(dp[0][0] - prices[1]);\n\n        for i in 2..n {\n            dp[i][0] = dp[i - 1][0].max(dp[i - 1][1] + prices[i]);\n            dp[i][1] = dp[i - 1][1].max(dp[i - 2][0] - prices[i]);\n        }\n\n        dp[n - 1][0]\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you will need to use dynamic programming to maximize the profit while respecting the cooldown period constraint.\n\n# Explanation\n1. **Initialization**: Create a `dp` table where `dp[i][0]` represents the maximum profit on day `i` if you do not hold any stock, and `dp[i][1]` represents the maximum profit on day `i` if you hold a stock.\n2. **Base Cases**: On day 0:\n   - `dp[0][0]` is 0, as you do nothing.\n   - `dp[0][1]` is `-prices[0]` because if you buy the stock, the profit is negative the price of the stock.\n3. **Recurrence Relations**:\n   - For `dp[i][0]`: You can either do nothing (carry forward the previous state) or sell today after a cooldown.\n   - For `dp[i][1]`: You can either do nothing (carry forward the previous state) or buy today, but to account for the cooldown, you consider the state `dp[i-2][0]` rather than `dp[i-1][0]`.\n4. **Loop through each day**: Calculate the maximum profit for each state (`dp[i][0]` and `dp[i][1]`).\n5. **Return the result**: The maximum profit on the last day when not holding any stock (`dp[n-1][0]`).\n\n# Pseudocode\n```\n# Function to calculate maximum profit with cooldown\nfunction maxProfit(prices):\n    if prices is empty:\n        return 0\n    \n    n = length of prices\n    create dp table with dimensions n x 2\n    \n    # Base cases\n    dp[0][0] = 0  # Max profit on day 0 without holding any stock\n    dp[0][1] = -prices[0]  # Max profit on day 0 with holding a stock\n    \n    for i from 1 to n-1:\n        if i >= 2:\n            dp[i-2_0] = dp[i-2][0]\n        else:\n            dp[i-2_0] = 0\n\n        # On day i, the maximum profit without holding a stock\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n\n        # On day i, the maximum profit holding a stock\n        dp[i][1] = max(dp[i-1][1], dp[i-2_0] - prices[i])\n    \n    return dp[n-1][0]  # Maximum profit on the last day without holding any stock\n```\n\nThis pseudocode encapsulates the dynamic programming approach necessary to solve the problem by maximizing profit with respect to the trading constraints, ensuring the correct consideration of cooldown periods.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-best-time-to-buy-and-sell-stock-with-cooldown"
    },
    {
        "name": "Burst Balloons",
        "site": "LeetCode",
        "href": "/solution/LeetCode-burst-balloons",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxCoins(vector<int>& nums) {\n        int n = nums.size();\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        \n        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n        \n        for (int len = 1; len <= n; ++len) {\n            for (int left = 1; left <= n - len + 1; ++left) {\n                int right = left + len - 1;\n                for (int k = left; k <= right; ++k) {\n                    dp[left][right] = max(dp[left][right], dp[left][k - 1] + nums[left - 1] * nums[k] * nums[right + 1] + dp[k + 1][right]);\n                }\n            }\n        }\n        \n        return dp[1][n];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] newNums = new int[n + 2];\n        newNums[0] = 1;\n        newNums[n + 1] = 1;\n        for (int i = 1; i <= n; i++) {\n            newNums[i] = nums[i - 1];\n        }\n        \n        int[][] dp = new int[n + 2][n + 2];\n        for (int len = 1; len <= n; len++) {\n            for (int left = 1; left <= n - len + 1; left++) {\n                int right = left + len - 1;\n                for (int k = left; k <= right; k++) {\n                    dp[left][right] = Math.max(dp[left][right], dp[left][k - 1] + newNums[left - 1] * newNums[k] * newNums[right + 1] + dp[k + 1][right]);\n                }\n            }\n        }\n        \n        return dp[1][n];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxCoins(self, nums):\n        n = len(nums)\n        nums = [1] + nums + [1]\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        \n        for length in range(1, n + 1):\n            for i in range(1, n - length + 2):\n                j = i + length - 1\n                for k in range(i, j + 1):\n                    dp[i][j] = max(dp[i][j], dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1])\n        \n        return dp[1][n]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxCoins(int* nums, int numsSize) {\n    int n = numsSize;\n    int* coins = (int*)calloc(n + 2, sizeof(int));\n    coins[0] = coins[n+1] = 1;\n    for (int i = 1; i <= n; i++) {\n        coins[i] = nums[i - 1];\n    }\n    \n    int dp[n + 2][n + 2];\n    memset(dp, 0, sizeof(dp));\n    for (int len = 3; len <= n + 2; len++) {\n        for (int left = 0; left <= n + 2 - len; left++) {\n            int right = left + len - 1;\n            for (int k = left + 1; k < right; k++) {\n                dp[left][right] = fmax(dp[left][right], dp[left][k] + dp[k][right] + coins[left] * coins[k] * coins[right]);\n            }\n        }\n    }\n    \n    return dp[0][n+1];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MaxCoins(int[] nums) {\n        int n = nums.Length;\n        int[] newNums = new int[n + 2];\n        newNums[0] = 1;\n        newNums[n + 1] = 1;\n        \n        for (int i = 0; i < n; i++) {\n            newNums[i + 1] = nums[i];\n        }\n        \n        int[,] dp = new int[n + 2, n + 2];\n        \n        for (int len = 1; len <= n; len++) {\n            for (int left = 1; left <= n - len + 1; left++) {\n                int right = left + len - 1;\n                for (int k = left; k <= right; k++) {\n                    dp[left, right] = Math.Max(dp[left, right], \n                                               newNums[left - 1] * newNums[k] * newNums[right + 1] + dp[left, k - 1] + dp[k + 1, right]);\n                }\n            }\n        }\n        \n        return dp[1, n];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    const n = nums.length;\n    \n    // Extend nums array with 1 at start and end\n    const newNums = [1, ...nums, 1];\n    \n    // Initialize a 2D DP array with dimensions n+2 x n+2\n    const dp = new Array(n+2).fill(0).map(() => new Array(n+2).fill(0));\n    \n    // Iterate over the range of each subarray length\n    for (let len = 1; len <= n; len++) {\n        for (let left = 1; left <= n - len + 1; left++) {\n            // Calculate the right index of the subarray\n            const right = left + len - 1;\n            // Iterate over possible last balloon to burst in subarray\n            for (let k = left; k <= right; k++) {\n                // Update the maximum coins by bursting balloons wisely\n                dp[left][right] = Math.max(dp[left][right], dp[left][k-1] + newNums[left-1] * newNums[k] * newNums[right+1] + dp[k+1][right]);\n            }\n        }\n    }\n    \n    return dp[1][n];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxCoins(nums: number[]): number {\n    const n = nums.length;\n    const dp: number[][] = new Array(n + 2).fill(0).map(() => new Array(n + 2).fill(0));\n    \n    nums.unshift(1);\n    nums.push(1);\n    \n    for (let len = 1; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            const j = i + len - 1;\n            for (let k = i; k <= j; k++) {\n                dp[i][j] = Math.max(dp[i][j], dp[i][k - 1] + nums[i - 1] * nums[k] * nums[j + 1] + dp[k + 1][j]);\n            }\n        }\n    }\n    \n    return dp[1][n];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxCoins($nums) {\n        $n = count($nums);\n        $nums = array_merge([1], $nums, [1]);\n        \n        $dp = array_fill(0, $n + 2, array_fill(0, $n + 2, 0));\n        \n        for ($len = 1; $len <= $n; $len++) {\n            for ($left = 1; $left <= $n - $len + 1; $left++) {\n                $right = $left + $len - 1;\n                for ($k = $left; $k <= $right; $k++) {\n                    $dp[$left][$right] = max($dp[$left][$right], $nums[$left - 1] * $nums[$k] * $nums[$right + 1] + $dp[$left][$k - 1] + $dp[$k + 1][$right]);\n                }\n            }\n        }\n        \n        return $dp[1][$n];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func maxCoins(_ nums: [Int]) -> Int {\n        let n = nums.count\n        var dp = Array(repeating: Array(repeating: 0, count: n+2), count: n+2)\n        let balloons = [1] + nums + [1]\n        \n        for len in 1...n {\n            for i in 1...(n-len+1) {\n                let j = i + len - 1\n                for k in i...j {\n                    dp[i][j] = max(dp[i][j], dp[i][k-1] + balloons[i-1]*balloons[k]*balloons[j+1] + dp[k+1][j])\n                }\n            }\n        }\n        \n        return dp[1][n]\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxCoins(nums: IntArray): Int {\n        val n = nums.size\n        val newNums = IntArray(n + 2)\n        newNums[0] = 1\n        newNums[n + 1] = 1\n        for (i in 1..n) {\n            newNums[i] = nums[i - 1]\n        }\n\n        val dp = Array(n + 2) { IntArray(n + 2) }\n        for (length in 1..n) {\n            for (left in 1..n - length + 1) {\n                val right = left + length - 1\n                for (last in left..right) {\n                    dp[left][right] = maxOf(dp[left][right],\n                        newNums[left - 1] * newNums[last] * newNums[right + 1] +\n                                dp[left][last - 1] + dp[last + 1][right]\n                    )\n                }\n            }\n        }\n\n        return dp[1][n]\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int maxCoins(List<int> nums) {\n    int n = nums.length;\n    nums.insert(0, 1);\n    nums.add(1);\n\n    List<List<int>> dp = List.generate(n + 2, (_) => List.filled(n + 2, 0));\n\n    for (int len = 1; len <= n; len++) {\n      for (int left = 1; left <= n - len + 1; left++) {\n        int right = left + len - 1;\n        for (int k = left; k <= right; k++) {\n          dp[left][right] = \n            dp[left][right] = dp[left][right] > (dp[left][k - 1] + nums[left - 1] * nums[k] * nums[right + 1] + dp[k + 1][right]) ? dp[left][right] : (dp[left][k - 1] + nums[left - 1] * nums[k] * nums[right + 1] + dp[k + 1][right]);\n        }\n      }\n    }\n\n    return dp[1][n];\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func maxCoins(nums []int) int {\n    n := len(nums)\n    dp := make([][]int, n+2)\n    for i := 0; i < n+2; i++ {\n        dp[i] = make([]int, n+2)\n    }\n\n    newNums := make([]int, n+2)\n    newNums[0], newNums[n+1] = 1, 1\n    for i := 1; i <= n; i++ {\n        newNums[i] = nums[i-1]\n    }\n\n    for length := 1; length <= n; length++ {\n        for left := 1; left <= n-length+1; left++ {\n            right := left + length - 1\n            for k := left; k <= right; k++ {\n                dp[left][right] = max(dp[left][right], dp[left][k-1]+dp[k+1][right]+newNums[left-1]*newNums[k]*newNums[right+1])\n            }\n        }\n    }\n\n    return dp[1][n]\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef max_coins(nums)\n    n = nums.length\n    nums.unshift(1)\n    nums.push(1)\n    dp = Array.new(n+2) { Array.new(n+2, 0) }\n    \n    (1..n).each do |len|\n        (1..n-len+1).each do |left|\n            right = left + len - 1\n            (left..right).each do |i|\n                dp[left][right] = [dp[left][right], nums[left-1] * nums[i] * nums[right+1] + dp[left][i-1] + dp[i+1][right]].max\n            end\n        end\n    end\n    \n    dp[1][n]\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of bursting balloons to collect the maximum number of coins, we can take a dynamic programming approach. The strategy is to break down the problem into subproblems and solve it using a bottom-up technique. We'll use a 2D array `dp` where `dp[i][j]` represents the maximum coins that can be collected by bursting all the balloons between the indices `i` and `j`.\n\n# Explanation\n1. **Initialization:** We start by padding the `nums` array with 1 at both the beginning and end to handle the boundary conditions easily.\n2. **DP Table:** We create a 2D list `dp` where `dp[i][j]` stores the maximum coins obtainable by bursting all balloons between the `i-th` and `j-th` balloons.\n3. **Filling DP Table:** \n    - We iterate over all possible lengths of subarrays.\n    - For each subarray of a given length, we calculate the maximum coins by considering each possible balloon to burst last in that subarray.\n    - The coins collected from bursting a balloon are added to the maximum coins obtained from the left and right subproblems.\n4. **Result:** The final answer we are interested in is stored in `dp[1][n]`, where `n` is the length of the original `nums` array.\n\n# Pseudocode\n```\nfunction maxCoins(nums):\n    n = length(nums)\n    # Pad the nums array with 1 at both ends\n    nums = [1] + nums + [1]\n    \n    # Initialize a DP table with dimensions (n+2) x (n+2)\n    dp = 2D list of size (n+2) x (n+2) initialized with 0\n\n    # Iterate over the length of the subarray from 1 to n\n    for length from 1 to n:\n        # Iterate over the starting point of the subarray\n        for i from 1 to n - length + 1:\n            # Calculate the ending point of the subarray\n            j = i + length - 1\n            # Iterate over each possible middle balloon to burst\n            for k from i to j:\n                dp[i][j] = max(dp[i][j], dp[i][k-1] + dp[k+1][j] + nums[i-1] * nums[k] * nums[j+1])\n    \n    # Return the maximum coins that can be collected by bursting all balloons\n    return dp[1][n]\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-burst-balloons"
    },
    {
        "name": "Count Of Smaller Numbers After Self",
        "site": "LeetCode",
        "href": "/solution/LeetCode-count-of-smaller-numbers-after-self",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> countSmaller(vector<int>& nums) {\n        vector<int> result(nums.size(), 0);\n        vector<int> sorted;\n        \n        for(int i = nums.size() - 1; i >= 0; i--) {\n            int left = 0, right = sorted.size();\n            while(left < right) {\n                int mid = left + (right - left) / 2;\n                if(sorted[mid] >= nums[i]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            result[i] = right;\n            sorted.insert(sorted.begin() + right, nums[i]);\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        List<Integer> sorted = new ArrayList<>();\n        \n        for (int i = nums.length - 1; i >= 0; i--) {\n            int index = findIndex(sorted, nums[i]);\n            result.add(0, index);\n            sorted.add(index, nums[i]);\n        }\n        \n        return result;\n    }\n    \n    private int findIndex(List<Integer> list, int target) {\n        if (list.isEmpty()) {\n            return 0;\n        }\n        \n        int left = 0;\n        int right = list.size() - 1;\n        \n        if (target > list.get(right)) {\n            return right + 1;\n        }\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (list.get(mid) < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return left;\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> CountSmaller(int[] nums) {\n        List<int> resultList = new List<int>();\n        for (int i = 0; i < nums.Length; i++)\n        {\n            int count = 0;\n            for (int j = i + 1; j < nums.Length; j++)\n            {\n                if (nums[j] < nums[i])\n                {\n                    count++;\n                }\n            }\n            resultList.Add(count);\n        }\n        return resultList;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function countSmaller(nums: number[]): number[] {\n    const counts: number[] = new Array(nums.length).fill(0);\n    \n    const sortedNums = nums.slice().sort((a, b) => a - b);\n    \n    for (let i = 0; i < nums.length; i++) {\n        const count = sortedNums.indexOf(nums[i]);\n        counts[i] = count;\n        sortedNums.splice(count, 1);\n    }\n    \n    return counts;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to return an array where each element counts the number of smaller elements to its right in the given input array. This problem can be efficiently solved using a modified version of Binary Indexed Tree (Fenwick Tree) or by maintaining a sort order using binary search and insertion.\n\n# Explanation\n\n1. **Initialization**:\n    - We initialize an empty list `sorted` that will maintain the elements in sorted order from the right.\n    - We initialize a list `result` of the same length as the input list `nums`, filled with zeros.\n\n2. **Iterate from Right to Left**:\n    - Loop through the list `nums` from the last element to the first.\n    - For each element, use binary search to determine the correct position where the element should be inserted in the `sorted` list to maintain sorted order.\n\n3. **Binary Search for Insertion Point**:\n    - Use binary search to find the position to insert the current element in `sorted`. The position found will also denote the number of elements smaller than the current element that are already in the list.\n    - Insert the current element at the correct position found in `sorted`.\n\n4. **Update Result Array**:\n    - Update the `result[i]` with the position found from the binary search as it represents the count of smaller elements to the right of `nums[i]`.\n\n# Pseudocode\n\n```text\nfunction countSmaller(nums):\n    let n = length of nums\n    let result = array of size n initialized with zeros\n    let sorted = empty array\n    \n    for i from n-1 to 0:\n        pos = binarySearch(sorted, nums[i])\n        insert sorted at pos with nums[i]\n        result[i] = pos\n        \n    return result\n\nfunction binarySearch(array, target):\n    let left = 0\n    let right = length of array\n    \n    while left < right:\n        let mid = left + (right - left) / 2\n        if array[mid] >= target:\n            right = mid\n        else:\n            left = mid + 1\n            \n    return left\n```\n\nThis pseudocode provides a clear step-by-step approach to solving the problem using binary search to find the insertion point, thereby counting smaller elements efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-count-of-smaller-numbers-after-self"
    },
    {
        "name": "Maximum Product Of Word Lengths",
        "site": "LeetCode",
        "href": "/solution/LeetCode-maximum-product-of-word-lengths",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int maxProduct(vector<string>& words) {\n        int n = words.size();\n        vector<int> masks(n);\n        vector<int> lens(n);\n\n        for (int i = 0; i < n; i++) {\n            int mask = 0;\n            for (char c : words[i]) {\n                mask |= 1 << (c - 'a');\n            }\n            masks[i] = mask;\n            lens[i] = words[i].length();\n        }\n\n        int maxProd = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((masks[i] & masks[j]) == 0) {\n                    maxProd = max(maxProd, lens[i] * lens[j]);\n                }\n            }\n        }\n\n        return maxProd;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int maxProduct(String[] words) {\n        int max = 0;\n        \n        int[] bitMasks = new int[words.length];\n        for (int i = 0; i < words.length; i++) {\n            for (char c : words[i].toCharArray()) {\n                bitMasks[i] |= 1 << (c - 'a');\n            }\n        }\n        \n        for (int i = 0; i < words.length; i++) {\n            for (int j = i + 1; j < words.length; j++) {\n                if ((bitMasks[i] & bitMasks[j]) == 0) {\n                    max = Math.max(max, words[i].length() * words[j].length());\n                }\n            }\n        }\n        \n        return max;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxProduct(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        def has_common_letters(w1, w2):\n            return any(letter in w2 for letter in w1)\n\n        max_prod = 0\n        for i in range(len(words)):\n            for j in range(i+1, len(words)):\n                if not has_common_letters(words[i], words[j]):\n                    max_prod = max(max_prod, len(words[i]) * len(words[j]))\n        \n        return max_prod\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int maxProduct(char** words, int wordsSize) {\n    int max = 0;\n    \n    for (int i = 0; i < wordsSize; i++) {\n        for (int j = i + 1; j < wordsSize; j++) {\n            int flag = 0;\n            for (int k = 0; words[i][k] != '\\0'; k++) {\n                for (int l = 0; words[j][l] != '\\0'; l++) {\n                    if (words[i][k] == words[j][l]) {\n                        flag = 1;\n                        break;\n                    }\n                }\n                if (flag == 1) {\n                    break;\n                }\n            }\n            \n            if (flag == 0) {\n                int product = strlen(words[i]) * strlen(words[j]);\n                if (product > max) {\n                    max = product;\n                }\n            }\n        }\n    }\n    \n    return max;\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the task at hand is to find the maximum product of the lengths of two words from a list, where the words do not share any common letters.\n\n# Explanation:\n1. **Input**: An array of words, each consisting of only lowercase English letters.\n2. **Output**: The maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such pair exists, return 0.\n\n# Steps:\n1. **Helper Function**: Create a helper function to check if two words share any common letters. This function would take two strings as input, and return a boolean indicating whether there is any shared letter.\n2. **Iterate Over All Pairs**: Use nested loops to compare every possible pair of words in the list.\n3. **Check Common Letters**: For each pair, use the helper function to check if they share any common letters.\n4. **Update Maximum Product**: If the pair does not share any common letters, calculate the product of their lengths and update the maximum product accordingly.\n5. **Return**: After checking all pairs, return the maximum product found.\n\n# Pseudocode:\n``` \nfunction maxProduct(words):\n    # Helper function to check if two words share common letters\n    function hasCommonLetters(w1, w2):\n        for letter in w1:\n            if letter in w2:\n                return True\n        return False\n    \n    max_prod = 0\n    \n    # Iterate through all pairs of words in the list\n    for i in range( length(words) ):\n        for j in range(i + 1, length(words) ):\n            if not hasCommonLetters(words[i], words[j]):\n                product = length(words[i]) * length(words[j])\n                if product > max_prod:\n                    max_prod = product\n                    \n    return max_prod\n```\n\nThis pseudocode outlines the approach to solve the problem methodically by using helper functions and nested loops to ensure all conditions are checked and the optimal solution is found.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-maximum-product-of-word-lengths"
    },
    {
        "name": "Remove Duplicate Letters",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-duplicate-letters",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        string ans;\n        vector<int> count(26); // count frequency of each character\n        vector<bool> visited(26); // check if character is already in answer\n        \n        for(char c : s) {\n            count[c - 'a']++;\n        }\n        \n        for(char c : s) {\n            count[c - 'a']--;\n            \n            if(visited[c - 'a']) {\n                continue;\n            }\n            \n            while(!ans.empty() && ans.back() > c && count[ans.back() - 'a'] > 0) {\n                visited[ans.back() - 'a'] = false;\n                ans.pop_back();\n            }\n            \n            ans.push_back(c);\n            visited[c - 'a'] = true;\n        }\n        \n        return ans;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String removeDuplicateLetters(String s) {\n        Stack<Character> stack = new Stack<>();\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n\n        for (char c : s.toCharArray()) {\n            count[c]++;\n        }\n\n        for (char c : s.toCharArray()) {\n            count[c]--;\n\n            if (visited[c]) {\n                continue;\n            }\n\n            while (!stack.isEmpty() && stack.peek() > c && count[stack.peek()] > 0) {\n                visited[stack.pop()] = false;\n            }\n\n            stack.push(c);\n            visited[c] = true;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : stack) {\n            sb.append(c);\n        }\n\n        return sb.toString();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def removeDuplicateLetters(self, s):\n        stack = []\n        counter = collections.Counter(s)\n        visited = set()\n        \n        for char in s:\n            counter[char] -= 1\n            if char in visited:\n                continue\n            \n            while stack and char < stack[-1] and counter[stack[-1]] > 0:\n                visited.remove(stack.pop())\n            \n            stack.append(char)\n            visited.add(char)\n        \n        return ''.join(stack)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* removeDuplicateLetters(char* s) {\n    char *result = calloc(27, sizeof(char));\n    int count[26] = {0};\n    bool visited[26] = {false};\n    \n    for(int i = 0; i < strlen(s); i++) {\n        count[s[i] - 'a']++;\n    }\n    \n    int index = 0;\n    for(int i = 0; i < strlen(s); i++) {\n        count[s[i] - 'a']--;\n        if(visited[s[i] - 'a']) {\n            continue;\n        }\n        \n        while(index > 0 && s[i] < result[index - 1] && count[result[index - 1] - 'a'] > 0) {\n            visited[result[index - 1] - 'a'] = false;\n            index--;\n        }\n        \n        result[index++] = s[i];\n        visited[s[i] - 'a'] = true;\n    }\n    \n    result[index] = '\\0';\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string RemoveDuplicateLetters(string s) {\n        if (string.IsNullOrEmpty(s))\n            return string.Empty;\n        \n        int[] count = new int[26];\n        bool[] visited = new bool[26];\n        StringBuilder sb = new StringBuilder();\n        \n        foreach (char c in s)\n            count[c - 'a']++;\n        \n        foreach (char c in s)\n        {\n            count[c - 'a']--;\n            if (visited[c - 'a'])\n                continue;\n            \n            while (sb.Length > 0 && sb[sb.Length - 1] > c && count[sb[sb.Length - 1] - 'a'] > 0)\n            {\n                visited[sb[sb.Length - 1] - 'a'] = false;\n                sb.Remove(sb.Length - 1, 1);\n            }\n            sb.Append(c);\n            visited[c - 'a'] = true;\n        }\n        \n        return sb.ToString();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar removeDuplicateLetters = function(s) {\n    const stack = [];\n    const count = new Array(26).fill(0);\n    const visited = new Array(26).fill(false);\n\n    for (let char of s) {\n        count[char.charCodeAt(0) - 97]++;\n    }\n\n    for (let char of s) {\n        count[char.charCodeAt(0) - 97]--;\n\n        if (visited[char.charCodeAt(0) - 97]) {\n            continue;\n        }\n\n        while (stack.length > 0 && stack[stack.length - 1] > char && count[stack[stack.length - 1].charCodeAt(0) - 97] > 0) {\n            visited[stack.pop().charCodeAt(0) - 97] = false;\n        }\n\n        stack.push(char);\n        visited[char.charCodeAt(0) - 97] = true;\n    }\n\n    return stack.join('');\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function removeDuplicateLetters(s: string): string {\n    const lastSeen: {[key: string]: number} = {};\n    const stack: string[] = [];\n    const seen: Set<string> = new Set();\n\n    for (let i = 0; i < s.length; i++) {\n        lastSeen[s[i]] = i;\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        if (!seen.has(char)) {\n            while (stack.length > 0 && stack[stack.length - 1] > char && i < lastSeen[stack[stack.length - 1]]) {\n                const top = stack.pop();\n                seen.delete(top);\n            }\n            stack.push(char);\n            seen.add(char);\n        }\n    }\n\n    return stack.join('');\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return String\n     */\n    function removeDuplicateLetters($s) {\n        $stack = [];\n        $seen = [];\n        $lastOccur = [];\n        \n        for ($i = 0; $i < strlen($s); $i++) {\n            $lastOccur[ord($s[$i]) - ord('a')] = $i;\n        }\n        \n        for ($i = 0; $i < strlen($s); $i++) {\n            $char = $s[$i];\n            if (!in_array($char, $seen)) {\n                while (!empty($stack) && end($stack) > $char && $i < $lastOccur[ord(end($stack)) - ord('a')]) {\n                    array_pop($stack);\n                    array_pop($seen);\n                }\n                $stack[] = $char;\n                $seen[] = $char;\n            }\n        }\n        \n        return implode(\"\", $stack);\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func removeDuplicateLetters(_ s: String) -> String {\n        var stack = [Character]()\n        var seen = Set<Character>()\n        var lastOccurrence = [Character: Int]()\n        \n        for (index, char) in s.enumerated() {\n            lastOccurrence[char] = index\n        }\n        \n        for (index, char) in s.enumerated() {\n            if !seen.contains(char) {\n                while let lastChar = stack.last, char < lastChar, index < lastOccurrence[lastChar]! {\n                    seen.remove(lastChar)\n                    stack.removeLast()\n                }\n                seen.insert(char)\n                stack.append(char)\n            }\n        }\n        \n        return String(stack)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun removeDuplicateLetters(s: String): String {\n        val stack = mutableListOf<Char>()\n        val count = IntArray(26)\n        val visited = BooleanArray(26)\n        \n        for (c in s) {\n            count[c - 'a']++\n        }\n        \n        for (c in s) {\n            count[c - 'a']--\n            if (visited[c - 'a']) {\n                continue\n            }\n            \n            while (stack.isNotEmpty() && stack.last() > c && count[stack.last() - 'a'] > 0) {\n                visited[stack.last() - 'a'] = false\n                stack.removeAt(stack.size - 1)\n            }\n            \n            stack.add(c)\n            visited[c - 'a'] = true\n        }\n        \n        return stack.joinToString(\"\")\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String removeDuplicateLetters(String s) {\n    List<int> count = List.filled(26, 0);\n    List<bool> used = List.filled(26, false);\n    List<String> stack = [];\n\n    for (int i = 0; i < s.length; i++) {\n      count[s.codeUnitAt(i) - 'a'.codeUnitAt(0)]++;\n    }\n\n    for (int i = 0; i < s.length; i++) {\n      count[s.codeUnitAt(i) - 'a'.codeUnitAt(0)]--;\n      if (used[s.codeUnitAt(i) - 'a'.codeUnitAt(0)]) {\n        continue;\n      }\n\n      while (stack.isNotEmpty &&\n          s.codeUnitAt(i) < stack.last.codeUnitAt(0) &&\n          count[stack.last.codeUnitAt(0) - 'a'.codeUnitAt(0)] > 0) {\n        used[stack.last.codeUnitAt(0) - 'a'.codeUnitAt(0)] = false;\n        stack.removeLast();\n      }\n\n      stack.add(s[i]);\n      used[s.codeUnitAt(i) - 'a'.codeUnitAt(0)] = true;\n    }\n\n    return stack.join();\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func removeDuplicateLetters(s string) string {\n    lastOccur := make(map[byte]int)\n    for i, char := range s {\n        lastOccur[byte(char)] = i\n    }\n    \n    stack := make([]byte, 0)\n    seen := make(map[byte]bool)\n    \n    for i, char := range s {\n        b := byte(char)\n        if _, ok := seen[b]; !ok {\n            for len(stack) > 0 && b < stack[len(stack)-1] && lastOccur[stack[len(stack)-1]] > i {\n                delete(seen, stack[len(stack)-1])\n                stack = stack[:len(stack)-1]\n            }\n            seen[b] = true\n            stack = append(stack, b)\n        }\n    }\n    \n    return string(stack)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {String}\ndef remove_duplicate_letters(s)\n    stack = []\n    seen = {}\n    last_occurrence = {}\n\n    s.each_char.with_index do |char, index|\n        last_occurrence[char] = index\n    end\n\n    s.each_char.with_index do |char, index|\n        next if seen[char]\n\n        while !stack.empty? && char < stack.last && last_occurrence[stack.last] > index\n            seen[stack.pop] = false\n        end\n\n        stack.push(char)\n        seen[char] = true\n    end\n\n    stack.join\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn remove_duplicate_letters(s: String) -> String {\n        let mut stack: Vec<char> = Vec::new();\n        let mut seen: [bool; 26] = [false; 26];\n        let mut last_occurrence: [usize; 26] = [0; 26];\n\n        for (i, c) in s.chars().enumerate() {\n            last_occurrence[c as usize - 'a' as usize] = i;\n        }\n\n        for (i, c) in s.chars().enumerate() {\n            if !seen[c as usize - 'a' as usize] {\n                while !stack.is_empty() && c < *stack.last().unwrap() && last_occurrence[*stack.last().unwrap() as usize - 'a' as usize] > i {\n                    seen[*stack.last().unwrap() as usize - 'a' as usize] = false;\n                    stack.pop();\n                }\n                stack.push(c);\n                seen[c as usize - 'a' as usize] = true;\n            }\n        }\n\n        stack.iter().collect()\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to ensure that each letter appears once and only once in the output string and that the resulting string is the smallest lexicographical order among all possible results. Here\u2019s a detailed explanation followed by the pseudocode.\n\n# Explanation\n1. **Initialize Data Structures:**\n   - Use a stack to build the result string incrementally.\n   - Use a counter to keep track of the number of remaining occurrences of each character.\n   - Use a set to keep track of characters that are in the current result.\n   \n2. **Iterate Through the String:**\n   - For each character, decrement its count in the counter.\n   - If the character is already in the visited set, skip it because it\u2019s already in the current result.\n   - Otherwise, while the character at the top of the stack is larger than the current character and appears later in the string (counter value > 0), remove it from the stack and visited set.\n   \n3. **Push the Current Character:**\n   - Add the current character to the stack and mark it as visited.\n\n4. **Return the Result:**\n   - Join the characters from the stack to form the final result string.\n\n# Pseudocode\n\n```\n# Pseudocode\n\nfunction removeDuplicateLetters(s):\n    stack = empty stack\n    counter = frequency_counter(s)  # count the occurrences of each character in s\n    visited = empty set\n    \n    for char in s:\n        counter[char] -= 1  # Decrement the counter for the current character\n        \n        if char in visited:\n            continue  # skip if the character is already in the result\n        \n        # Maintain lexicographical order and remove characters that will still appear later\n        while stack is not empty and char < stack[top] and counter[stack[top]] > 0:\n            visited.remove(stack.pop())\n        \n        stack.append(char)\n        visited.add(char)\n    \n    return join_characters_in_stack(stack)\n\nfunction frequency_counter(s):\n    # Returns a dictionary with the frequency count of each character in s\n    counter = empty dictionary\n    for char in s:\n        if char in counter:\n            counter[char] += 1\n        else:\n            counter[char] = 1\n    return counter\n\nfunction join_characters_in_stack(stack):\n    # Joins the characters in the stack to form a single string\n    result = \"\"\n    for char in stack:\n        result += char\n    return result\n```\n\nThis pseudocode outlines the logic to remove duplicate letters and ensure the smallest lexicographical order. The solution uses a stack to keep track of the selected characters and a counter to manage their occurrences.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-duplicate-letters"
    },
    {
        "name": "Wiggle Sort Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-wiggle-sort-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    void wiggleSort(vector<int>& nums) {\n        vector<int> sorted(nums);\n        sort(sorted.begin(), sorted.end());\n        \n        int n = nums.size();\n        int mid = (n + 1) / 2;\n        \n        int largeIdx = n - 1;\n        int smallIdx = mid - 1;\n        \n        for (int i = 0; i < n; i++) {\n            nums[i] = i % 2 == 0 ? sorted[smallIdx--] : sorted[largeIdx--];\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public void wiggleSort(int[] nums) {\n        int[] sortedNums = Arrays.copyOf(nums, nums.length);\n        Arrays.sort(sortedNums);\n        \n        int n = nums.length;\n        int mid = (n + 1) / 2;\n        int end = n;\n        \n        for (int i = 0; i < n; i++) {\n            nums[i] = i % 2 == 0 ? sortedNums[--mid] : sortedNums[--end];\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def wiggleSort(self, nums):\n        nums.sort()\n        mid = (len(nums) + 1) // 2\n        nums[::2], nums[1::2] = nums[:mid][::-1], nums[mid:][::-1]\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public void WiggleSort(int[] nums) {\n        Array.Sort(nums);\n        int[] result = new int[nums.Length];\n        int mid = nums.Length / 2;\n        if (nums.Length % 2 != 0) mid++;\n\n        int evenIndex = mid - 1;\n        int oddIndex = nums.Length - 1;\n\n        for (int i = 0; i < nums.Length; i++) {\n            if (i % 2 == 0) {\n                result[i] = nums[evenIndex];\n                evenIndex--;\n            } else {\n                result[i] = nums[oddIndex];\n                oddIndex--;\n            }\n        }\n\n        Array.Copy(result, nums, nums.Length);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify \nnums in-place instead.\n */\nvar wiggleSort = function(nums) {\n    // Sort the nums array\n    nums.sort((a, b) => a - b);\n    \n    const n = nums.length;\n    const mid = Math.floor((n + 1) / 2);\n    const copy = nums.slice();\n    \n    let left = mid - 1;\n    let right = n - 1;\n    \n    for (let i = 0; i < n; i++) {\n        if (i % 2 === 0) {\n            nums[i] = copy[left];\n            left--;\n        } else {\n            nums[i] = copy[right];\n            right--;\n        }\n    }\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n Do not return anything, modify nums in-place \ninstead.\n */\nfunction wiggleSort(nums: number[]): void {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const mid = Math.floor((n + 1) / 2);\n    const result = new Array(n).fill(0);\n    \n    let left = mid - 1;\n    let right = n - 1;\n    \n    for (let i = 0; i < n; i++) {\n        if (i % 2 === 0) {\n            result[i] = nums[left];\n            left--;\n        } else {\n            result[i] = nums[right];\n            right--;\n        }\n    }\n    \n    for (let i = 0; i < n; i++) {\n        nums[i] = result[i];\n    }\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func wiggleSort(_ nums: inout [Int]) {\n        let n = nums.count\n        let sortedNums = nums.sorted()\n        var low = 0\n        var high = n - 1\n        var mid = (n - 1) / 2\n        \n        var result = [Int](repeating: 0, count: n)\n        \n        for i in 0..<n {\n            if i % 2 == 0 {\n                nums[i] = sortedNums[mid]\n                mid -= 1\n            } else {\n                nums[i] = sortedNums[high]\n                high -= 1\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  void wiggleSort(List<int> nums) {\n    List<int> sortedNums = List.from(nums)..sort();\n    int n = nums.length;\n    \n    int mid = (n + 1) ~/ 2;\n    List<int> small = sortedNums.sublist(0, mid);\n    List<int> large = sortedNums.sublist(mid);\n    \n    int index = 0;\n    for (int i = small.length - 1, j = large.length - 1; i >= 0 || j >= 0;) {\n      if (i >= 0) {\n        nums[index] = small[i];\n        i--;\n        index++;\n      }\n      if (j >= 0) {\n        nums[index] = large[j];\n        j--;\n        index++;\n      }\n    }\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "import \"sort\"\n\nfunc wiggleSort(nums []int) {\n    n := len(nums)\n    sort.Ints(nums)\n    mid := n / 2\n    if n%2 == 1 {\n        mid++\n    }\n    copyNums := make([]int, n)\n    copy(copyNums, nums)\n\n    index := 0\n    for i := 0; i < mid; i++ {\n        nums[index] = copyNums[mid-1-i]\n        if index+1 < n {\n            nums[index+1] = copyNums[n-1-i]\n        }\n        index += 2\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn wiggle_sort(nums: &mut Vec<i32>) {\n        let n = nums.len();\n        \n        let mut sorted_nums = nums.clone();\n        sorted_nums.sort_unstable();\n        \n        let mut mid = (n - 1) / 2;\n        \n        let mut result = vec![0; n];\n        \n        for i in 0..n {\n            result[i] = if i % 2 == 0 {\n                mid -= 1;\n                sorted_nums[mid + 1]\n            } else {\n                sorted_nums[n - 1 - (i / 2)]\n            };\n        }\n        \n        nums.clone_from_slice(&result);\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to reorder the array such that the elements alternate between being smaller and larger than their neighbors. Let's break it down into an explanation and pseudocode.\n\n# Explanation\n\n1. **Sort the Array**: Begin by sorting the array. This gives us a straightforward way to access the smallest and largest elements.\n2. **Find Midpoint**: Identify the midpoint of the array. This helps in splitting the array into two halves, where the first contains the smaller elements and the second contains the larger elements.\n3. **Reverse Halves**: Reversing both halves ensures that when we weave them together, the elements alternate correctly.\n4. **Reorder Using Slicing**: Interleave these two halves using array slicing in steps of 2.\n\n# Pseudocode\n\n```text\nfunction wiggleSort(nums):\n    sort(nums)                                     # Step 1: sort the array\n    mid = (length(nums) + 1) // 2                  # Step 2: find the midpoint\n    # Step 3: reverse the first half and the second half\n    first_half = nums[:mid][reverse]\n    second_half = nums[mid:][reverse]\n  \n    # Step 4: interleave the two halves\n    for i in range(mid):\n        nums[2 * i] = first_half[i]\n        if 2 * i + 1 < len(nums):\n            nums[2 * i + 1] = second_half[i]\n```\n\nThis pseudocode outlines the logical steps to achieve the desired wiggle sort ordering. Here's a brief recap: \n- Sort the array.\n- Find the midpoint.\n- Reverse the two halves.\n- Interleave the elements from the two halves. \n\nThe provided Python solution captures the essence of this approach effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-wiggle-sort-ii"
    },
    {
        "name": "Bulb Switcher",
        "site": "LeetCode",
        "href": "/solution/LeetCode-bulb-switcher",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int bulbSwitch(int n) {\n        return sqrt(n);\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int bulbSwitch(int n) {\n        return (int) Math.sqrt(n);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def bulbSwitch(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int(n ** 0.5)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int bulbSwitch(int n) {\n    return (int)sqrt(n);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int BulbSwitch(int n) {\n        return (int)Math.Sqrt(n);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar bulbSwitch = function(n) {\n    return Math.floor(Math.sqrt(n));\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function bulbSwitch(n: number): number {\n    return Math.floor(Math.sqrt(n));\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function bulbSwitch($n) {\n        return intval(sqrt($n));\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": " class Solution {\n    func bulbSwitch(_ n: Int) -> Int {\n        return Int(sqrt(Double(n)))\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun bulbSwitch(n: Int): Int {\n        return Math.sqrt(n.toDouble()).toInt()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "import 'dart:math';\n\nclass Solution {\n  int bulbSwitch(int n) {\n      return sqrt(n).toInt();\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "package main\n\nfunc bulbSwitch(n int) int {\n    return int(math.Sqrt(float64(n)))\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @return {Integer}\ndef bulb_switch(n)\n    Math.sqrt(n).to_i\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to understand the inherent pattern that develops from the toggling rounds. Let's break down the solution:\n\n# Explanation\n\n1. Each bulb will be toggled in its corresponding rounds. For example, the first bulb gets toggled in every round, the second bulb gets toggled in every second round, and so on.\n2. A bulb ends up being on if it is toggled an odd number of times. Bulb `i` is toggled every time `j` (where `j` is a factor of `i`).\n3. A bulb will have an odd number of toggles if `i` has an odd number of factors, or more simply, if `i` is a perfect square. This is due to the fact that factors usually come in pairs, except for perfect squares which have a middle number that appears only once.\n4. Therefore, the problem boils down to counting the number of perfect squares up to `n`.\n\n# Pseudocode\n\n```\ndef bulbSwitch(n):\n    # Explanation: \n    # Number of bulbs that remain ON are the perfect squares up to n.\n    # This is because perfect square numbers have an odd number of divisors.\n    \n    # Calculate the number of perfect squares up to n\n    result = int(n ** 0.5)\n    \n    # Return the result\n    return result\n```\n\nThis method leverages the fact that the perfect squares are the bulbs that stay on because they are toggled an odd number of times. The count of such perfect squares up to any number `n` is computed directly by taking the integer part of the square root of `n`. This makes the solution both simple and efficient.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-bulb-switcher"
    },
    {
        "name": "Create Maximum Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-create-maximum-number",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int m = nums1.length;\n        int n = nums2.length;\n        int[] result = new int[k];\n        \n        for (int i = Math.max(0, k - n); i <= k && i <= m; i++) {\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);\n            if (greater(candidate, 0, result, 0)) {\n                result = candidate;\n            }\n        }\n        \n        return result;\n    }\n    \n    private int[] maxArray(int[] nums, int k) {\n        int n = nums.length;\n        int[] result = new int[k];\n        int index = 0;\n        \n        for (int i = 0; i < n; i++) {\n            while (index > 0 && n - i > k - index && result[index - 1] < nums[i]) {\n                index--;\n            }\n            if (index < k) {\n                result[index++] = nums[i];\n            }\n        }\n        \n        return result;\n    }\n    \n    private int[] merge(int[] nums1, int[] nums2, int k) {\n        int[] result = new int[k];\n        int i = 0, j = 0;\n        \n        for (int r = 0; r < k; r++) {\n            result[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n        }\n        \n        return result;\n    }\n    \n    private boolean greater(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n            i++;\n            j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def merge(nums1, nums2):\n            merged = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    merged.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    merged.append(nums2[0])\n                    nums2 = nums2[1:]\n            return merged\n        \n        def maxArray(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        result = []\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            merged = merge(maxArray(nums1, i), maxArray(nums2, k - i))\n            result = max(result, merged)\n        \n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] MaxNumber(int[] nums1, int[] nums2, int k) {\n        int m = nums1.Length, n = nums2.Length;\n        int[] ans = new int[k];\n        \n        for (int i = Math.Max(0, k - n); i <= k && i <= m; i++) {\n            int[] candidate = Merge(MaxArray(nums1, i), MaxArray(nums2, k - i), k);\n            if (Compare(candidate, 0, ans, 0) > 0) {\n                Array.Copy(candidate, 0, ans, 0, k);\n            }\n        }\n        \n        return ans;\n    }\n    \n    private int[] Merge(int[] nums1, int[] nums2, int k) {\n        int[] ans = new int[k];\n        for (int i = 0, j = 0, r = 0; r < k; r++) {\n            ans[r] = Compare(nums1, i, nums2, j) > 0 ? nums1[i++] : nums2[j++];\n        }\n        return ans;\n    }\n    \n    private int[] MaxArray(int[] nums, int k) {\n        int n = nums.Length;\n        int[] ans = new int[k];\n        for (int i = 0, j = 0; i < n; i++) {\n            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) {\n                j--;\n            }\n            if (j < k) {\n                ans[j++] = nums[i];\n            }\n        }\n        return ans;\n    }\n    \n    private int Compare(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.Length && j < nums2.Length && nums1[i] == nums2[j]) {\n            i++;\n            j++;\n        }\n        if (i == nums1.Length) {\n            return -1;\n        }\n        if (j == nums2.Length) {\n            return 1;\n        }\n        return nums1[i] - nums2[j];\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function maxNumber(nums1: number[], nums2: number[], k: number): number[] {\n    let maxSubsequence: number[] = [];\n\n    const merge = (arr1: number[], arr2: number[]): number[] => {\n        let merged: number[] = [];\n        while (arr1.length || arr2.length) {\n            let maxArray = arr1 > arr2 ? arr1 : arr2;\n            merged.push(maxArray.shift());\n        }\n        return merged;\n    };\n\n    const getMaxSubsequence = (nums: number[], k: number): number[] => {\n        let stack: number[] = [];\n        let toPop = nums.length - k;\n\n        for (const num of nums) {\n            while (toPop > 0 && stack.length && stack[stack.length - 1] < num) {\n                stack.pop();\n                toPop--;\n            }\n            stack.push(num);\n        }\n\n        return stack.slice(0, k);\n    };\n\n    for (let i = 0; i <= k; i++) {\n        if (i <= nums1.length && k - i <= nums2.length) {\n            let subsequence = merge(getMaxSubsequence(nums1, i), getMaxSubsequence(nums2, k - i));\n            maxSubsequence = maxSubsequence.length ? subsequence > maxSubsequence ? subsequence : maxSubsequence : subsequence;\n        }\n    }\n\n    return maxSubsequence;\n};\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun maxNumber(nums1: IntArray, nums2: IntArray, \nk: Int): IntArray {\n        val m = nums1.size\n        val n = nums2.size\n        val result = IntArray(k) { 0 }\n        \n        for (i in max(0, k - n)..min(k, m)) {\n            val candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i))\n            if (isGreater(candidate, 0, result, 0)) {\n                for (j in 0 until k) {\n                    result[j] = candidate[j]\n                }\n            }\n        }\n        \n        return result\n    }\n    \n    private fun maxArray(nums: IntArray, k: Int): IntArray {\n        val n = nums.size\n        val result = IntArray(k) { 0 }\n        var top = 0\n        var remain = n - k\n        \n        for (num in nums) {\n            while (top > 0 && result[top - 1] < num && remain > 0) {\n                top--\n                remain--\n            }\n            if (top < k) {\n                result[top++] = num\n            } else {\n                remain--\n            }\n        }\n        \n        return result\n    }\n    \n    private fun merge(nums1: IntArray, nums2: IntArray): IntArray {\n        val (m, n) = nums1.size to nums2.size\n        val result = IntArray(m + n) { 0 }\n        \n        var i = 0\n        var j = 0\n        var pos = 0\n        \n        while (i < m && j < n) {\n            if (isGreater(nums1, i, nums2, j)) {\n                result[pos++] = nums1[i++]\n            } else {\n                result[pos++] = nums2[j++]\n            }\n        }\n        \n        while (i < m) {\n            result[pos++] = nums1[i++]\n        }\n        \n        while (j < n) {\n            result[pos++] = nums2[j++]\n        }\n        \n        return result\n    }\n    \n    private fun isGreater(nums1: IntArray, start1: Int, \nnums2: IntArray, start2: Int): Boolean {\n        var i = start1\n        var j = start2\n        \n        while (i < nums1.size && j < nums2.size && \nnums1[i] == nums2[j]) {\n            i++\n            j++\n        }\n        \n        return j == nums2.size || (i < nums1.size && \nnums1[i] > nums2[j])\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> maxNumber(List<int> nums1, List<int> nums2, int k) {\n    List<int> result = [];\n    for (int i = 0; i <= k; i++) {\n      if (i <= nums1.length && k - i <= nums2.length) {\n        List<int> candidate = merge(\n            getMax(nums1, i), getMax(nums2, k - i));\n        if (compare(candidate, result)) {\n          result = List.from(candidate);\n        }\n      }\n    }\n    return result;\n  }\n\n  List<int> merge(List<int> nums1, List<int> nums2) {\n    List<int> merged = [];\n    while (nums1.isNotEmpty || nums2.isNotEmpty) {\n      if (compare(nums1, nums2)) {\n        merged.add(nums1.removeAt(0));\n      } else {\n        merged.add(nums2.removeAt(0));\n      }\n    }\n    return merged;\n  }\n\n  List<int> getMax(List<int> nums, int k) {\n    List<int> result = [];\n    int toRemove = nums.length - k;\n    for (int num in nums) {\n      while (toRemove > 0 &&\n          result.isNotEmpty &&\n          result.last < num) {\n        result.removeLast();\n        toRemove--;\n      }\n      result.add(num);\n    }\n    return result.sublist(0, k);\n  }\n\n  bool compare(List<int> nums1, List<int> nums2) {\n    for (int i = 0; i < nums1.length && i < nums2.length; i++) {\n      if (nums1[i] > nums2[i]) {\n        return true;\n      }\n      if (nums1[i] < nums2[i]) {\n        return false;\n      }\n    }\n    return nums1.length > nums2.length;\n  }\n}"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def maxNumber(nums1: Array[Int], nums2: Array[Int], k: Int): Array[Int] = {\n        val m = nums1.length\n        val n = nums2.length\n        val result = new Array[Int](k)\n        \n        for (i <- Math.max(0, k - n) to Math.min(k, m)) {\n            val candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i))\n            if (greater(candidate, 0, result, 0)) {\n                for (j <- 0 until k) {\n                    result(j) = candidate(j)\n                }\n            }\n        }\n        \n        result\n    }\n    \n    def maxArray(nums: Array[Int], len: Int): Array[Int] = {\n        val result = new Array[Int](len)\n        var i = 0\n        var j = 0\n        \n        while (i < nums.length) {\n            while (j > 0 && nums(i) > result(j - 1) && i + len - j < nums.length) {\n                j -= 1\n            }\n            \n            if (j < len) {\n                result(j) = nums(i)\n                j += 1\n            }\n            \n            i += 1\n        }\n        \n        result\n    }\n    \n    def merge(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\n        val len1 = nums1.length\n        val len2 = nums2.length\n        val result = new Array[Int](len1 + len2)\n        var i = 0\n        var j = 0\n        var r = 0\n        \n        while (i < len1 && j < len2) {\n            if (greater(nums1, i, nums2, j)) {\n                result(r) = nums1(i)\n                i += 1\n            } else {\n                result(r) = nums2(j)\n                j += 1\n            }\n            r += 1\n        }\n        \n        while (i < len1) {\n            result(r) = nums1(i)\n            i += 1\n            r += 1\n        }\n        \n        while (j < len2) {\n            result(r) = nums2(j)\n            j += 1\n            r += 1\n        }\n        \n        result\n    }\n    \n    def greater(nums1: Array[Int], start1: Int, nums2: Array[Int], start2: Int): Boolean = {\n        var i = start1\n        var j = start2\n        while (i < nums1.length && j < nums2.length && nums1(i) == nums2(j)) {\n            i += 1\n            j += 1\n        }\n        j == nums2.length || (i < nums1.length && nums1(i) > nums2(j))\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn max_number(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<i32> {\n        let m = nums1.len();\n        let n = nums2.len();\n        let mut res = Vec::new();\n        \n        for i in 0..=k {\n            if i <= m as i32 && k - i <= n as i32 {\n                let max1 = Self::get_max_sub_array(&nums1, i as usize);\n                let max2 = Self::get_max_sub_array(&nums2, (k - i) as usize);\n                let merged = Self::merge_max_arrays(&max1, &max2);\n                if Self::compare_arrays(&merged, &res) {\n                    res = merged;\n                }\n            }\n        }\n        \n        res\n    }\n    \n    fn get_max_sub_array(nums: &Vec<i32>, k: usize) -> Vec<i32> {\n        let mut stack = Vec::new();\n        let mut drop_count = nums.len() - k;\n        \n        for &num in nums {\n            while drop_count > 0 && !stack.is_empty() && *stack.last().unwrap() < num {\n                stack.pop();\n                drop_count -= 1;\n            }\n            stack.push(num);\n        }\n        \n        stack.truncate(k);\n        stack\n    }\n    \n    fn merge_max_arrays(nums1: &Vec<i32>, nums2: &Vec<i32>) -> Vec<i32> {\n        let mut merged = Vec::new();\n        let mut i = 0;\n        let mut j = 0;\n        \n        while i < nums1.len() || j < nums2.len() {\n            if Self::compare_arrays(&nums1[i..].to_vec(), &nums2[j..].to_vec()) {\n                merged.push(nums1[i]);\n                i += 1;\n            } else {\n                merged.push(nums2[j]);\n                j += 1;\n            }\n        }\n        \n        merged\n    }\n    \n    fn compare_arrays(nums1: &Vec<i32>, nums2: &Vec<i32>) -> bool {\n        let min_len = nums1.len().min(nums2.len());\n        \n        for i in 0..min_len {\n            if nums1[i] > nums2[i] {\n                return true;\n            } else if nums1[i] < nums2[i] {\n                return false;\n            }\n        }\n        \n        nums1.len() > nums2.len()\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create the maximum number of length \\( k \\) from digits of two given integer arrays while preserving the relative order of the digits from the same array.\n\n### # Explanation\n\n1. **Combining Digits:** We need to select individual digits from each of the two arrays, ensuring the order is maintained, and form a large number. The challenge is to ensure the resulting combined number is the largest possible.\n   \n2. **Merging Arrays:** Merging two arrays such that the merged result is always the largest possible at each step necessitates comparing possible merges.\n   \n3. **Max Array Function:** Create a function to determine the maximum possible number of length \\( k \\) from a single array, ensuring the highest valued digits are retained.\n\n4. **Brute Force Exploration:** Brute force different combinations from both arrays and keep track of the current best possible combination.\n\n### # Pseudocode\n\n```python\ndef maxNumber(nums1, nums2, k):\n    # Helper function to merge two arrays\n    def merge(nums1, nums2):\n        merged = []\n        while nums1 or nums2:\n            if nums1 > nums2:\n                merged.append(nums1[0])\n                nums1 = nums1[1:]\n            else:\n                merged.append(nums2[0])\n                nums2 = nums2[1:]\n        return merged\n    \n    # Helper function to get the maximum number array of length k from a single array\n    def maxArray(nums, k):\n        stack = []\n        drop = len(nums) - k\n        for num in nums:\n            while drop and stack and stack[-1] < num:\n                stack.pop()\n                drop -= 1\n            stack.append(num)\n        return stack[:k]\n    \n    result = []\n    # Explore different combinations\n    for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n        merged = merge(maxArray(nums1, i), maxArray(nums2, k - i))\n        result = max(result, merged)\n    \n    return result\n\n# nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n# Expected output: [9,8,6,5,3]\nprint(maxNumber([3,4,6,5], [9,1,2,5,8,3], 5))\n\n# nums1 = [6,7], nums2 = [6,0,4], k = 5\n# Expected output: [6,7,6,0,4]\nprint(maxNumber([6,7], [6,0,4], 5))\n\n# nums1 = [3,9], nums2 = [8,9], k = 3\n# Expected output: [9,8,9]\nprint(maxNumber([3,9], [8,9], 3))\n```\n\nThis pseudocode demonstrates the necessary approach to solve the challenge: combining the arrays in a way that considers all combinations and possesses functions to pick the maximum possible digits while preserving order. The final answer is determined by exploring all possible valid digit combinations.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-create-maximum-number"
    },
    {
        "name": "Count Of Range Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-count-of-range-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        int count = 0;\n        long sum = 0;\n        multiset<long> sums;\n        sums.insert(0);\n        for (int num : nums) {\n            sum += num;\n            auto it = sums.lower_bound(sum - upper);\n            auto endIt = sums.upper_bound(sum - lower);\n            count += distance(it, endIt);\n            sums.insert(sum);\n        }\n        return count;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        // Solution code here\n        int count = 0;\n        \n        for (int i = 0; i < nums.length; i++) {\n            long sum = 0;\n            for (int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if (sum >= lower && sum <= upper) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the number of range sums within a specified interval given by `lower` and `upper`. Here, the key is to use a prefix sum array and efficiently count the sums that fall within the range using a data structure that allows us to quickly find and count the necessary sums.\n\n# Explanation\n\n1. **Prefix Sum**: We first compute the prefix sum array which helps in calculating the sum of any subarray in constant time.\n2. **Binary Search Tree/Multiset**: To efficiently count the range sums, we use a data structure that supports logarithmic time complexity for insertion and range counting, such as a multiset.\n\n3. **Iterating through the array**: As we iterate through the array, we maintain the cumulative sum and use the data structure to count the number of times a sum falls within the `lower` and `upper` bounds by leveraging the properties of the prefix sums.\n\n4. **Counting the Valid Ranges**: For each prefix sum, we look at the multiset to count how many of the previous sums fall within `(current prefix sum - upper)` and `(current prefix sum - lower)`. \n\n# Pseudocode\n\n```\n# Pseudocode\n\nfunction countRangeSum(nums, lower, upper):\n    # Initialize count to store the number of valid ranges\n    count <- 0\n    \n    # Initialize sum to keep the current prefix sum\n    sum <- 0\n    \n    # Initialize a multiset to store prefix sums\n    sums <- empty multiset\n    sums.insert(0)\n    \n    # Iterate over each number in the input array nums\n    for num in nums:\n        # Update the current prefix sum\n        sum <- sum + num\n        \n        # Use lower_bound and upper_bound to find the valid range in the multiset\n        start <- sums.lower_bound(sum - upper)\n        end <- sums.upper_bound(sum - lower)\n        \n        # Count the number of sums in the valid range and add to count\n        count <- count + distance(start, end)\n        \n        # Insert the current prefix sum into the multiset\n        sums.insert(sum)\n    \n    # Return the total count of valid ranges\n    return count\n```\n\nBy following this pseudocode, you'll be able to count the range sums efficiently within the given interval `[lower, upper]` for any input array `nums`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-count-of-range-sum"
    },
    {
        "name": "Power Of Three",
        "site": "LeetCode",
        "href": "/solution/LeetCode-power-of-three",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isPowerOfThree(int n) {\n        if (n <= 0) {\n            return false;\n        }\n        \n        return Math.log10(n) / Math.log10(3) % 1 == 0;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isPowerOfThree(self, n):\n        return n > 0 and 1162261467 % n == 0"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isPowerOfThree(int n) {\n    return n > 0 && 1162261467 % n == 0;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsPowerOfThree(int n) {\n        return n > 0 && 1162261467 % n == 0;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfThree = function(n) {\n    return n > 0 && 1162261467 % n === 0;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isPowerOfThree(n: number): boolean {\n    return n > 0 && 1162261467 % n === 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Boolean\n     */\n    function isPowerOfThree($n) {\n        if ($n <= 0) {\n            return false;\n        }\n        \n        while ($n % 3 == 0) {\n            $n /= 3;\n        }\n        \n        return $n == 1;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isPowerOfThree(_ n: Int) -> Bool {\n        if n <= 0 {\n            return false\n        }\n        \n        let maxPowerOfThree = Int(pow(3.0, (log(Double(Int32.max)) / log(3.0)).rounded(.down)))\n        \n        return maxPowerOfThree % n == 0\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isPowerOfThree(n: Int): Boolean {\n        return n > 0 && 1162261467 % n == 0\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isPowerOfThree(int n) {\n    return n > 0 && 1162261467 % n == 0;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isPowerOfThree(n int) bool {\n    return n > 0 && 1162261467 % n == 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Boolean}\ndef is_power_of_three(n)\n    n > 0 && 1162261467 % n == 0\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def isPowerOfThree(n: Int): Boolean = {\n        n > 0 && 1162261467 % n == 0\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_power_of_three(n: i32) -> bool {\n        n > 0 && 1162261467 % n == 0\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (is-power-of-three n)\n  (-> exact-integer? boolean?)\n  (cond\n    [(<= n 0) #f]\n    [(= n 1) #t]\n    [(= (remainder n 3) 0) (is-power-of-three (/ n 3))]\n    [else #f]\n  )\n)"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec is_power_of_three(N :: integer()) -> boolean().\nis_power_of_three(N) ->\n    if\n        N == 1 -> true;\n        N > 0 andalso N rem 3 == 0 -> is_power_of_three(N div 3);\n        true -> false\n    end."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given integer \\( n \\) is a power of three. In other words, we need to check if there exists an integer \\( x \\) such that \\( n = 3^x \\).\n\n# Explanation\n1. **Simple Check with Loop/Recursion**:\n   - Continuously divide \\( n \\) by 3.\n   - If \\( n \\) becomes 1, it was a power of three.\n   - If \\( n \\) becomes a non-integer at any point, it is not a power of three.\n   \n2. **Optimized Solution without Loop/Recursion**:\n   - Use logarithms: \\( n \\) is a power of three if and only if \\( \\log_3(n) \\) is an integer.\n   - Alternatively, since the given \\( n \\) is within \\( -2^{31} \\) to \\( 2^{31} - 1 \\), the largest integer power of 3 within this range is \\( 3^{19} = 1162261467 \\).\n   - Any power of three must be a divisor of 1162261467. Hence, if \\( 1162261467 \\mod n == 0 \\), then \\( n \\) is a power of three.\n\n# Pseudocode\n```\nfunction isPowerOfThree(n):\n    # Check if n is greater than 0 and 1162261467 is divisible by n\n    if n > 0 and 1162261467 % n == 0:\n        return True\n    return False\n```\n\nThis approach efficiently checks whether \\( n \\) is a power of three in constant time.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-power-of-three"
    },
    {
        "name": "Palindrome Pairs",
        "site": "LeetCode",
        "href": "/solution/LeetCode-palindrome-pairs",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        vector<vector<int>> result;\n        unordered_map<string, int> wordIndex;\n        \n        for (int i = 0; i < words.size(); ++i) {\n            wordIndex[words[i]] = i;\n        }\n        \n        for (int i = 0; i < words.size(); ++i) {\n            for (int j = 0; j <= words[i].size(); ++j) {\n                string left = words[i].substr(0, j);\n                string right = words[i].substr(j);\n                \n                if (isPalindrome(left)) {\n                    string rev_right = right;\n                    reverse(rev_right.begin(), rev_right.end());\n                    if (wordIndex.find(rev_right) != wordIndex.end() && wordIndex[rev_right] != i) {\n                        result.push_back({wordIndex[rev_right], i});\n                    }\n                }\n                \n                if (!right.empty() && isPalindrome(right)) {\n                    string rev_left = left;\n                    reverse(rev_left.begin(), rev_left.end());\n                    if (wordIndex.find(rev_left) != wordIndex.end()) {\n                        result.push_back({i, wordIndex[rev_left]});\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    bool isPalindrome(string& s) {\n        int i = 0, j = s.size() - 1;\n        while (i < j) {\n            if (s[i] != s[j]) {\n                return false;\n            }\n            ++i;\n            --j;\n        }\n        return true;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        List<List<Integer>> result = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < words.length; i++) {\n            map.put(words[i], i);\n        }\n\n        for (int i = 0; i < words.length; i++) {\n            for (int j = 0; j <= words[i].length(); j++) {\n                String left = words[i].substring(0, j);\n                String right = words[i].substring(j);\n\n                if (isPalindrome(left)) {\n                    String reversedRight = new StringBuilder(right).reverse().toString();\n                    if (map.containsKey(reversedRight) && map.get(reversedRight) != i) {\n                        result.add(Arrays.asList(map.get(reversedRight), i));\n                    }\n                }\n\n                if (right.length() > 0 && isPalindrome(right)) {\n                    String reversedLeft = new StringBuilder(left).reverse().toString();\n                    if (map.containsKey(reversedLeft) && map.get(reversedLeft) != i) {\n                        result.add(Arrays.asList(i, map.get(reversedLeft)));\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isPalindrome(char *str, int start, int end) {\n    while (start < end) {\n        if (str[start++] != str[end--]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint** palindromePairs(char **words, int wordsSize, int* returnSize, int** returnColumnSizes) {\n    int** result = (int**)malloc(wordsSize * wordsSize * sizeof(int*));\n    *returnColumnSizes = (int*)malloc(wordsSize * wordsSize * sizeof(int));\n    int count = 0;\n\n    for (int i = 0; i < wordsSize; i++) {\n        for (int j = 0; j < wordsSize; j++) {\n            if (i != j) {\n                char *concat = (char*)malloc(strlen(words[i]) + strlen(words[j]) + 1);\n                strcpy(concat, words[i]);\n                strcat(concat, words[j]);\n                if (isPalindrome(concat, 0, strlen(concat) - 1)) {\n                    (*returnColumnSizes)[count] = 2;\n                    result[count] = (int*)malloc(2 * sizeof(int));\n                    result[count][0] = i;\n                    result[count][1] = j;\n                    count++;\n                }\n                free(concat);\n            }\n        }\n    }\n\n    *returnSize = count;\n    return result;\n}\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function palindromePairs(words: string[]): number[][] {\n    const isPalindrome = (str: string): boolean => {\n        let left = 0;\n        let right = str.length - 1;\n        while (left < right) {\n            if (str[left] !== str[right]) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    };\n\n    const result: number[][] = [];\n\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n            if (i === j) continue;\n            if (isPalindrome(words[i] + words[j])) {\n                result.push([i, j]);\n            }\n        }\n    }\n\n    return result;\n};\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify all pairs of strings from a given list whose concatenation results in a palindrome. Here's how you can approach solving the problem:\n\n# Explanation\n\n1. **Data Structures**:\n   - Use an unordered map (or dictionary in Python) to store each word and its corresponding index. This will help us quickly check if the reverse of a string (or its parts) exists in the input list.\n\n2. **Iterate Over the Words**:\n   - For each word, split it into two parts: the left part and the right part, at all possible positions (including an empty split).\n   - For each split, check if the left part is a palindrome. If it is, reverse the right part and check if the reversed right part exists in the map. If it does, and its index is different from the current word\u2019s index, it means we found a valid pair.\n   - Similarly, check if the right part is a palindrome. If it is, reverse the left part and check if the reversed left part exists in the map. If it does, it again means it's a valid pair (but ensure not to count duplicates).\n\n3. **Palindrome Check**:\n   - Implement a utility function to check if a given string is a palindrome.\n\n4. **Complexity Consideration**:\n   - The algorithm aims to stay within O(sum of words[i].length) runtime complexity, which involves careful complexity management while iterating and checking palindromes.\n\n# Pseudocode\n\nHere\u2019s the structured pseudocode based on the above explanation:\n\n```plaintext\nfunction palindromePairs(words):\n    indexMap = {}\n    result = []\n\n    # Populate the index map with word and its index\n    for i from 0 to len(words)-1:\n        indexMap[words[i]] = i\n\n    # Function to check if a string is a palindrome\n    function isPalindrome(s):\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    # Check each word to find palindrome pairs\n    for i from 0 to len(words)-1:\n        word = words[i]\n        \n        # Check all possible splits of the word\n        for j from 0 to len(word):\n            left = word[0:j]\n            right = word[j:]\n\n            # If the left part is a palindrome, check the reversed right part\n            if isPalindrome(left):\n                reversedRight = reverse(right)\n                if reversedRight in indexMap and indexMap[reversedRight] != i:\n                    result.append([indexMap[reversedRight], i])\n\n            # If the right part is a palindrome, check the reversed left part and avoid duplicates\n            if j != len(word) and isPalindrome(right):\n                reversedLeft = reverse(left)\n                if reversedLeft in indexMap and indexMap[reversedLeft] != i:\n                    result.append([i, indexMap[reversedLeft]])\n\n    return result\n\nfunction reverse(s):\n    return s[::-1]  # Simple reverse string function\n```\n\nThis pseudocode efficiently addresses the problem by checking for possible palindrome pairs using palindrome checks and reversals while iterating through each word and its splits. The usage of an index map helps in achieving the desired complexity.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-palindrome-pairs"
    },
    {
        "name": "Odd Even Linked List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-odd-even-linked-list",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), \n *     next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if (!head || !head->next) {\n            return head;\n        }\n\n        ListNode *odd = head;\n        ListNode *even = head->next;\n        ListNode *evenHead = even;\n\n        while (even && even->next) {\n            odd->next = even->next;\n            odd = odd->next;\n            even->next = odd->next;\n            even = even->next;\n        }\n\n        odd->next = evenHead;\n\n        return head;\n    }\n};\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n\nclass Solution(object):\n    def oddEvenList(self, head):\n        if not head:\n            return None\n        \n        odd = head\n        even = head.next\n        even_head = even\n        \n        while even and even.next:\n            odd.next = even.next\n            odd = odd.next\n            even.next = odd.next\n            even = even.next\n        \n        odd.next = even_head\n        \n        return head\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* oddEvenList(struct ListNode* head){\n    if(head == NULL || head->next == NULL) {\n        return head;\n    }\n    \n    struct ListNode* odd = head;\n    struct ListNode* even = head->next;\n    struct ListNode* evenHead = even;\n    \n    while(even != NULL && even->next != NULL) {\n        odd->next = even->next;\n        odd = odd->next;\n        even->next = odd->next;\n        even = even->next;\n    }\n    \n    odd->next = evenHead;\n    \n    return head;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val = 0, ListNode next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode OddEvenList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenHead = even;\n        \n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        \n        odd.next = evenHead;\n        \n        return head;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nvar oddEvenList = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n\n    let odd = head;\n    let even = head.next;\n    let evenHead = even;\n\n    while (even !== null && even.next !== null) {\n        odd.next = even.next;\n        odd = odd.next;\n        even.next = odd.next;\n        even = even.next;\n    }\n\n    odd.next = evenHead;\n\n    return head;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction oddEvenList(head: ListNode | null): ListNode | null {\n    if (!head) return head;\n    \n    let odd = head;\n    let even = head.next;\n    let evenHead = even;\n    \n    while (even !== null && even.next !== null) {\n        odd.next = even.next;\n        odd = odd.next;\n        even.next = odd.next;\n        even = even.next;\n    }\n    \n    odd.next = evenHead;\n    \n    return head;\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun oddEvenList(head: ListNode?): ListNode? {\n        if (head?.next == null) {\n            return head\n        }\n        \n        var odd = head\n        var even = head.next\n        var evenHead = even\n        \n        while (even?.next != null) {\n            odd?.next = even.next\n            odd = odd?.next\n            even.next = odd?.next\n            even = even.next\n        }\n        \n        odd?.next = evenHead\n        \n        return head\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc oddEvenList(head *ListNode) *ListNode {\n    if head == nil {\n        return nil\n    }\n    \n    odd := head\n    even := head.Next\n    evenHead := even\n    \n    for even != nil && even.Next != nil {\n        odd.Next = even.Next\n        odd = odd.Next\n        even.Next = odd.Next\n        even = even.Next\n    }\n    \n    odd.Next = evenHead\n    return head\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n# @param {ListNode} head\n# @return {ListNode}\ndef odd_even_list(head)\n    return head if head.nil? || head.next.nil?\n\n    odd_head = head\n    even_head = head.next\n    even_start = even_head\n\n    while even_head && even_head.next\n        odd_head.next = even_head.next\n        odd_head = odd_head.next\n        even_head.next = odd_head.next\n        even_head = even_head.next\n    end\n\n    odd_head.next = even_start\n    head\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n * }\n */\nobject Solution {\n    def oddEvenList(head: ListNode): ListNode = {\n        if (head == null || head.next == null) return head\n        var odd = head\n        var even = head.next\n        var evenHead = even\n        while (even != null && even.next != null) {\n            odd.next = even.next\n            odd = odd.next\n            even.next = odd.next\n            even = even.next\n        }\n        odd.next = evenHead\n        head\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to rearrange the nodes in a singly linked list such that all nodes at odd indices come before all nodes at even indices while maintaining their relative order. We also must ensure the solution operates in O(1) extra space complexity and O(n) time complexity.\n\nHere's a step-by-step approach:\n\n# Explanation\n\n1. **Identify Special Cases**: If the linked list is empty or has only one element, return it as-is because no rearrangement is needed.\n\n2. **Initialize Pointers**:\n   - `odd` to point to the head (first element, which is considered odd).\n   - `even` to point to the second element (considered even).\n   - `even_head` to keep track of the starting point of the even list, so we can later attach it after the odd list.\n\n3. **Rearrange Nodes**:\n   - Iterate through the list using the `even` pointer. The loop runs as long as `even` and `even.next` are not null.\n   - Re-link the `odd` nodes to the next odd node, and then move the `odd` pointer.\n   - Re-link the `even` nodes to the next even node, and then move the `even` pointer.\n\n4. **Combine Lists**:\n   - After exiting the loop, attach the even list, which starts at `even_head`, to the end of the odd list.\n\n5. **Return the Modified List**: The head of the list now points to the re-ordered list.\n\n# Pseudocode\n\n```\n# Definition for the singly-linked list node class\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def oddEvenList(self, head):\n        # Special case: if list is empty or has only one node, return it as it is\n        if not head:\n            return None\n        \n        # Initialize pointers\n        odd = head\n        even = head.next\n        even_head = even\n        \n        # Loop to reposition the odd and even nodes\n        while even and even.next:\n            odd.next = even.next       # Link odd node to the next odd node\n            odd = odd.next             # Move odd pointer to the next odd node\n            even.next = odd.next       # Link even node to the next even node\n            even = even.next           # Move even pointer to the next even node\n        \n        # Attach the even list after the odd list\n        odd.next = even_head\n        \n        # Return the head of the reordered list\n        return head\n```\n\nThis pseudocode provides a structured plan to implement the solution while ensuring the constraints of O(1) space complexity and O(n) time complexity are met.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-odd-even-linked-list"
    },
    {
        "name": "Longest Increasing Path In A Matrix",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-increasing-path-in-a-matrix",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int longestIncreasingPath(int[][] matrix) {\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int[][] memo = new int[m][n];\n        int max = 0;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                max = Math.max(max, dfs(matrix, i, j, Integer.MIN_VALUE, memo));\n            }\n        }\n        \n        return max;\n    }\n    \n    private int dfs(int[][] matrix, int i, int j, int prev, int[][] memo) {\n        if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length || matrix[i][j] <= prev) {\n            return 0;\n        }\n        \n        if (memo[i][j] != 0) {\n            return memo[i][j];\n        }\n        \n        int curr = matrix[i][j];\n        int path = 0;\n        path = Math.max(path, dfs(matrix, i + 1, j, curr, memo));\n        path = Math.max(path, dfs(matrix, i - 1, j, curr, memo));\n        path = Math.max(path, dfs(matrix, i, j + 1, curr, memo));\n        path = Math.max(path, dfs(matrix, i, j - 1, curr, memo));\n        \n        memo[i][j] = 1 + path;\n        return memo[i][j];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"        \n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                dp[i][j] = 1 + max(\n                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,\n                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,\n                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,\n                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0\n                )\n            return dp[i][j]\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        M, N = len(matrix), len(matrix[0])\n        dp = [[0] * N for _ in range(M)]\n        \n        return max(dfs(x, y) for x in range(M) for y in range(N))"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize) {\n    if (matrix == NULL || matrixSize == 0) return 0;\n    \n    int m = matrixSize, n = matrixColSize[0];\n    int maxLen = 0;\n    int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    int** dp = (int**)malloc(m * sizeof(int*));\n    for (int i = 0; i < m; i++) {\n        dp[i] = (int*)malloc(n * sizeof(int));\n        memset(dp[i], 0, n * sizeof(int));\n    }\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            maxLen = fmax(maxLen, dfs(matrix, m, n, i, j, dp, dirs));\n        }\n    }\n    \n    for (int i = 0; i < m; i++) {\n         free(dp[i]);\n    }\n    free(dp);\n    \n    return maxLen;\n}\n\nint dfs(int** matrix, int m, int n, int i, int j, int** dp, int dirs[4][2]) {\n    if (dp[i][j] > 0) return dp[i][j];\n    \n    int maxLen = 1;\n    for (int k = 0; k < 4; k++) {\n        int x = i + dirs[k][0], y = j + dirs[k][1];\n        if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {\n            maxLen = fmax(maxLen, 1 + dfs(matrix, m, n, x, y, dp, dirs));\n        }\n    }\n    \n    dp[i][j] = maxLen;\n    return maxLen;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LongestIncreasingPath(int[][] matrix) \n    {\n        // Check if the matrix is empty or null\n        if (matrix == null || matrix.Length == 0)\n            return 0;\n        \n        int rows = matrix.Length;\n        int cols = matrix[0].Length;\n        \n        int[][] cache = new int[rows][];\n        for (int i = 0; i < rows; i++)\n        {\n            cache[i] = new int[cols];\n        }\n        \n        int maxPath = 0;\n        \n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < cols; j++)\n            {\n                maxPath = Math.Max(maxPath, DFS(matrix, i, j, cache));\n            }\n        }\n        \n        return maxPath;\n    }\n    \n    private int DFS(int[][] matrix, int i, int j, int[][] cache)\n    {\n        if (cache[i][j] != 0)\n            return cache[i][j];\n        \n        int[][] directions = {new int[]{0, 1}, new int[]{0, -1}, new int[]{1, 0}, new int[]{-1, 0}};\n        int max = 1;\n        \n        foreach (int[] dir in directions)\n        {\n            int x = i + dir[0];\n            int y = j + dir[1];\n            \n            if (x >= 0 && x < matrix.Length && y >= 0 && y < matrix[0].Length && matrix[x][y] > matrix[i][j])\n            {\n                max = Math.Max(max, 1 + DFS(matrix, x, y, cache));\n            }\n        }\n        \n        cache[i][j] = max;\n        \n        return max;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nconst longestIncreasingPath = (matrix) => {\n    const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  \n    const dfs = (i, j, matrix, dp) => {\n        if (dp[i][j] !== 0) return dp[i][j];\n        \n        let max = 1;\n        for (const [dx, dy] of dirs) {\n            const x = i + dx;\n            const y = j + dy;\n            if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[x][y] <= matrix[i][j]) continue;\n\n            const len = 1 + dfs(x, y, matrix, dp);\n            max = Math.max(max, len);\n        }\n        \n        dp[i][j] = max;\n        return max;\n    };\n  \n    if (!matrix || matrix.length === 0) return 0;\n  \n    const m = matrix.length;\n    const n = matrix[0].length;\n    let result = 1;\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\n  \n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            result = Math.max(result, dfs(i, j, matrix, dp));\n        }\n    }\n  \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function longestIncreasingPath(matrix: number[][]): number {\n    if (matrix.length === 0) return 0;\n    \n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    \n    const memo: number[][] = Array.from({ length: rows }, () => new Array(cols).fill(0));\n    \n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    \n    const dfs = (row: number, col: number): number => {\n        if (memo[row][col] !== 0) return memo[row][col];\n        \n        let max = 1;\n        \n        for (const [dx, dy] of directions) {\n            const newRow = row + dx;\n            const newCol = col + dy;\n            \n            if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols || matrix[newRow][newCol] <= matrix[row][col]) {\n                continue;\n            }\n            \n            const len = 1 + dfs(newRow, newCol);\n            max = Math.max(max, len);\n        }\n        \n        memo[row][col] = max;\n        return max;\n    };\n    \n    let result = 0;\n    \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            result = Math.max(result, dfs(i, j));\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func longestIncreasingPath(_ matrix: [[Int]]) -> Int {\n        guard matrix.count > 0, matrix[0].count > 0 else {\n            return 0\n        }\n        \n        let m = matrix.count\n        let n = matrix[0].count\n        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n        var result = 0\n        \n        let dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n        \n        func dfs(_ i: Int, _ j: Int) -> Int {\n            if dp[i][j] != 0 {\n                return dp[i][j]\n            }\n            \n            for dir in dirs {\n                let x = i + dir[0]\n                let y = j + dir[1]\n                if x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j] {\n                    dp[i][j] = max(dp[i][j], dfs(x, y))\n                }\n            }\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        }\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                result = max(result, dfs(i, j))\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun longestIncreasingPath(matrix: Array<IntArray>): Int {\n        val dirs = arrayOf(intArrayOf(0, 1), intArrayOf(0, -1), intArrayOf(1, 0), intArrayOf(-1, 0))\n        if (matrix.isEmpty() || matrix[0].isEmpty()) return 0\n        \n        val m = matrix.size\n        val n = matrix[0].size\n        val cache = Array(m) { IntArray(n) }\n        \n        fun dfs(x: Int, y: Int): Int {\n            if (cache[x][y] != 0) {\n                return cache[x][y]\n            }\n            \n            var max = 1\n            for (dir in dirs) {\n                val nextX = x + dir[0]\n                val nextY = y + dir[1]\n                if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n || matrix[nextX][nextY] <= matrix[x][y]) {\n                    continue\n                }\n                val len = 1 + dfs(nextX, nextY)\n                max = maxOf(max, len)\n            }\n            \n            cache[x][y] = max\n            return max\n        }\n        \n        var result = 0\n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                result = maxOf(result, dfs(i, j))\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int longestIncreasingPath(List<List<int>> matrix) {\n    if (matrix.isEmpty) return 0;\n\n    int maxPath = 0;\n    List<List<int>> memo = List.generate(matrix.length, (index) => List.filled(matrix[0].length, 0));\n\n    for (int i = 0; i < matrix.length; i++) {\n      for (int j = 0; j < matrix[0].length; j++) {\n        maxPath = max(maxPath, dfs(matrix, i, j, memo));\n      }\n    }\n\n    return maxPath;\n  }\n\n  int dfs(List<List<int>> matrix, int i, int j, List<List<int>> memo) {\n    if (memo[i][j] != 0) return memo[i][j];\n\n    int maxPath = 1;\n    List<int> directionsX = [0, 0, -1, 1];\n    List<int> directionsY = [-1, 1, 0, 0];\n\n    for (int k = 0; k < 4; k++) {\n      int x = i + directionsX[k];\n      int y = j + directionsY[k];\n\n      if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[x][y] <= matrix[i][j]) {\n        continue;\n      }\n\n      maxPath = max(maxPath, 1 + dfs(matrix, x, y, memo));\n    }\n\n    memo[i][j] = maxPath;\n    return maxPath;\n  }\n\n  int max(int a, int b) => a > b ? a : b;\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func longestIncreasingPath(matrix [][]int) int {\n    if len(matrix) == 0 || len(matrix[0]) == 0 {\n        return 0\n    }\n\n    rows := len(matrix)\n    cols := len(matrix[0])\n    dirs := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    dp := make([][]int, rows)\n    for i := range dp {\n        dp[i] = make([]int, cols)\n    }\n\n    var dfs func(int, int) int\n    dfs = func(x, y int) int {\n        if dp[x][y] != 0 {\n            return dp[x][y]\n        }\n\n        dp[x][y]++\n        for _, dir := range dirs {\n            nx, ny := x+dir[0], y+dir[1]\n            if 0 <= nx && nx < rows && 0 <= ny && ny < cols && matrix[nx][ny] > matrix[x][y] {\n                dp[x][y] = max(dp[x][y], 1+dfs(nx, ny))\n            }\n        }\n        return dp[x][y]\n    }\n\n    res := 0\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            res = max(res, dfs(i, j))\n        }\n    }\n\n    return res\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} matrix\n# @return {Integer}\ndef longest_increasing_path(matrix)\n    return 0 if matrix.empty? || matrix[0].empty?\n    \n    m = matrix.length\n    n = matrix[0].length\n    directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    dp = Array.new(m) { Array.new(n, 0) }\n    \n    def dfs(matrix, dp, i, j, m, n, directions)\n        return dp[i][j] if dp[i][j] != 0\n        \n        max = 1\n        directions.each do |dx, dy|\n            x = i + dx\n            y = j + dy\n            \n            if x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]\n                max = [max, 1 + dfs(matrix, dp, x, y, m, n, directions)].max\n            end\n        end\n        \n        dp[i][j] = max\n        return dp[i][j]\n    end\n    \n    result = 1\n    (0...m).each do |i|\n        (0...n).each do |j|\n            result = [result, dfs(matrix, dp, i, j, m, n, directions)].max\n        end\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def longestIncreasingPath(matrix: Array[Array[Int]]): Int = {\n        val rows = matrix.length\n        val cols = matrix(0).length\n        val directions = List((0, 1), (0, -1), (1, 0), (-1, 0))\n\n        def dfs(x: Int, y: Int, memo: Array[Array[Int]]): Int = {\n            if (memo(x)(y) != 0) return memo(x)(y)\n            var max = 1\n            for ((dx, dy) <- directions) {\n                val nextX = x + dx\n                val nextY = y + dy\n                if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix(nextX)(nextY) > matrix(x)(y)) {\n                    max = Math.max(max, 1 + dfs(nextX, nextY, memo))\n                }\n            }\n            memo(x)(y) = max\n            max\n        }\n\n        var result = 0\n        val memo = Array.ofDim[Int](rows, cols)\n        for (i <- 0 until rows; j <- 0 until cols) {\n            result = Math.max(result, dfs(i, j, memo))\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn longest_increasing_path(matrix: Vec<Vec<i32>>) -> i32 {\n        let m = matrix.len();\n        let n = matrix[0].len();\n        \n        let mut dp = vec![vec![0; n]; m];\n        let directions = vec![(0, 1), (0, -1), (1, 0), (-1, 0)];\n        \n        fn dfs(matrix: &Vec<Vec<i32>>, dp: &mut Vec<Vec<i32>>, x: usize, y: usize, m: usize, n: usize) -> i32 {\n            if dp[x][y] != 0 {\n                return dp[x][y];\n            }\n            \n            let mut max_path = 1;\n            for dir in [(0, 1), (0, -1), (1, 0), (-1, 0)].iter() {\n                let new_x = x as i32 + dir.0;\n                let new_y = y as i32 + dir.1;\n                \n                if new_x >= 0 && new_x < m as i32 && new_y >= 0 && new_y < n as i32 && matrix[new_x as usize][new_y as usize] > matrix[x][y] {\n                    let path_len = 1 + dfs(matrix, dp, new_x as usize, new_y as usize, m, n);\n                    max_path = max_path.max(path_len);\n                }\n            }\n            \n            dp[x][y] = max_path;\n            return max_path;\n        }\n        \n        let mut result = 0;\n        for i in 0..m {\n            for j in 0..n {\n                result = result.max(dfs(&matrix, &mut dp, i, j, m, n));\n            }\n        }\n        \n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the longest increasing path in a given matrix where we can move in four directions: left, right, up, or down. We will leverage Depth-First Search (DFS) combined with memoization to keep track of the paths already explored to optimize our solution.\n\n### # Explanation:\n1. **DFS with Memoization:** We will use DFS to explore all possible paths from each cell and memoization to store the length of the longest increasing path starting from that cell.\n2. **Base Case:** The base case for our DFS is when we reach a cell for which we already have a computed path length in our memoization table.\n3. **Directional Movement:** For each cell, we attempt to move in the four possible directions (up, down, left, right) but only proceed if the moving to the next cell results in a strictly increasing sequence.\n4. **Memoization Table:** We maintain a table `dp` where `dp[i][j]` holds the length of the longest increasing path starting from cell `(i, j)`.\n5. **Boundary Conditions:** We ensure that our moves do not go out of the bounds of the matrix.\n6. **Initialization:** We initialize the dimensions of the matrix and the memoization table, and we handle edge cases where the matrix might be empty.\n7. **Result:** By computing the longest increasing path starting from each cell and taking the maximum, we get our result.\n\n### # Pseudocode:\n```\nfunction longestIncreasingPath(matrix):\n    if matrix is empty or matrix[0] is empty:\n        return 0\n    \n    M, N = dimensions of the matrix\n    dp = 2D array of size MxN initialized to 0\n    \n    function dfs(i, j):\n        if dp[i][j] is not 0:\n            return dp[i][j]\n        \n        val = matrix[i][j]\n        longest_path = 1\n        \n        if i > 0 and val > matrix[i - 1][j]:\n            longest_path = max(longest_path, 1 + dfs(i - 1, j))\n        if i < M - 1 and val > matrix[i + 1][j]:\n            longest_path = max(longest_path, 1 + dfs(i + 1, j))\n        if j > 0 and val > matrix[i][j - 1]:\n            longest_path = max(longest_path, 1 + dfs(i, j - 1))\n        if j < N - 1 and val > matrix[i][j + 1]:\n            longest_path = max(longest_path, 1 + dfs(i, j + 1))\n        \n        dp[i][j] = longest_path\n        return dp[i][j]\n    \n    max_length = 0\n    for x in range(M):\n        for y in range(N):\n            max_length = max(max_length, dfs(x, y))\n    \n    return max_length\n```\n\nThis pseudocode outlines the approach to solve the challenge of finding the longest increasing path in a given matrix using DFS with memoization. It guarantees that we explore each cell's path only once, resulting in an optimal solution.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-increasing-path-in-a-matrix"
    },
    {
        "name": "Patching Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-patching-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        long reach = 1;\n        int patches = 0;\n        int i = 0;\n        \n        while (reach <= n) {\n            if (i < nums.size() && nums[i] <= reach) {\n                reach += nums[i];\n                i++;\n            } else {\n                reach += reach;\n                patches++;\n            }\n        }\n        \n        return patches;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minPatches(int[] nums, int n) {\n        long missing = 1;\n        int patches = 0;\n        int i = 0;\n\n        while (missing <= n) {\n            if (i < nums.length && nums[i] <= missing) {\n                missing += nums[i];\n                i++;\n            } else {\n                missing += missing;\n                patches++;\n            }\n        }\n\n        return patches;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minPatches(self, nums, n):\n        patches = 0\n        covered = 0\n        i = 0\n\n        while covered < n:\n            if i < len(nums) and nums[i] <= covered + 1:\n                covered += nums[i]\n                i += 1\n            else:\n                patches += 1\n                covered += covered + 1\n\n        return patches"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int minPatches(int* nums, int numsSize, int n) {\n    long miss = 1, added = 0, i = 0;\n    \n    while (miss <= n) {\n        if (i < numsSize && nums[i] <= miss) {\n            miss += nums[i++];\n        } else {\n            miss += miss;\n            added++;\n        }\n    }\n    \n    return added;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinPatches(int[] nums, int n) {\n        long miss = 1;\n        int patches = 0;\n        int i = 0;\n        \n        while(miss <= n){\n            if(i < nums.Length && nums[i] <= miss){\n                miss += nums[i];\n                i++;\n            } else {\n                miss += miss;\n                patches++;\n            }\n        }\n        \n        return patches;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number}\n */\nvar minPatches = function(nums, n) {\n    let patches = 0;\n    let missing = 1;\n    let i = 0;\n    \n    while (missing <= n) {\n        if (i < nums.length && nums[i] <= missing) {\n            missing += nums[i];\n            i++;\n        } else {\n            missing += missing;\n            patches++;\n        }\n    }\n    \n    return patches;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minPatches(nums: number[], n: number): number {\n    let patches = 0;\n    let missing = 1;\n    let i = 0;\n\n    while (missing <= n) {\n        if (i < nums.length && nums[i] <= missing) {\n            missing += nums[i];\n            i++;\n        } else {\n            missing += missing;\n            patches++;\n        }\n    }\n\n    return patches;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $n\n     * @return Integer\n     */\n    function minPatches($nums, $n) {\n        $patches = 0;\n        $covered = 0;\n        $i = 0;\n\n        while ($covered < $n) {\n            if ($i < count($nums) && $nums[$i] <= $covered + 1) {\n                $covered += $nums[$i];\n                $i++;\n            } else {\n                $covered += $covered + 1;\n                $patches++;\n            }\n        }\n        \n        return $patches;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minPatches(_ nums: [Int], _ n: Int) -> Int {\n        var patches = 0\n        var missing = 1\n        var i = 0\n        \n        while missing <= n {\n            if i < nums.count && nums[i] <= missing {\n                missing += nums[i]\n                i += 1\n            } else {\n                missing *= 2\n                patches += 1\n            }\n        }\n        \n        return patches\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minPatches(nums: IntArray, n: Int): Int {\n        var patches = 0\n        var index = 0\n        var coveredRange: Long = 0\n        \n        while (coveredRange < n) {\n            if (index < nums.size && nums[index] <= coveredRange + 1) {\n                coveredRange += nums[index].toLong()\n                index++\n            } else {\n                coveredRange += coveredRange + 1\n                patches++\n            }\n        }\n        \n        return patches\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int minPatches(List<int> nums, int n) {\n      int patches = 0;\n      int i = 0;\n      int miss = 1;\n      \n      while (miss <= n) {\n          if (i < nums.length && nums[i] <= miss) {\n              miss += nums[i];\n              i++;\n          } else {\n              miss += miss;\n              patches++;\n          }\n      }\n      \n      return patches;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minPatches(nums []int, n int) int {\n    patches := 0\n    missing := 1\n    index := 0\n\n    for missing <= n {\n        if index < len(nums) && nums[index] <= missing {\n            missing += nums[index]\n            index++\n        } else {\n            missing += missing\n            patches++\n        }\n    }\n\n    return patches\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} n\n# @return {Integer}\ndef min_patches(nums, n)\n    patches = 0\n    missed_num = 1\n    i = 0\n    \n    while missed_num <= n\n        if i < nums.length && nums[i] <= missed_num\n            missed_num += nums[i]\n            i += 1\n        else\n            missed_num *= 2\n            patches += 1\n        end\n    end\n    \n    patches\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minPatches(nums: Array[Int], n: Int): Int = {\n        var patches = 0\n        var miss = 1L\n        var i = 0\n        \n        while (miss <= n) {\n            if (i < nums.length && nums(i) <= miss) {\n                miss += nums(i)\n                i += 1\n            } else {\n                miss += miss\n                patches += 1\n            }\n        }\n        \n        patches\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the minimum number of patches required to ensure that any number in the range [1, n] can be formed by the sum of some elements in the given sorted integer array.\n\n# Explanation\n\nThe idea is to keep a variable `covered` that represents the maximum number we can form with the current elements in the array (including the patches we add). Initially, `covered` is 0 because we cannot form any number with an empty set. We iterate through the array and compare each element with `covered + 1`. \n\n- If the current array element is less than or equal to `covered + 1`, it means we can use this element to extend the range of numbers we can form. Thus, we add this element to `covered` and move to the next element.\n- If the current array element is greater than `covered + 1`, it means there's a gap, and we need to patch the array by adding `covered + 1` to ensure we can form this number. This patch will double the number of elements we can cover (`covered` becomes `2 * covered + 1`). We increase the patch count as well.\n\nWe continue this process until `covered` reaches or exceeds `n`.\n\n# Pseudocode\n\n```\nfunction minPatches(nums, n):\n    patches = 0\n    covered = 0\n    i = 0\n    \n    while covered < n:\n        if i < length of nums and nums[i] <= covered + 1:\n            covered = covered + nums[i]\n            i = i + 1\n        else:\n            patches = patches + 1\n            covered = covered + covered + 1\n            \n    return patches\n```\n\nThis pseudocode efficiently handles the challenge by ensuring coverage of all numbers in the range [1, n] while keeping track of how many patches (additional numbers) are required. The complexity is linear regarding the number of elements in the input array, making it scalable for large values of `n`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-patching-array"
    },
    {
        "name": "Verify Preorder Serialization Of A Binary Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-verify-preorder-serialization-of-a-binary-tree",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        stack<string> nodes;\n        stringstream ss(preorder);\n        string node;\n        \n        while (getline(ss, node, ',')) {\n            while (!nodes.empty() && node == \"#\" && nodes.top() == \"#\") {\n                nodes.pop();\n                \n                if (nodes.empty()) {\n                    return false;\n                }\n                \n                nodes.pop();\n            }\n            \n            nodes.push(node);\n        }\n        \n        return nodes.size() == 1 && nodes.top() == \"#\";\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isValidSerialization(String preorder) {\n        int slots = 1;\n        String[] nodes = preorder.split(\",\");\n        \n        for (String node : nodes) {\n            slots--;\n            \n            if (slots < 0) {\n                return false;\n            }\n            \n            if (!node.equals(\"#\")) {\n                slots += 2;\n            }\n        }\n        \n        return slots == 0;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isValidSerialization(self, preorder):\n        \"\"\"\n        :type preorder: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        for node in preorder.split(\",\"):\n            stack.append(node)\n            while len(stack) >= 3 and stack[-1] == stack[-2] == \"#\" and stack[-3] != \"#\":\n                stack.pop()\n                stack.pop()\n                stack.pop()\n                stack.append(\"#\")\n         \n        return len(stack) == 1 and stack[0] == \"#\""
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isValidSerialization(char* preorder) {\n    int slots = 1;\n    char* token = strtok(preorder, \",\");\n    \n    while (token != NULL) {\n        if (slots == 0) {\n            return false;\n        }\n        \n        if (strcmp(token, \"#\") == 0) {\n            slots--;\n        } else {\n            slots++;\n        }\n        \n        token = strtok(NULL, \",\");\n    }\n    \n    return slots == 0;\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} preorder\n * @return {boolean}\n */\nconst isValidSerialization = (preorder) => {\n    const nodes = preorder.split(',');\n    let slots = 1;\n    \n    for (let node of nodes) {\n        if (slots <= 0) {\n            return false;\n        }\n        \n        if (node === '#') {\n            slots--;\n        } else {\n            slots++;\n        }\n    }\n    \n    return slots === 0;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isValidSerialization(preorder: string): boolean {\n    const nodes = preorder.split(\",\");\n    let slots = 1;\n    \n    for (let node of nodes) {\n        slots--;\n        \n        if (slots < 0) {\n            return false;\n        }\n        \n        if (node !== \"#\") {\n            slots += 2;\n        }\n    }\n    \n    return slots === 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $preorder\n     * @return Boolean\n     */\n    function isValidSerialization($preorder) {\n        $slots = 1;\n        $nodes = explode(\",\", $preorder);\n        foreach ($nodes as $node) {\n            $slots--;\n            if ($slots < 0) {\n                return false;\n            }\n            if ($node != \"#\") {\n                $slots += 2;\n            }\n        }\n        return $slots == 0;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isValidSerialization(_ preorder: String) -> Bool {\n        var slots = 1\n        let nodes = preorder.split(separator: \",\")\n        \n        for node in nodes {\n            slots -= 1\n            if slots < 0 {\n                return false\n            }\n            \n            if node != \"#\" {\n                slots += 2\n            }\n        }\n        \n        return slots == 0\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isValidSerialization(preorder: String): Boolean {\n        var slots = 1\n        for (node in preorder.split(\",\")) {\n            if (slots == 0) return false\n            if (node == \"#\") {\n                slots--\n            } else {\n                slots++\n            }\n        }\n        return slots == 0\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isValidSerialization(String preorder) {\n    List<String> nodes = preorder.split(',');\n    \n    int diff = 1;\n    \n    for (int i = 0; i < nodes.length; i++) {\n      if (--diff < 0) return false;\n      \n      if (nodes[i] != '#') {\n        diff += 2;\n      }\n    }\n    \n    return diff == 0;\n  }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} preorder\n# @return {Boolean}\ndef is_valid_serialization(preorder)\n    nodes = preorder.split(',')\n    slots = 1\n    \n    nodes.each do |node|\n        slots -= 1\n        return false if slots < 0\n        \n        if node != '#'\n            slots += 2\n        end\n    end\n    \n    slots == 0\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_valid_serialization(preorder: String) -> bool {\n        let mut slots = 1;\n        for node in preorder.split(',') {\n            if slots == 0 {\n                return false;\n            }\n            if node == \"#\" {\n                slots -= 1;\n            } else {\n                slots += 1;\n            }\n        }\n        slots == 0\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to validate the preorder traversal serialization of a binary tree by checking the given string of comma-separated values. The problem requires that we do not reconstruct the tree but instead use a stack-based approach to simulate the validation process.\n\nHere\u2019s a structured explanation of the methodology involved:\n\n# Explanation\n1. **Input Parsing**: The input is a single string consisting of node values and '#' characters, each value separated by a comma. The node values represent the preorder traversal of a binary tree.\n2. **Stack Usage**: Use a stack to keep track of the elements as we process them. The stack helps to manage the structure of the tree implicitly.\n3. **Validation Rule**:\n   - Iterate through each node value from the input string.\n   - Append each node value to the stack.\n   - After appending, check if the last three items in the stack match the pattern of a leaf node in the tree (i.e., two '#' symbols followed by a non-# symbol). If they do, it means we've completed a subtree, and we can reduce this part to a single '#' in the stack.\n4. **Final Validation**: After processing all elements, the stack should ideally have just one element, which is a '#'. This indicates that the entire tree structure has been validated correctly.\n\n# Pseudocode\n```plaintext\n# Function to validate preorder serialization of binary tree\ndef isValidSerialization(preorder):\n    # Initialize an empty stack\n    stack = []\n    \n    # Split the input string by commas to process each node value\n    for node in preorder.split(\",\"):\n        # Push the current node value onto the stack\n        stack.append(node)\n        \n        # Check if the last three elements on the stack form a pattern of a complete subtree\n        while len(stack) >= 3 and stack[-1] == stack[-2] == \"#\" and stack[-3] != \"#\":\n            # Pop the two '#' elements which signify null child nodes\n            stack.pop()\n            stack.pop()\n            # Pop the root node of the subtree\n            stack.pop()\n            # Replace the completed subtree with '#'\n            stack.append(\"#\")\n    \n    # The final serialized tree should be reduced to a single '#'\n    return len(stack) == 1 and stack[0] == \"#\"\n```\n\nThis pseudocode outlines the process of verifying the preorder serialization without constructing the actual tree. The use of a stack efficiently manages the node values and helps in simplifying subtrees as we traverse through the input string.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-verify-preorder-serialization-of-a-binary-tree"
    },
    {
        "name": "Reconstruct Itinerary",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reconstruct-itinerary",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        unordered_map<string, multiset<string>> graph;\n        vector<string> result;\n        \n        for (const auto& ticket : tickets) {\n            graph[ticket[0]].insert(ticket[1]);\n        }\n        \n        function<void(string)> dfs = [&](string src) {\n            while (!graph[src].empty()) {\n                string dest = *graph[src].begin();\n                graph[src].erase(graph[src].begin());\n                dfs(dest);\n            }\n            result.push_back(src);\n        };\n        \n        dfs(\"JFK\");\n        \n        reverse(result.begin(), result.end());\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\n        List<String> result = new ArrayList<>();\n        \n        for (List<String> ticket : tickets) {\n            String from = ticket.get(0);\n            String to = ticket.get(1);\n            graph.putIfAbsent(from, new PriorityQueue<>());\n            graph.get(from).offer(to);\n        }\n        \n        dfs(\"JFK\", graph, result);\n        \n        return result;\n    }\n    \n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, List<String> result) {\n        PriorityQueue<String> pq = graph.get(airport);\n        \n        while (pq != null && !pq.isEmpty()) {\n            dfs(pq.poll(), graph, result);\n        }\n        \n        result.add(0, airport);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findItinerary(self, tickets):\n        def dfs(curr):\n            while graph[curr]:\n                dfs(graph[curr].pop(0))\n            result.append(curr)\n        \n        graph = collections.defaultdict(list)\n        for ticket in sorted(tickets):\n            graph[ticket[0]].append(ticket[1])\n        \n        result = []\n        dfs(\"JFK\")\n        \n        return result[::-1]"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> FindItinerary(IList<IList<string>> tickets) {\n        var graph = new Dictionary<string, List<string>>();\n        var result = new List<string>();\n\n        foreach (var ticket in tickets) {\n            if (!graph.ContainsKey(ticket[0])) {\n                graph[ticket[0]] = new List<string>();\n            }\n            graph[ticket[0]].Add(ticket[1]);\n        }\n\n        foreach (var pair in graph) {\n            pair.Value.Sort();\n        }\n\n        Visit(\"JFK\");\n\n        result.Reverse();\n        return result;\n\n        void Visit(string airport) {\n            while (graph.ContainsKey(airport) && graph[airport].Count > 0) {\n                var dest = graph[airport][0];\n                graph[airport].RemoveAt(0);\n                Visit(dest);\n            }\n            result.Add(airport);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string[][]} tickets\n * @return {string[]}\n */\nvar findItinerary = function(tickets) {\n    let adjList = {};\n    for (let ticket of tickets) {\n        if (!adjList[ticket[0]]) {\n            adjList[ticket[0]] = [];\n        }\n        adjList[ticket[0]].push(ticket[1]);\n    }\n\n    for (let list in adjList) {\n        adjList[list].sort();\n    }\n\n    let result = [];\n\n    const dfs = (node) => {\n        let neighbors = adjList[node];\n        while (neighbors && neighbors.length) {\n            dfs(neighbors.shift());\n        }\n        result.unshift(node);\n    };\n\n    dfs('JFK');\n\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findItinerary(tickets: string[][]): string[] {\n    const graph: { [key: string]: string[] } = {};\n    const result: string[] = [];\n\n    tickets.forEach(([from, to]) => {\n        if (graph[from]) {\n            graph[from].push(to);\n        } else {\n            graph[from] = [to];\n        }\n    });\n\n    Object.values(graph).forEach((connections) => connections.sort());\n\n    const dfs = (node: string) => {\n        while (graph[node] && graph[node].length > 0) {\n            const next = graph[node].shift();\n            dfs(next);\n        }\n        result.unshift(node);\n    };\n\n    dfs('JFK');\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $tickets\n     * @return String[]\n     */\n    function findItinerary($tickets) {\n        $graph = [];\n        foreach ($tickets as $ticket) {\n            $from = $ticket[0];\n            $to = $ticket[1];\n            if (!isset($graph[$from])) {\n                $graph[$from] = [];\n            }\n            $graph[$from][] = $to;\n        }\n        \n        foreach ($graph as $from => $to) {\n            sort($graph[$from]);\n        }\n        \n        $result = [];\n        $this->dfs($graph, 'JFK', $result);\n        \n        return $result;\n    }\n    \n    function dfs(&$graph, $from, &$result) {\n        while (isset($graph[$from]) && count($graph[$from]) > 0) {\n            $to = array_shift($graph[$from]);\n            $this->dfs($graph, $to, $result);\n        }\n        array_unshift($result, $from);\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findItinerary(tickets: List<List<String>>): List<String> {\n        val graph = mutableMapOf<String, MutableList<String>>()\n        val result = mutableListOf<String>()\n\n        for (ticket in tickets) {\n            val from = ticket[0]\n            val to = ticket[1]\n            if (!graph.containsKey(from)) {\n                graph[from] = mutableListOf()\n            }\n            graph[from]!!.add(to)\n        }\n\n        for (key in graph.keys) {\n            graph[key]!!.sort()\n        }\n\n        fun dfs(city: String) {\n            while (graph.containsKey(city) && graph[city]!!.isNotEmpty()) {\n                val nextCity = graph[city]!!.removeAt(0)\n                dfs(nextCity)\n            }\n            result.add(0, city)\n        }\n\n        dfs(\"JFK\")\n\n        return result\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> findItinerary(List<List<String>> tickets) {\n    Map<String, List<String>> graph = {};\n    List<String> result = [];\n\n    for (List<String> ticket in tickets) {\n      graph.putIfAbsent(ticket[0], () => []).add(ticket[1]);\n    }\n\n    for (List<String> destinations in graph.values) {\n      destinations.sort();\n    }\n\n    void dfs(String source) {\n      while (graph.containsKey(source) && graph[source]!.isNotEmpty) {\n        String destination = graph[source]!.removeAt(0);\n        dfs(destination);\n      }\n      result.insert(0, source);\n    }\n\n    dfs('JFK');\n\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findItinerary(tickets [][]string) []string {\n    graph := make(map[string][]string)\n    result := []string{}\n    \n    for _, ticket := range tickets {\n        graph[ticket[0]] = append(graph[ticket[0]], ticket[1])\n    }\n    \n    for key := range graph {\n        sort.Strings(graph[key])\n    }\n    \n    var dfs func(string)\n    dfs = func(origin string) {\n        for {\n            if destinations, ok := graph[origin]; !ok || len(destinations) == 0 {\n                break\n            }\n            nextDest := graph[origin][0]\n            graph[origin] = graph[origin][1:]\n            dfs(nextDest)\n        }\n        result = append([]string{origin}, result...)\n    }\n    \n    dfs(\"JFK\")\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String[][]} tickets\n# @return {String[]}\ndef find_itinerary(tickets)\n    graph = Hash.new { |h, k| h[k] = [] }\n    tickets.each { |from, to| graph[from] << to }\n    graph.values.each(&:sort!)\n    \n    result = []\n    stack = ['JFK']\n    \n    while stack.any?\n        if graph[stack.last].empty?\n            result.unshift(stack.pop)\n        else\n            stack.push(graph[stack.last].shift)\n        end\n    end\n    \n    result\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to develop an algorithm that reconstructs an itinerary given a list of airline tickets. The itinerary should start from \"JFK\" and follow lexically smaller paths when multiple options are available.\n\n# Explanation\n1. **Data Structure**: Use a dictionary to represent the graph, where each key is an airport and its value is a list of destinations. The destinations must be sorted to ensure we follow the smallest lexical order.\n2. **Depth-First Search (DFS)**: Utilize DFS to traverse the graph. Begin at \"JFK\" and always move to the lexicographically smallest destination available.\n3. **Backtracking**: Append the airport to the result list once there are no more destinations to visit from the current node. This ensures all the required paths are explored and helps in building the itinerary correctly.\n4. **Reverse the Result**: Since we append to the result list during backtracking, reverse the final list to get the correct itinerary order.\n\n# Pseudocode\n```\nfunction findItinerary(tickets):\n    # Initialize the graph using a dictionary\n    graph = defaultdict(list)\n    \n    # Sort the tickets to ensure the smallest lexical order is respected\n    for ticket in sorted(tickets):\n        source, destination = ticket\n        graph[source].append(destination)\n    \n    # Initialize the result list\n    result = []\n    \n    # Define the DFS function\n    function dfs(current_airport):\n        # While there are destinations to visit from the current airport\n        while graph[current_airport]:\n            # Get the next destination in lexical order\n            next_destination = graph[current_airport].pop(0)\n            # Recursively visit the next destination\n            dfs(next_destination)\n        # Append the current airport to the result in backtracking manner\n        result.append(current_airport)\n    \n    # Start the DFS traversal from 'JFK'\n    dfs(\"JFK\")\n    \n    # Reverse the result list to get the itinerary in the correct order\n    return result[::-1]\n```\n\nThis pseudocode outlines the process of constructing the flight itinerary using depth-first search, ensuring that the flights are used in lexically smallest order while backtracking to form the final itinerary in the correct sequence.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reconstruct-itinerary"
    },
    {
        "name": "Increasing Triplet Subsequence",
        "site": "LeetCode",
        "href": "/solution/LeetCode-increasing-triplet-subsequence",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool increasingTriplet(vector<int>& nums) {\n        int first = INT_MAX, second = INT_MAX;\n        \n        for(int num : nums){\n            if(num <= first){\n                first = num;\n            }else if(num <= second){\n                second = num;\n            }else{\n                return true;\n            }\n        }\n        \n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int n = nums.length;\n        int small = Integer.MAX_VALUE;\n        int big = Integer.MAX_VALUE;\n        \n        for (int num : nums) {\n            if (num <= small) {\n                small = num;\n            } else if (num <= big) {\n                big = num;\n            } else {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def increasingTriplet(self, nums):\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool increasingTriplet(int* nums, int numsSize) {\n    int first = INT_MAX, second = INT_MAX;\n    \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] <= first) {\n            first = nums[i];\n        } else if (nums[i] <= second) {\n            second = nums[i];\n        } else {\n            return true;\n        }\n    }\n    \n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IncreasingTriplet(int[] nums) {\n        int small = Int32.MaxValue;\n        int big = Int32.MaxValue;\n        \n        foreach (int num in nums) {\n            if (num <= small) {\n                small = num;\n            }\n            else if (num <= big) {\n                big = num;\n            }\n            else {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst increasingTriplet = (nums) => {\n    let first = Infinity;\n    let second = Infinity;\n\n    for (let num of nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n\n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function increasingTriplet(nums: number[]): boolean {\n    let first = Infinity;\n    let second = Infinity;\n    \n    for (const num of nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function increasingTriplet($nums) {\n        $first = PHP_INT_MAX;\n        $second = PHP_INT_MAX;\n        \n        foreach ($nums as $num) {\n            if ($num <= $first) {\n                $first = $num;\n            } elseif ($num <= $second) {\n                $second = $num;\n            } else {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func increasingTriplet(_ nums: [Int]) -> Bool {\n        var small = Int.max\n        var big = Int.max\n        \n        for num in nums {\n            if num <= small {\n                small = num\n            } else if num <= big {\n                big = num\n            } else {\n                return true\n            }\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun increasingTriplet(nums: IntArray): Boolean {\n        var small = Int.MAX_VALUE\n        var big = Int.MAX_VALUE\n        \n        for (num in nums) {\n            if (num <= small) {\n                small = num\n            } else if (num <= big) {\n                big = num\n            } else {\n                return true\n            }\n        }\n        \n        return false\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool increasingTriplet(List<int> nums) {\n    int first = 2147483647, second = 2147483647;\n    for (int num in nums) {\n      if (num <= first) {\n        first = num;\n      } else if (num <= second) {\n        second = num;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func increasingTriplet(nums []int) bool {\n    min1, min2 := math.MaxInt32, math.MaxInt32\n    \n    for _, num := range nums {\n        if num <= min1 {\n            min1 = num\n        } else if num <= min2 {\n            min2 = num\n        } else {\n            return true\n        }\n    }\n    \n    return false\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef increasing_triplet(nums)\n    first = second = Float::INFINITY\n    \n    nums.each do |num|\n        if num <= first\n            first = num\n        elsif num <= second\n            second = num\n        else\n            return true\n        end\n    end\n    \n    false\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn increasing_triplet(nums: Vec<i32>) -> bool {\n        let mut small = i32::MAX;\n        let mut big = i32::MAX;\n        \n        for num in nums {\n            if num <= small {\n                small = num;\n            } else if num <= big {\n                big = num;\n            } else {\n                return true;\n            }\n        }\n        \n        false\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if there is an increasing triplet subsequence in an integer array. Essentially, we want to check if there exists indices \\(i, j, k\\) such that \\(i < j < k\\) and \\(nums[i] < nums[j] < nums[k]\\).\n\n# Explanation\nThe given solution works in \\(O(n)\\) time complexity and \\(O(1)\\) space complexity. Here's a step-by-step explanation for the approach:\n1. The solution initializes two variables, `first` and `second`, to positive infinity. These variables store the smallest and the second smallest numbers found so far in the array.\n2. The algorithm iterates through each number in the array.\n3. For each number:\n   - If it is smaller than or equal to `first`, it updates `first` to be this number.\n   - Otherwise, if it is smaller than or equal to `second`, it updates `second` to be this number.\n   - Otherwise, it means there's a valid increasing triplet subsequence since the current number is greater than both `first` and `second`.\n4. If the loop completes without finding such a triplet, the function returns `false`.\n\n# Pseudocode\n\n```\nfunction increasingTriplet(nums):\n    initialize first to positive infinity\n    initialize second to positive infinity\n    \n    for each num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return true\n    \n    return false\n```\n\nThis approach ensures that the algorithm runs in linear time (\\(O(n)\\)) since it only requires a single pass through the array and maintains constant space complexity (\\(O(1)\\)) by using only two extra variables.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-increasing-triplet-subsequence"
    },
    {
        "name": "Self Crossing",
        "site": "LeetCode",
        "href": "/solution/LeetCode-self-crossing",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool isSelfCrossing(vector<int>& distance) {\n        int n = distance.size();\n        if (n <= 3) return false;\n        \n        for (int i = 3; i < n; ++i) {\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) return true;\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) return true;\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2]\n                && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) return true;\n        }\n        \n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean isSelfCrossing(int[] distance) {\n        if (distance.length < 4) {\n            return false;\n        }\n        \n        for (int i = 3; i < distance.length; i++) {\n            if (distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3]) {\n                return true;\n            }\n            if (i >= 4 && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] == distance[i-3]) {\n                return true;\n            }\n            if (i >= 5 && distance[i-2] >= distance[i-4] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] <= distance[i-3] && distance[i-1] + distance[i-5] >= distance[i-3]) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\n                return True\n        return False\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool isSelfCrossing(int* distance, int distanceSize) \n{\n    if (distanceSize < 4) {\n        return false;\n    }\n    \n    for (int i = 3; i < distanceSize; i++) {\n        if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\n            return true;\n        }\n        \n        if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\n            return true;\n        }\n        \n        if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool IsSelfCrossing(int[] distance) {\n        int n = distance.Length;\n        \n        if (n <= 3) return false;\n        \n        for (int i = 3; i < n; i++) {\n            if (i >= 3 && distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) return true;\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) return true;\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) return true;\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function isSelfCrossing(distance: number[]): boolean \n{\n    for (let i = 3; i < distance.length; i++) {\n        if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\n            return true;\n        }\n        if (i >= 4 && distance[i - 1] === distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\n            return true;\n        }\n        if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\n            return true;\n        }\n    }\n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $distance\n     * @return Boolean\n     */\n    function isSelfCrossing($distance) {\n        $n = count($distance);\n        \n        if ($n < 4) {\n            return false;\n        }\n        \n        for ($i = 3; $i < $n; $i++) {\n            if ($distance[$i] >= $distance[$i-2] && $distance[$i-1] <= $distance[$i-3]) {\n                return true;\n            }\n            if ($i >= 4 && $distance[$i-1] == $distance[$i-3] && $distance[$i] + $distance[$i-4] >= $distance[$i-2]) {\n                return true;\n            }\n            if ($i >= 5 && $distance[$i-2] >= $distance[$i-4] && $distance[$i] + $distance[$i-4] >= $distance[$i-2] && $distance[$i-1] <= $distance[$i-3] && $distance[$i-1] + $distance[$i-5] >= $distance[$i-3]) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func isSelfCrossing(_ distance: [Int]) -> Bool {\n        if distance.count < 4 {\n            return false\n        }\n        \n        for i in 3..<distance.count {\n            if distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3] {\n                return true\n            }\n            \n            if i >= 4 && distance[i-1] == distance[i-3] && distance[i] + distance[i-4] >= distance[i-2] {\n                return true\n            }\n            \n            if i >= 5 && distance[i-2] >= distance[i-4] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] <= distance[i-3] && distance[i-1] + distance[i-5] >= distance[i-3] {\n                return true\n            }\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun isSelfCrossing(distance: IntArray): Boolean {\n        for (i in 3 until distance.size) {\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\n                return true\n            }\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\n                return true\n            }\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\n                return true\n            }\n        }\n        return false\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool isSelfCrossing(List<int> distance) {\n    for (int i = 3; i < distance.length; i++) {\n      if (i >= 3 && distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\n        return true;\n      }\n      if (i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2]) {\n        return true;\n      }\n      if (i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] >= distance[i - 2] - distance[i - 4] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func isSelfCrossing(distance []int) bool {\n    if len(distance) < 4 {\n        return false\n    }\n    \n    for i := 3; i < len(distance); i++ {\n        if distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3] {\n            return true\n        }\n        \n        if i >= 4 && distance[i-1] == distance[i-3] && distance[i]+distance[i-4] >= distance[i-2] {\n            return true\n        }\n        \n        if i >= 5 && distance[i-2] >= distance[i-4] && distance[i]+distance[i-4] >= distance[i-2] && distance[i-1] <= distance[i-3] && distance[i-1]+distance[i-5] >= distance[i-3] {\n            return true\n        }\n    }\n    \n    return false\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} distance\n# @return {Boolean}\ndef is_self_crossing(distance)\n    n = distance.length\n    return false if n < 4\n    for i in 3...n\n        if distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3]\n            return true\n        elsif i >= 4 && distance[i-1] == distance[i-3] && distance[i] + distance[i-4] >= distance[i-2]\n            return true\n        elsif i >= 5 && distance[i-2] >= distance[i-4] && distance[i] + distance[i-4] >= distance[i-2] && distance[i-1] <= distance[i-3] && distance[i-1] + distance[i-5] >= distance[i-3]\n            return true\n        end\n    end\n    false\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn is_self_crossing(distance: Vec<i32>) -> bool {\n        let n = distance.len();\n        \n        if n <= 3 {\n            return false;\n        }\n        \n        for i in 3..n {\n            if distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] {\n                return true;\n            }\n            \n            if i >= 4 && distance[i - 1] == distance[i - 3] && distance[i] + distance[i - 4] >= distance[i - 2] {\n                return true;\n            }\n            \n            if i >= 5 && distance[i - 2] >= distance[i - 4] && distance[i] + distance[i - 4] >= distance[i - 2] && distance[i - 1] <= distance[i - 3] && distance[i - 1] + distance[i - 5] >= distance[i - 3] {\n                return true;\n            }\n        }\n        \n        false\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine whether a given path crosses itself based on a series of movements on an X-Y plane. The movements follow a specific order: north, west, south, and east, repeating in this counter-clockwise pattern.\n\n# Explanation:\n1. **Initialization**: We begin at the point (0, 0).\n2. **Movement**: We traverse through the given `distance` array, moving in the specified direction. We cycle through directions: north, west, south, east, and repeat.\n3. **Self-Crossing Evaluation**: \n   - As we progress, we need to check if the current line segment (created by the movement defined by `distance[i]`) intersects with any of the previous line segments.\n   - The algorithm uses a systematic approach to evaluate potential crossings by observing certain patterns that could denote a crossing:\n     - ***First condition***: The current segment crosses the segment from three steps before it.\n     - ***Second condition***: The current segment meets the segment from four steps before head-on.\n     - ***Third condition***: The current segment crosses the segment from five steps before it.\n\nBy methodically checking these conditions, we determine if the path crosses itself.\n\n# Pseudocode:\n\n``` \nfunction isSelfCrossing(distance):\n    for i from 3 to len(distance)-1:\n        # Check the first condition\n        if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n            return True\n\n        # Check the second condition (only if there are at least 5 segments)\n        if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n            return True\n\n        # Check the third condition (only if there are at least 6 segments)\n        if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] \n           and distance[i-1] <= distance[i-3] and distance[i-1] + distance[i-5] >= distance[i-3]:\n            return True\n\n    return False\n```\n\nThis pseudocode captures the essential logic to detect if a path crosses itself based on the given distances and directional movement instructions. Each condition checks for a specific pattern of intersection based on the rules, ensuring the path is verified adequately for self-crossing scenarios.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-self-crossing"
    },
    {
        "name": "House Robber Iii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-house-robber-iii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        if (!root) return 0;\n        \n        pair<int, int> result = helper(root);\n        \n        return max(result.first, result.second);\n    }\n    \n    pair<int, int> helper(TreeNode* node) {\n        if (!node) return {0, 0};\n        \n        pair<int, int> left = helper(node->left);\n        pair<int, int> right = helper(node->right);\n        \n        int rob_current = node->val + left.second + right.second;\n        int not_rob_current = max(left.first, left.second) + max(right.first, right.second);\n        \n        return {rob_current, not_rob_current};\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int rob(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        int[] result = robSub(root);\n        \n        return Math.max(result[0], result[1]);\n    }\n    \n    private int[] robSub(TreeNode node) {\n        if (node == null) {\n            return new int[2];\n        }\n        \n        int[] left = robSub(node.left);\n        int[] right = robSub(node.right);\n        \n        int[] result = new int[2];\n        result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n        result[1] = node.val + left[0] + right[0];\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n */\npublic class Solution {\n    public int Rob(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        \n        int[] result = RobSub(root);\n        return Math.Max(result[0], result[1]);\n    }\n    \n    private int[] RobSub(TreeNode root){\n        if(root == null){\n            return new int[2];\n        }\n        \n        int[] left = RobSub(root.left);\n        int[] right = RobSub(root.right);\n        \n        int[] result = new int[2];\n        result[0] = Math.Max(left[0], left[1]) + Math.Max(right[0], right[1]);\n        result[1] = root.val + left[0] + right[0];\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n */\nvar rob = function(root) {\n    function dfs(node) {\n        if (node === null) {\n            return [0, 0];\n        }\n        const left = dfs(node.left);\n        const right = dfs(node.right);\n        const steal = node.val + left[1] + right[1];\n        const skip = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n        return [steal, skip];\n    }\n    \n    const result = dfs(root);\n    return Math.max(result[0], result[1]);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction rob(root: TreeNode | null): number {\n    function robHelper(node: TreeNode | null): [number, number] {\n        if (!node) {\n            return [0, 0];\n        }\n        \n        const left = robHelper(node.left);\n        const right = robHelper(node.right);\n        \n        const robCurr = node.val + left[1] + right[1];\n        const notRobCurr = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n        \n        return [robCurr, notRobCurr];\n    }\n    \n    const result = robHelper(root);\n    return Math.max(result[0], result[1]);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function rob($root) {\n        $result = $this->helper($root);\n        return max($result[0], $result[1]);\n    }\n    \n    function helper($node) {\n        if ($node == null) {\n            return [0, 0];\n        }\n        \n        $left = $this->helper($node->left);\n        $right = $this->helper($node->right);\n        \n        $rob = $node->val + $left[1] + $right[1];\n        $notRob = max($left[0], $left[1]) + max($right[0], $right[1]);\n        \n        return [$rob, $notRob];\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc rob(root *TreeNode) int {\n    result := robHelper(root)\n    return max(result[0], result[1])\n}\n\nfunc robHelper(node *TreeNode) [2]int {\n    if node == nil {\n        return [2]int{0, 0}\n    }\n\n    left := robHelper(node.Left)\n    right := robHelper(node.Right)\n\n    rob := node.Val + left[1] + right[1]\n    noRob := max(left[0], left[1]) + max(right[0], right[1])\n\n    return [2]int{rob, noRob}\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n\ndef rob(root)\n    def helper(node)\n        return [0, 0] if node.nil?\n        \n        left = helper(node.left)\n        right = helper(node.right)\n        \n        rob_current = node.val + left[1] + right[1]\n        not_rob_current = [left[0], left[1]].max + [right[0], right[1]].max\n        \n        [rob_current, not_rob_current]\n    end\n    \n    result = helper(root)\n    result.max\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null)\n */\n\nobject Solution {\n    def rob(root: TreeNode): Int = {\n        def robSub(root: TreeNode): Array[Int] = {\n            if (root == null) return Array(0, 0)\n            val left = robSub(root.left)\n            val right = robSub(root.right)\n            Array(Math.max(left(0), left(1)) + Math.max(right(0), right(1)), root.value + left(0) + right(0))\n        }\n        val res = robSub(root)\n        Math.max(res(0), res(1))\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we must determine the maximum amount of money the thief can rob from a binary tree structured set of houses, ensuring that two directly-linked houses are not robbed on the same night.\n\n# Explanation\nThe problem can be approached using a depth-first search (DFS) and dynamic programming (DP) strategy. For each node, we need to consider two scenarios:\n1. Robbing the current house.\n2. Not robbing the current house.\n\nWhen robbing the current house, its direct children cannot be robbed. When not robbing the current house, its maximum possible value is either the sum of the amounts from robbing or not robbing each of its children.\n\nWe will use a helper function that returns two values for each node:\n- The maximum amount of money that can be robbed including the current node.\n- The maximum amount of money that can be robbed excluding the current node.\n\nThe final result will be the maximum of these two values starting from the root of the tree.\n\n# Pseudocode\n```\nFunction rob(root):\n    # Define a helper function using DFS\n    Function dfs(node):\n        # Base case: if the node is null, return [0, 0]\n        If node is null:\n            Return [0, 0]\n        \n        # Recursively get the values for left and right children\n        Left = dfs(node.left)\n        Right = dfs(node.right)\n        \n        # Case 1: Rob this node\n        RobThisNode = node.val + Left[1] + Right[1]\n        \n        # Case 2: Do not rob this node\n        DoNotRobThisNode = max(Left[0], Left[1]) + max(Right[0], Right[1])\n        \n        # Return the values for this node\n        Return [RobThisNode, DoNotRobThisNode]\n\n    # Call dfs with the root and get the result\n    Result = dfs(root)\n    # The final result is the maximum value of robbing or not robbing the root\n    Return max(Result[0], Result[1])\n```\n\nThis pseudocode guides the implementation of a function to solve the problem using a DFS approach combined with dynamic programming principles.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-house-robber-iii"
    },
    {
        "name": "Arranging Coins",
        "site": "LeetCode",
        "href": "/solution/LeetCode-arranging-coins",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int arrangeCoins(int n) {\n        long left = 0, right = n;\n        long k, curr;\n        while (left <= right) {\n            k = left + (right - left) / 2;\n            curr = k * (k + 1) / 2;\n            if (curr == n) {\n                return k;\n            }\n            if (n < curr) {\n                right = k - 1;\n            } else {\n                left = k + 1;\n            }\n        }\n        return right;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int arrangeCoins(int n) {\n        return (int) (Math.sqrt(2.0 * n + 0.25) - 0.5);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            k = (left + right) // 2\n            curr = k * (k + 1) // 2\n            if curr == n:\n                return k\n            elif curr < n:\n                left = k + 1\n            else:\n                right = k - 1\n        return right"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int arrangeCoins(int n) {\n    long left = 1, right = n;\n    long curr, k;\n    \n    while (left <= right) {\n        k = left + (right - left) / 2; // Binary search\n        curr = k * (k + 1) / 2;\n        \n        if (curr == n) {\n            return k;\n        }\n        \n        if (n < curr) {\n            right = k - 1;\n        } else {\n            left = k + 1;\n        }\n    }\n    \n    return right;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int ArrangeCoins(int n) {\n        return (int)(Math.Sqrt(2 * (long)n + 0.25) - 0.5);\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar arrangeCoins = function(n) {\n    return Math.floor(Math.sqrt(2 * n + 0.25) - 0.5);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function arrangeCoins(n: number): number {\n    let left = 0;\n    let right = n;\n    \n    while (left <= right) {\n        const mid = Math.floor(left + (right - left) / 2);\n        const curr = mid * (mid + 1) / 2;\n        \n        if (curr === n) {\n            return mid;\n        } else if (curr < n) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return right;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function arrangeCoins($n) {\n        return floor(sqrt(2 * $n + 0.25) - 0.5);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func arrangeCoins(_ n: Int) -> Int {\n        var left = 0\n        var right = n\n        while left <= right {\n            let mid = left + (right - left) / 2\n            let sum = mid * (mid + 1) / 2\n            if sum == n {\n                return mid\n            } else if sum < n {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return right\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun arrangeCoins(n: Int): Int {\n        var left = 1\n        var right = n\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            val curr = mid.toLong() * (mid + 1) / 2\n            if (curr == n.toLong()) {\n                return mid\n            } else if (curr < n.toLong()) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return right\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int arrangeCoins(int n) {\n    int left = 0;\n    int right = n;\n    \n    while (left <= right) {\n      int mid = left + (right - left) ~/ 2;\n      int curr = mid * (mid + 1) ~/ 2;\n      \n      if (curr == n) return mid;\n      if (curr < n) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return right;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func arrangeCoins(n int) int {\n    return int((-1 + math.Sqrt(1+8*float64(n))) / 2)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef arrange_coins(n)\n    ((-1 + Math.sqrt(1 + 8 * n)) / 2).to_i\nend\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec arrange_coins(N :: integer()) -> integer().\narrange_coins(N) ->\n    Rows = trunc((math:sqrt(1 + 8*N) - 1) / 2),\n    Rows.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec arrange_coins(n :: integer) :: integer\n  def arrange_coins(n) do\n    floor((-1.0 + :math.sqrt(1 + 8 * n)) / 2)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the number of complete rows of a staircase that can be built with a given number of coins. The staircase is constructed in such a way that the ith row contains exactly i coins, and the last row may not be complete.\n\n# Explanation\n\n1. **Binary Search Approach**: \n   - We can utilize a binary search algorithm to find the maximum number of complete rows.\n   - The formula for the sum of the first k natural numbers is \\( \\frac{k(k+1)}{2} \\), which gives us the total number of coins required to make k full rows.\n   - We aim to find the largest k such that \\( \\frac{k(k+1)}{2} \\leq n \\).\n\n2. **Steps**:\n   - Initialize two pointers: `left` starting at 1 and `right` starting at n (the total number of coins).\n   - Perform binary search:\n     - Compute the middle point `k`.\n     - Calculate the total number of coins, `curr`, required to build `k` rows using the formula \\( k \\times (k + 1) // 2 \\).\n     - If `curr` is equal to `n`, return `k`.\n     - If `curr` is less than `n`, adjust the left pointer to `k + 1`.\n     - If `curr` is greater than `n`, adjust the right pointer to `k - 1`.\n   - When the loop terminates, the `right` pointer will be at the largest number of complete rows that can be built with `n` coins.\n\n# Pseudocode\n\n```python\n# Pseudocode\n\n# Function to find the number of complete rows\ndef arrangeCoins(n):\n    # Initialize left and right pointers\n    left = 1\n    right = n\n\n    # Binary search loop\n    while left <= right:\n        # Calculate the middle point\n        k = (left + right) // 2\n        # Calculate the total coins required to fill k rows\n        curr = k * (k + 1) // 2\n\n        # Check if the total coins required is exactly n\n        if curr == n:\n            return k\n        # If the required coins are less than n, move the left pointer up\n        elif curr < n:\n            left = k + 1\n        # If the required coins are more than n, move the right pointer down\n        else:\n            right = k - 1\n\n    # Return the highest number of complete rows\n    return right\n```\n\nThis approach efficiently finds the solution by leveraging binary search, making the problem solvable in logarithmic time O(log n).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-arranging-coins"
    },
    {
        "name": "Sort Characters By Frequency",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sort-characters-by-frequency",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string frequencySort(string s) {\n        unordered_map<char, int> freq;\n        for (char c : s) {\n            freq[c]++;\n        }\n\n        auto comp = [&](char a, char b) {\n            return freq[a] != freq[b] ? freq[a] > freq[b] : a < b;\n        };\n\n        sort(s.begin(), s.end(), comp);\n\n        return s;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String frequencySort(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        \n        PriorityQueue<Character> maxHeap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\n        maxHeap.addAll(map.keySet());\n        \n        StringBuilder result = new StringBuilder();\n        while (!maxHeap.isEmpty()) {\n            char current = maxHeap.poll();\n            int count = map.get(current);\n            for (int i = 0; i < count; i++) {\n                result.append(current);\n            }\n        }\n        \n        return result.toString();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def frequencySort(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        char_freq = collections.Counter(s)\n        sorted_chars = sorted(char_freq.keys(), key=lambda x: (-char_freq[x], x))\n        result = ''.join([char * char_freq[char] for char in sorted_chars])\n        \n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string FrequencySort(string s) {\n        Dictionary<char, int> frequency = new Dictionary<char, int>();\n        foreach (char c in s)\n        {\n            if (frequency.ContainsKey(c))\n            {\n                frequency[c]++;\n            }\n            else\n            {\n                frequency[c] = 1;\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        foreach (var item in frequency.OrderByDescending(x => x.Value))\n        {\n            sb.Append(new string(item.Key, item.Value));\n        }\n        \n        return sb.ToString();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string}\n */\nconst frequencySort = (s) => {\n    const charMap = {};\n    const sortedChars = [];\n    let result = '';\n\n    for (let char of s) {\n        charMap[char] = (charMap[char] || 0) + 1;\n    }\n\n    sortedChars.push(...Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]));\n\n    sortedChars.forEach(char => {\n        result += char.repeat(charMap[char]);\n    });\n\n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function frequencySort(s: string): string {\n    const charMap: { [key: string]: number } = {};\n    \n    for (let char of s) {\n        if (char in charMap) {\n            charMap[char]++;\n        } else {\n            charMap[char] = 1;\n        }\n    }\n    \n    const sortedChars = Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]);\n    \n    let result = '';\n    for (let char of sortedChars) {\n        result += char.repeat(charMap[char]);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return String\n     */\n    function frequencySort($s) {\n        $map = [];\n        $result = '';\n\n        for ($i = 0; $i < strlen($s); $i++) {\n            $map[$s[$i]] = isset($map[$s[$i]]) ? $map[$s[$i]] + 1 : 1;\n        }\n\n        arsort($map);\n\n        foreach ($map as $char => $count) {\n            $result .= str_repeat($char, $count);\n        }\n\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func frequencySort(_ s: String) -> String {\n        var dict: [Character: Int] = [:]\n        \n        for char in s {\n            dict[char, default: 0] += 1\n        }\n        \n        let sortedChars = dict.sorted { $0.value > $1.value }\n        \n        var result = \"\"\n        for (char, count) in sortedChars {\n            result += String(repeating: char, count: count)\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun frequencySort(s: String): String {\n        val charCount = s.groupingBy { it }.eachCount()\n        val sortedChars = charCount.keys.sortedByDescending { charCount[it] }\n\n        val result = StringBuilder()\n        for (char in sortedChars) {\n            result.append(char.toString().repeat(charCount[char] ?: 0))\n        }\n\n        return result.toString()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String frequencySort(String s) {\n    Map<String, int> charFrequency = {};\n    \n    for (int i = 0; i < s.length; i++) {\n      charFrequency[s[i]] = (charFrequency[s[i]] ?? 0) + 1;\n    }\n    \n    List<String> uniqueChars = charFrequency.keys.toList();\n    uniqueChars.sort((a, b) => charFrequency[b]!.compareTo(charFrequency[a]!));\n    \n    StringBuffer sb = StringBuffer();\n    for (String char in uniqueChars) {\n      sb.write(char * charFrequency[char]!);\n    }\n    \n    return sb.toString();\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func frequencySort(s string) string {\n    // Count frequency of each character\n    freqMap := make(map[rune]int)\n    for _, char := range s {\n        freqMap[char]++\n    }\n\n    // Sort characters by frequency\n    sortedChars := make([]rune, 0, len(freqMap))\n    for char := range freqMap {\n        sortedChars = append(sortedChars, char)\n    }\n    sort.Slice(sortedChars, func(i, j int) bool {\n        return freqMap[sortedChars[i]] > freqMap[sortedChars[j]]\n    })\n\n    // Build the sorted string\n    var result strings.Builder\n    for _, char := range sortedChars {\n        for i := 0; i < freqMap[char]; i++ {\n            result.WriteRune(char)\n        }\n    }\n\n    return result.String()\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {String}\ndef frequency_sort(s)\n    char_freq = s.chars.group_by(&:itself).transform_values(&:count)\n    sorted_chars = char_freq.sort_by { |char, freq| -freq }.map { |char, freq| char * freq }\n    sorted_chars.join\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn frequency_sort(s: String) -> String {\n        let mut char_count: HashMap<char, i32> = HashMap::new();\n        \n        for c in s.chars() {\n            *char_count.entry(c).or_insert(0) += 1;\n        }\n        \n        let mut sorted_chars: Vec<char> = char_count.keys().map(|&c| c).collect();\n        sorted_chars.sort_by_key(|&c| char_count[&c]);\n        sorted_chars.reverse();\n        \n        let mut res = String::new();\n        for c in sorted_chars {\n            for _ in 0..char_count[&c] {\n                res.push(c);\n            }\n        }\n        \n        res\n    }\n}\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec frequency_sort(s :: String.t) :: String.t\n  def frequency_sort(s) do\n    s\n    |> String.graphemes()\n    |> Enum.group_by(& &1)\n    |> Enum.sort_by(fn {_, values} -> -length(values) end)\n    |> Enum.reduce(\"\", fn {_, vals}, acc -> acc <> Enum.join(vals, \"\") end)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a method that sorts the characters in a given string based on their frequency in descending order. Where frequencies tie, the characters can be ordered arbitrarily among themselves.\n\n# Explanation\n1. **Count Frequencies**: First, we'll count how often each character appears in the string.\n2. **Sort Characters**: Next, we'll sort these characters primarily by their frequency in descending order.\n3. **Build Result String**: Finally, we will concatenate these characters to form the resulting string, repeating each character by its counted frequency.\n\n# Pseudocode\n\n1. **Initialize Counter**: Use a counter to tally the frequency of each character in the string.\n2. **Sort Characters**: Sort the characters primarily based on the frequency (in descending order).\n3. **Build the Result**: Concatenate the characters repeated by their frequency.\n\nHere\u2019s the pseudocode for the described solution:\n\n```pseudocode\nfunction frequencySort(s: string) -> string:\n    // Initialize a counter to store the frequency of each character\n    char_freq = Counter(s)\n    \n    // Sort characters by frequency (descending)\n    sorted_chars = sort char_freq.keys() based on (-char_freq[character])\n    \n    // Initialize an empty string to store result\n    result = \"\"\n    \n    // Build resulting string by repeating each character according to its frequency\n    for character in sorted_chars:\n        result += character * char_freq[character]\n    \n    // Return the constructed string\n    return result\n```\n\nThis pseudocode outlines the steps required to achieve the desired sorting based on character frequencies efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sort-characters-by-frequency"
    },
    {
        "name": "Delete Node In A Bst",
        "site": "LeetCode",
        "href": "/solution/LeetCode-delete-node-in-a-bst",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (!root) return NULL;\n        \n        if (root->val > key) {\n            root->left = deleteNode(root->left, key);\n        } else if (root->val < key) {\n            root->right = deleteNode(root->right, key);\n        } else {\n            if (!root->left) {\n                TreeNode* rightChild = root->right;\n                delete root;\n                return rightChild;\n            } else if (!root->right) {\n                TreeNode* leftChild = root->left;\n                delete root;\n                return leftChild;\n            }\n            TreeNode* successor = root->right;\n            while (successor->left) {\n                successor = successor->left;\n            }\n            root->val = successor->val;\n            root->right = deleteNode(root->right, successor->val);\n        }\n        return root;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) return null;\n        if (key < root.val) {\n            root.left = deleteNode(root.left, key);\n        } else if (key > root.val) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n            root.val = findMin(root.right).val;\n            root.right = deleteNode(root.right, root.val);\n        }\n        return root;\n    }\n    \n    private TreeNode findMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\n    if (root == NULL) return root;\n    \n    if (root->val > key) {\n        root->left = deleteNode(root->left, key);\n    } else if (root->val < key) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == NULL) {\n            struct TreeNode* temp = root->right;\n            free(root);\n            return temp;\n        } else if (root->right == NULL) {\n            struct TreeNode* temp = root->left;\n            free(root);\n            return temp;\n        }\n        \n        struct TreeNode* temp = root->right;\n        while (temp->left != NULL) {\n            temp = temp->left;\n        }\n        \n        root->val = temp->val;\n        root->right = deleteNode(root->right, temp->val);\n    }\n    \n    return root;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode DeleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n        \n        if (key < root.val) {\n            root.left = DeleteNode(root.left, key);\n        } else if (key > root.val) {\n            root.right = DeleteNode(root.right, key);\n        } else {\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n            \n            TreeNode minNode = FindMin(root.right);\n            root.val = minNode.val;\n            root.right = DeleteNode(root.right, root.val);\n        }\n        \n        return root;\n    }\n    \n    private TreeNode FindMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.left = (left===undefined ? null : left);\n *     this.right = (right===undefined ? null : right);\n * }\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n    if (!root) return null;\n    \n    if (root.val < key) {\n        root.right = deleteNode(root.right, key);\n    } else if (root.val > key) {\n        root.left = deleteNode(root.left, key);\n    } else {\n        if (!root.left) return root.right;\n        else if (!root.right) return root.left;\n\n        let cur = root.right;\n        while (cur.left) cur = cur.left;\n        root.val = cur.val;\n        root.right = deleteNode(root.right, cur.val);\n    }\n    \n    return root;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n    if (!root) {\n        return null;\n    }\n    \n    if (key < root.val) {\n        root.left = deleteNode(root.left, key);\n    } else if (key > root.val) {\n        root.right = deleteNode(root.right, key);\n    } else {\n        if (!root.left) {\n            return root.right;\n        } else if (!root.right) {\n            return root.left;\n        } else {\n            let temp = findMin(root.right);\n            root.val = temp.val;\n            root.right = deleteNode(root.right, temp.val);\n        }\n    }\n    \n    return root;\n}\n\nfunction findMin(node: TreeNode): TreeNode {\n    let current = node;\n    while (current.left) {\n        current = current.left;\n    }\n    return current;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n* Definition for a binary tree node.\n* class TreeNode {\n*     public $val = null;\n*     public $left = null;\n*     public $right = null;\n*     function __construct($value) { $this->val = $value; }\n* }\n*/\n\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $key\n     * @return TreeNode\n     */\n    function deleteNode($root, $key) {\n        if ($root == null) return $root;\n        \n        if ($key < $root->val) {\n            $root->left = $this->deleteNode($root->left, $key);\n        } else if ($key > $root->val) {\n            $root->right = $this->deleteNode($root->right, $key);\n        } else {\n            if ($root->left == null) return $root->right;\n            else if ($root->right == null) return $root->left;\n            \n            $temp = $this->minValue($root->right);\n            $root->val = $temp->val;\n            $root->right = $this->deleteNode($root->right, $temp->val);\n        }\n        \n        return $root;\n    }\n    \n    function minValue($node) {\n        $current = $node;\n        while ($current->left != null) {\n            $current = $current->left;\n        }\n        return $current;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\n        guard let root = root else { return nil }\n        \n        if key < root.val {\n            root.left = deleteNode(root.left, key)\n        } else if key > root.val {\n            root.right = deleteNode(root.right, key)\n        } else {\n            if root.left == nil {\n                return root.right\n            } else if root.right == nil {\n                return root.left\n            }\n            \n            var node = root.right!\n            while let left = node.left {\n                node = left\n            }\n            root.val = node.val\n            root.right = deleteNode(root.right, node.val)\n        }\n        \n        return root\n    }\n}\n\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun deleteNode(root: TreeNode?, key: Int): TreeNode? {\n        if (root == null) return null\n        \n        if (root.`val` == key) {\n            if (root.left == null) return root.right\n            if (root.right == null) return root.left\n            \n            var minNode = findMinNode(root.right)\n            root.`val` = minNode.`val`\n            root.right = deleteNode(root.right, minNode.`val`)\n        } else if (root.`val` < key) {\n            root.right = deleteNode(root.right, key)\n        } else {\n            root.left = deleteNode(root.left, key)\n        }\n        \n        return root\n    }\n    \n    fun findMinNode(node: TreeNode?): TreeNode {\n        var current = node\n        while (current?.left != null) {\n            current = current.left\n        }\n        return current!!\n    }\n}\n  "
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \n func deleteNode(root *TreeNode, key int) *TreeNode {\n    if root == nil {\n        return nil\n    }\n    \n    if key < root.Val {\n        root.Left = deleteNode(root.Left, key)\n    } else if key > root.Val {\n        root.Right = deleteNode(root.Right, key)\n    } else {\n        if root.Left == nil {\n            return root.Right\n        } else if root.Right == nil {\n            return root.Left\n        }\n        \n        minRight := findMin(root.Right)\n        root.Val = minRight.Val\n        root.Right = deleteNode(root.Right, minRight.Val)\n    }\n    \n    return root\n}\n\nfunc findMin(node *TreeNode) *TreeNode {\n    for node.Left != nil {\n        node = node.Left\n    }\n    return node\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n    \ndef delete_node(root, key)\n    if root.nil?\n        return nil\n    end\n    \n    if root.val > key\n        root.left = delete_node(root.left, key)\n    elsif root.val < key\n        root.right = delete_node(root.right, key)\n    else\n        if root.left.nil?\n            return root.right\n        elsif root.right.nil?\n            return root.left\n        end\n        \n        min_node = find_min(root.right)\n        root.val = min_node.val\n        root.right = delete_node(root.right, min_node.val)\n    end\n    \n    return root\nend\n\ndef find_min(node)\n    while !node.left.nil?\n        node = node.left\n    end\n    return node\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, \n * _right: TreeNode = null) {\n *     var value: Int = _value\n *     var left: TreeNode = _left\n *     var right: TreeNode = _right\n * }\n */\n\nobject Solution {\n  def deleteNode(root: TreeNode, key: Int): TreeNode = {\n    if (root == null) return null\n    if (root.value > key) {\n      root.left = deleteNode(root.left, key)\n    } else if (root.value < key) {\n      root.right = deleteNode(root.right, key)\n    } else {\n      if (root.left == null) return root.right\n      else if (root.right == null) return root.left\n      var minNode = findMin(root.right)\n      root.value = minNode.value\n      root.right = deleteNode(root.right, minNode.value)\n    }\n    root\n  }\n  \n  def findMin(node: TreeNode): TreeNode = {\n    var curr = node\n    while (curr.left != null) {\n      curr = curr.left\n    }\n    curr\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, a systematic approach to binary search tree (BST) node deletion should be taken. The process involves searching for the node to be deleted and then handling the deletion based on the node's characteristics.\n\n### # Explanation:\n\n1. **Search Phase**: Search for the node with the specified key in the BST.\n2. **Deletion Phase**: Once the node is found, there are three main cases to handle:\n    - **Node with no children (Leaf Node)**: Simply remove the node from the tree.\n    - **Node with one child**: Replace the node with its child.\n    - **Node with two children**: Find the inorder successor (smallest value in the right subtree), replace the node's value with the successor's, and then delete the successor.\n\nThese steps ensure the BST properties are maintained after the deletion.\n\n### # Pseudocode:\n\n```plaintext\nfunction deleteNode(root, key):\n    # Base case: if the tree is empty\n    if root is null:\n        return null\n    \n    # If the key to be deleted is smaller than the root's key\n    # then it lies in the left subtree\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    \n    # If the key to be deleted is greater than the root's key\n    # then it lies in the right subtree\n    else if key > root.val:\n        root.right = deleteNode(root.right, key)\n    \n    # If the key is the same as the root's key, then this is the node\n    # to be deleted\n    else:\n        # Node with only one child or no child\n        if root.left is null:\n            return root.right\n        else if root.right is null:\n            return root.left\n        \n        # Node with two children: Get the inorder successor\n        # (smallest in the right subtree)\n        min_larger_node = findMin(root.right)\n        root.val = min_larger_node.val\n        \n        # Delete the inorder successor\n        root.right = deleteNode(root.right, min_larger_node.val)\n    \n    return root\n\nfunction findMin(node):\n    current = node\n    # Loop to find the leftmost leaf\n    while current.left is not null:\n        current = current.left\n    return current\n```\n\n### Explanation of Pseudocode:\n\n1. **Base Case**: If the tree is empty, return `null`.\n2. **Search Phase**: Compare the key with the root's value to decide whether to move to the left or right subtree.\n3. **Deletion**:\n   - If the node does not have a left child, return its right child.\n   - If the node does not have a right child, return its left child.\n   - If the node has two children, find the inorder successor (minimum value in the right subtree), replace the node's value with the successor's value, and recursively delete the inorder successor.\n4. **Helper Function (`findMin`)**: This function helps in finding the minimum value node in the right subtree, which is used to replace the value of the node to be deleted when it has two children.\n\nThis pseudocode provides a structured approach to solve the BST node deletion problem while ensuring the BST properties are maintained.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-delete-node-in-a-bst"
    },
    {
        "name": "Serialize And Deserialize Bst",
        "site": "LeetCode",
        "href": "/solution/LeetCode-serialize-and-deserialize-bst",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "// Your solution code for Serialize and Deserialize BST goes here\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (root == nullptr) return \"null\";\n\n        string s = to_string(root->val) + \" \";\n        s += serialize(root->left) + \" \";\n        s += serialize(root->right);\n\n        return s;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserializeUtil(queue<string>& nodes) {\n        if (nodes.empty() || nodes.front() == \"null\") {\n            nodes.pop();\n            return nullptr;\n        }\n\n        TreeNode* root = new TreeNode(stoi(nodes.front()));\n        nodes.pop();\n        root->left = deserializeUtil(nodes);\n        root->right = deserializeUtil(nodes);\n\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        istringstream ss(data);\n        queue<string> nodes;\n        string str;\n\n        while (ss >> str) {\n            nodes.push(str);\n        }\n\n        return deserializeUtil(nodes);\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int val) { this.val = val; }\n * }\n */\n\npublic class Codec {\n    \n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) return;\n        sb.append(node.val).append(\",\");\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data.isEmpty()) return null;\n        String[] values = data.split(\",\");\n        Queue<Integer> queue = new LinkedList<>();\n        for (String val : values) {\n            queue.offer(Integer.parseInt(val));\n        }\n        return deserializeHelper(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private TreeNode deserializeHelper(Queue<Integer> queue, int lower, int upper) {\n        if (queue.isEmpty()) return null;\n        int val = queue.peek();\n        if (val < lower || val > upper) return null;\n        queue.poll();\n        TreeNode node = new TreeNode(val);\n        node.left = deserializeHelper(queue, lower, val);\n        node.right = deserializeHelper(queue, val, upper);\n        return node;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    \n    def serialize(self, root):\n        def _serialize(node):\n            if not node:\n                return 'None'\n            return str(node.val) + ',' + _serialize(node.left) + ',' + _serialize(node.right)\n        \n        return _serialize(root)\n    \n    def deserialize(self, data):\n        def _deserialize(nodes):\n            if nodes[0] == 'None':\n                nodes.popleft()\n                return None\n            root = TreeNode(int(nodes[0]))\n            nodes.popleft()\n            root.left = _deserialize(nodes)\n            root.right = _deserialize(nodes)\n            return root\n        \n        data = collections.deque(data.split(','))\n        return _deserialize(data)\n  "
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (!root) return '';\n    \n    let result = [];\n    \n    function dfs(node) {\n        if (node) {\n            result.push(node.val);\n            dfs(node.left);\n            dfs(node.right);\n        } else {\n            result.push('#');\n        }\n    }\n    \n    dfs(root);\n    \n    return result.join(',');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if (!data) return null;\n    \n    data = data.split(',');\n    \n    function buildTree() {\n        if (data.length === 0) return null;\n        \n        let val = data.shift();\n        if (val === '#') {\n            return null;\n        }\n        \n        let node = new TreeNode(parseInt(val));\n        node.left = buildTree();\n        node.right = buildTree();\n        \n        return node;\n    }\n    \n    return buildTree();\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n* Definition for a binary tree node.\n* class TreeNode {\n*     val: number\n*     left: TreeNode | null\n*     right: TreeNode | null\n*     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n*         this.val = (val===undefined ? 0 : val)\n*         this.left = (left===undefined ? null : left)\n*         this.right = (right===undefined ? null : right)\n*     }\n* }\n*\n* Encodes a tree to a single string.\n*/\nfunction serialize(root: TreeNode | null): string {\n    if (!root) return '';\n    \n    const queue = [root];\n    const result: string[] = [];\n    \n    while (queue.length > 0) {\n        const node = queue.shift();\n        if (node) {\n            result.push(node.val.toString());\n            queue.push(node.left, node.right);\n        } else {\n            result.push('null');\n        }\n    }\n    \n    return result.join(',');\n};\n\n/**\n* Decodes your encoded data to tree.\n*/\nfunction deserialize(data: string): TreeNode | null {\n    if (!data) return null;\n    \n    const values = data.split(',');\n    const root = new TreeNode(parseInt(values[0]));\n    const queue = [root];\n    let i = 1;\n    \n    while (queue.length > 0) {\n        const node = queue.shift();\n        if (values[i] !== 'null') {\n            const left = new TreeNode(parseInt(values[i]));\n            node.left = left;\n            queue.push(left);\n        }\n        i++;\n        if (values[i] !== 'null') {\n            const right = new TreeNode(parseInt(values[i]));\n            node.right = right;\n            queue.push(right);\n        }\n        i++;\n    }\n    \n    return root;\n};\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "import java.util.LinkedList\n\n/**\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Codec() {\n\n    // Encodes a tree to a single string.\n    fun serialize(root: TreeNode?): String {\n        val sb = StringBuilder()\n        serializeHelper(root, sb)\n        return sb.toString()\n    }\n\n    private fun serializeHelper(node: TreeNode?, sb: StringBuilder) {\n        if (node == null) {\n            sb.append(\"null,\")\n            return\n        }\n        sb.append(node.`val`).append(\",\")\n        serializeHelper(node.left, sb)\n        serializeHelper(node.right, sb)\n    }\n\n    // Decodes your encoded data to tree.\n    fun deserialize(data: String): TreeNode? {\n        val nodes = LinkedList<String>()\n        nodes.addAll(data.split(\",\"))\n        return deserializeHelper(nodes)\n    }\n\n    private fun deserializeHelper(nodes: LinkedList<String>): TreeNode? {\n        if (nodes.isEmpty() || nodes.first() == \"null\") {\n            nodes.removeFirst()\n            return null\n        }\n\n        val rootValue = nodes.removeFirst().toInt()\n        val root = TreeNode(rootValue)\n        root.left = deserializeHelper(nodes)\n        root.right = deserializeHelper(nodes)\n        return root\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\ntype Codec struct {\n}\n\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {\n        return \"\"\n    }\n    return strconv.Itoa(root.Val) + \",\" + this.serialize(root.Left) + \",\" + this.serialize(root.Right)\n}\n\nfunc (this *Codec) deserialize(data string) *TreeNode {\n    nums := strings.Split(data, \",\")\n    var buildTree func() *TreeNode\n    buildTree = func() *TreeNode {\n        if nums[0] == \"\" {\n            nums = nums[1:]\n            return nil\n        }\n        val, _ := strconv.Atoi(nums[0])\n        root := &TreeNode{Val: val}\n        nums = nums[1:]\n        root.Left = buildTree()\n        root.Right = buildTree()\n        return root\n    }\n    return buildTree()\n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the task is to create methods to serialize and deserialize a binary search tree (BST). Serialization is converting the tree into a single string so it can be stored or transmitted. Conversely, deserialization reconstructs the tree from the string.\n\nHere's how to break down the solution:\n\n# Explanation\n\n1. **Serialization**: This involves traversing the tree in a specific order (for example, preorder traversal) and converting each node's value into a string. If a node is `None`, we insert a placeholder string such as `'None'`.\n\n2. **Deserialization**: This involves reading the string back, splitting it into components, and using a recursive algorithm to rebuild the tree structure.\n\n- **Pre-order traversal**: This is a common method for serialization. We process the current node, then recursively process the left and right subtrees.\n- **Using 'None'**: During serialization, for null children, we insert 'None' to ensure the tree structure is maintained.\n- **Queue/Deque**: For deserialization, we can use a queue or deque to easily process nodes one by one from the string.\n\n## Pseudocode\n\n### Serialize Method\n1. Define a helper function `_serialize` that takes a node as input:\n   - If the node is `None`, return the string `'None'`.\n   - Otherwise, concatenate the node's value and make recursive calls to `_serialize` for the left and right children.\n2. Call `_serialize` with the root node and return the resulting string.\n\n### Deserialize Method\n1. Define a helper function `_deserialize` that takes a queue (or deque) of node values:\n   - If the first value is `'None'`, remove it from the queue and return `None`.\n   - Otherwise, create a new node with the current value and recursively set its left and right children using `_deserialize`.\n2. Convert the input string into a queue (or deque) of values and call `_deserialize` with this queue.\n\n### Pseudocode Summary\n\n```pseudocode\n# Definition of TreeNode class\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Codec:\n\n    # Serialize method\n    def serialize(self, root):\n        def _serialize(node):\n            if node is None:\n                return 'None'\n            left_serialized = _serialize(node.left)\n            right_serialized = _serialize(node.right)\n            return str(node.val) + ',' + left_serialized + ',' + right_serialized\n        \n        return _serialize(root)\n    \n    # Deserialize method\n    def deserialize(self, data):\n        def _deserialize(nodes):\n            if nodes[0] == 'None':\n                nodes.popleft()\n                return None\n            root = TreeNode(int(nodes[0]))\n            nodes.popleft()\n            root.left = _deserialize(nodes)\n            root.right = _deserialize(nodes)\n            return root\n        \n        node_list = data.split(',')\n        node_deque = collections.deque(node_list)\n        return _deserialize(node_deque)\n```\nIn this way, the defined `serialize` and `deserialize` methods convert the BST to a string and back, ensuring the original structure is preserved.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-serialize-and-deserialize-bst"
    },
    {
        "name": "Find All Numbers Disappeared In An Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-all-numbers-disappeared-in-an-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        vector<int> result;\n        for(int i=0; i<nums.size(); i++) {\n            int index = abs(nums[i]) - 1;\n            if(nums[index] > 0) {\n                nums[index] = -nums[index];\n            }\n        }\n        for(int i=0; i<nums.size(); i++) {\n            if(nums[i] > 0) {\n                result.push_back(i+1);\n            }\n        }\n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            int index = Math.abs(nums[i]) - 1;\n            if (nums[index] > 0) {\n                nums[index] = -nums[index];\n            }\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                result.add(i + 1);\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] > 0:\n                nums[index] = -nums[index]\n        \n        result = []\n        for i in range(n):\n            if nums[i] > 0:\n                result.append(i+1)\n        \n        return result\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller \ncalls free().\n */\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){\n    int* res = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = 0;\n    \n    for(int i = 0; i < numsSize; i++){\n        int index = abs(nums[i]) - 1;\n        if(nums[index] > 0){\n            nums[index] = -nums[index];\n        }\n    }\n    \n    for(int i = 0; i < numsSize; i++){\n        if(nums[i] > 0){\n            res[(*returnSize)++] = i + 1;\n        }\n    }\n    \n    return res;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> FindDisappearedNumbers(int[] nums) {\n        IList<int> result = new List<int>();\n\n        for (int i = 0; i < nums.Length; i++) {\n            int index = Math.Abs(nums[i]) - 1;\n            if (nums[index] > 0) {\n                nums[index] = -nums[index];\n            }\n        }\n\n        for (int i = 0; i < nums.Length; i++) {\n            if (nums[i] > 0) {\n                result.Add(i + 1);\n            }\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findDisappearedNumbers = function(nums) {\n    const result = [];\n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        }\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findDisappearedNumbers(nums: number[]): number[] {\n    const result: number[] = [];\n    \n    for (let i = 0; i < nums.length; i++) {\n        const newIndex = Math.abs(nums[i]) - 1;\n        if (nums[newIndex] > 0) {\n            nums[newIndex] *= -1;\n        }\n    }\n    \n    for (let i = 1; i <= nums.length; i++) {\n        if (nums[i - 1] > 0) {\n            result.push(i);\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function findDisappearedNumbers($nums) {\n        $result = [];\n        $n = count($nums);\n        $map = array_fill(1, $n, false);\n        \n        foreach ($nums as $num) {\n            $map[$num] = true;\n        }\n        \n        foreach ($map as $key => $val) {\n            if (!$val) {\n                $result[] = $key;\n            }\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\n        var nums = nums\n        var result = [Int]()\n        \n        for num in nums {\n            let index = abs(num) - 1\n            if nums[index] > 0 {\n                nums[index] *= -1\n            }\n        }\n        \n        for i in 0..<nums.count {\n            if nums[i] > 0 {\n                result.append(i + 1)\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findDisappearedNumbers(nums: IntArray): List<Int> {\n        val result = mutableListOf<Int>()\n        val n = nums.size\n        val numSet = HashSet<Int>()\n        \n        for (num in nums) {\n            numSet.add(num)\n        }\n        \n        for (i in 1..n) {\n            if (!numSet.contains(i)) {\n                result.add(i)\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> findDisappearedNumbers(List<int> nums) {\n    List<int> result = [];\n    \n    for (int i = 0; i < nums.length; i++) {\n      int index = (nums[i].abs()) - 1;\n      if (nums[index] > 0) {\n        nums[index] = -nums[index];\n      }\n    }\n    \n    for (int i = 0; i < nums.length; i++) {\n      if (nums[i] > 0) {\n        result.add(i + 1);\n      }\n    }\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findDisappearedNumbers(nums []int) []int {\n    result := []int{}\n    \n    for _, num := range nums {\n        index := abs(num) - 1\n        if nums[index] > 0 {\n            nums[index] = -nums[index]\n        }\n    }\n    \n    for i, num := range nums {\n        if num > 0 {\n            result = append(result, i+1)\n        }\n    }\n    \n    return result\n}\n\nfunc abs(num int) int {\n    if num < 0 {\n        return -num\n    }\n    return num\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef find_disappeared_numbers(nums)\n    result = []\n    n = nums.length\n    nums.each { |num| nums[(num - 1) % n] += n }\n    nums.each_with_index { |num, index| result << index + 1 if num <= n }\n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findDisappearedNumbers(nums: Array[Int]): List[Int] = {\n        val n = nums.length\n        val numSet = nums.toSet\n        (1 to n).filter(!numSet.contains(_)).toList\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\n        let mut nums = nums;\n        let n = nums.len();\n\n        for i in 0..n {\n            let idx = (nums[i].abs() - 1) as usize;\n            if nums[idx] > 0 {\n                nums[idx] = -nums[idx];\n            }\n        }\n\n        let mut result = Vec::new();\n        for i in 0..n {\n            if nums[i] > 0 {\n                result.push(i as i32 + 1);\n            }\n        }\n\n        result\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (find-disappeared-numbers nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  (define n (+ 1 (length nums)))\n  (define present (make-vector n #f))\n  (for ([num nums]) (vector-set! present num #t))\n  (define disappeared '())\n  (for ([i (in-range 1 n)]) (unless (vector-ref present i) (set! disappeared (cons i disappeared))))\n  disappeared\n)\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec find_disappeared_numbers(Nums :: [integer()]) -> \n[integer()].\nfind_disappeared_numbers(Nums) ->\n    lists:seq(1, length(Nums)) -- Nums.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec find_disappeared_numbers(nums :: [integer]) :: [integer]\n  def find_disappeared_numbers(nums) do\n    1..length(nums)\n    |> Enum.reject(&Enum.member?(nums, &1))\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find all the numbers in the range [1, n] that do not appear in a given array `nums` where `n` is the length of the array. Our objective is to accomplish this without using extra space and in O(n) runtime.\n\n# Explanation\n1. **Mark Numbers in the Array:** Iterate through each number in the array and for each number `num`, calculate its corresponding index `index = |num| - 1`. If the number at this index is positive, make it negative to mark it as present.\n2. **Identify Missing Numbers:** After marking, iterate through the array again and collect indices which are still positive. These indices represent the missing numbers.\n\n# Pseudocode\n```\nfunction findDisappearedNumbers(nums):\n    n = length of nums\n    \n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n    \n    result = []\n    for i from 0 to n-1:\n        if nums[i] > 0:\n            result.append(i + 1)\n    \n    return result\n```\n\nBreaking it down:\n- Load the size `n` of the input array.\n- For each element `num` in the array:\n  - Calculate its index `abs(num) - 1`.\n  - If the element at this calculated index is positive, make it negative.\n- After marking the presence of numbers, iterate through the array:\n  - If an element is still positive, the corresponding index+1 is a missing number.\n- Collect such numbers and return them as the result.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-all-numbers-disappeared-in-an-array"
    },
    {
        "name": "Number Of Boomerangs",
        "site": "LeetCode",
        "href": "/solution/LeetCode-number-of-boomerangs",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res = 0;\n        for(int i = 0; i < points.size(); i++){\n            unordered_map<int, int> counter;\n            for(int j = 0; j < points.size(); j++){\n                int dist = pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2);\n                counter[dist]++;\n            }\n            for(auto it = counter.begin(); it != counter.end(); it++){\n                res += it->second * (it->second - 1);\n            }\n        }\n        return res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int result = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) continue;\n                \n                int dist = (int)Math.pow(points[i][0] - points[j][0], 2) + (int)Math.pow(points[i][1] - points[j][1], 2);\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            \n            for (int val : map.values()) {\n                result += val * (val - 1);\n            }\n            map.clear();\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numberOfBoomerangs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        def get_distance(p1, p2):\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n        \n        total = 0\n        for p1 in points:\n            dist_map = {}\n            for p2 in points:\n                if p1 == p2:\n                    continue\n                dist = get_distance(p1, p2)\n                dist_map[dist] = dist_map.get(dist, 0) + 1\n                \n            for k in dist_map:\n                total += dist_map[k] * (dist_map[k] - 1)\n                \n        return total"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumberOfBoomerangs(int[][] points) {\n        int result = 0;\n        \n        for (int i = 0; i < points.Length; i++) {\n            Dictionary<int, int> map = new Dictionary<int, int>();\n            \n            for (int j = 0; j < points.Length; j++) {\n                if (i == j) continue;\n                \n                int distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                \n                if (!map.ContainsKey(distance)) {\n                    map.Add(distance, 1);\n                } else {\n                    result += 2 * map[distance];\n                    map[distance]++;\n                }\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let count = 0;\n    \n    for (let i = 0; i < points.length; i++) {\n        const map = {};\n        \n        for (let j = 0; j < points.length; j++) {\n            if (i === j) continue;\n            \n            const dist = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\n            \n            if (map[dist]) {\n                count += map[dist] * 2;\n                map[dist]++;\n            } else {\n                map[dist] = 1;\n            }\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numberOfBoomerangs(points: number[][]): number {\n    let count = 0;\n\n    for (let i = 0; i < points.length; i++) {\n        const map = new Map<number, number>();\n\n        for (let j = 0; j < points.length; j++) {\n            if (i !== j) {\n                const dist = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\n                map.set(dist, (map.get(dist) || 0) + 1);\n            }\n        }\n\n        for (const val of map.values()) {\n            count += val * (val - 1);\n        }\n    }\n\n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $points\n     * @return Integer\n     */\n    function numberOfBoomerangs($points) {\n        $result = 0;\n        for ($i = 0; $i < count($points); $i++) {\n            $map = [];\n            for ($j = 0; $j < count($points); $j++) {\n                if ($i != $j) {\n                    $distance = pow($points[$i][0] - $points[$j][0], 2) + pow($points[$i][1] - $points[$j][1], 2);\n                    if (isset($map[$distance])) {\n                        $result += 2 * $map[$distance];\n                        $map[$distance]++;\n                    } else {\n                        $map[$distance] = 1;\n                    }\n                }\n            }\n        }\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func numberOfBoomerangs(_ points: [[Int]]) -> Int {\n        var count = 0\n        for i in 0..<points.count {\n            var map = [Int: Int]()\n            for j in 0..<points.count {\n                if i != j {\n                    let xDist = points[i][0] - points[j][0]\n                    let yDist = points[i][1] - points[j][1]\n                    let distance = xDist*xDist + yDist*yDist\n                    map[distance, default: 0] += 1\n                }\n            }\n            for (_, value) in map {\n                count += value * (value - 1)\n            }\n        }\n        return count\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numberOfBoomerangs(points: Array<IntArray>): Int {\n        var count = 0\n        for (i in points.indices) {\n            val map = HashMap<Int, Int>()\n            for (j in points.indices) {\n                if (i == j) continue\n                val distance = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1])\n                map[distance] = map.getOrDefault(distance, 0) + 1\n            }\n            for (value in map.values) {\n                count += value * (value - 1)\n            }\n        }\n        return count\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numberOfBoomerangs(List<List<int>> points) {\n      int count = 0;\n  \n      for (int i = 0; i < points.length; i++) {\n          Map<int, int> map = {};\n  \n          for (int j = 0; j < points.length; j++) {\n              if (i != j) {\n                  int dist = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + \n                             (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n  \n                  map[dist] = (map[dist] ?? 0) + 1;\n              }\n          }\n  \n          for (var value in map.values) {\n              count += value * (value - 1);\n          }\n      }\n  \n      return count;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numberOfBoomerangs(points [][]int) int {\n    count := 0\n    for i := 0; i < len(points); i++ {\n        distanceMap := make(map[int]int)\n        for j := 0; j < len(points); j++ {\n            if i != j {\n                distance := (points[i][0]-points[j][0])*(points[i][0]-points[j][0]) + (points[i][1]-points[j][1])*(points[i][1]-points[j][1])\n                distanceMap[distance]++\n            }\n        }\n        for _, v := range distanceMap {\n            count += v * (v - 1)\n        }\n    }\n    return count\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} points\n# @return {Integer}\ndef number_of_boomerangs(points)\n    count = 0\n    points.each do |p1|\n        distance_map = {}\n        points.each do |p2|\n            next if p1 == p2\n            distance = (p2[0] - p1[0])**2 + (p2[1] - p1[1])**2\n            count += 2 * distance_map[distance].to_i\n            distance_map[distance] = distance_map[distance].to_i + 1\n        end\n    end\n    count\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    import scala.collection.mutable\n\n    def numberOfBoomerangs(points: Array[Array[Int]]): Int = {\n        def distance(p1: Array[Int], p2: Array[Int]): Int = {\n            val dx = p1(0) - p2(0)\n            val dy = p1(1) - p2(1)\n            dx * dx + dy * dy\n        }\n\n        var count = 0\n        for (i <- points.indices) {\n            val map = mutable.Map[Int, Int]()\n            for (j <- points.indices) {\n                if (j != i) {\n                    val d = distance(points(i), points(j))\n                    map.update(d, map.getOrElse(d, 0) + 1)\n                }\n            }\n            for ((_, v) <- map) {\n                count += v * (v - 1)\n            }\n        }\n        count\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn number_of_boomerangs(points: Vec<Vec<i32>>) -> i32 {\n        \n        let mut count = 0;\n        \n        for i in 0..points.len() {\n            let mut map = std::collections::HashMap::new();\n            \n            for j in 0..points.len() {\n                if i != j {\n                    let dist = (points[i][0] - points[j][0]).pow(2) + (points[i][1] - points[j][1]).pow(2);\n                    *map.entry(dist).or_insert(0) += 1;\n                }\n            }\n            \n            for &val in map.values() {\n                count += val * (val - 1);\n            }\n        }\n        \n        count\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify the number of boomerangs formed by a given set of points in a 2D plane. A boomerang is defined as a tuple of points (i, j, k) such that the distance between points i and j is the same as the distance between points i and k.\n\n# Explanation:\n1. **Define a Distance Function:** We need a function to compute the squared distance between two points. Squared distance is preferred to avoid computing square roots, thus reducing computational complexity.\n2. **Distance Map:** For each point `p1` in the points list, build a hashmap that stores the count of other points at each unique distance from `p1`.\n3. **Count Boomerangs:** Iterate through points and populate the distance map. For each point `p1`, calculate distances to all other points and store the counts in the distance map.\n4. **Calculate Boomerangs:** For each unique distance, if a distance occurs `k` times, it contributes `k * (k - 1)` boomerangs because if there are `k` points at the same distance, we can pick any two of them to form (i, j, k) tuples.\n\n# Pseudocode:\n```\nfunction numberOfBoomerangs(points):\n    # Helper function to calculate the squared distance\n    function get_distance(p1, p2):\n        return (p1[0] - p2[0])^2 + (p1[1] - p2[1])^2\n    \n    total_boomerangs = 0\n   \n    # Iterate over each point as reference point p1\n    for p1 in points:\n        distance_map = {}  # Dictionary to store distance frequency\n        \n        # Compute distances from p1 to all other points\n        for p2 in points:\n            if p1 != p2:\n                dist = get_distance(p1, p2)\n                # Increment the count of points at this distance\n                if dist in distance_map:\n                    distance_map[dist] += 1\n                else:\n                    distance_map[dist] = 1\n        \n        # Compute boomerangs using distances stored in distance_map\n        for dist_value in distance_map.values():\n            total_boomerangs += dist_value * (dist_value - 1)\n    \n    return total_boomerangs\n```\n\nThis pseudocode iterates over each point, calculates distances, updates the distance map, and finally counts the number of boomerangs based on the frequencies stored in the map.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-number-of-boomerangs"
    },
    {
        "name": "Arithmetic Slices Ii Subsequence",
        "site": "LeetCode",
        "href": "/solution/LeetCode-arithmetic-slices-ii-subsequence",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& nums) {\n        int n = nums.size();\n        int ans = 0;\n        vector<unordered_map<long long, int>> dp(n);\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                long long diff = (long long)nums[i] - (long long)nums[j];\n                dp[i][diff] += 1;\n                if (dp[j].count(diff)) {\n                    dp[i][diff] += dp[j][diff];\n                    ans += dp[j][diff];\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        int n = nums.length;\n        int count = 0;\n        \n        Map<Integer, Integer>[] dp = new Map[n];\n        \n        for (int i = 0; i < n; i++) {\n            dp[i] = new HashMap<>();\n            \n            for (int j = 0; j < i; j++) {\n                long diff = (long) nums[i] - nums[j];\n                \n                if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) {\n                    continue;\n                }\n                \n                int d = (int) diff;\n                int sum = dp[j].getOrDefault(d, 0);\n                int original = dp[i].getOrDefault(d, 0);\n                \n                dp[i].put(d, original + sum + 1);\n                count += sum;\n            }\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "from collections import defaultdict\n\nclass Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        dp = [defaultdict(int) for _ in nums]\n        res = 0\n        \n        for i in range(len(nums)):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                res += count\n                \n        return res\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumberOfArithmeticSlices(int[] nums) {\n        int n = nums.Length;\n        int count = 0;\n        var dp = new Dictionary<int, int>[n];\n\n        for (int i = 0; i < n; i++)\n        {\n            dp[i] = new Dictionary<int, int>();\n            for (int j = 0; j < i; j++)\n            {\n                long diff = (long)nums[i] - (long)nums[j];\n                if (diff <= int.MinValue || diff >= int.MaxValue)\n                    continue;\n\n                int d = (int)diff;\n                int sum = dp[j].ContainsKey(d) ? dp[j][d] : 0;\n                int original = dp[i].ContainsKey(d) ? dp[i][d] : 0;\n                dp[i][d] = original + sum + 1;\n                count += sum;\n            }\n        }\n\n        return count;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    const n = nums.length;\n    let count = 0;\n\n    const dp = Array(n).fill(0).map(() => ({}));\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            const diff = nums[i] - nums[j];\n            if (dp[j][diff]) {\n                dp[i][diff] = (dp[i][diff] || 0) + dp[j][diff];\n                count += dp[j][diff];\n            }\n            dp[i][diff] = (dp[i][diff] || 0) + 1;\n        }\n    }\n\n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numberOfArithmeticSlices(nums: number[]): number {\n    const n = nums.length;\n    let count = 0;\n    const dp: Map<number, number>[] = new Array(n);\n    \n    for (let i = 0; i < n; i++) {\n        dp[i] = new Map();\n        \n        for (let j = 0; j < i; j++) {\n            const diff = nums[i] - nums[j];\n            const sum = dp[j].get(diff) || 0;\n            const original = dp[i].get(diff) || 0;\n            \n            dp[i].set(diff, original + sum + 1);\n            count += sum;\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function numberOfArithmeticSlices($nums) {\n        $n = count($nums);\n        $dp = array_fill(0, $n, []);\n        $count = 0;\n        \n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $i > $j; $j++) {\n                $diff = $nums[$i] - $nums[$j];\n                $sum = $dp[$j][$diff] ?? 0;\n                $old = $dp[$i][$diff] ?? 0;\n                \n                $dp[$i][$diff] = $old + $sum + 1;\n                $count += $sum;\n            }\n        }\n        \n        return $count;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\n        var count = 0\n        var dp = [Int:[Int:Int]]()\n        \n        for i in 0..<nums.count {\n            dp[i] = [:]\n            for j in 0..<i {\n                let diff = nums[i] - nums[j]\n                \n                if let val = dp[j]?[diff] {\n                    dp[i, default: [:]][diff, default: 0] += val + 1\n                    count += val\n                } else {\n                    dp[i, default: [:]][diff, default: 0] += 1\n                }\n            }\n        }\n        \n        return count\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numberOfArithmeticSlices(nums: IntArray): Int {\n        if (nums.size < 3) return 0\n        \n        var total = 0\n        val dp = Array<MutableMap<Long, Int>>(nums.size) { mutableMapOf() }\n        \n        for (i in 0 until nums.size) {\n            for (j in 0 until i) {\n                val diff = nums[i].toLong() - nums[j].toLong()\n                val sum = dp[j].getOrDefault(diff, 0)\n                val original = dp[i].getOrDefault(diff, 0)\n                dp[i][diff] = original + sum + 1\n                total += sum\n            }\n        }\n        \n        return total\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numberOfArithmeticSlices(List<int> nums) {\n      int n = nums.length;\n      int total = 0;\n\n      List<Map<int, int>> dp = List.generate(n, (_) => {});\n\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n          int diff = nums[i] - nums[j];\n          int prevCount = dp[j][diff] ?? 0;\n          int currentCount = dp[i][diff] ?? 0;\n          dp[i][diff] = prevCount + currentCount + 1;\n          total += prevCount;\n        }\n      }\n\n      return total;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numberOfArithmeticSlices(nums []int) int {\n    n := len(nums)\n    if n < 3 {\n        return 0\n    }\n\n    dp := make([]map[int]int, n)\n    res := 0\n\n    for i := 0; i < n; i++ {\n        dp[i] = make(map[int]int)\n        for j := 0; j < i; j++ {\n            diff := nums[i] - nums[j]\n            count := dp[j][diff]\n            dp[i][diff] += count + 1\n            if count > 0 {\n                res += count\n            }\n        }\n    }\n\n    return res\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def numberOfArithmeticSlices(nums: Array[Int]): Int = {\n        val n = nums.length\n        var count = 0\n        val dp = Array.fill(n)(Map.empty[Long, Int])\n\n        for {\n            i <- 0 until n\n            j <- 0 until i\n        } {\n            val diff = nums(i).toLong - nums(j)\n            val prev = dp(j).getOrElse(diff, 0)\n            val curr = dp(i).getOrElse(diff, 0) + prev + 1\n            dp(i) = dp(i) + (diff -> curr)\n            count += prev\n        }\n\n        count\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn number_of_arithmetic_slices(nums: Vec<i32>) -> i32 {\n        use std::collections::HashMap;\n        \n        let n = nums.len();\n        let mut dp = vec![HashMap::new(); n];\n        let mut count = 0;\n\n        for i in 0..n {\n            for j in 0..i {\n                let diff = nums[i] as i64 - nums[j] as i64;\n                let sum = *dp[j].get(&diff).unwrap_or(&0);\n                let original = *dp[i].get(&diff).unwrap_or(&0);\n                dp[i].insert(diff, original + sum + 1);\n                count += sum;\n            }\n        }\n        \n        count as i32\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use a dynamic programming approach to keep track of the number of arithmetic subsequences ending at each index with each possible difference.\n\n## Explanation\n\n1. **Initialize Data Structures**:\n   - Use an array of dictionaries `dp`, where each dictionary at index `i` will hold counts of subsequences that end at `nums[i]` with various differences.\n   - Initialize `res` to count the total number of arithmetic subsequences.\n\n2. **Iterate and Update**:\n   - Iterate through every pair of indices `i` and `j` such that `j < i`.\n   - Calculate the difference `diff = nums[i] - nums[j]`.\n   - Use `dp[j][diff]` to get the count of existing arithmetic subsequences ending at `j` with difference `diff`.\n   - Update `dp[i][diff]` by adding `dp[j][diff] + 1` to include the subsequences extended by `nums[i]`.\n   - Increment `res` by `count` to account for the number of valid subsequences.\n\n3. **Return Result**:\n   - After iterating through all pairs, return the result `res`.\n\n## Pseudocode\n\n```python\n# Pseudocode\nfunction numberOfArithmeticSlices(nums):\n    # Initialize list of dictionaries for dynamic programming\n    dp = [defaultdict(int) for each element in nums]\n    res = 0\n    \n    # Iterate through every possible pair of indices\n    for i from 0 to length of nums - 1:\n        for j from 0 to i - 1:\n            diff = nums[i] - nums[j]            # Calculate the difference\n            count = dp[j][diff]                 # Get the count of subsequences ending at j with this difference\n            dp[i][diff] += count + 1            # Update dp[i][diff] to include the new subsequences\n            res += count                        # Add the count to the result\n            \n    return res                                 # Return the total count of arithmetic subsequences\n```\n\nThis pseudocode outlines the core logic required to count all arithmetic subsequences within the given list. By maintaining and updating the counts of subsequences ending at each index with specific differences, we can efficiently determine the number of such subsequences.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-arithmetic-slices-ii-subsequence"
    },
    {
        "name": "Add Two Numbers Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-add-two-numbers-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n */\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        stack<int> s1, s2;\n        \n        while (l1) {\n            s1.push(l1->val);\n            l1 = l1->next;\n        }\n        \n        while (l2) {\n            s2.push(l2->val);\n            l2 = l2->next;\n        }\n        \n        int sum = 0;\n        ListNode* res = new ListNode(0);\n        \n        while (!s1.empty() || !s2.empty()) {\n            if (!s1.empty()) { \n                sum += s1.top();\n                s1.pop();\n            }\n            \n            if (!s2.empty()) {\n                sum += s2.top();\n                s2.pop();\n            }\n            \n            res->val = sum % 10;\n            ListNode* head = new ListNode(sum / 10);\n            head->next = res;\n            res = head;\n            sum /= 10;\n        }\n        \n        return res->val == 0 ? res->next : res;\n    }\n};\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        // Convert linked lists to stacks\n        Stack<int> stack1 = new Stack<int>();\n        Stack<int> stack2 = new Stack<int>();\n        \n        while (l1 != null) {\n            stack1.Push(l1.val);\n            l1 = l1.next;\n        }\n        \n        while (l2 != null) {\n            stack2.Push(l2.val);\n            l2 = l2.next;\n        }\n        \n        int carry = 0;\n        ListNode result = null;\n        \n        while (stack1.Count > 0 || stack2.Count > 0 || carry > 0) {\n            int sum = carry;\n            sum += stack1.Count > 0 ? stack1.Pop() : 0;\n            sum += stack2.Count > 0 ? stack2.Pop() : 0;\n            \n            carry = sum / 10;\n            sum %= 10;\n            \n            ListNode newNode = new ListNode(sum);\n            newNode.next = result;\n            result = newNode;\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nvar addTwoNumbers = function(l1, l2) {\n    let stack1 = [];\n    let stack2 = [];\n    \n    while (l1) {\n        stack1.push(l1.val);\n        l1 = l1.next;\n    }\n    \n    while (l2) {\n        stack2.push(l2.val);\n        l2 = l2.next;\n    }\n    \n    let sum = 0;\n    let result = new ListNode(0);\n    \n    while (stack1.length || stack2.length) {\n        if (stack1.length) sum += stack1.pop();\n        if (stack2.length) sum += stack2.pop();\n        \n        result.val = sum % 10;\n        let head = new ListNode(Math.floor(sum / 10));\n        head.next = result;\n        result = head;\n        sum = Math.floor(sum / 10);\n    }\n    \n    return result.val === 0 ? result.next : result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/*\nDon't send code in this format\n*/\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next? :ListNode){       \n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    let stack1: number[] = [];\n    let stack2: number[] = [];\n    \n    while (l1) {\n        stack1.push(l1.val);\n        l1 = l1.next;\n    }\n    \n    while (l2) {\n        stack2.push(l2.val);\n        l2 = l2.next;\n    }\n    \n    let sum: number = 0;\n    let resultList: ListNode | null = null;\n    \n    while (stack1.length > 0 || stack2.length > 0 || sum > 0) {\n        if (stack1.length > 0) sum += stack1.pop()!;\n        if (stack2.length > 0) sum += stack2.pop()!;\n        \n        let newNode: ListNode = new ListNode(sum % 10);\n        newNode.next = resultList;\n        resultList = newNode;\n        \n        sum = Math.floor(sum / 10);\n    }\n    \n    return resultList;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n\n    /**\n     * Definition for a singly-linked list.\n     * class ListNode {\n     *     public $val = 0;\n     *     public $next = null;\n     *     function __construct($val = 0, $next = null) {\n     *         $this->val = $val;\n     *         $this->next = $next;\n     *     }\n     * }\n     */\n\n    /**\n     * @param ListNode $l1\n     * @param ListNode $l2\n     * @return ListNode\n     */\n    function addTwoNumbers($l1, $l2) {\n        $stack1 = [];\n        $stack2 = [];\n        \n        while ($l1 != null) {\n            array_push($stack1, $l1->val);\n            $l1 = $l1->next;\n        }\n        \n        while ($l2 != null) {\n            array_push($stack2, $l2->val);\n            $l2 = $l2->next;\n        }\n        \n        $carry = 0;\n        $dummy = null;\n        \n        while (!empty($stack1) || !empty($stack2) || $carry > 0) {\n            $num1 = !empty($stack1) ? array_pop($stack1) : 0;\n            $num2 = !empty($stack2) ? array_pop($stack2) : 0;\n            \n            $sum = $num1 + $num2 + $carry;\n            $carry = intdiv($sum, 10);\n            \n            $node = new ListNode($sum % 10);\n            $node->next = $dummy;\n            $dummy = $node;\n        }\n        \n        return $dummy;\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    stack1 := []*ListNode{}\n    stack2 := []*ListNode{}\n\n    for node := l1; node != nil; node = node.Next {\n        stack1 = append(stack1, node)\n    }\n    for node := l2; node != nil; node = node.Next {\n        stack2 = append(stack2, node)\n    }\n\n    var head *ListNode\n    carry := 0\n    for len(stack1) > 0 || len(stack2) > 0 || carry > 0 {\n        sum := carry\n        if len(stack1) > 0 {\n            sum += stack1[len(stack1)-1].Val\n            stack1 = stack1[:len(stack1)-1]\n        }\n        if len(stack2) > 0 {\n            sum += stack2[len(stack2)-1].Val\n            stack2 = stack2[:len(stack2)-1]\n        }\n\n        node := &ListNode{Val: sum % 10, Next: head}\n        head = node\n        carry = sum / 10\n    }\n\n    return head\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "class ListNode\n    attr_accessor :val, :next\n    def initialize(val = 0, _next = nil)\n        @val = val\n        @next = _next\n    end\nend\n\ndef add_two_numbers(l1, l2)\n    stack1 = []\n    stack2 = []\n    \n    while l1\n        stack1.push(l1.val)\n        l1 = l1.next\n    end\n    \n    while l2\n        stack2.push(l2.val)\n        l2 = l2.next\n    end\n    \n    carry = 0\n    sum = nil\n    \n    while !stack1.empty? || !stack2.empty? || carry > 0\n        val1 = stack1.empty? ? 0 : stack1.pop\n        val2 = stack2.empty? ? 0 : stack2.pop\n        total = val1 + val2 + carry\n        carry = total / 10\n        current = ListNode.new(total % 10)\n        current.next = sum\n        sum = current\n    end\n    \n    sum\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "import scala.collection.mutable.Stack\n\n/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n */\n\nobject Solution {\n    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {\n        var stack1 = new Stack[Int]()\n        var stack2 = new Stack[Int]()\n        \n        var temp1 = l1\n        var temp2 = l2\n        \n        while(temp1 != null){\n            stack1.push(temp1.x)\n            temp1 = temp1.next\n        }\n        \n        while(temp2 != null){\n            stack2.push(temp2.x)\n            temp2 = temp2.next\n        }\n        \n        var carry = 0\n        var result: ListNode = null\n        \n        while(!stack1.isEmpty || !stack2.isEmpty || carry != 0){\n            var sum = carry\n            if(!stack1.isEmpty) sum += stack1.pop()\n            if(!stack2.isEmpty) sum += stack2.pop()\n            \n            val newNode = new ListNode(sum % 10)\n            newNode.next = result\n            result = newNode\n            \n            carry = sum / 10\n        }\n        \n        result\n    }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>,\n// }\nimpl Solution {\n    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut stack1 = Vec::new();\n        let mut stack2 = Vec::new();\n        \n        let mut head1 = &l1;\n        let mut head2 = &l2;\n        \n        while let Some(node) = head1 {\n            stack1.push(node.val);\n            head1 = &node.next;\n        }\n        \n        while let Some(node) = head2 {\n            stack2.push(node.val);\n            head2 = &node.next;\n        }\n        \n        let mut carry = 0;\n        let mut result = None;\n        \n        while !stack1.is_empty() || !stack2.is_empty() || carry != 0 {\n            let mut sum = carry;\n            if let Some(val) = stack1.pop() {\n                sum += val;\n            }\n            if let Some(val) = stack2.pop() {\n                sum += val;\n            }\n            carry = sum / 10;\n            let node = Box::new(ListNode {\n                val: sum % 10,\n                next: result,\n            });\n            result = Some(node);\n        }\n        \n        result\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to add two numbers represented as linked lists where the most significant digit comes first. Here's a structured approach to resolve this:\n\n### # Explanation\n1. **Convert Linked Lists to Stacks**: \n    - Traverse through both linked lists and push their elements onto two separate stacks (`stack1` and `stack2`). This helps us to process digits starting from the least significant (rightmost) by popping elements from the stacks.\n\n2. **Perform Addition**:\n    - Initialize a variable `sum` to 0 and create a dummy node for the result linked list.\n    - While there are elements in either of the stacks:\n        - Pop the top elements from both stacks if they exist and add these values along with any carry from the previous addition.\n        - Compute the new digit (which is the unit place of the accumulated sum) and update the carry (which is the ten's place of the accumulated sum).\n        - Create a new node with the computed digit and link it to the front of the result linked list.\n    \n3. **Handle Remaining Carry**:\n    - After processing all elements, if there is any carry left, create a new node with this carry and attach it to the front of the result linked list.\n\n4. **Return Result**: \n    - Since we've constructed the result list in reverse order, return it starting from the node after the dummy node.\n\n### # Pseudocode\n```\n# Define the ListNode class to represent the linked list nodes\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1, l2):\n    # Initialize two stacks to hold the digits of l1 and l2\n    stack1 = []\n    stack2 = []\n\n    # Push all elements from l1 to stack1\n    while l1 is not None:\n        stack1.append(l1.val)\n        l1 = l1.next\n\n    # Push all elements from l2 to stack2\n    while l2 is not None:\n        stack2.append(l2.val)\n        l2 = l2.next\n\n    # Initialize the sum and the result linked list\n    sum = 0\n    result = ListNode(0)\n\n    # Process until both stacks are empty\n    while stack1 or stack2:\n        if stack1:\n            sum += stack1.pop()\n        if stack2:\n            sum += stack2.pop()\n\n        # Update the result node with the current digit\n        result.val = sum % 10\n\n        # Create a new head node with the carry\n        head = ListNode(sum // 10)\n        head.next = result\n        \n        # Move the result to the new head\n        result = head\n\n        # Propagate the carry\n        sum //= 10\n\n    # Return the result node, skipping the initial dummy node if its value is 0\n    return result if result.val != 0 else result.next\n```\n\nThis pseudocode provides a step-by-step approach to adding two numbers represented as linked lists with digits arranged in significant-first order without reversing the input lists.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-add-two-numbers-ii"
    },
    {
        "name": "String Compression",
        "site": "LeetCode",
        "href": "/solution/LeetCode-string-compression",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        int n = chars.size();\n        int i = 0, j = 0;\n        while (i < n) {\n            int count = 0;\n            char current_char = chars[i];\n            while (i < n && chars[i] == current_char) {\n                i++;\n                count++;\n            }\n            chars[j++] = current_char;\n            if (count > 1) {\n                string count_str = to_string(count);\n                for (char c : count_str) {\n                    chars[j++] = c;\n                }\n            }\n        }\n        return j;\n    }\n};\n  "
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int compress(char[] chars) {\n        if(chars == null || chars.length == 0) {\n            return 0;\n        }\n        \n        int index = 0;\n        int count = 1;\n        \n        for(int i = 1; i <= chars.length; i++) {\n            if(i < chars.length && chars[i] == chars[i - 1]) {\n                count++;\n            } else {\n                chars[index++] = chars[i - 1];\n                if(count > 1) {\n                    char[] countChars = String.valueOf(count).toCharArray();\n                    for(char c : countChars) {\n                        chars[index++] = c;\n                    }\n                }\n                count = 1;\n            }\n        }\n        \n        return index;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def compress(self, chars):\n        \"\"\"\n        :type chars: List[str]\n        \"\"\"\n        if len(chars) == 0:\n            return 0\n        \n        count = 1\n        prev = chars[0]\n        index = 0\n        \n        for i in range(1, len(chars)):\n            if chars[i] == prev:\n                count += 1\n            else:\n                chars[index] = prev\n                index += 1\n                if count > 1:\n                    for digit in str(count):\n                        chars[index] = digit\n                        index += 1\n                prev = chars[i]\n                count = 1\n        \n        chars[index] = prev\n        index += 1\n        if count > 1:\n            for digit in str(count):\n                chars[index] = digit\n                index += 1\n        \n        return index"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int compress(char* chars, int charsSize) {\n    int index = 0;\n    int count = 1;\n    for(int i = 0; i < charsSize; i++) {\n        if(i + 1 < charsSize && chars[i] == chars[i+1]) {\n            count++;\n        } else {\n            chars[index++] = chars[i];\n            if(count > 1) {\n                char strCount[5];\n                int len = snprintf(strCount, 5, \"%d\", count);\n                for(int j = 0; j < len; j++) {\n                    chars[index++] = strCount[j];\n                }\n            }\n            count = 1;\n        }\n    }\n    return index;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Compress(char[] chars) {\n        int index = 0;\n        int count = 1;\n\n        for (int i = 1; i <= chars.Length; i++) {\n            if (i == chars.Length || chars[i] != chars[i - 1]) {\n                chars[index++] = chars[i - 1];\n                if (count > 1) {\n                    foreach (char c in count.ToString()) {\n                        chars[index++] = c;\n                    }\n                }\n                count = 1;\n            } else {\n                count++;\n            }\n        }\n\n        return index;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[]} chars\n * @return {number}\n */\nconst compress = chars => {\n    let index = 0;\n    let i = 0;\n    \n    while (i < chars.length) {\n        let j = i;\n        while (j < chars.length && chars[j] === chars[i]) {\n            j++;\n        }\n        \n        chars[index++] = chars[i];\n        if (j - i > 1) {\n            for (let digit of String(j - i)) {\n                chars[index++] = digit;\n            }\n        }\n        \n        i = j;\n    }\n    \n    return index;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function compress(chars: string[]): number {\n    let index = 0;\n    let count = 1;\n\n    for (let i = 1; i <= chars.length; i++) {\n        if (i === chars.length || chars[i] !== chars[i - 1]) {\n            chars[index++] = chars[i - 1];\n            if (count > 1) {\n                for (const digit of count.toString()) {\n                    chars[index++] = digit;\n                }\n            }\n            count = 1;\n        } else {\n            count++;\n        }\n    }\n\n    return index;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[] $chars\n     * @return Integer\n     */\n    function compress(&$chars) {\n        $count = count($chars);\n        $idx = 0;\n        \n        for ($i = 0; $i < $count; $i++) {\n            $currChar = $chars[$i];\n            $charCount = 1;\n            while ($i + 1 < $count && $chars[$i] == $chars[$i + 1]) {\n                $charCount++;\n                $i++;\n            }\n            $chars[$idx] = $currChar;\n            $idx++;\n            if ($charCount > 1) {\n                $charCountStr = strval($charCount);\n                for ($j = 0; $j < strlen($charCountStr); $j++) {\n                    $chars[$idx] = $charCountStr[$j];\n                    $idx++;\n                }\n            }\n        }\n        \n        return $idx;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func compress(_ chars: inout [Character]) -> Int {\n        var index = 0\n        var count = 1\n        \n        for i in 1..<chars.count {\n            if chars[i] == chars[i - 1] {\n                count += 1\n            } else {\n                chars[index] = chars[i - 1]\n                index += 1\n                if count > 1 {\n                    let countStr = String(count)\n                    for char in countStr {\n                        chars[index] = char\n                        index += 1\n                    }\n                }\n                count = 1\n            }\n        }\n        \n        chars[index] = chars[chars.count - 1]\n        index += 1\n        if count > 1 {\n            let countStr = String(count)\n            for char in countStr {\n                chars[index] = char\n                index += 1\n            }\n        }\n        \n        return index\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun compress(chars: CharArray): Int {\n        var index = 0\n        var i = 0\n        while (i < chars.size) {\n            var count = 0\n            var j = i\n            while (j < chars.size && chars[j] == chars[i]) {\n                count++\n                j++\n            }\n            chars[index++] = chars[i]\n            if (count > 1) {\n                for (c in count.toString().toCharArray()) {\n                    chars[index++] = c\n                }\n            }\n            i = j\n        }\n        return index\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int compress(List<String> chars) {\n    int index = 0;\n    int i = 0;\n    while (i < chars.length) {\n      int j = i;\n      while (j < chars.length && chars[j] == chars[i]) {\n        j++;\n      }\n      chars[index++] = chars[i];\n      if (j - i > 1) {\n        for (String digit in (j - i).toString().split('')) {\n          chars[index++] = digit;\n        }\n      }\n      i = j;\n    }\n    return index;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func compress(chars []byte) int {\n    n := len(chars)\n    if n == 0 {\n        return 0\n    }\n    \n    write := 0\n    anchor := 0\n    \n    for read := 0; read < n; read++ {\n        if read+1 == n || chars[read] != chars[read+1] {\n            chars[write] = chars[anchor]\n            write++\n            if read > anchor {\n                for _, c := range []byte(strconv.Itoa(read - anchor + 1)) {\n                    chars[write] = c\n                    write++\n                }\n            }\n            anchor = read + 1\n        }\n    }\n    \n    return write\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[]} chars\n# @return {Integer}\ndef compress(chars)\n    index = 0\n    i = 0\n    \n    while i < chars.length\n        count = 0\n        current_char = chars[i]\n        \n        while i < chars.length && chars[i] == current_char\n            count += 1\n            i += 1\n        end\n        \n        chars[index] = current_char\n        index += 1\n        \n        if count > 1\n            count.to_s.chars.each do |c|\n                chars[index] = c\n                index += 1\n            end\n        end\n    end\n    \n    return index\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def compress(chars: Array[Char]): Int = {\n        var index = 0\n        var count = 1\n        \n        def addChar(c: Char, cnt: Int): Unit = {\n            chars(index) = c\n            index += 1\n            if (cnt > 1) {\n                val cntStr = cnt.toString\n                for (i <- 0 until cntStr.length) {\n                    chars(index) = cntStr(i)\n                    index += 1\n                }\n            }\n        }\n        \n        for (i <- 1 until chars.length) {\n            if (chars(i) == chars(i - 1)) {\n                count += 1\n            } else {\n                addChar(chars(i - 1), count)\n                count = 1\n            }\n        }\n        \n        addChar(chars(chars.length - 1), count)\n        \n        index\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn compress(chars: &mut Vec<char>) -> i32 {\n        let mut i = 0;\n        let mut j = 0;\n        \n        while i < chars.len() {\n            let mut count = 0;\n            let current_char = chars[i];\n            while i < chars.len() && chars[i] == current_char {\n                i += 1;\n                count += 1;\n            }\n            chars[j] = current_char;\n            j += 1;\n            if count > 1 {\n                for c in count.to_string().chars() {\n                    chars[j] = c;\n                    j += 1;\n                }\n            }\n        }\n        \n        j as i32\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the goal is to compress an array of characters by representing consecutive repeated characters with the character followed by its count. Here is how you can approach it:\n\n# Explanation\n\n1. **Initialize Variables**: \n   - `index` to track the position at which to insert the next character or number in the `chars` array.\n   - `count` for counting the number of repetitions of a character.\n   - `prev` to keep track of the current character being processed.\n\n2. **Traverse the List**: Loop through the `chars` array starting from the second element.\n   - If the current character is the same as `prev`, increase `count`.\n   - If it is different, update `chars` at the `index` with `prev` and proceed to check if `count` is greater than 1.\n     - If `count` > 1, convert `count` to a string and update `chars` by adding each digit of `count` at the `index`.\n   - Reset `count` to 1 and update `prev` to the new character.\n\n3. **Handle the Last Sequence**: After the loop, handle the last sequence of characters in the same way as done in the loop.\n\n4. **Return the New Length**: Finally, return the value of `index` which represents the length of the compressed array.\n\n# Pseudocode\n\n```\n# Initialize variables\nindex = 0\ncount = 1\nprev = chars[0]\n\n# Traverse through the list starting from the second element\nfor i in range(1, len(chars)):\n    if chars[i] == prev:\n        # Increment count if same character is found\n        count += 1\n    else:\n        # Write the character to the index position\n        chars[index] = prev\n        index += 1\n        \n        # Write the count if it is more than 1\n        if count > 1:\n            for digit in str(count):\n                chars[index] = digit\n                index += 1\n                \n        # Update prev to the current character and reset count\n        prev = chars[i]\n        count = 1\n\n# Handle the last group\nchars[index] = prev\nindex += 1\n\nif count > 1:\n    for digit in str(count):\n        chars[index] = digit\n        index += 1\n\n# Return the new length of chars\nreturn index\n```\n\nThis pseudocode covers the logic required to solve the string compression problem as outlined in the challenge. It ensures that the character array is modified in place and returns the new length of the compressed array.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-string-compression"
    },
    {
        "name": "Find All Duplicates In An Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-all-duplicates-in-an-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> result;\n        for (int num : nums) {\n            int index = abs(num) - 1;\n            if (nums[index] < 0) {\n                result.push_back(abs(num));\n            } else {\n                nums[index] *= -1;\n            }\n        }\n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        for (int num : nums) {\n            int index = Math.abs(num) - 1;\n            if (nums[index] < 0) {\n                result.add(Math.abs(num));\n            } else {\n                nums[index] = -nums[index];\n            }\n        }\n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution:\n    def findDuplicates(self, nums):\n        result = []\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] < 0:\n                result.append(abs(num))\n            else:\n                nums[index] *= -1\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller \n   calls free().\n */\nint* findDuplicates(int* nums, int numsSize, int* returnSize){\n    int* result = (int*)malloc(numsSize * sizeof(int));\n    *returnSize = 0;\n    \n    for (int i = 0; i < numsSize; i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            result[(*returnSize)++] = abs(nums[i]);\n        } else {\n            nums[index] = -nums[index];\n        }\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> FindDuplicates(int[] nums) {\n        List<int> result = new List<int>();\n        \n        for (int i = 0; i < nums.Length; i++) {\n            int index = Math.Abs(nums[i]) - 1;\n            if (nums[index] < 0) {\n                result.Add(index + 1);\n            } else {\n                nums[index] = -nums[index];\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findDuplicates = function(nums) {\n    let result = [];\n    \n    for (let num of nums) {\n        let index = Math.abs(num) - 1;\n        if (nums[index] < 0) {\n            result.push(index + 1);\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findDuplicates(nums: number[]): number[] {\n    const result: number[] = [];\n    for (let num of nums) {\n        const index = Math.abs(num) - 1;\n        if (nums[index] < 0) {\n            result.push(index + 1);\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function findDuplicates($nums) {\n        $result = [];\n        foreach ($nums as $num) {\n            $index = abs($num) - 1;\n            if ($nums[$index] < 0) {\n                $result[] = $index + 1;\n            } else {\n                $nums[$index] *= -1;\n            }\n        }\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findDuplicates(_ nums: [Int]) -> [Int] {\n        var result: [Int] = []\n        \n        var nums = nums\n        \n        for num in nums {\n            let index = abs(num) - 1\n            if nums[index] < 0 {\n                result.append(index + 1)\n            }\n            nums[index] = -nums[index]\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findDuplicates(nums: IntArray): List<Int> {\n        val result = mutableListOf<Int>()\n        for (num in nums) {\n            val index = Math.abs(num) - 1\n            if (nums[index] < 0) {\n                result.add(index + 1)\n            } else {\n                nums[index] = -nums[index]\n            }\n        }\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<int> findDuplicates(List<int> nums) {\n    List<int> result = [];\n    \n    for (int num in nums) {\n      int index = num.abs() - 1;\n      if (nums[index] < 0) {\n        result.add(index + 1);\n      } else {\n        nums[index] *= -1;\n      }\n    }\n    \n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findDuplicates(nums []int) []int {\n    result := []int{}\n    \n    for _, num := range nums {\n        index := abs(num) - 1\n        if nums[index] < 0 {\n            result = append(result, abs(num))\n        } else {\n            nums[index] *= -1\n        }\n    }\n    \n    return result\n}\n\nfunc abs(x int) int {\n    if x < 0 {\n        return -x\n    }\n    return x\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef find_duplicates(nums)\n    result = []\n    nums.each do |num|\n        index = num.abs - 1\n        if nums[index] < 0\n            result << index + 1\n        else\n            nums[index] *= -1\n        end\n    end\n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findDuplicates(nums: Array[Int]): List[Int] = {\n        val result = scala.collection.mutable.ListBuffer[Int]()\n        \n        for (num <- nums) {\n            val index = Math.abs(num) - 1\n            if (nums(index) < 0) {\n                result += index + 1\n            } else {\n                nums(index) = -nums(index)\n            }\n        }\n        \n        result.toList\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_duplicates(nums: Vec<i32>) -> Vec<i32> {\n        let mut result = Vec::new();\n        let mut nums = nums;\n        \n        for i in 0..nums.len() {\n            let index = (nums[i].abs() - 1) as usize;\n            if nums[index] < 0 {\n                result.push(nums[i].abs());\n            } else {\n                nums[index] *= -1;\n            }\n        }\n        \n        result\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (find-duplicates nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  (define seen (make-vector (+ (length nums) 1) 0))\n  (define result '())\n  \n  (for ([num nums])\n    (if (= (vector-ref seen num) 1)\n        (set! result (cons num result))\n        (vector-set! seen num 1)))\n  \n  result\n)"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec find_duplicates(Nums :: [integer()]) -> [integer()].\nfind_duplicates(Nums) ->\n    Result = lists:map(fun(_) -> 0 end, Nums),\n    find_duplicates(Nums, Result, []).\n\nfind_duplicates([], _, Result) ->\n    lists:reverse(Result);\nfind_duplicates([H|T], Seen, Result) ->\n    case lists:nth(H, Seen) of\n        0 -> find_duplicates(T, lists:sublist(Seen, H-1) ++ [1] ++ lists:nthtail(H, Seen), Result);\n        1 -> find_duplicates(T, Seen, [H|Result])\n    end.\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec find_duplicates(nums :: [integer]) :: [integer]\n  def find_duplicates(nums) do\n    Enum.reduce(nums, {[], %{}}, fn x, {duplicates, seen} ->\n      if Map.get(seen, x, 0) == 1 do\n        {[x | duplicates], seen}\n      else\n        {duplicates, Map.put(seen, x, 1)}\n      end\n    end)\n    |> elem(0)\n    |> Enum.reverse()\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the objective is to identify all the integers in a given array that appear exactly twice. We need to achieve this in O(n) time complexity, using only constant extra space.\n\n## Explanation\n\n1. **Problem Constraints**:\n   - The array `nums` has a length of n.\n   - All integers in `nums` are within the range from 1 to n.\n   - Each integer appears exactly once or twice in the array.\n\n2. **Approach**:\n   - Use the array itself to record the presence of elements to avoid extra space usage.\n   - Iterate through the array and treat each number as an index to mark the corresponding position in the array.\n   - For every number in the array, convert the value at the index indicated by the current number to its negative counterpart to mark its visitation.\n   - If an index is already marked negative, it indicates the current number has been encountered before, hence a duplicate.\n\n3. **Steps**:\n   1. Initialize an empty list to store duplicates.\n   2. Iterate through each element in the array:\n      - Compute the index as `abs(num) - 1`.\n      - If the value at this index is negative, the current number is a duplicate and should be added to the result.\n      - Otherwise, mark the value at this index as negative to indicate the visitation.\n   3. Return the list of duplicates.\n\n## Pseudocode\n\n```plaintext\n# Pseudocode\n\nfunction findDuplicates(nums):\n    result = []\n    \n    for each num in nums:\n        index = abs(num) - 1\n        \n        if nums[index] < 0:\n            result.append(abs(num))\n        else:\n            nums[index] *= -1\n    \n    return result\n```\n\nBy following this method and pseudocode, the solution ensures linear time complexity and constant extra space usage in accordance with the problem constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-all-duplicates-in-an-array"
    },
    {
        "name": "Minimum Genetic Mutation",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-genetic-mutation",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minMutation(string startGene, string endGene, vector<string>& bank) {\n        unordered_set<string> geneBank(bank.begin(), bank.end());\n        if (geneBank.find(endGene) == geneBank.end()) {\n            return -1;\n        }\n        \n        queue<string> q;\n        q.push(startGene);\n        int mutations = 0;\n        vector<char> bases = {'A', 'C', 'G', 'T'};\n        \n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                string currentGene = q.front();\n                q.pop();\n                \n                if (currentGene == endGene) {\n                    return mutations;\n                }\n                \n                for (int j = 0; j < 8; j++) {\n                    char originalChar = currentGene[j];\n                    for (char base : bases) {\n                        currentGene[j] = base;\n                        if (geneBank.find(currentGene) != geneBank.end()) {\n                            q.push(currentGene);\n                            geneBank.erase(currentGene);\n                        }\n                    }\n                    currentGene[j] = originalChar;\n                }\n            }\n            mutations++;\n        }\n        \n        return -1;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minMutation(String startGene, String endGene, String[] bank) {\n        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));\n        if (!bankSet.contains(endGene)) {\n            return -1;\n        }\n        \n        char[] choices = {'A', 'C', 'G', 'T'};\n        \n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.offer(startGene);\n        visited.add(startGene);\n        \n        int mutations = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String current = queue.poll();\n                if (current.equals(endGene)) {\n                    return mutations;\n                }\n                \n                char[] currentChars = current.toCharArray();\n                for (int j = 0; j < currentChars.length; j++) {\n                    char originalChar = currentChars[j];\n                    for (char c : choices) {\n                        currentChars[j] = c;\n                        String newGene = new String(currentChars);\n                        if (!visited.contains(newGene) && bankSet.contains(newGene)) {\n                            visited.add(newGene);\n                            queue.offer(newGene);\n                        }\n                    }\n                    currentChars[j] = originalChar;\n                }\n            }\n            \n            mutations++;\n        }\n        \n        return -1;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minMutation(self, startGene, endGene, bank):\n        if endGene not in bank:\n            return -1\n        \n        queue = [(startGene, 0)]\n        visited = set()\n        \n        while queue:\n            gene, mutations = queue.pop(0)\n            \n            if gene == endGene:\n                return mutations\n            \n            for i in range(len(gene)):\n                for nucleotide in ['A', 'C', 'G', 'T']:\n                    newGene = gene[:i] + nucleotide + gene[i+1:]\n                    \n                    if newGene in bank and newGene not in visited:\n                        visited.add(newGene)\n                        queue.append((newGene, mutations + 1))\n        \n        return -1"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinMutation(string startGene, string endGene, string[] bank) {\n        if (startGene == endGene) return 0;\n        \n        HashSet<string> bankSet = new HashSet<string>(bank);\n        if (!bankSet.Contains(endGene)) return -1;\n        \n        HashSet<string> visited = new HashSet<string>();\n        visited.Add(startGene);\n        \n        Queue<string> queue = new Queue<string>();\n        queue.Enqueue(startGene);\n        \n        char[] genes = new char[] { 'A', 'C', 'G', 'T' };\n        \n        int mutations = 0;\n        \n        while (queue.Count > 0) {\n            int size = queue.Count;\n            \n            for (int i = 0; i < size; i++) {\n                string currentGene = queue.Dequeue();\n                \n                if (currentGene == endGene) {\n                    return mutations;\n                }\n                \n                char[] geneArray = currentGene.ToCharArray();\n                \n                for (int j = 0; j < geneArray.Length; j++) {\n                    char originalChar = geneArray[j];\n                    \n                    foreach (char c in genes) {\n                        geneArray[j] = c;\n                        string newGene = new string(geneArray);\n                        \n                        if (bankSet.Contains(newGene) && !visited.Contains(newGene)) {\n                            visited.Add(newGene);\n                            queue.Enqueue(newGene);\n                        }\n                    }\n                    \n                    geneArray[j] = originalChar;\n                }\n            }\n            \n            mutations++;\n        }\n        \n        return -1;\n    }\n}\n  "
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} startGene\n * @param {string} endGene\n * @param {string[]} bank\n * @return {number}\n */\nvar minMutation = function(startGene, endGene, bank) {\n    if (startGene === endGene) return 0;\n    \n    let queue = [[startGene, 0]];\n    let bankSet = new Set(bank);\n    \n    while (queue.length > 0) {\n        let [gene, steps] = queue.shift();\n        \n        if (gene === endGene) return steps;\n        \n        for (let i = 0; i < gene.length; i++) {\n            for (let char of \"ACGT\") {\n                if (gene[i] === char) continue;\n                \n                let mutated = gene.slice(0, i) + char + gene.slice(i + 1);\n                \n                if (bankSet.has(mutated)) {\n                    queue.push([mutated, steps + 1]);\n                    bankSet.delete(mutated);\n                }\n            }\n        }\n    }\n    \n    return -1;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $startGene\n     * @param String $endGene\n     * @param String[] $bank\n     * @return Integer\n     */\n    function minMutation($startGene, $endGene, $bank) {\n        $queue = [[$startGene, 0]];\n        $bankSet = array_flip($bank);\n        \n        while (!empty($queue)) {\n            [$gene, $steps] = array_shift($queue);\n            if ($gene == $endGene) {\n                return $steps;\n            }\n            \n            for ($i = 0; $i < strlen($gene); $i++) {\n                foreach (['A', 'C', 'G', 'T'] as $replace) {\n                    if ($gene[$i] == $replace) continue;\n                    $newGene = substr_replace($gene, $replace, $i, 1);\n                    if (isset($bankSet[$newGene])) {\n                        unset($bankSet[$newGene]); // Mark as visited\n                        $queue[] = [$newGene, $steps + 1];\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minMutation(_ startGene: String, _ endGene: String, _ bank: [String]) -> Int {\n        if !bank.contains(endGene) {\n            return -1\n        }\n        \n        var visited = Set<String>()\n        var queue = [(startGene, 0)]\n        \n        while !queue.isEmpty {\n            let currentGene = queue.removeFirst()\n            let gene = currentGene.0\n            let mutations = currentGene.1\n            \n            if gene == endGene {\n                return mutations\n            }\n            \n            for nextGene in bank {\n                if !visited.contains(nextGene) && isOneMutationApart(gene, nextGene) {\n                    visited.insert(nextGene)\n                    queue.append((nextGene, mutations + 1))\n                }\n            }\n        }\n        \n        return -1\n    }\n    \n    func isOneMutationApart(_ gene1: String, _ gene2: String) -> Bool {\n        var differences = 0\n        for i in 0..<gene1.count {\n            if gene1[gene1.index(gene1.startIndex, offsetBy: i)] != gene2[gene2.index(gene2.startIndex, offsetBy: i)] {\n                differences += 1\n            }\n            if differences > 1 {\n                return false\n            }\n        }\n        return differences == 1\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can use the Breadth-First Search (BFS) algorithm. BFS will help us explore all possible valid mutations level by level until we find the target gene string. Below, we break down the solution into explanation and pseudocode sections.\n\n# Explanation\n1. **Check if the End Gene is in the Bank:** If `endGene` is not in the list of valid genes (`bank`), return -1 immediately since it's not possible to reach it.\n2. **Initialize BFS Structures:** We use a queue to keep track of the current gene string and the number of mutations taken so far. We also use a set called `visited` to keep track of the gene strings we've already processed to avoid re-processing and infinite loops.\n3. **Explore Possible Mutations:** For each gene, explore all possible single-character mutations by changing each position to 'A', 'C', 'G', or 'T'. For each newly formed gene, if it is valid (exists in the `bank`) and hasn't been visited yet, add it to the queue and mark it as visited.\n4. **Check for Solution:** If at any point the `endGene` is reached, return the number of mutations taken to reach it.\n5. **Terminate:** If the queue is exhausted without finding the `endGene`, return -1 indicating no valid mutation path exists.\n\n# Pseudocode\n\n```pseudocode\nFunction minMutation(startGene, endGene, bank):\n    if endGene not in bank:\n        return -1\n\n    Initialize queue with (startGene, 0)  # (current gene, number of mutations)\n    Initialize empty set visited\n\n    While queue is not empty:\n        (currentGene, mutations) = queue.pop_front()\n\n        if currentGene == endGene:\n            return mutations\n        \n        For each position in currentGene:\n            For each nucleotide in ['A', 'C', 'G', 'T']:\n                newGene = currentGene with nucleotide at position changed\n                \n                If newGene in bank and newGene not in visited:\n                    visited.add(newGene)\n                    queue.add((newGene, mutations + 1))\n    \n    return -1\n```\n\nThis pseudocode ensures that all possible paths are explored systematically, and the shortest path (minimum mutations) is found using BFS.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-genetic-mutation"
    },
    {
        "name": "K Th Smallest In Lexicographical Order",
        "site": "LeetCode",
        "href": "/solution/LeetCode-k-th-smallest-in-lexicographical-order",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findKthNumber(int n, int k) {\n        int curr = 1;\n        k--;\n        \n        while (k > 0) {\n            int steps = calculateSteps(n, curr, curr + 1);\n            if (steps <= k) {\n                curr++;\n                k -= steps;\n            } else {\n                curr *= 10;\n                k--;\n            }\n        }\n        \n        return curr;\n    }\n    \n    int calculateSteps(int n, long n1, long n2) {\n        int steps = 0;\n        while (n1 <= n) {\n            steps += min((long)n + 1, n2) - n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n        return steps;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findKthNumber(int n, int k) {\n        int curr = 1;\n        k = k - 1;\n\n        while (k > 0) {\n            int steps = calculateSteps(n, curr, curr + 1);\n            if (steps <= k) {\n                curr += 1;\n                k -= steps;\n            } else {\n                curr *= 10;\n                k -= 1;\n            }\n        }\n\n        return curr;\n    }\n\n    private int calculateSteps(int n, long n1, long n2) {\n        int steps = 0;\n        while (n1 <= n) {\n            steps += Math.min(n + 1, n2) - n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n        return steps;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count_steps(prefix, n):\n            curr = prefix\n            next = prefix + 1\n            steps = 0\n            while curr <= n:\n                steps += min(n + 1, next) - curr\n                curr *= 10\n                next *= 10\n            return steps\n        \n        prefix = 1\n        k -= 1\n        while k > 0:\n            steps = count_steps(prefix, n)\n            if steps <= k:\n                prefix += 1\n                k -= steps\n            else:\n                prefix *= 10\n                k -= 1\n        \n        return prefix"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int findKthNumber(int n, int k) {\n    int curr = 1;\n    k = k - 1;\n\n    while (k > 0) {\n        int steps = 0;\n        long long first = curr;\n        long long last = curr + 1;\n        \n        while (first <= n) {\n            steps += fmin((long long)n + 1, last) - first;\n            first *= 10;\n            last *= 10;\n        }\n        \n        if (steps <= k) {\n            curr++;\n            k -= steps;\n        } else {\n            curr *= 10;\n            k--;\n        }\n    }\n    \n    return curr;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindKthNumber(int n, int k) {\n        int curr = 1;\n        k = k - 1;\n\n        while (k > 0) {\n            long steps = getSteps(n, curr, curr + 1);\n            if (steps <= k) {\n                curr += 1;\n                k -= (int)steps;\n            } else {\n                curr *= 10;\n                k -= 1;\n            }\n        }\n\n        return curr;\n    }\n\n    private long getSteps(int n, long n1, long n2) {\n        long steps = 0;\n        while (n1 <= n) {\n            steps += Math.Min(n + 1, n2) - n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n        return steps;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar findKthNumber = function(n, k) {\n    let cur = 1;\n    k = k - 1;\n    \n    while (k > 0) {\n        let steps = calculateSteps(n, cur, cur + 1);\n        \n        if (steps <= k) {\n            k -= steps;\n            cur += 1;\n        } else {\n            k -= 1;\n            cur *= 10;\n        }\n    }\n    \n    return cur;\n};\n\nvar calculateSteps = function(n, n1, n2) {\n    let steps = 0;\n    \n    while (n1 <= n) {\n        steps += Math.min(n + 1, n2) - n1;\n        n1 *= 10;\n        n2 *= 10;\n    }\n    \n    return steps;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findKthNumber(n: number, k: number): number {\n    let curr = 1;\n    k = k - 1;\n    \n    while (k > 0) {\n        let steps = calculateSteps(n, curr, curr + 1);\n        if (steps <= k) {\n            curr += 1;\n            k -= steps;\n        } else {\n            curr *= 10;\n            k -= 1;\n        }\n    }\n    \n    return curr;\n};\n\nfunction calculateSteps(n: number, n1: number, n2: number): number {\n    let steps = 0;\n    \n    while (n1 <= n) {\n        steps += Math.min(n + 1, n2) - n1;\n        n1 *= 10;\n        n2 *= 10;\n    }\n    \n    return steps;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer\n     */\n    function findKthNumber($n, $k) {\n        $curr = 1;\n        $k -= 1;\n        while ($k > 0) {\n            $steps = $this->calculateSteps($n, $curr, $curr + 1);\n            if ($steps <= $k) {\n                $curr += 1;\n                $k -= $steps;\n            } else {\n                $curr *= 10;\n                $k -= 1;\n            }\n        }\n        return $curr;\n    }\n\n    private function calculateSteps($n, $n1, $n2) {\n        $steps = 0;\n        while ($n1 <= $n) {\n            $steps += min($n + 1, $n2) - $n1;\n            $n1 *= 10;\n            $n2 *= 10;\n        }\n        return $steps;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findKthNumber(_ n: Int, _ k: Int) -> Int {\n        var cur = 1\n        \n        var k = k - 1\n        \n        while k > 0 {\n            var steps = 0\n            var first = cur\n            var last = cur + 1\n            while first <= n {\n                steps += min(n + 1, last) - first\n                first *= 10\n                last *= 10\n            }\n            if steps <= k {\n                cur += 1\n                k -= steps\n            } else {\n                cur *= 10\n                k -= 1\n            }\n        }\n        \n        return cur\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int findKthNumber(int n, int k) {\n    int result = 1;\n    k--;\n    \n    while (k > 0) {\n      int steps = countSteps(n, result, result + 1);\n      if (steps <= k) {\n        result += 1;\n        k -= steps;\n      } else {\n        result *= 10;\n        k -= 1;\n      }\n    }\n    \n    return result;\n  }\n  \n  int countSteps(int n, int n1, int n2) {\n    int steps = 0;\n    \n    while (n1 <= n) {\n      steps += n + 1 - n1; // Made a slight change here\n      n1 *= 10;\n      n2 *= 10;\n    }\n    \n    return steps;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findKthNumber(n int, k int) int {\n    getCount := func(prefix int) int {\n        count := 0\n        cur, next := prefix, prefix+1\n        for cur <= n {\n            count += min(next, n+1) - cur\n            cur *= 10\n            next *= 10\n        }\n        return count\n    }\n\n    prefix := 1\n    p := 1\n    for p < k {\n        count := getCount(prefix)\n        if p+count > k {\n            prefix *= 10\n            p++\n        } else {\n            prefix++\n            p += count\n        }\n    }\n\n    return prefix\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer}\ndef find_kth_number(n, k)\n    cur = 1\n    k -= 1\n    while k > 0\n        count = 0\n        interval = [cur, cur + 1]\n        while interval[0] <= n\n            count += [n + 1, interval[1]].min - interval[0]\n            interval = [interval[0]*10, interval[1]*10]\n        end\n        if count <= k\n            cur += 1\n            k -= count\n        else\n            cur *= 10\n            k -= 1\n        end\n    end\n    return cur\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findKthNumber(n: Int, k: Int): Int = {\n        def countPrefix(prefix: Long, n: Int): Int = {\n            var count = 0\n            var cur = prefix\n            var next = prefix + 1\n\n            while (cur <= n) {\n                count += Math.min(n.toLong + 1, next).toInt - cur.toInt\n                cur *= 10\n                next *= 10\n            }\n\n            count\n        }\n\n        var kVal = k - 1\n        var current = 1\n\n        while (kVal > 0) {\n            val steps = countPrefix(current.toLong, n)\n            if (steps <= kVal) {\n                current += 1\n                kVal -= steps\n            } else {\n                current *= 10\n                kVal -= 1\n            }\n        }\n\n        current\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_kth_number(n: i32, k: i32) -> i32 {\n        let mut cur = 1;\n        let mut k = k - 1;\n\n        while k > 0 {\n            let steps = Self::calculate_steps(n, cur as i64, (cur + 1) as i64);\n            \n            if steps <= k {\n                cur += 1;\n                k -= steps;\n            } else {\n                cur *= 10;\n                k -= 1;\n            }\n        }\n\n        cur as i32\n    }\n\n    fn calculate_steps(n: i32, n1: i64, n2: i64) -> i32 {\n        let mut steps = 0;\n        let mut n1 = n1;\n        let mut n2 = n2;\n\n        while n1 <= n as i64 {\n            steps += i64::min(n as i64 + 1, n2) - n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n\n        steps as i32\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll focus on finding the k-th smallest number in lexicographical order within the range from 1 to n. The solution involves a combination of counting the number of lexicographical steps between prefixes and aggressively narrowing down the search until the k-th number is found.\n\n# Explanation\n\n1. **Counting Steps**: We use a helper function to count the steps between two prefixes within the given range. This function is crucial because it helps determine whether to move to the next prefix or go deeper within the current prefix.\n   \n2. **Initial Setup**: We start with the prefix `1` and reduce `k` by 1 since we are counting from 0.\n\n3. **Iterative Search**:\n    - While `k` is greater than 0, we'll count the steps of the current prefix.\n    - If the steps are less than or equal to `k`, it means the k-th number is beyond the current prefix, so we move to the next prefix.\n    - Otherwise, we go deeper into the current prefix.\n    - This process repeats until `k` is reduced to 0.\n\n4. **Returning Result**: The loop will end with the `prefix` pointing at the k-th lexicographical number.\n\n# Pseudocode\n\n```\nfunction findKthNumber(n, k):\n    # Helper function to count steps between prefixes\n    function count_steps(prefix, n):\n        curr = prefix\n        next = prefix + 1\n        steps = 0\n        \n        while curr <= n:\n            steps += min(n + 1, next) - curr\n            curr *= 10\n            next *= 10\n        \n        return steps\n    \n    prefix = 1\n    k -= 1  # Decrement k since we start from 1\n    \n    while k > 0:\n        # Calculate steps between the current prefix and the next prefix\n        steps = count_steps(prefix, n)\n        \n        if steps <= k:\n            # If there are fewer steps than k, move to the next prefix\n            prefix += 1\n            k -= steps\n        else:\n            # Otherwise, go deeper within the current prefix\n            prefix *= 10\n            k -= 1\n    \n    # Return the result - the k-th lexicographical number\n    return prefix\n```\n\nThis pseudocode outlines the core steps and logic needed to solve the problem iteratively by counting steps between prefixes and adjusting the prefix based on the value of `k`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-k-th-smallest-in-lexicographical-order"
    },
    {
        "name": "Find All Anagrams In A String",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-all-anagrams-in-a-string",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        \n        if (s == null || s.length() == 0 || p == null || p.length() == 0) {\n            return result;\n        }\n        \n        int[] target = new int[26], window = new int[26];\n        for (char c : p.toCharArray()) {\n            target[c - 'a']++;\n        }\n        \n        int left = 0, right = 0, count = p.length();\n        while (right < s.length()) {\n            if (target[s.charAt(right) - 'a'] > 0) {\n                window[s.charAt(right) - 'a']++;\n                if (window[s.charAt(right) - 'a'] <= target[s.charAt(right) - 'a']) {\n                    count--;\n                }\n            }\n            \n            if (right - left + 1 > p.length()) {\n                if (window[s.charAt(left) - 'a'] > 0) {\n                    if (window[s.charAt(left) - 'a'] <= target[s.charAt(left) - 'a']) {\n                        count++;\n                    }\n                    window[s.charAt(left) - 'a']--;\n                }\n                left++;\n            }\n            \n            if (count == 0) {\n                result.add(left);\n            }\n            \n            right++;\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[int]\n        \"\"\"\n        if not s or not p or len(s) < len(p):\n            return []\n\n        result = []\n        p_count = collections.Counter(p)\n        s_count = collections.Counter(s[:len(p)-1])\n\n        for i in range(len(p)-1, len(s)):\n            s_count[s[i]] += 1\n            if s_count == p_count:\n                result.append(i - len(p) + 1)\n            s_count[s[i - len(p) + 1]] -= 1\n            if s_count[s[i - len(p) + 1]] == 0:\n                del s_count[s[i - len(p) + 1]]\n\n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<int> FindAnagrams(string s, string p) {\n        List<int> result = new List<int>();\n        \n        if (s == null || s.Length == 0 || p == null || p.Length == 0) {\n            return result;\n        }\n        \n        int[] charCount = new int[26];\n        foreach (char c in p) {\n            charCount[c - 'a']++;\n        }\n        \n        int left = 0, right = 0, count = p.Length;\n        \n        while (right < s.Length) {\n            if (charCount[s[right] - 'a'] > 0) {\n                count--;\n            }\n            charCount[s[right] - 'a']--;\n            right++;\n            \n            if (count == 0) {\n                result.Add(left);\n            }\n            \n            if (right - left == p.Length) {\n                if (charCount[s[left] - 'a'] >= 0) {\n                    count++;\n                }\n                charCount[s[left] - 'a']++;\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nconst findAnagrams = (s, p) => {\n    const result = [];\n    const map = new Map();\n    for (let char of p) {\n        map.set(char, map.get(char) + 1 || 1);\n    }\n    let left = 0, right = 0, count = p.length;\n    \n    while (right < s.length) {\n        if (map.has(s[right]) && map.get(s[right]) > 0) {\n            map.set(s[right], map.get(s[right]) - 1);\n            count--;\n            right++;\n        } else if (map.has(s[left])) {\n            map.set(s[left], map.get(s[left]) + 1);\n            count++;\n            left++;\n        } else {\n            right++;\n            left = right;\n            count = p.length;\n        }\n        \n        if (count === 0) {\n            result.push(left);\n            map.set(s[left], map.get(s[left]) + 1);\n            count++;\n            left++;\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findAnagrams(s: string, p: string): number[] {\n    const result: number[] = [];\n    if (s.length < p.length) {\n        return result;\n    }\n\n    const charCountP: number[] = Array(26).fill(0);\n    const charCountS: number[] = Array(26).fill(0);\n    const aCharCode = \"a\".charCodeAt(0);\n\n    for (let i = 0; i < p.length; i++) {\n        charCountP[p.charCodeAt(i) - aCharCode]++;\n        charCountS[s.charCodeAt(i) - aCharCode]++;\n    }\n\n    for (let i = 0; i <= s.length - p.length; i++) {\n        if (charCountP.join(\"\") === charCountS.join(\"\")) {\n            result.push(i);\n        }\n\n        if (i < s.length - p.length) {\n            const startPos = s.charCodeAt(i) - aCharCode;\n            const endPos = s.charCodeAt(i + p.length) - aCharCode;\n            charCountS[startPos]--;\n            charCountS[endPos]++;\n        }\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findAnagrams(_ s: String, _ p: String) -> [Int] {\n        var result = [Int]()\n        let pArr = Array(p)\n        var pMap = [Character: Int]()\n        \n        for char in pArr {\n            pMap[char, default: 0] += 1\n        }\n        \n        let sArr = Array(s)\n        var sMap = [Character: Int]()\n        \n        for i in 0..<sArr.count {\n            sMap[sArr[i], default: 0] += 1\n            if i >= pArr.count {\n                let start = i - pArr.count\n                if let count = sMap[sArr[start]] {\n                    if count == 1 {\n                        sMap.removeValue(forKey: sArr[start])\n                    } else {\n                        sMap[sArr[start]] = count - 1\n                    }\n                }\n            }\n            \n            if i >= pArr.count - 1 && sMap == pMap {\n                result.append(i - pArr.count + 1)\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findAnagrams(s string, p string) []int {\n    var result []int\n    if len(s) == 0 || len(p) == 0 {\n        return result\n    }\n\n    pCount := make(map[byte]int)\n    for i := 0; i < len(p); i++ {\n        pCount[p[i]]++\n    }\n\n    left, right := 0, 0\n    remaining := len(p)\n\n    for right < len(s) {\n        if pCount[s[right]] > 0 {\n            remaining--\n        }\n        pCount[s[right]]--\n        right++\n\n        if remaining == 0 {\n            result = append(result, left)\n        }\n\n        if right-left == len(p) {\n            if pCount[s[left]] >= 0 {\n                remaining++\n            }\n            pCount[s[left]]++\n            left++\n        }\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {String} p\n# @return {Integer[]}\ndef find_anagrams(s, p)\n    result = []\n    return result if s.length < p.length\n    \n    p_freq = Array.new(26, 0)\n    s_freq = Array.new(26, 0)\n    \n    p.each_char { |char| p_freq[char.ord - 'a'.ord] += 1 }\n    \n    window_start = 0\n    p_length = p.length\n    \n    (0...s.length).each do |window_end|\n        right_char = s[window_end]\n        s_freq[right_char.ord - 'a'.ord] += 1\n        \n        if window_end >= p_length - 1\n            if s_freq == p_freq\n                result.push(window_start)\n            end\n            \n            left_char = s[window_start]\n            s_freq[left_char.ord - 'a'.ord] -= 1\n            window_start += 1\n        end\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_anagrams(s: String, p: String) -> Vec<i32> {\n        let s_chars: Vec<char> = s.chars().collect();\n        let p_chars: Vec<char> = p.chars().collect();\n        let mut res: Vec<i32> = Vec::new();\n\n        if s.len() < p.len() {\n            return res;\n        }\n\n        let mut p_freq: [i32; 26] = [0; 26];\n        let mut s_freq: [i32; 26] = [0; 26];\n\n        for &ch in p_chars.iter() {\n            let idx = (ch as u8 - b'a') as usize;\n            p_freq[idx] += 1;\n        }\n\n        for i in 0..s_chars.len() {\n            if i >= p_chars.len() {\n                let idx = (s_chars[i - p_chars.len()] as u8 - b'a') as usize;\n                s_freq[idx] -= 1;\n            }\n\n            let idx = (s_chars[i] as u8 - b'a') as usize;\n            s_freq[idx] += 1;\n\n            if i >= p_chars.len() - 1 {\n                if p_freq == s_freq {\n                    res.push((i - p_chars.len() + 1) as i32);\n                }\n            }\n        }\n\n        res\n    }\n}"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec find_anagrams(s :: String.t, p :: String.t) :: [integer]\n  def find_anagrams(s, p) do\n    len = String.length(p)\n    p_dict = Enum.reduce(String.graphemes(p), %{}, fn c, acc -> Map.update(acc, c, 1, &(&1 + 1)) end)\n    \n    Enum.map(0..String.length(s) - len, fn i ->\n      sub = String.slice(s, i, len)\n      sub_dict = Enum.reduce(String.graphemes(sub), %{}, fn c, acc -> Map.update(acc, c, 1, &(&1 + 1)) end)\n      Map.equal?(p_dict, sub_dict) && i\n    end) |> Enum.filter(&(&1))\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find all the starting indices of substrings in `s` that are anagrams of `p`.\n\n# Explanation\n1. **Input Constraints and Considerations**: \n    - The lengths of `s` and `p` are between 1 and 30,000.\n    - Both `s` and `p` consist only of lowercase English letters.\n2. **Understanding Anagrams**: An anagram of `p` must use all of its characters with the same frequency. Thus, a valid substring from `s` will have the same character frequency as `p`.\n3. **Optimal Approach**: Utilize the sliding window technique combined with frequency counters (dictionaries). This ensures we reduce the time complexity to O(n) compared to checking every possible substring which would be O(n * m).\n    - Use a frequency counter for `p`.\n    - Initialize a frequency counter for the first window in `s` of length equal to `p`.\n    - Slide the window across `s` and update the frequency counter dynamically.\n    - Each time the frequency counter matches that of `p`, record the starting index.\n\n# Pseudocode\n```\nfunction findAnagrams(s, p):\n    if length of s < length of p:\n        return []\n\n    result = []\n    p_count = frequencyCounter(p)\n    window_count = frequencyCounter(s[0 to len(p) - 1])\n\n    for i from len(p) to len(s):\n        if window_count == p_count:\n            result.append(i - len(p))\n\n        char_to_add = s[i]\n        window_count[char_to_add] += 1\n\n        char_to_remove = s[i - len(p)]\n        window_count[char_to_remove] -= 1\n\n        if window_count[char_to_remove] == 0:\n            remove char_to_remove from window_count\n\n    # Check the last window\n    if window_count == p_count:\n        result.append(len(s) - len(p))\n\n    return result\n\nfunction frequencyCounter(str):\n    count = {}\n    for char in str:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    return count\n```\n\nThis pseudocode effectively finds all anagrams by leveraging the sliding window approach and efficient counting of character frequencies.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-all-anagrams-in-a-string"
    },
    {
        "name": "Path Sum Iii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-path-sum-iii",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n        \nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        def dfs(node, target):\n            if not node:\n                return 0\n            \n            count = 0\n            if node.val == target:\n                count += 1\n            \n            count += dfs(node.left, target - node.val)\n            count += dfs(node.right, target - node.val)\n            \n            return count\n        \n        if not root:\n            return 0\n        \n        return dfs(root, targetSum) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n */\nvar pathSum = function(root, targetSum) {\n    if (!root) return 0;\n    \n    const dfs = (node, sum) => {\n        if (!node) return 0;\n        \n        let count = 0;\n        if (node.val === sum) count++;\n        count += dfs(node.left, sum - node.val);\n        count += dfs(node.right, sum - node.val);\n        \n        return count;\n    };\n    \n    return dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction pathSum(root: TreeNode | null, targetSum: number): number {\n    const map = new Map();\n    map.set(0, 1);\n    \n    return dfs(root, 0, targetSum, map);\n};\n\nfunction dfs(node: TreeNode | null, currentSum: number, targetSum: number, map: Map<number, number>): number {\n    if (node === null) return 0;\n    \n    currentSum += node.val;\n    let count = map.get(currentSum - targetSum) || 0;\n    map.set(currentSum, (map.get(currentSum) || 0) + 1);\n    \n    count += dfs(node.left, currentSum, targetSum, map) + dfs(node.right, currentSum, targetSum, map);\n    \n    map.set(currentSum, (map.get(currentSum) || 0) - 1);\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n\n    /**\n     * Definition for a binary tree node.\n     * class TreeNode {\n     *     public $val = null;\n     *     public $left = null;\n     *     public $right = null;\n     *     function __construct($value) {\n     *         $this->val = $value;\n     *     }\n     * }\n     */\n    \n    /**\n     * @param TreeNode $root\n     * @param Integer $targetSum\n     * @return Integer\n     */\n    function pathSum($root, $targetSum) {\n        if ($root === null) {\n            return 0;\n        }\n        \n        return $this->dfs($root, $targetSum) + $this->pathSum($root->left, $targetSum) + $this->pathSum($root->right, $targetSum);\n    }\n    \n    function dfs($node, $target) {\n        if ($node === null) {\n            return 0;\n        }\n        \n        $count = 0;\n        \n        if ($node->val === $target) {\n            $count++;\n        }\n        \n        $count += $this->dfs($node->left, $target - $node->val);\n        $count += $this->dfs($node->right, $target - $node->val);\n        \n        return $count;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *        self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func pathSum(_ root: TreeNode?, _ targetSum: Int) -> Int {\n        var count = 0\n        var sumMap: [Int: Int] = [0: 1]\n        \n        func dfs(_ node: TreeNode?, _ currentSum: Int, _ targetSum: Int) {\n            guard let node = node else { return }\n            \n            let newSum = currentSum + node.val\n            let complement = newSum - targetSum\n            count += sumMap[complement] ?? 0\n            \n            sumMap[newSum] = (sumMap[newSum] ?? 0) + 1\n            \n            dfs(node.left, newSum, targetSum)\n            dfs(node.right, newSum, targetSum)\n            \n            sumMap[newSum] = (sumMap[newSum] ?? 0) - 1\n        }\n        \n        dfs(root, 0, targetSum)\n        \n        return count\n    }\n}\n\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc pathSum(root *TreeNode, targetSum int) int {\n    if root == nil {\n        return 0\n    }\n    return pathSumFrom(root, targetSum) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)\n}\n\nfunc pathSumFrom(node *TreeNode, targetSum int) int {\n    if node == nil {\n        return 0\n    }\n    res := 0\n    if node.Val == targetSum {\n        res++\n    }\n    res += pathSumFrom(node.Left, targetSum-node.Val)\n    res += pathSumFrom(node.Right, targetSum-node.Val)\n    return res\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse the binary tree and determine how many paths sum up to a given target value. The paths can start or end at any node, but they must go downwards (from parent to child).\n\n# Explanation\n\n1. **Tree Traversal and DFS:** We will use Depth-First Search (DFS) to traverse each node. For each node, we'll check if any path from that node downward can sum up to the target.\n2. **Recursive Counting:** For each node, calculate the number of paths starting at that node that sum up to the target.\n3. **Summing Results:** Repeat the process for the left and right child nodes as starting points, and sum all these results for the total count.\n\n# Pseudocode\n\n```\nclass Solution:\n    def pathSum(self, root, targetSum):\n        # Helper function to perform DFS and count paths with sum equal to given target\n        def dfs(node, target):\n            if not node:\n                return 0\n\n            count = 0\n            if node.val == target:\n                count += 1\n            \n            # Recur for left and right children with the adjusted target (target - current node's value)\n            count += dfs(node.left, target - node.val)\n            count += dfs(node.right, target - node.val)\n            \n            return count\n        \n        if not root:\n            return 0\n        \n        # Calculate paths starting from the current root, and recursively do the same for left and right children nodes\n        return dfs(root, targetSum) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nThis pseudocode breaks down the problem into manageable parts:\n1. The `dfs` function checks for the paths starting from a given node and returns the count of such valid paths.\n2. The main function `pathSum` combines the results from different starting nodes to give the final count of paths that sum up to the target value.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-path-sum-iii"
    },
    {
        "name": "Find Right Interval",
        "site": "LeetCode",
        "href": "/solution/LeetCode-find-right-interval",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findRightInterval(vector<vector<int>>& intervals) {\n        map<int, int> startIdxMap;\n        vector<int> res;\n\n        for (int i = 0; i < intervals.size(); ++i) {\n            startIdxMap[intervals[i][0]] = i;\n        }\n\n        for (auto interval : intervals) {\n            auto it = startIdxMap.lower_bound(interval[1]);\n            if (it == startIdxMap.end()) {\n                res.push_back(-1);\n            } else {\n                res.push_back(it->second);\n            }\n        }\n\n        return res;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        int n = intervals.length;\n        int[] res = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            map.put(intervals[i][0], i);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            Integer key = map.ceilingKey(intervals[i][1]);\n            res[i] = (key != null) ? map.get(key) : -1; \n        }\n        \n        return res;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findRightInterval(self, intervals):\n        start_sorted = sorted([(interval[0], index) for index, interval in enumerate(intervals)])\n        result = []\n        for interval in intervals:\n            target = interval[1]\n            left, right = 0, len(start_sorted) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if start_sorted[mid][0] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            result.append(start_sorted[left][1] if left < len(start_sorted) else -1)\n        return result\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller \ncalls free().\n */\nint* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize){\n    int* result = (int*)malloc(intervalsSize * sizeof(int));\n    \n    for(int i = 0; i < intervalsSize; i++) {\n        int minIndex = -1;\n        int minStart = INT_MAX;\n        for(int j = 0; j < intervalsSize; j++) {\n            if(intervals[j][0] >= intervals[i][1] && intervals[j][0] < minStart) {\n                minIndex = j;\n                minStart = intervals[j][0];\n            }\n        }\n        result[i] = minIndex;\n    }\n    *returnSize = intervalsSize;\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] FindRightInterval(int[][] intervals) {\n        int[] result = new int[intervals.Length];\n        SortedDictionary<int, int> map = new SortedDictionary<int, int>();\n\n        for (int i = 0; i < intervals.Length; i++) {\n            map[intervals[i][0]] = i;\n        }\n\n        foreach (var interval in intervals) {\n            var end = interval[1];\n            var entry = map.FirstOrDefault(x => x.Key >= end);\n            result[Array.IndexOf(intervals, interval)] = entry.Equals(default(KeyValuePair<int,int>)) ? -1 : entry.Value;\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} intervals\n * @return {number[]}\n */\nvar findRightInterval = function(intervals) {\n    const startPoints = intervals.map((interval, index) => [interval[0], index]);\n    startPoints.sort((a, b) => a[0] - b[0]);\n    \n    return intervals.map(interval => {\n        const target = interval[1];\n        let left = 0;\n        let right = startPoints.length - 1;\n        while (left < right) {\n            const mid = Math.floor((left + right) / 2);\n            if (startPoints[mid][0] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return startPoints[left][0] >= target ? startPoints[left][1] : -1;\n    });\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findRightInterval(intervals: number[][]): number[] {\n    const n = intervals.length;\n    const result: number[] = [];\n\n    const sortedIntervals = intervals.map((interval, index) => [interval[0], interval[1], index]).sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 0; i < n; i++) {\n        let left = 0;\n        let right = n - 1;\n        let ans = -1;\n\n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n            if (sortedIntervals[mid][0] >= intervals[i][1]) {\n                ans = sortedIntervals[mid][2];\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        result.push(ans);\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $intervals\n     * @return Integer[]\n     */\n    function findRightInterval($intervals) {\n        $n = count($intervals);\n        $startMap = [];\n        $result = [];\n\n        foreach ($intervals as $key => $interval) {\n            $startMap[$interval[0]] = $key;\n        }\n\n        ksort($startMap);\n\n        foreach ($intervals as $interval) {\n            $target = $interval[1];\n            $found = false;\n            foreach ($startMap as $start => $index) {\n                if ($start >= $target) {\n                    $result[] = $index;\n                    $found = true;\n                    break;\n                }\n            }\n            if (!$found) {\n                $result[] = -1;\n            }\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findRightInterval(_ intervals: [[Int]]) -> [Int] {\n        var res = [Int]()\n        var intervalDict = [Int: Int]()\n        \n        for (index, interval) in intervals.enumerated() {\n            intervalDict[interval[0]] = index\n        }\n        \n        let sortedIntervals = intervals.sorted { $0[0] < $1[0] }\n        \n        for interval in intervals {\n            var low = 0\n            var high = sortedIntervals.count - 1\n            var rightIndex = -1\n            \n            while low <= high {\n                let mid = low + (high - low) / 2\n                if sortedIntervals[mid][0] >= interval[1] {\n                    rightIndex = intervalDict[sortedIntervals[mid][0]] ?? -1\n                    high = mid - 1\n                } else {\n                    low = mid + 1\n                }\n            }\n            \n            res.append(rightIndex)\n        }\n        \n        return res\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findRightInterval(intervals: Array<IntArray>): IntArray {\n        val n = intervals.size\n        val result = IntArray(n) { -1 }\n        val sortedIntervals = intervals.mapIndexed { index, interval -> Pair(interval[0], index) }\n            .sortedBy { it.first }\n        \n        for (i in intervals.indices) {\n            val end = intervals[i][1]\n            var left = 0\n            var right = n - 1\n            while (left <= right) {\n                val mid = left + (right - left) / 2\n                if (sortedIntervals[mid].first == end) {\n                    result[i] = sortedIntervals[mid].second\n                    break\n                } else if (sortedIntervals[mid].first < end) {\n                    left = mid + 1\n                } else {\n                    result[i] = sortedIntervals[mid].second\n                    right = mid - 1\n                }\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findRightInterval(intervals [][]int) []int {\n    n := len(intervals)\n    result := make([]int, n)\n    intervalsMap := make(map[int]int)\n\n    for i, interval := range intervals {\n        intervalsMap[interval[0]] = i\n    }\n\n    starts := make([]int, n)\n    for i, interval := range intervals {\n        starts[i] = interval[0]\n    }\n\n    sort.Ints(starts)\n\n    for i, interval := range intervals {\n        end := interval[1]\n        idx := sort.SearchInts(starts, end)\n        if idx == n {\n            result[i] = -1\n        } else {\n            result[i] = intervalsMap[starts[idx]]\n        }\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findRightInterval(intervals: Array[Array[Int]]): Array[Int] = {\n        var res = Array.fill(intervals.length)(-1)\n        val sortedIntervals = intervals.zipWithIndex.sortBy(_._1.head)\n        for (i <- 0 until intervals.length) {\n            var left = 0\n            var right = intervals.length - 1\n            while (left <= right) {\n                val mid = left + (right - left) / 2\n                if (sortedIntervals(mid)._1.head >= intervals(i)(1)) {\n                    res(i) = sortedIntervals(mid)._2\n                    right = mid - 1\n                } else {\n                    left = mid + 1\n                }\n            }\n        }\n        res\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the right intervals for each given interval. The right interval for an interval `i` is an interval `j` such that `start[j] >= end[i]` and `start[j]` is minimized. If no such interval exists, we should return `-1` for that interval.\n\nHere's a comprehensive explanation of the approach and the pseudocode.\n\n## Explanation\n1. **Sorting the Intervals by Start Time**: \n   - We sort the intervals by their start times while keeping track of their original indices. This sorted list will help us efficiently find the smallest start that is greater than or equal to a given end using binary search.\n\n2. **Binary Search for the Right Interval**:\n   - For each interval, we look for the smallest start time that is greater than or equal to its end time. Binary search is apt for this purpose because it allows us to quickly find the smallest acceptable start time in a sorted list.\n\n3. **Construct the Result List**:\n   - For each interval, append the index of the right interval found via binary search to the result list. If no right interval is found, append `-1`.\n\n## Pseudocode\n```plaintext\nfunction findRightInterval(intervals):\n    n = length(intervals)\n    \n    # Create a list of tuples (start, index) and sort it by start times\n    start_sorted = sort([(intervals[i][0], i) for i in range(n)])\n    \n    result = []\n    \n    for interval in intervals:\n        target = interval[1]\n        \n        # Initialize binary search bounds\n        left, right = 0, n - 1\n        index = -1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if start_sorted[mid][0] >= target:\n                index = start_sorted[mid][1]\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        result.append(index)\n    \n    return result\n```\n\n1. **Initialize Variables**:\n   - `n`: Total number of intervals.\n   - `start_sorted`: List of tuples with start times and their original indices, sorted by start times.\n\n2. **Binary Search**:\n   - For each interval, perform a binary search on `start_sorted` to find the smallest interval start time that is greater than or equal to the interval's end time.\n\n3. **Result Compilation**:\n   - Append the corresponding index to the result list, or `-1` if no suitable interval was found.\n\nThis solution ensures efficiency by leveraging sorting and binary search, making it scalable for input sizes up to the constraints given.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-find-right-interval"
    },
    {
        "name": "Non Overlapping Intervals",
        "site": "LeetCode",
        "href": "/solution/LeetCode-non-overlapping-intervals",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return 0;\n        \n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[1] < b[1];\n        });\n        \n        int count = 1;\n        int end = intervals[0][1];\n        \n        for (int i = 1; i < intervals.size(); i++) {\n            if (intervals[i][0] >= end) {\n                count++;\n                end = intervals[i][1];\n            }\n        }\n        \n        return intervals.size() - count;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\n\n        int count = 0;\n        int end = Integer.MIN_VALUE;\n\n        for (int[] interval : intervals) {\n            if (interval[0] >= end) {\n                end = interval[1];\n            } else {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int EraseOverlapIntervals(int[][] intervals) {\n        if (intervals == null || intervals.Length == 0) {\n            return 0;\n        }\n        \n        Array.Sort(intervals, (a, b) => a[1] - b[1]);\n        \n        int count = 0;\n        int end = intervals[0][1];\n        \n        for (int i = 1; i < intervals.Length; i++) {\n            if (intervals[i][0] < end) {\n                count++;\n            } else {\n                end = intervals[i][1];\n            }\n        }\n        \n        return count;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    let count = 0;\n    let prevEnd = intervals[0][1];\n    \n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prevEnd) {\n            count++;\n            prevEnd = Math.min(prevEnd, intervals[i][1]);\n        } else {\n            prevEnd = intervals[i][1];\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function eraseOverlapIntervals(intervals: number[][]): number {\n    intervals.sort((a, b) => a[1] - b[1]);\n    let count = 0;\n    let end = -Infinity;\n    for (const interval of intervals) {\n        if (interval[0] >= end) {\n            end = interval[1];\n        } else {\n            count++;\n        }\n    }\n    return count;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n        guard !intervals.isEmpty else {\n            return 0\n        }\n        \n        let sortedIntervals = intervals.sorted { $0[1] < $1[1] }\n        \n        var count = 1\n        var end = sortedIntervals[0][1]\n        \n        for i in 1..<sortedIntervals.count {\n            if sortedIntervals[i][0] >= end {\n                count += 1\n                end = sortedIntervals[i][1]\n            }\n        }\n        \n        return sortedIntervals.count - count\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun eraseOverlapIntervals(intervals: Array<IntArray>): Int {\n        if (intervals.isEmpty()) return 0\n        \n        intervals.sortBy { it[1] }\n        \n        var end = intervals[0][1]\n        var count = 0\n        \n        for (i in 1 until intervals.size) {\n            if (intervals[i][0] < end) {\n                count++\n            } else {\n                end = intervals[i][1]\n            }\n        }\n        \n        return count\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int eraseOverlapIntervals(List<List<int>> intervals) {\n    intervals.sort((a, b) => a[1] - b[1]);\n    int end = intervals[0][1];\n    int removeCount = 0;\n    \n    for (int i = 1; i < intervals.length; i++) {\n      if (intervals[i][0] < end) {\n        removeCount++;\n      } else {\n        end = intervals[i][1];\n      }\n    }\n    \n    return removeCount;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func eraseOverlapIntervals(intervals [][]int) int {\n    if len(intervals) == 0 {\n        return 0\n    }\n\n    sort.Slice(intervals, func(i, j int) bool {\n        return intervals[i][1] < intervals[j][1]\n    })\n\n    count := 1\n    end := intervals[0][1]\n\n    for i := 1; i < len(intervals); i++ {\n        if intervals[i][0] >= end {\n            count++\n            end = intervals[i][1]\n        }\n    }\n\n    return len(intervals) - count\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} intervals\n# @return {Integer}\ndef erase_overlap_intervals(intervals)\n    intervals.sort_by! { |interval| interval[1] }\n    non_overlapping_count = 0\n    end_time = intervals[0][1]\n    \n    (1...intervals.length).each do |i|\n        if intervals[i][0] < end_time\n            non_overlapping_count += 1\n        else\n            end_time = intervals[i][1]\n        end\n    end\n    \n    return non_overlapping_count\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def eraseOverlapIntervals(intervals: Array[Array[Int]]): Int = {\n        if (intervals.isEmpty) return 0\n        val sortedIntervals = intervals.sortBy(_.last)\n        var count = 1\n        var end = sortedIntervals.head(1)\n        \n        for (i <- 1 until sortedIntervals.length) {\n            if (sortedIntervals(i)(0) >= end) {\n                count += 1\n                end = sortedIntervals(i)(1)\n            }\n        }\n        \n        intervals.length - count\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn erase_overlap_intervals(intervals: Vec<Vec<i32>>) -> i32 {\n        let mut intervals = intervals;\n        intervals.sort_by(|a, b| a[1].cmp(&b[1]));\n        \n        let mut count = 0;\n        let mut end = i32::MIN;\n        \n        for interval in intervals {\n            if interval[0] >= end {\n                end = interval[1];\n            } else {\n                count += 1;\n            }\n        }\n        \n        count\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the minimum number of intervals to remove to make the rest of the intervals non-overlapping.\n\n### # Explanation\n1. **Sort by Start Times**: Begin by sorting the intervals based on their start times.\n2. **Initialize Counters**: Initialize a counter `count` to keep track of the number of intervals to remove. Also, initialize `prevEnd` to store the end time of the previous interval in the sorted list.\n3. **Iterate and Compare**: Iterate through the sorted intervals starting from the second interval. For each interval:\n   - If the start time of the current interval is less than the end time of the previous interval (`intervals[i][0] < prevEnd`), an overlap is detected:\n     - Increment the `count` because this interval overlaps with the previous one.\n     - Update `prevEnd` to be the minimum of the current interval's end time or `prevEnd`, ensuring we have the smallest end time to potentially reduce future overlaps.\n   - If there's no overlap, simply update `prevEnd` to the end time of the current interval.\n4. **Return the Count**: Finally, return the `count` which represents the number of intervals removed to eliminate all overlaps.\n\n### # Pseudocode\n```\nfunction eraseOverlapIntervals(intervals):\n    # Step 1: Sort intervals based on their start times\n    sort(intervals, by start time)\n    \n    # Step 2: Initialize count and prevEnd\n    count = 0\n    prevEnd = intervals[0][1]\n    \n    # Step 3: Iterate through sorted intervals starting from the second interval\n    for i from 1 to length(intervals) - 1:\n        if intervals[i][0] < prevEnd then:\n            # Overlapping interval found, increment the count\n            count += 1\n            # Update prevEnd to the minimum end time to reduce future overlaps\n            prevEnd = min(prevEnd, intervals[i][1])\n        else:\n            # No overlap, update prevEnd to current interval's end time\n            prevEnd = intervals[i][1]\n    \n    # Step 4: Return the count of intervals to remove\n    return count\n```\n\nThis pseudocode outlines the high-level approach to solving the problem, including sorting the intervals, iterating over them to detect overlaps, and counting the intervals to be removed.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-non-overlapping-intervals"
    },
    {
        "name": "Number Of Segments In A String",
        "site": "LeetCode",
        "href": "/solution/LeetCode-number-of-segments-in-a-string",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int countSegments(string s) {\n        int count = 0;\n        bool inSegment = false;\n        \n        for(char c : s) {\n            if(c != ' ' && !inSegment) {\n                count++;\n                inSegment = true;\n            } else if(c == ' ' && inSegment) {\n                inSegment = false;\n            }\n        }\n        \n        return count;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int countSegments(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if ((i == 0 || s.charAt(i - 1) == ' ') && s.charAt(i) != ' ') {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        \n        segments = s.split()\n        return len(segments)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int countSegments(char* s) {\n    int count = 0;\n    int i = 0;\n    while (s[i] != '\\0') {\n        if (s[i] != ' ' && (i == 0 || s[i - 1] == ' ')) {\n            count++;\n        }\n        i++;\n    }\n    return count;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int CountSegments(string s) {\n        if (string.IsNullOrWhiteSpace(s)) {\n            return 0;\n        }\n        \n        int count = 0;\n        \n        for (int i = 0; i < s.Length; i++) {\n            if ((i == 0 || s[i - 1] == ' ') && s[i] != ' ') {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar countSegments = function(s) {\n    let count = 0;\n    for (let i = 0; i < s.length; i++) {\n        if ((i === 0 || s[i-1] === ' ') && s[i] !== ' ') {\n            count++;\n        }\n    }\n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function countSegments(s: string): number {\n    if (s.trim() === '') return 0;\n    return s.trim().split(/\\s+/).length;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function countSegments($s) {\n        $segments = explode(\" \", $s);\n        $count = 0;\n        foreach ($segments as $seg) {\n            if ($seg != \"\") {\n                $count++;\n            }\n        }\n        return $count;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func countSegments(_ s: String) -> Int {\n        let trimmedString = s.trimmingCharacters(in: .whitespaces)\n        if trimmedString.isEmpty {\n            return 0\n        }\n        \n        var count = 1\n        for i in 0..<(trimmedString.count - 1) {\n            if trimmedString[trimmedString.index(trimmedString.startIndex, offsetBy: i)] == \" \" && trimmedString[trimmedString.index(trimmedString.startIndex, offsetBy: i+1)] != \" \" {\n                count += 1\n            }\n        }\n        \n        return count\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun countSegments(s: String): Int {\n        if (s.isEmpty()) {\n            return 0\n        }\n        \n        var count = 0\n        var inSegment = false\n        \n        for (char in s) {\n            if (char != ' ' && !inSegment) {\n                inSegment = true\n                count++\n            } else if (char == ' ') {\n                inSegment = false\n            }\n        }\n        \n        return count\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int countSegments(String s) {\n    if (s.isEmpty) {\n      return 0;\n    }\n    \n    int count = 0;\n    for (int i = 0; i < s.length; i++) {\n      if ((i == 0 || s[i - 1] == ' ') && s[i] != ' ') {\n        count++;\n      }\n    }\n    \n    return count;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func countSegments(s string) int {\n    count := 0\n    for i := 0; i < len(s); i++ {\n        if (i == 0 || s[i-1] == ' ') && s[i] != ' ' {\n            count++\n        }\n    }\n    return count\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef count_segments(s)\n    s.split(\" \").count { |segment| !segment.empty? }\nend\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec count_segments(s :: String.t) :: integer\n  def count_segments(s) do\n    segments = s |> String.split(\" \") |> Enum.reject(&(&1 == \"\"))\n    Enum.count(segments)\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to count the number of segments in a given string `s`, where a segment is defined as a contiguous sequence of non-space characters. We can achieve this by utilizing Python's string manipulation methods.\n\nHere's a step-by-step explanation and pseudocode for the solution:\n\n# Explanation\n1. **Check for Empty String**: If the input string `s` is empty, the number of segments is `0`, as there are no characters to form any segment.\n2. **Splitting the String**: Use the `split()` method. This method splits the string at each space and returns a list of segments (non-space character sequences).\n3. **Count the Segments**: The length of the list returned by `split()` gives the total number of segments in the string.\n\n# Pseudocode\n```\nfunction countSegments(s: string) -> int:\n    if s is empty:\n        return 0\n    \n    segments = split(s, ' ')\n    return length(segments)\n```\n\nThis pseudocode translates to the following steps:\n- Check if the input string `s` is empty.\n- Use the `split()` method to divide the string into segments based on spaces.\n- Return the length of the resulting list which represents the number of segments.\n\nBy following these steps, we can determine the number of segments in any given string `s`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-number-of-segments-in-a-string"
    },
    {
        "name": "N Ary Tree Level Order Traversal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-n-ary-tree-level-order-traversal",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\nclass Solution(object):\n    def levelOrder(self, root):\n        if not root:\n            return []\n        \n        result = []\n        queue = [root]\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                queue.extend(node.children)\n            result.append(level)\n        \n        return result\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n */\n\nvar levelOrder = function(root) {\n    if(!root) return [];\n    \n    let result = [];\n    let queue = [root];\n    \n    while(queue.length > 0) {\n        let size = queue.length;\n        let currentLevel = [];\n        \n        for(let i = 0; i < size; i++) {\n            let node = queue.shift();\n            currentLevel.push(node.val);\n            if(node.children) {\n                queue.push(...node.children);\n            }\n        }\n        \n        result.push(currentLevel);\n    }\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for node.\n * class Node {\n *     val: number\n *     children: Node[]\n *     constructor(val?: number) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.children = []\n *     }\n * }\n */\nfunction levelOrder(root: Node | null): number[][] {\n    if (!root) return [];\n\n    const result: number[][] = [];\n    const queue: Node[] = [root];\n\n    while (queue.length > 0) {\n        const levelSize: number = queue.length;\n        const currentLevel: number[] = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const current: Node = queue.shift() as Node;\n            currentLevel.push(current.val);\n            current.children.forEach(child => queue.push(child));\n        }\n\n        result.push(currentLevel);\n    }\n\n    return result;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $children = [];\n * }\n */\nclass Solution {\n\n    /**\n     * @param Node $root\n     * @return Integer[][]\n     */\n    function levelOrder($root) {\n        if ($root === null) return [];\n        $result = [];\n        $queue = [$root];\n        \n        while (!empty($queue)) {\n            $level = [];\n            $size = count($queue);\n            for ($i = 0; $i < $size; $i++) {\n                $node = array_shift($queue);\n                $level[] = $node->val;\n                foreach ($node->children as $child) {\n                    array_push($queue, $child);\n                }\n            }\n            $result[] = $level;\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var children: [Node]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.children = []\n *     }\n * }\n */\n\nclass Solution {\n    func levelOrder(_ root: Node?) -> [[Int]] {\n        guard let root = root else { return [] }\n        \n        var result = [[Int]]()\n        var queue = [Node]()\n        queue.append(root)\n        \n        while !queue.isEmpty {\n            var levelValues = [Int]()\n            let levelSize = queue.count\n            \n            for _ in 0..<levelSize {\n                let node = queue.removeFirst()\n                levelValues.append(node.val)\n                queue.append(contentsOf: node.children)\n            }\n            \n            result.append(levelValues)\n        }\n        \n        return result\n    }\n}\n  "
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\nfunc levelOrder(root *Node) [][]int {\n    result := [][]int{}\n    if root == nil {\n        return result\n    }\n\n    queue := []*Node{root}\n    \n    for len(queue) > 0 {\n        levelSize := len(queue)\n        levelValues := []int{}\n        \n        for i := 0; i < levelSize; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            levelValues = append(levelValues, node.Val)\n            for _, child := range node.Children {\n                queue = append(queue, child)\n            }\n        }\n        \n        result = append(result, levelValues)\n    }\n    \n    return result\n}\n  "
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :children\n#     def initialize(val)\n#         @val = val\n#         @children = []\n#     end\n# end\n\n# @param {Node} root\n# @return {Integer[][]}\ndef level_order(root)\n    return [] if root.nil?\n    \n    result = []\n    queue = [root]\n    \n    until queue.empty?\n        current_level = []\n        next_level = []\n        \n        queue.each do |node|\n            current_level << node.val\n            next_level += node.children if node.children\n        end\n        \n        result << current_level\n        queue = next_level\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var children: List[Node] = List()\n * }\n */\n\nobject Solution {\n    def levelOrder(root: Node): List[List[Int]] = {\n        import scala.collection.mutable.Queue\n        \n        val result = scala.collection.mutable.ListBuffer[List[Int]]()\n        \n        if (root == null) return result.toList\n\n        val q = Queue[Node]()\n        q.enqueue(root)\n\n        while (q.nonEmpty) {\n            val levelSize = q.size\n            val levelNodes = scala.collection.mutable.ListBuffer[Int]()\n\n            for (_ <- 0 until levelSize) {\n                val node = q.dequeue()\n                levelNodes += node.value\n                for(child <- node.children) {\n                    if(child != null) q.enqueue(child)\n                }\n            }\n\n            result += levelNodes.toList\n        }\n\n        result.toList\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to perform a level order traversal of an n-ary tree. A level order traversal means visiting nodes level by level from top to bottom and left to right within each level. Here\u2019s how we can approach the solution:\n\n### # Explanation\n1. **Definition of Node**: Each node in an n-ary tree has a value and a list of children.\n2. **BFS Approach**: We can use a Breadth-First Search (BFS) approach which uses a queue to keep track of nodes to visit at each level. This is appropriate for level order traversal.\n3. **Initialization**: Start with a queue initialized with the root node.\n4. **Processing Nodes**: For each node, process all its children and then move on to the next level.\n5. **Store Levels**: Keep a list to store the nodes' values level by level.\n\n### # Pseudocode\n\n```pseudo\n# Create class definitions\nclass Node:\n    # Constructor to initialize a node\n    function __init__(val, children=None):\n        this.val = val\n        this.children = children if children else []\n\nclass Solution:\n    # Function to perform level order traversal\n    function levelOrder(root):\n        if root is null:\n            return []\n\n        # Initialize the result list and queue\n        result = []\n        queue = [root]\n        \n        # While there are nodes to process\n        while queue is not empty:\n            level = []\n\n            # Process all nodes at the current level\n            for i from 0 to len(queue) - 1:\n                node = queue.pop(0)\n                level.append(node.val)  # Collect the node value\n                queue.extend(node.children)  # Add all children to the queue\n            \n            # Add current level to the result\n            result.append(level)\n        \n        return result\n```\n\nWith this design:\n- The **Node** class represents each element of the n-ary tree.\n- The **levelOrder** function in the **Solution** class executes the BFS to collect nodes at each level and appends the list of nodes to the result list for each tree level.\n\nBy following this approach, we can construct a solution that provides the level order traversal of the n-ary tree effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-n-ary-tree-level-order-traversal"
    },
    {
        "name": "All Oone Data Structure",
        "site": "LeetCode",
        "href": "/solution/LeetCode-all-oone-data-structure",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class AllOne {\n    class Node {\n        String key;\n        int count;\n        \n        public Node(String key, int count) {\n            this.key = key;\n            this.count = count;\n        }\n    }\n    \n    Map<String, Node> keyMap;\n    TreeMap<Integer, LinkedHashSet<String>> countMap;\n    \n    public AllOne() {\n        keyMap = new HashMap<>();\n        countMap = new TreeMap<>();\n    }\n    \n    public void inc(String key) {\n        if (keyMap.containsKey(key)) {\n            Node node = keyMap.get(key);\n            int prevCount = node.count;\n            int newCount = prevCount + 1;\n            node.count = newCount;\n            keyMap.put(key, node);\n            \n            countMap.get(prevCount).remove(key);\n            if (countMap.get(prevCount).isEmpty()) {\n                countMap.remove(prevCount);\n            }\n            \n            countMap.putIfAbsent(newCount, new LinkedHashSet<>());\n            countMap.get(newCount).add(key);\n        } else {\n            Node node = new Node(key, 1);\n            keyMap.put(key, node);\n            \n            countMap.putIfAbsent(1, new LinkedHashSet<>());\n            countMap.get(1).add(key);\n        }\n    }\n    \n    public void dec(String key) {\n        if (keyMap.containsKey(key)) {\n            Node node = keyMap.get(key);\n            int prevCount = node.count;\n            int newCount = prevCount - 1;\n            \n            if (newCount == 0) {\n                keyMap.remove(key);\n                countMap.get(prevCount).remove(key);\n                if (countMap.get(prevCount).isEmpty()) {\n                    countMap.remove(prevCount);\n                }\n            } else {\n                node.count = newCount;\n                keyMap.put(key, node);\n                \n                countMap.get(prevCount).remove(key);\n                if (countMap.get(prevCount).isEmpty()) {\n                    countMap.remove(prevCount);\n                }\n            \n                countMap.putIfAbsent(newCount, new LinkedHashSet<>());\n                countMap.get(newCount).add(key);\n            }\n        }\n    }\n    \n    public String getMaxKey() {\n        if (countMap.isEmpty()) {\n            return \"\";\n        }\n        return countMap.lastEntry().getValue().iterator().next();\n    }\n    \n    public String getMinKey() {\n        if (countMap.isEmpty()) {\n            return \"\";\n        }\n        return countMap.firstEntry().getValue().iterator().next();\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class AllOne {\n  Map<String, int> counters = {};\n\n  void inc(String key) {\n    counters[key] = (counters[key] ?? 0) + 1;\n  }\n\n  void dec(String key) {\n    counters[key] = (counters[key] ?? 0) - 1;\n    if (counters[key] == 0) {\n      counters.remove(key);\n    }\n  }\n\n  String getMaxKey() {\n    if (counters.isEmpty) {\n      return \"\";\n    }\n\n    return counters.entries.reduce((a, b) => a.value > b.value ? a : b).key;\n  }\n\n  String getMinKey() {\n    if (counters.isEmpty) {\n      return \"\";\n    }\n\n    return counters.entries.reduce((a, b) => a.value < b.value ? a : b).key;\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to design a data structure that allows storage, increment, decrement, and retrieval of strings by their counts. We will separately use a couple of data structures to achieve this while ensuring an O(1) average time complexity for each operation.\n\n# Explanation\n1. **Data Structures**:\n   - `keyMap`: A hash map to store the count of each key.\n   - `countMap`: A tree map to store keys in different sets under their respective count values.\n\n2. **Operations**:\n   - **Initialization (`AllOne`)**: Initialize `keyMap` and `countMap`.\n   - **Increment (`inc`)**:\n     - If the key is already in `keyMap`, increment its count.\n     - If it's a new key, add it with a count of 1.\n     - Adjust the placement of the key in the `countMap` based on the updated count.\n   - **Decrement (`dec`)**:\n     - If the key's count becomes zero, remove it from both maps.\n     - Otherwise, decrement its count and adjust its position in `countMap`.\n   - **Get Maximum Key (`getMaxKey`)**: Retrieve the key with the highest count from `countMap`.\n   - **Get Minimum Key (`getMinKey`)**: Retrieve the key with the lowest count from `countMap`.\n\nHere's the pseudocode detailed:\n\n# Pseudocode\n```\nclass AllOne:\n    class Node:\n        def __init__(self, key, count):\n            self.key = key\n            self.count = count\n  \n    def __init__(self):\n        Initialize keyMap as empty.\n        Initialize countMap as empty.\n\n    def inc(self, key):\n        if keyMap contains key:\n            node = keyMap[key]\n            prevCount = node.count\n            newCount = prevCount + 1\n            node.count = newCount\n            \n            Remove key from countMap at prevCount\n            if countMap[prevCount] is empty:\n                Remove prevCount from countMap\n            \n            Add key to countMap at newCount\n        else:\n            node = Node(key, 1)\n            keyMap[key] = node\n          \n            Add key to countMap at count 1\n\n    def dec(self, key):\n        node = keyMap[key]\n        prevCount = node.count\n        newCount = prevCount - 1\n        \n        if newCount == 0:\n            Remove key from keyMap\n            Remove key from countMap at prevCount\n            if countMap[prevCount] is empty:\n                Remove prevCount from countMap\n        else:\n            node.count = newCount\n            keyMap[key] = node\n            \n            Remove key from countMap at prevCount\n            if countMap[prevCount] is empty:\n                Remove prevCount from countMap\n\n            Add key to countMap at newCount\n\n    def getMaxKey(self):\n        if countMap is empty:\n            return \"\"\n        else:\n            maxCount = maximum key in countMap\n            return any element from countMap[maxCount]\n\n    def getMinKey(self):\n        if countMap is empty:\n            return \"\"\n        else:\n            minCount = minimum key in countMap\n            return any element from countMap[minCount]\n```\n\nBy following this structured approach, each of the required operations (increment, decrement, get maximum key, get minimum key) will be achieved with optimal efficiency.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-all-oone-data-structure"
    },
    {
        "name": "Flatten A Multilevel Doubly Linked List",
        "site": "LeetCode",
        "href": "/solution/LeetCode-flatten-a-multilevel-doubly-linked-list",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public Node flatten(Node head) {\n        if (head == null) {\n            return null;\n        }\n        \n        Node pseudoHead = new Node();\n        pseudoHead.next = head;\n        \n        flattenDFS(pseudoHead, head);\n        \n        pseudoHead.next.prev = null;\n        return pseudoHead.next;\n    }\n    \n    private Node flattenDFS(Node prev, Node curr) {\n        if (curr == null) {\n            return prev;\n        }\n        \n        curr.prev = prev;\n        prev.next = curr;\n        \n        Node tempNext = curr.next;\n        \n        Node tail = flattenDFS(curr, curr.child);\n        curr.child = null;\n        \n        return flattenDFS(tail, tempNext);\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\nclass Solution(object):\n    def flatten(self, head):\n        if not head:\n            return head\n        \n        pseudo_head = Node(0, None, head, None)\n        self.flatten_dfs(pseudo_head, head)\n        pseudo_head.next.prev = None\n        return pseudo_head.next\n    \n    def flatten_dfs(self, prev, curr):\n        if not curr:\n            return prev\n        \n        curr.prev = prev\n        prev.next = curr\n        \n        temp_next = curr.next\n        tail = self.flatten_dfs(curr, curr.child)\n        curr.child = None\n\n        return self.flatten_dfs(tail, temp_next)\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public Node Flatten(Node head) {\n        if(head == null) return null;\n        \n        Node curr = head;\n        while(curr != null) {\n            if(curr.child != null) {\n                Node next = curr.next;\n                Node child = Flatten(curr.child);\n                curr.child = null;\n                \n                curr.next = child;\n                child.prev = curr;\n                \n                while(child.next != null) {\n                    child = child.next;\n                }\n                \n                child.next = next;\n                if(next != null) {\n                    next.prev = child;\n                }\n            }\n            curr = curr.next;\n        }\n        \n        return head;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * // Definition for a Node.\n * function Node(val,prev,next,child) {\n *    this.val = val;\n *    this.prev = prev;\n *    this.next = next;\n *    this.child = child;\n * };\n *\n * @param {Node} head\n * @return {Node}\n */\nvar flatten = function(head) {\n    if (!head) return head;\n    \n    let stack = [head];\n    let prev = null;\n    \n    while (stack.length > 0) {\n        let current = stack.pop();\n        \n        if (current.next) stack.push(current.next);\n        if (current.child) {\n            stack.push(current.child);\n            current.next = current.child;\n            current.child.prev = current;\n            current.child = null;\n        }\n        \n        if (prev) {\n            prev.next = current;\n            current.prev = prev;\n        }\n        \n        prev = current;\n    }\n    \n    while (head.prev) {\n        head = head.prev;\n    }\n    \n    return head;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for node.\n * class Node {\n *     val: number\n *     prev: Node | null\n *     next: Node | null\n *     child: Node | null\n *     constructor(val?: number, prev?: Node, next?: Node, child?: Node) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.prev = (prev === undefined ? null : prev)\n *         this.next = (next === undefined ? null : next)\n *         this.child = (child === undefined ? null : child)\n *     }\n * }\n */\nfunction flatten(head: Node | null): Node | null {\n    if (!head) return head;\n    \n    let current: Node | null = head;\n    while (current) {\n        if (current.child) {\n            let next = current.next;\n            current.next = flatten(current.child);\n            current.next.prev = current;\n            current.child = null;\n            while (current.next) {\n                current = current.next;\n            }\n            current.next = next;\n            if (next) {\n                next.prev = current;\n            }\n        }\n        current = current.next;\n    }\n    \n    return head;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $prev = null;\n *     public $next = null;\n *     public $child = null;\n * }\n */\n\nclass Solution {\n    /**\n     * @param Node $head\n     * @return Node\n     */\n    function flatten($head) {\n        $stack = [];\n        $current = $head;\n        while ($current !== null || !empty($stack)) {\n            if ($current->child !== null) {\n                if ($current->next !== null) {\n                    array_push($stack, $current->next);\n                }\n                $current->next = $current->child;\n                $current->child->prev = $current;\n                $current->child = null;\n            }\n            if ($current->next === null && !empty($stack)) {\n                $current->next = array_pop($stack);\n                $current->next->prev = $current;\n            }\n            $current = $current->next;\n        }\n        return $head;\n    }\n}\n\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Prev *Node\n *     Next *Node\n *     Child *Node\n * }\n */\n\nfunc flatten(root *Node) *Node {\n    if root == nil {\n        return root\n    }\n\n    pseudoHead := &Node{}\n    prev := pseudoHead\n    stack := []*Node{root}\n\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        prev.Next = node\n        node.Prev = prev\n\n        if node.Next != nil {\n            stack = append(stack, node.Next)\n        }\n        if node.Child != nil {\n            stack = append(stack, node.Child)\n            node.Child = nil\n        }\n\n        prev = node\n    }\n\n    pseudoHead.Next.Prev = nil\n    return pseudoHead.Next\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :prev, :next, :child\n#     def initialize(val=nil, prev=nil, next_=nil, child=nil)\n#         @val = val\n#         @prev = prev\n#         @next = next_\n#         @child = child\n#     end\n# end\n\ndef flatten(head)\n    return head if head.nil?\n    \n    sentinel = Node.new\n    curr, prev = head, sentinel\n    \n    stack = []\n    \n    while curr != nil || !stack.empty?\n        if curr && curr.child\n            if curr.next\n                stack.push(curr.next)\n            end\n            curr.next = curr.child\n            curr.next.prev = curr\n            curr.child = nil\n        end\n        \n        if curr.nil? && !stack.empty?\n            curr = stack.pop\n        end\n        \n        prev.next = curr\n        curr.prev = prev\n        prev = curr\n        curr = curr.next\n    end\n    \n    sentinel.next.prev = nil\n    sentinel.next\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var prev: Node = null\n *   var next: Node = null\n *   var child: Node = null\n */\n\nobject Solution {\n  def flatten(head: Node): Node = {\n    var current = head\n    while (current != null) {\n      if (current.child != null) {\n        val next = current.next\n        val child = flatten(current.child)\n        current.next = child\n        child.prev = current\n        current.child = null\n        var temp = child\n        while (temp.next != null) {\n          temp = temp.next\n        }\n        temp.next = next\n        if (next != null) {\n          next.prev = temp\n        }\n      }\n      current = current.next\n    }\n    head\n  }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to flatten a multilevel doubly linked list so that all nodes appear in a single-level, doubly linked list. The key steps include traversing the list, identifying nodes with child pointers, and inserting these child nodes between the current node and the next node, while ensuring that all child pointers are set to null.\n\n# Explanation\n1. **Initial Check**: If the head of the list is null, return null.\n2. **Helper Function**: Implement a helper function to handle the depth-first search (DFS) traversal of the multilevel list.\n3. **Pseudo Head**: Create a pseudo head to simplify edge cases (like handling prev pointers of the actual head).\n4. **DFS Traversal**: Traverse through the list using the DFS approach to properly link all nodes in a single-level, ensuring to process child nodes before moving to the next node.\n5. **Re-linking**: For each node, if it has a child, recursively flatten the child list, attach it to the current node, and then move to the next node.\n6. **Finish Up**: Ensure all child pointers are set to null and correctly update the previous and next pointers to reflect the flattened list.\n\n# Pseudocode\n```\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, prev, next, child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\nclass Solution:\n    def flatten(self, head):\n        # Initial guard clause\n        if not head:\n            return head\n\n        # Create a pseudo head to handle edge cases smoothly\n        pseudo_head = Node(0, None, head, None)\n        self.flatten_dfs(pseudo_head, head)\n        \n        # Detach the pseudo head from the real head\n        pseudo_head.next.prev = None\n        return pseudo_head.next\n\n    def flatten_dfs(self, prev, curr):\n        # Guard clause for the recursive DFS\n        if not curr:\n            return prev\n\n        # Update the current node's prev\n        curr.prev = prev\n        # Update the previous node's next\n        prev.next = curr\n\n        # Store the next pointer as it might be modified\n        temp_next = curr.next\n\n        # Recursively flatten the child list\n        tail = self.flatten_dfs(curr, curr.child)\n        # Unlink the child from the current node\n        curr.child = None\n\n        # Recursively flatten the next part\n        return self.flatten_dfs(tail, temp_next)\n```\n\nThis pseudocode defines a mechanism to flatten the multilevel doubly linked list by utilizing a DFS approach, thereby ensuring that all nodes are correctly linked in a single level and all child pointers are set to null.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-flatten-a-multilevel-doubly-linked-list"
    },
    {
        "name": "Fizz Buzz",
        "site": "LeetCode",
        "href": "/solution/LeetCode-fizz-buzz",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> fizzBuzz(int n) {\n        vector<string> result;\n        for (int i = 1; i <= n; ++i) {\n            if (i % 3 == 0 && i % 5 == 0) {\n                result.push_back(\"FizzBuzz\");\n            } else if (i % 3 == 0) {\n                result.push_back(\"Fizz\");\n            } else if (i % 5 == 0) {\n                result.push_back(\"Buzz\");\n            } else {\n                result.push_back(to_string(i));\n            }\n        }\n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> fizzBuzz(int n) {\n        List<String> answer = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 && i % 5 == 0) {\n                answer.add(\"FizzBuzz\");\n            } else if (i % 3 == 0) {\n                answer.add(\"Fizz\");\n            } else if (i % 5 == 0) {\n                answer.add(\"Buzz\");\n            } else {\n                answer.add(String.valueOf(i));\n            }\n        }\n        return answer;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\n \nchar ** fizzBuzz(int n, int* returnSize){\n    *returnSize = n;\n    char **answer = (char **)malloc(n * sizeof(char *));\n    for(int i = 1; i <= n; i++){\n        if(i % 3 == 0 && i % 5 == 0){\n            answer[i-1] = \"FizzBuzz\";\n        } else if(i % 3 == 0){\n            answer[i-1] = \"Fizz\";\n        } else if(i % 5 == 0){\n            answer[i-1] = \"Buzz\";\n        } else {\n            answer[i-1] = (char *)malloc(10 * sizeof(char));\n            sprintf(answer[i-1], \"%d\", i);\n        }\n    }\n    return answer;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> FizzBuzz(int n) {\n        IList<string> answer = new List<string>();\n        \n        for(int i=1; i<=n; i++){\n            if(i % 3 == 0 && i % 5 == 0){\n                answer.Add(\"FizzBuzz\");\n            }\n            else if(i % 3 == 0){\n                answer.Add(\"Fizz\");\n            }\n            else if(i % 5 == 0){\n                answer.Add(\"Buzz\");\n            }\n            else{\n                answer.Add(i.ToString());\n            }\n        }\n        \n        return answer;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar fizzBuzz = function(n) {\n    const result = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 3 === 0 && i % 5 === 0) {\n            result.push(\"FizzBuzz\");\n        } else if (i % 3 === 0) {\n            result.push(\"Fizz\");\n        } else if (i % 5 === 0) {\n            result.push(\"Buzz\");\n        } else {\n            result.push(i.toString());\n        }\n    }\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function fizzBuzz(n: number): string[] {\n    const result: string[] = [];\n    \n    for (let i = 1; i <= n; i++) {\n        if (i % 3 === 0 && i % 5 === 0) {\n            result.push(\"FizzBuzz\");\n        } else if (i % 3 === 0) {\n            result.push(\"Fizz\");\n        } else if (i % 5 === 0) {\n            result.push(\"Buzz\");\n        } else {\n            result.push(String(i));\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return String[]\n     */\n    function fizzBuzz($n) {\n        $res = [];\n        for ($i = 1; $i <= $n; $i++) {\n            if ($i % 3 == 0 && $i % 5 == 0) {\n                $res[] = \"FizzBuzz\";\n            } elseif ($i % 3 == 0) {\n                $res[] = \"Fizz\";\n            } elseif ($i % 5 == 0) {\n                $res[] = \"Buzz\";\n            } else {\n                $res[] = (string) $i;\n            }\n        }\n        return $res;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func fizzBuzz(_ n: Int) -> [String] {\n        var answer = [String]()\n        \n        for i in 1...n {\n            if i % 3 == 0 && i % 5 == 0 {\n                answer.append(\"FizzBuzz\")\n            } else if i % 3 == 0 {\n                answer.append(\"Fizz\")\n            } else if i % 5 == 0 {\n                answer.append(\"Buzz\")\n            } else {\n                answer.append(String(i))\n            }\n        }\n        \n        return answer\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate an array of strings based on specific rules derived from an integer input \\( n \\). We'll iterate through numbers from 1 to \\( n \\) and apply the rules to determine the corresponding string for each number.\n\n# Explanation:\n1. **Initialization**: We will start by initializing an empty list `result` to store our answers.\n2. **Loop through Numbers**: We use a loop that runs from 1 to \\( n \\) (inclusive).\n3. **Conditional Checks**:\n   - If the current number is divisible by both 3 and 5 (i.e., `i % 3 == 0` and `i % 5 == 0`), we append \"FizzBuzz\" to the list.\n   - If the number is divisible by only 3 (i.e., `i % 3 == 0`), we append \"Fizz\".\n   - If the number is divisible by only 5 (i.e., `i % 5 == 0`), we append \"Buzz\".\n   - If none of the above conditions are met, we append the number itself as a string.\n\n# Pseudocode:\n```\nclass Solution:\n    def fizzBuzz(self, n):\n        # Initialize an empty list to store the results\n        result = []\n\n        # Loop through each number from 1 to n (inclusive)\n        for i in range(1, n + 1):\n            # Check if the number is divisible by both 3 and 5\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # Check if the number is divisible by 3\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # Check if the number is divisible by 5\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # If the number is not divisible by 3 or 5, convert it to a string and add it to the list\n            else:\n                result.append(str(i))\n        \n        # Return the resulting list\n        return result\n```\n\nBy following this methodology, we ensure that each number in the range from 1 to \\( n \\) is correctly converted according to the `FizzBuzz` rules and added to the final result list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-fizz-buzz"
    },
    {
        "name": "Construct Quad Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-construct-quad-tree",
        "languages": [
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * // Definition for a QuadTree node.\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\n */\n\nvar construct = function(grid) {\n    const isLeaf = (grid, row, col, size) => {\n        const val = grid[row][col];\n        for (let i = row; i < row + size; i++) {\n            for (let j = col; j < col + size; j++) {\n                if (grid[i][j] !== val) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    \n    const build = (grid, row, col, size) => {\n        if (isLeaf(grid, row, col, size)) {\n            return new Node(grid[row][col] === 1, true, null, null, null, null);\n        } else {\n            const half = size / 2;\n            return new Node('*', false, build(grid, row, col, half), build(grid, row, col + half, half), build(grid, row + half, col, half), build(grid, row + half, col + half, half));\n        }\n    };\n    \n    return build(grid, 0, 0, grid.length);\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for node.\n * class Node {\n *     val: boolean\n *     isLeaf: boolean\n *     topLeft: Node | null\n *     topRight: Node | null\n *     bottomLeft: Node | null\n *     bottomRight: Node | null\n * }\n */\nfunction construct(grid: number[][]): Node | null {\n    function buildTree(row: number, col: number, size: number): Node | null {\n        if (size === 1) {\n            return new Node(grid[row][col] === 1, true, null, null, null, null);\n        }\n        \n        const topLeft = buildTree(row, col, size / 2);\n        const topRight = buildTree(row, col + size / 2, size / 2);\n        const bottomLeft = buildTree(row + size / 2, col, size / 2);\n        const bottomRight = buildTree(row + size / 2, col + size / 2, size / 2);\n        \n        if (topLeft?.isLeaf && topRight?.isLeaf && bottomLeft?.isLeaf && bottomRight?.isLeaf &&\n            (topLeft.val === topRight.val) && (topRight.val === bottomLeft.val) && (bottomLeft.val === bottomRight.val)) {\n            return new Node(topLeft.val, true, null, null, null, null);\n        } else {\n            return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\n        }\n    }\n    \n    return buildTree(0, 0, grid.length);\n};\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a QuadTree node.\n * type Node struct {\n *     Val bool\n *     IsLeaf bool\n *     TopLeft *Node\n *     TopRight *Node\n *     BottomLeft *Node\n *     BottomRight *Node\n * }\n */\nfunc construct(grid [][]int) *Node {\n    if len(grid) == 0 {\n        return nil\n    }\n    isLeaf := true\n    val := grid[0][0] == 1\n    for i := range grid {\n        for j := range grid[i] {\n            if grid[i][j] != grid[0][0] {\n                isLeaf = false\n                break\n            }\n        }\n    }\n    if isLeaf {\n        return &Node{Val: val, IsLeaf: true}\n    }\n    return &Node{\n        IsLeaf: false,\n        Val: false,\n        TopLeft: construct(subGrid(grid, 0, 0, len(grid)/2)),\n        TopRight: construct(subGrid(grid, 0, len(grid)/2, len(grid)/2)),\n        BottomLeft: construct(subGrid(grid, len(grid)/2, 0, len(grid)/2)),\n        BottomRight: construct(subGrid(grid, len(grid)/2, len(grid)/2, len(grid)/2)),\n    }\n}\n\nfunc subGrid(grid [][]int, row, col, size int) [][]int {\n    sub := make([][]int, size)\n    for i := 0; i < size; i++ {\n        sub[i] = make([]int, size)\n        copy(sub[i], grid[row+i][col:col+size])\n    }\n    return sub\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a QuadTree node.\n# class Node\n#     attr_accessor :val, :isLeaf, :topLeft, :topRight, :bottomLeft, :bottomRight\n\ndef construct(grid)\n    if grid.flatten.uniq.size == 1\n        return Node.new(grid[0][0] == 1 ? true : false, true, nil, nil, nil, nil)\n    else\n        n = grid.length\n        node = Node.new(false, false, nil, nil, nil, nil)\n        node.topLeft = construct(grid[0...n/2].map{|row| row[0...n/2]})\n        node.topRight = construct(grid[0...n/2].map{|row| row[n/2..-1]})\n        node.bottomLeft = construct(grid[n/2..-1].map{|row| row[0...n/2]})\n        node.bottomRight = construct(grid[n/2..-1].map{|row| row[n/2..-1]})\n    end\n    return node\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge where we need to construct a Quad-Tree from a given grid of 0s and 1s, we can follow these steps:\n\n### # Explanation\n1. **Check for Leaf Node**: We need a helper function to check if a given sub-grid consists entirely of the same value (either all 0s or all 1s). If so, this sub-grid forms a leaf node in the Quad-Tree.\n2. **Recursive Division**: If the sub-grid is not uniform, we need to divide it into four equal sub-grids and recursively process each of these sub-grids.\n3. **Build Tree**: Using another helper function, we can create the Quad-Tree nodes. If the sub-grid is uniform, a leaf node is created. Otherwise, a non-leaf node with four children representing the four sub-grids is created.\n4. **Combine Results**: Starting from the top-level grid, recursively build the Quad-Tree using the above helper functions and return the root node.\n\n### # Pseudocode\n\n```\n# Define Node class to represent Quad-Tree nodes\nclass Node:\n    def __init__(self, val, isLeaf, topLeft=None, topRight=None, bottomLeft=None, bottomRight=None):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\n# Function to check if a sub-grid is a leaf (i.e., all cells have the same value)\ndef isLeaf(grid, row, col, size):\n    val = grid[row][col]\n    for i in range(row, row + size):\n        for j in range(col, col + size):\n            if grid[i][j] != val:\n                return False\n    return True\n\n# Function to build the Quad-Tree recursively\ndef buildQuadTree(grid, row, col, size):\n    if isLeaf(grid, row, col, size):\n        return Node(grid[row][col] == 1, True)\n    half = size // 2\n    return Node(\n        True,  # This value does not matter if the node is not a leaf\n        False,\n        buildQuadTree(grid, row, col, half),               # topLeft\n        buildQuadTree(grid, row, col + half, half),        # topRight\n        buildQuadTree(grid, row + half, col, half),        # bottomLeft\n        buildQuadTree(grid, row + half, col + half, half)  # bottomRight\n    )\n\n# Main function to construct the Quad-Tree from the given grid\ndef construct(grid):\n    return buildQuadTree(grid, 0, 0, len(grid))\n```\n\n### # Key Points\n- **isLeaf()** function checks if a sub-grid contains the same values.\n- **buildQuadTree()** function constructs the Quad-Tree recursively.\n- **construct()** function acts as the main entry point to start the Quad-Tree construction from the full grid. \n\nThis approach ensures that we handle the grid recursively and efficiently build the Quad-Tree structure.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-construct-quad-tree"
    },
    {
        "name": "Longest Repeating Character Replacement",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-repeating-character-replacement",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int n = s.length();\n        int maxFreq = 0, maxLength = 0;\n        vector<int> count(26, 0);\n        int start = 0;\n        \n        for (int end = 0; end < n; end++) {\n            maxFreq = max(maxFreq, ++count[s[end] - 'A']);\n            while (end - start + 1 - maxFreq > k) {\n                count[s[start] - 'A']--;\n                start++;\n            }\n            maxLength = max(maxLength, end - start + 1);\n        }\n        \n        return maxLength;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int characterReplacement(String s, int k) {\n        int[] count = new int[26];\n        int maxCount = 0, maxLength = 0;\n        int start = 0;\n        \n        for (int end = 0; end < s.length(); end++) {\n            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);\n            \n            if (end - start + 1 - maxCount > k) {\n                count[s.charAt(start) - 'A']--;\n                start++;\n            }\n            \n            maxLength = Math.max(maxLength, end - start + 1);\n        }\n        \n        return maxLength;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def characterReplacement(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        \n        max_length = 0\n        max_count = 0\n        start = 0\n        count_map = {}\n        \n        for end in range(len(s)):\n            count_map[s[end]] = count_map.get(s[end], 0) + 1\n            max_count = max(max_count, count_map[s[end]])\n            \n            if end - start + 1 - max_count > k:\n                count_map[s[start]] -= 1\n                start += 1\n                \n            max_length = max(max_length, end - start + 1)\n        \n        return max_length"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int characterReplacement(char* s, int k) {\n    int maxLen = 0;\n    int maxCount = 0;\n    int charCount[26] = {0};\n    int start = 0;\n    \n    for (int end = 0; s[end] != '\\0'; end++) {\n        charCount[s[end] - 'A']++;\n        maxCount = fmax(maxCount, charCount[s[end] - 'A']);\n        \n        if (end - start + 1 - maxCount > k) {\n            charCount[s[start] - 'A']--;\n            start++;\n        }\n        \n        maxLen = fmax(maxLen, end - start + 1);\n    }\n    \n    return maxLen;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int CharacterReplacement(string s, int k) \n    {\n        int[] count = new int[26];\n        int maxCount = 0;\n        int maxLength = 0;\n        int start = 0;\n        \n        for (int end = 0; end < s.Length; end++) {\n            maxCount = Math.Max(maxCount, ++count[s[end] - 'A']);\n            \n            if (end - start + 1 - maxCount > k) {\n                count[s[start] - 'A']--;\n                start++;\n            }\n            \n            maxLength = Math.Max(maxLength, end - start + 1);\n        }\n        \n        return maxLength;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function(s, k) {\n    let maxCount = 0, maxLength = 0;\n    let charCount = new Array(26).fill(0);\n    let start = 0;\n    \n    for (let end = 0; end < s.length; end++) {\n        maxCount = Math.max(maxCount, ++charCount[s.charCodeAt(end) - 65]);\n        \n        if (end - start + 1 - maxCount > k) {\n            charCount[s.charCodeAt(start) - 65]--;\n            start++;\n        }\n        \n        maxLength = Math.max(maxLength, end - start + 1);\n    }\n    \n    return maxLength;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function characterReplacement(s: string, k: number): number {\n    let maxCount = 0;\n    let maxLength = 0;\n    let start = 0;\n    const charCount = new Array(26).fill(0);\n\n    for (let end = 0; end < s.length; end++) {\n        const charIndex = s.charCodeAt(end) - 'A'.charCodeAt(0);\n        charCount[charIndex]++;\n\n        maxCount = Math.max(maxCount, charCount[charIndex]);\n\n        if (end - start + 1 - maxCount > k) {\n            const startCharIndex = s.charCodeAt(start) - 'A'.charCodeAt(0);\n            charCount[startCharIndex]--;\n            start++;\n        }\n\n        maxLength = Math.max(maxLength, end - start + 1);\n    }\n\n    return maxLength;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    function characterReplacement($s, $k) {\n        $max = 0;\n        $start = 0;\n        $charCount = [];\n        $maxCharCount = 0;\n        \n        for ($end = 0; $end < strlen($s); $end++) {\n            $charCount[$s[$end]] = ($charCount[$s[$end]] ?? 0) + 1;\n            $maxCharCount = max($maxCharCount, $charCount[$s[$end]]);\n            \n            if ($end - $start + 1 - $maxCharCount > $k) {\n                $charCount[$s[$start]]--;\n                $start++;\n            }\n            \n            $max = max($max, $end - $start + 1);\n        }\n        \n        return $max;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @param Integer $k\n     * @return Integer\n     */\n    func characterReplacement(_ s: String, _ k: Int) -> Int {\n        var maxCount = 0\n        var maxLength = 0\n        var charCount = [Character: Int]()\n        var start = 0\n        \n        for end in 0..<s.count {\n            let char = Array(s)[end]\n            charCount[char, default: 0] += 1\n            maxCount = max(maxCount, charCount[char]!)\n            \n            if end - start + 1 - maxCount > k {\n                let startChar = Array(s)[start]\n                charCount[startChar]! -= 1\n                start += 1\n            }\n            \n            maxLength = max(maxLength, end - start + 1)\n        }\n        \n        return maxLength\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun characterReplacement(s: String, k: Int): Int {\n        var result = 0\n        var maxCount = 0\n        var start = 0\n        val count = IntArray(26)\n        \n        for (end in s.indices) {\n            maxCount = maxOf(maxCount, ++count[s[end] - 'A'])\n            \n            if (end - start + 1 - maxCount > k) {\n                count[s[start] - 'A']--\n                start++\n            }\n            \n            result = maxOf(result, end - start + 1)\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func characterReplacement(s string, k int) int {\n    maxLen := 0\n    for i := 0; i < 26; i++ {\n        left, right, count := 0, 0, 0\n        freq := make([]int, 26)\n        for right < len(s) {\n            freq[s[right]-'A']++\n            count = max(count, freq[s[right]-'A'])\n            for right-left+1-count > k {\n                freq[s[left]-'A']--\n                left++\n            }\n            maxLen = max(maxLen, right-left+1)\n            right++\n        }\n    }\n    return maxLen\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @param {Integer} k\n# @return {Integer}\ndef character_replacement(s, k)\n    # Start your code here\n    max_length = 0\n    max_count = 0\n    counts = Hash.new(0)\n    start_idx = 0\n    \n    s.each_char.with_index do |char, end_idx|\n        counts[char] += 1\n        max_count = [max_count, counts[char]].max\n        \n        if (end_idx - start_idx + 1) - max_count > k\n            counts[s[start_idx]] -= 1\n            start_idx += 1\n        end\n        \n        max_length = [max_length, end_idx - start_idx + 1].max\n    end\n    \n    max_length\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def characterReplacement(s: String, k: Int): Int = {\n        val n = s.length\n        var left = 0\n        var maxCount = 0\n        var maxLength = 0\n        var frequency = Array.ofDim[Int](26)\n        \n        for (right <- 0 until n) {\n            val index = s(right) - 'A'\n            frequency(index) += 1\n            maxCount = math.max(maxCount, frequency(index))\n            \n            if (right - left + 1 - maxCount > k) {\n                frequency(s(left) - 'A') -= 1\n                left += 1\n            }\n            \n            maxLength = math.max(maxLength, right - left + 1)\n        }\n        \n        maxLength\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn character_replacement(s: String, k: i32) -> i32 {\n        let mut max_length = 0;\n        let s = s.as_bytes();\n        for c in b'A'..=b'Z' {\n            let mut start = 0;\n            let mut end = 0;\n            let mut count = 0;\n            while end < s.len() {\n                if s[end] != c {\n                    count += 1;\n                }\n                while count > k {\n                    if s[start] != c {\n                        count -= 1;\n                    }\n                    start += 1;\n                }\n                max_length = max_length.max(end - start + 1);\n                end += 1;\n            }\n        }\n        max_length as i32\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will use the sliding window technique. Below is the detailed explanation followed by pseudocode for the solution.\n\n# Explanation\n1. We aim to find the longest substring where we can replace up to `k` characters to form a substring with all identical characters.\n2. We'll use a sliding window approach: start with a window of size 1 and expand it by moving the `end` pointer.\n3. Keep track of the count of each character within the window using a dictionary `count_map`.\n4. Maintain the count of the most frequent character in the current window using `max_count`.\n5. If the size of the window minus `max_count` exceeds `k`, it means we need more than `k` replacements, so we shrink the window by moving the `start` pointer and adjust the counts accordingly.\n6. Throughout, record the maximum length of the window that meets the conditions.\n\n# Pseudocode\n```\nfunction characterReplacement(s, k):\n    if s is an empty string:\n        return 0\n\n    initialize max_length to 0\n    initialize max_count to 0\n    initialize start to 0\n    initialize count_map as an empty dictionary\n\n    for end from 0 to length of s - 1:\n        increment count of s[end] in count_map\n        max_count = maximum of max_count and count_map[s[end]]\n        \n        if current window size - max_count > k:\n            decrement count of s[start] in count_map\n            move start pointer to the right by 1\n        \n        max_length = maximum of max_length and (end - start + 1)\n    \n    return max_length\n```\nThis pseudocode iterates through the string with a two-pointer approach (`start` and `end`) and dynamically maintains the count of characters in the current window. It calculates the maximum length of the window that can be made uniform with at most `k` changes.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-repeating-character-replacement"
    },
    {
        "name": "Reconstruct Original Digits From English",
        "site": "LeetCode",
        "href": "/solution/LeetCode-reconstruct-original-digits-from-english",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string originalDigits(string s) {\n        vector<int> count(10, 0);\n        vector<int> letters(26, 0);\n        for (char c : s) {\n            letters[c - 'a']++;\n        }\n        count[0] = letters['z' - 'a'];\n        count[2] = letters['w' - 'a'];\n        count[4] = letters['u' - 'a'];\n        count[6] = letters['x' - 'a'];\n        count[8] = letters['g' - 'a'];\n        count[3] = letters['h' - 'a'] - count[8];\n        count[5] = letters['f' - 'a'] - count[4];\n        count[7] = letters['s' - 'a'] - count[6];\n        count[9] = letters['i' - 'a'] - count[5] - count[6] - count[8];\n        count[1] = letters['o' - 'a'] - count[0] - count[2] - count[4];\n        \n        string res = \"\";\n        for (int i = 0; i < 10; i++) {\n            res += string(count[i], '0' + i);\n        }\n        return res;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String originalDigits(String s) {\n        int[] count = new int[10];\n        for (char c : s.toCharArray()) {\n            if (c == 'z') count[0]++;\n            if (c == 'w') count[2]++;\n            if (c == 'u') count[4]++;\n            if (c == 'x') count[6]++;\n            if (c == 'g') count[8]++;\n            if (c == 'h') count[3]++;\n            if (c == 'f') count[5]++;\n            if (c == 's') count[7]++;\n            if (c == 'i') count[9]++;\n            if (c == 'o') count[1]++;\n        }\n        \n        count[1] -= count[0] + count[2] + count[4];\n        count[3] -= count[8];\n        count[5] -= count[4];\n        count[7] -= count[6];\n        count[9] -= count[5] + count[6] + count[8];\n        \n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < count[i]; j++) {\n                result.append(i);\n            }\n        }\n        \n        return result.toString();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def originalDigits(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        count = collections.Counter(s)\n        \n        num = [0]*10\n        num[0] = count['z']\n        num[2] = count['w']\n        num[4] = count['u']\n        num[6] = count['x']\n        num[8] = count['g']\n        num[3] = count['h'] - num[8]\n        num[5] = count['f'] - num[4]\n        num[7] = count['s'] - num[6]\n        num[9] = count['i'] - num[5] - num[6] - num[8]\n        num[1] = count['n'] - 2*num[9] - num[7]\n        \n        res = \"\"\n        for i in range(10):\n            res += str(i)*num[i]\n        \n        return res\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* originalDigits(char* s) {\n    int count[10] = {0};\n    int letter_count[26] = {0};\n    int i, len = strlen(s);\n    char *result = (char*)malloc(sizeof(char) * (len + 1));\n    char str[2];\n    \n    for(i = 0; i < len; i++) {\n        letter_count[s[i] - 'a']++;\n    }\n    \n    count[0] = letter_count['z' - 'a'];\n    count[2] = letter_count['w' - 'a'];\n    count[4] = letter_count['u' - 'a'];\n    count[6] = letter_count['x' - 'a'];\n    count[8] = letter_count['g' - 'a'];\n    count[1] = letter_count['o' - 'a'] - count[0] - count[2] - count[4];\n    count[3] = letter_count['h' - 'a'] - count[8];\n    count[5] = letter_count['f' - 'a'] - count[4];\n    count[7] = letter_count['s' - 'a'] - count[6];\n    count[9] = letter_count['i' - 'a'] - count[5] - count[6] - count[8];\n    \n    result[0] = '\\0';\n    \n    for(i = 0; i < 10; i++) {\n        while(count[i] > 0) {\n            str[0] = i + '0';\n            str[1] = '\\0';\n            strcat(result, str);\n            count[i]--;\n        }\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string OriginalDigits(string s) {\n        int[] count = new int[10];\n        foreach (char ch in s) {\n            if (ch == 'z') count[0]++;\n            if (ch == 'w') count[2]++;\n            if (ch == 'u') count[4]++;\n            if (ch == 'x') count[6]++;\n            if (ch == 'g') count[8]++;\n            if (ch == 'o') count[1]++;\n            if (ch == 't') count[3]++;\n            if (ch == 'f') count[5]++;\n            if (ch == 's') count[7]++;\n            if (ch == 'i') count[9]++;\n        }\n        \n        count[1] -= count[0] + count[2] + count[4];\n        count[3] -= count[2] + count[8];\n        count[5] -= count[4];\n        count[7] -= count[6];\n        count[9] -= count[5] + count[6] + count[8];\n        \n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10; i++) {\n            while (count[i] > 0) {\n                sb.Append(i);\n                count[i]--;\n            }\n        }\n        \n        return sb.ToString();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar originalDigits = function(s) {\n    let count = new Array(10).fill(0);\n    \n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'z') count[0]++;\n        if (s[i] === 'w') count[2]++;\n        if (s[i] === 'u') count[4]++;\n        if (s[i] === 'x') count[6]++;\n        if (s[i] === 'g') count[8]++;\n        if (s[i] === 's') count[7]++; // 7 and 6\n        if (s[i] === 'f') count[5]++; // 5 and 4\n        if (s[i] === 'h') count[3]++; // 3 and 8\n        if (s[i] === 'i') count[9]++; // 9, 8, 6, and 5\n        if (s[i] === 'o') count[1]++; // 1, 2, and 0\n    }\n    \n    count[7] -= count[6];\n    count[5] -= count[4];\n    count[3] -= count[8];\n    count[9] -= count[8] + count[6] + count[5];\n    count[1] -= count[0] + count[2] + count[4];\n    \n    let result = '';\n    for (let i = 0; i < 10; i++) {\n        result += String(i).repeat(count[i]);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function originalDigits(s: string): string {\n    const count: { [key: string]: number } = {};\n    const uniqueChars: string[] = ['z', 'w', 'u', 'x', 'g', 'o', 'r', 'f', 'v', 'i'];\n    const nums: number[] = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\n    const words: string[] = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];\n\n    for (const char of s) {\n        count[char] = (count[char] || 0) + 1;\n    }\n\n    const res: number[] = [];\n\n    for (let i = 0; i < uniqueChars.length; i++) {\n        const char = uniqueChars[i];\n        const num = nums[i];\n        const word = words[num];\n\n        if (count[char] && count[char] > 0) {\n            const occurrences = count[char];\n            for (const c of word) {\n                count[c] -= occurrences;\n            }\n            res.push(num);\n        }\n    }\n\n    return res.sort((a, b) => a - b).join('');\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return String\n     */\n    function originalDigits($s) {\n        $count = array_fill(0, 10, 0);\n        $charCount = [];\n        $output = '';\n        \n        for ($i = 0; $i < strlen($s); $i++) {\n            $charCount[$s[$i]] = isset($charCount[$s[$i]]) ? $charCount[$s[$i]] + 1 : 1;\n        }\n        \n        $count[0] = $charCount['z'] ?? 0;\n        $count[2] = $charCount['w'] ?? 0;\n        $count[4] = $charCount['u'] ?? 0;\n        $count[6] = $charCount['x'] ?? 0;\n        $count[8] = $charCount['g'] ?? 0;\n        \n        $count[1] = ($charCount['o'] ?? 0) - $count[0] - $count[2] - $count[4];\n        $count[3] = ($charCount['h'] ?? 0) - $count[8];\n        $count[5] = ($charCount['f'] ?? 0) - $count[4];\n        $count[7] = ($charCount['s'] ?? 0) - $count[6];\n        $count[9] = ($charCount['i'] ?? 0) - $count[5] - $count[6] - $count[8];\n        \n        for ($i = 0; $i <= 9; $i++) {\n            $output .= str_repeat($i, $count[$i]);\n        }\n        \n        return $output;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func originalDigits(_ s: String) -> String {\n        var count: [Character: Int] = [:]\n        var res: [Int] = Array(repeating: 0, count: 10)\n        \n        for char in s {\n            count[char, default: 0] += 1\n        }\n        \n        res[0] = count[\"z\", default: 0]\n        res[2] = count[\"w\", default: 0]\n        res[4] = count[\"u\", default: 0]\n        res[6] = count[\"x\", default: 0]\n        res[8] = count[\"g\", default: 0]\n        res[3] = count[\"h\", default: 0] - res[8]\n        res[5] = count[\"f\", default: 0] - res[4]\n        res[7] = count[\"v\", default: 0] - res[5]\n        res[9] = count[\"i\", default: 0] - res[5] - res[6] - res[8]\n        res[1] = count[\"o\", default: 0] - res[0] - res[2] - res[4]\n        \n        var result: [String] = []\n        for (i, value) in res.enumerated() {\n            if value > 0 {\n                result.append(String(repeating: \"\\(i)\", count: value))\n            }\n        }\n        \n        return result.joined()\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun originalDigits(s: String): String {\n        val count = IntArray(10)\n        val ch = intArrayOf('z'.toInt(), 'w'.toInt(), 'u'.toInt(), 'x'.toInt(), 'g'.toInt(), 'f'.toInt(), 's'.toInt(), 'i'.toInt(), 'o'.toInt(), 't'.toInt())\n        val nums = intArrayOf(0, 2, 4, 6, 8, 5, 7, 9, 1, 3)\n        val chars = arrayOf(\"zero\", \"two\", \"four\", \"six\", \"eight\", \"five\", \"seven\", \"nine\", \"one\", \"three\")\n        \n        val lettersCount = IntArray(26)\n        for (letter in s) {\n            lettersCount[letter - 'a']++\n        }\n        \n        for (i in nums.indices) {\n            val num = nums[i]\n            val letter = chars[i]\n            val index = ch[i] - 'a'.toInt()\n            val countLetter = lettersCount[index]\n            \n            if (countLetter > 0) {\n                count[num] = countLetter\n                for (l in letter) {\n                    lettersCount[l.toInt() - 'a'.toInt()] -= countLetter\n                }\n            }\n        }\n        \n        val res = StringBuilder()\n        for (i in 0 until 10) {\n            for (j in 0 until count[i]) {\n                res.append(i)\n            }\n        }\n        \n        return res.toString()\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func originalDigits(s string) string {\n    count := make(map[byte]int)\n    digits := make([]int, 10)\n\n    for i := 0; i < len(s); i++ {\n        count[s[i]]++\n    }\n\n    digits[0] = count['z']\n    digits[2] = count['w']\n    digits[4] = count['u']\n    digits[6] = count['x']\n    digits[8] = count['g']\n    digits[3] = count['h'] - digits[8]\n    digits[5] = count['f'] - digits[4]\n    digits[7] = count['s'] - digits[6]\n    digits[9] = count['i'] - digits[5] - digits[6] - digits[8]\n    digits[1] = count['n'] - 2*digits[9] - digits[7]\n\n    result := \"\"\n    for i := 0; i < 10; i++ {\n        for j := 0; j < digits[i]; j++ {\n            result += string('0' + i)\n        }\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {String}\ndef original_digits(s)\n    counts = Hash.new(0)\n    result = \"\"\n    \n    s.chars.each do |char|\n        counts[char] += 1\n    end\n    \n    counts[\"0\"] = counts[\"z\"]\n    counts[\"2\"] = counts[\"w\"]\n    counts[\"4\"] = counts[\"u\"]\n    counts[\"6\"] = counts[\"x\"]\n    counts[\"8\"] = counts[\"g\"]\n    counts[\"3\"] = counts[\"h\"] - counts[\"8\"]\n    counts[\"5\"] = counts[\"f\"] - counts[\"4\"]\n    counts[\"7\"] = counts[\"s\"] - counts[\"6\"]\n    counts[\"9\"] = counts[\"i\"] - counts[\"5\"] - counts[\"6\"] - counts[\"8\"]\n    counts[\"1\"] = counts[\"n\"] - counts[\"7\"] - 2 * counts[\"9\"]\n    \n    \"0123456789\".each_char do |char|\n        result += char * counts[char].to_i\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def originalDigits(s: String): String = {\n        val digits = Array.ofDim[Int](10)\n        val charCount = Array.ofDim[Int](26)\n        \n        for (c <- s) {\n            charCount(c - 'a') += 1\n        }\n        \n        digits(0) = charCount('z' - 'a')\n        digits(2) = charCount('w' - 'a')\n        digits(4) = charCount('u' - 'a')\n        digits(6) = charCount('x' - 'a')\n        digits(8) = charCount('g' - 'a')\n        \n        digits(3) = charCount('h' - 'a') - digits(8)\n        digits(5) = charCount('f' - 'a') - digits(4)\n        digits(7) = charCount('s' - 'a') - digits(6)\n        \n        digits(1) = charCount('o' - 'a') - digits(0) - digits(2) - digits(4)\n        digits(9) = charCount('i' - 'a') - digits(5) - digits(6) - digits(8)\n        \n        val sb = new StringBuilder()\n        for (i <- 0 to 9; j <- 0 until digits(i)) {\n            sb.append(i)\n        }\n        \n        sb.toString()\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, the methodology involves identifying unique letters that are present in specific digits when the input string is shuffled. Here's a comprehensive plan:\n\n# Explanation\n\n1. **Identify Unique Characters**: Certain digits have unique characters not present in other digits. For instance, the digit '0' contains the letter 'z', which doesn't appear in any other digit.\n\n2. **Count Occurrences**: We count the occurrences of these unique characters in the input string.\n\n3. **Subtract Counts**: Based on the counts from the unique characters, we deduce the counts for other digits by subtracting appropriately.\n\n4. **Formulate Result**: Finally, we compose the result string by repeating the digits according to their counts and sorting them in ascending order.\n\n# Pseudocode\n\n```\n# Import necessary library\nimport collections\n\n# Define main function\nfunction originalDigits(s):\n    # Step 1: Count the frequency of each character in the input string\n    count = collections.Counter(s)\n\n    # Step 2: Initialize an array to store the counts of each digit from 0 to 9\n    num = [0] * 10\n\n    # Step 3: Unique character detection and counting\n    num[0] = count['z']  # Only in \"zero\"\n    num[2] = count['w']  # Only in \"two\"\n    num[4] = count['u']  # Only in \"four\"\n    num[6] = count['x']  # Only in \"six\"\n    num[8] = count['g']  # Only in \"eight\"\n\n    # Step 4: Count non-unique digits by deducting counts from already known digits\n    num[3] = count['h'] - num[8]  # \"three\" has 'h', but we subtract the count of 'eight'\n    num[5] = count['f'] - num[4]  # \"five\" has 'f', subtract the count of 'four'\n    num[7] = count['s'] - num[6]  # \"seven\" has 's', subtract the count of 'six'\n    num[9] = count['i'] - num[5] - num[6] - num[8]  # \"nine\" has 'i', subtract counts from 'five', 'six', and 'eight'\n    num[1] = count['n'] - 2 * num[9] - num[7]  # \"one\" has 'n', subtract counts from 'seven' and double the 'nine'\n\n    # Step 5: Formulate the result string\n    result = \"\"\n    for i in range(10):\n        result += str(i) * num[i]\n\n    return result\n\n# The above pseudocode covers all necessary steps.\n```\n\nThis approach ensures the solution is both efficient and correctly handles all edge cases as per the problem constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-reconstruct-original-digits-from-english"
    },
    {
        "name": "Maximum Xor Of Two Numbers In An Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-maximum-xor-of-two-numbers-in-an-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class TrieNode {\npublic:\n    TrieNode* next[2];\n    \n    TrieNode() {\n        next[0] = nullptr;\n        next[1] = nullptr;\n    }\n};\n\nclass Solution {\npublic:\n    int findMaximumXOR(vector<int>& nums) {\n        TrieNode* root = new TrieNode();\n        int maxXor = 0;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            TrieNode* curr = root;\n            TrieNode* complement = root;\n            int value = nums[i];\n            int currentXor = 0;\n            \n            for (int j = 31; j >= 0; j--) {\n                int bit = (value >> j) & 1;\n                \n                if (curr->next[bit] == nullptr) {\n                    curr->next[bit] = new TrieNode();\n                }\n                curr = curr->next[bit];\n                \n                int complementBit = 1 - bit;\n                if (complement->next[complementBit] != nullptr) {\n                    currentXor += (1 << j);\n                    complement = complement->next[complementBit];\n                } else {\n                    complement = complement->next[bit];\n                }\n            }\n            \n            maxXor = max(maxXor, currentXor);\n        }\n        \n        return maxXor;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findMaximumXOR(int[] nums) {\n        int max = 0, mask = 0;\n        for (int i = 31; i >= 0; i--) {\n            mask |= (1 << i);\n            Set<Integer> set = new HashSet<>();\n            for (int num : nums) {\n                set.add(num & mask);\n            }\n            int candidate = max | (1 << i);\n            for (int prefix : set) {\n                if (set.contains(prefix ^ candidate)) {\n                    max = candidate;\n                    break;\n                }\n            }\n        }\n        return max;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findMaximumXOR(self, nums):\n        ans = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            seen = set()\n            for num in nums:\n                seen.add(num & mask)\n            temp = ans | (1 << i)\n            for prefix in seen:\n                if temp ^ prefix in seen:\n                    ans = temp\n                    break\n        return ans"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindMaximumXOR(int[] nums) {\n        int max = 0, mask = 0;\n        for (int i = 31; i >= 0; i--) {\n            mask |= 1 << i;\n            HashSet<int> set = new HashSet<int>();\n            foreach (int num in nums) {\n                set.Add(num & mask);\n            }\n            int tmp = max | (1 << i);\n            foreach (int prefix in set) {\n                if (set.Contains(tmp ^ prefix)) {\n                    max = tmp;\n                    break;\n                }\n            }\n        }\n        return max;\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findMaximumXOR(nums: number[]): number {\n    let maxResult = 0;\n    let mask = 0;\n    \n    for (let i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        const set = new Set<number>();\n        for (const num of nums) {\n            set.add(num & mask);\n        }\n        const tempResult = maxResult | (1 << i);\n        for (const prefix of set) {\n            if (set.has(prefix ^ tempResult)) {\n                maxResult = tempResult;\n                break;\n            }\n        }\n    }\n    \n    return maxResult;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findMaximumXOR($nums) {\n        $maxXOR = 0;\n        $mask = 0;\n        for ($i = 31; $i >= 0; $i--) {\n            $mask |= (1 << $i);\n            $set = [];\n            foreach ($nums as $num) {\n                $set[] = $num & $mask;\n            }\n            $tmp = $maxXOR | (1 << $i);\n            foreach ($set as $prefix) {\n                if (in_array($prefix ^ $tmp, $set)) {\n                    $maxXOR = $tmp;\n                    break;\n                }\n            }\n        }\n        return $maxXOR;\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findMaximumXOR(nums: IntArray): Int {\n        var maxXor = 0\n        var mask = 0\n        for (i in 31 downTo 0) {\n            mask = mask or (1 shl i)\n            val set = HashSet<Int>()\n            for (num in nums) {\n                set.add(num and mask)\n            }\n            val temp = maxXor or (1 shl i)\n            for (prefix in set) {\n                if (set.contains(temp xor prefix)) {\n                    maxXor = temp\n                    break\n                }\n            }\n        }\n        return maxXor\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int findMaximumXOR(List<int> nums) {\n    int result = 0;\n    int mask = 0;\n    \n    for (int i = 31; i >= 0; i--) {\n      mask |= (1 << i);\n      Set<int> prefixes = Set();\n      for (int num in nums) {\n        prefixes.add(num & mask);\n      }\n      int temp = result | (1 << i);\n      for (int prefix in prefixes) {\n        if (prefixes.contains(temp ^ prefix)) {\n          result = temp;\n          break;\n        }\n      }\n    }\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_maximum_xor(nums)\n    result = 0\n    mask = 0\n    (31).downto(0) do |bit|\n        mask |= (1 << bit)\n        prefixes = Set.new\n        nums.each { |num| prefixes.add(num & mask) }\n        \n        temp = result | (1 << bit)\n        prefixes.each do |prefix|\n            if prefixes.include?(temp ^ prefix)\n                result = temp\n                break\n            end\n        end\n    end\n    \n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findMaximumXOR(nums: Array[Int]): Int = {\n        var result = 0\n        var mask = 0\n        for (i <- 31 to 0 by -1) {\n            mask = mask | (1 << i)\n            val set = nums.map(_ & mask).toSet\n            val next = result | (1 << i)\n            for (prefix <- set) {\n                if (set.contains(prefix ^ next)) {\n                    result = next\n                }\n            }\n        }\n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\n        let mut max_xor = 0;\n        \n        for i in 0..nums.len() {\n            for j in i..nums.len() {\n                max_xor = max_xor.max(nums[i] ^ nums[j]);\n            }\n        }\n        \n        max_xor\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the maximum XOR value from two numbers in the input array. The approach revolves around building the solution progressively by considering each bit position from the most significant bit (MSB) to the least significant bit (LSB).\n\n## Explanation\n\nWe can outline the steps to solve this problem as follows:\n\n1. **Initialization**: Create variables for the answer (`ans`) and a mask (`mask`) to isolate bits progressively.\n2. **Iterate through bit positions**: Start from the MSB and move towards the LSB.\n3. **Build the mask**: Update the mask to include one more bit from the left in each iteration.\n4. **Track seen prefixes**: Using the current mask, determine the prefixes of all numbers up to the current bit.\n5. **Hypothetical XOR**: Assume that the current bit in the maximum XOR is `1` (in each iteration).\n6. **Check for valid pairs**: See if there exist two prefixes in the set whose XOR is equal to the hypothetical maximum XOR for the current bit position.\n7. **Update answer**: If the pair exists, update the answer to include this bit; otherwise, move to the next bit.\n\n## Pseudocode\n\n```python\n# Initialize the answer and mask\nans = 0\nmask = 0\n\n# Loop through all bit positions from 31 (highest) to 0 (lowest)\nfor i in range(31, -1, -1):\n    # Update the mask to include the current bit position\n    mask |= (1 << i)\n\n    # Create a set to store prefixes of all numbers with the current mask\n    seen = set()\n    for num in nums:\n        seen.add(num & mask)\n\n    # Hypothetical maximum XOR with the current bit set to 1\n    temp = ans | (1 << i)\n\n    # Check if there is any prefix that can form the maximum XOR with another prefix\n    can_update = False  # to determine if temp can be the answer\n    for prefix in seen:\n        if (temp ^ prefix) in seen:\n            can_update = True\n            break\n\n    # If valid pairs are found, update the answer\n    if can_update:\n        ans = temp\n\n# Return the final answer which is the maximum XOR found\nreturn ans\n```\n\nThis pseudocode follows the steps outlined above, ensuring we check each bit position progressively, updating our answer only when a valid pair of prefixes is found. This method leverages bit manipulation and set operations to derive the maximum XOR efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-maximum-xor-of-two-numbers-in-an-array"
    },
    {
        "name": "Battleships In A Board",
        "site": "LeetCode",
        "href": "/solution/LeetCode-battleships-in-a-board",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int countBattleships(vector<vector<char>>& board) {\n        int count = 0;\n        for (int i = 0; i < board.size(); i++) {\n            for (int j = 0; j < board[i].size(); j++) {\n                if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] == '.') && (j == 0 || board[i][j - 1] == '.')) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int countBattleships(char[][] board) {\n        int count = 0;\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                if (board[i][j] == 'X') {\n                    if ((i == 0 || board[i - 1][j] == '.') && (j == 0 || board[i][j - 1] == '.')) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def countBattleships(self, board):\n        count = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'X':\n                    if i > 0 and board[i - 1][j] == 'X':\n                        continue\n                    if j > 0 and board[i][j - 1] == 'X':\n                        continue\n                    count += 1\n        return count"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int countBattleships(char** board, int boardSize, int* boardColSize) {\n    int count = 0;\n    for (int i = 0; i < boardSize; i++) {\n        for (int j = 0; j < *boardColSize; j++) {\n            if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] != 'X') && (j == 0 || board[i][j - 1] != 'X')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int CountBattleships(char[][] board) {\n        int count = 0;\n        for (int i = 0; i < board.Length; i++) {\n            for (int j = 0; j < board[i].Length; j++) {\n                if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] == '.') && (j == 0 || board[i][j - 1] == '.')) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @return {number}\n */\nvar countBattleships = function(board) {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === 'X' && (i === 0 || board[i-1][j] === '.') && (j === 0 || board[i][j-1] === '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function countBattleships(board: string[][]): number {\n    let count = 0;\n    \n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === 'X' && (i === 0 || board[i - 1][j] !== 'X') && (j === 0 || board[i][j - 1] !== 'X')) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $board\n     */\n    function countBattleships($board) {\n        $count = 0;\n        for ($i = 0; $i < count($board); $i++) {\n            for ($j = 0; $j < count($board[$i]); $j++) {\n                if ($board[$i][$j] == 'X' && ($i == 0 || $board[$i-1][$j] == '.') && ($j == 0 || $board[$i][$j-1] == '.')) {\n                    $count++;\n                }\n            }\n        }\n        return $count;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func countBattleships(_ board: [[Character]]) -> Int {\n        var count = 0\n        for i in 0..<board.count {\n            for j in 0..<board[i].count {\n                if board[i][j] == \"X\" {\n                    if (i == 0 || board[i - 1][j] != \"X\") && (j == 0 || board[i][j - 1] != \"X\") {\n                        count += 1\n                    }\n                }\n            }\n        }\n        return count\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun countBattleships(board: Array<CharArray>): Int {\n        var count = 0\n        for (i in board.indices) {\n            for (j in board[i].indices) {\n                if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] != 'X') && (j == 0 || board[i][j - 1] != 'X')) {\n                    count++\n                }\n            }\n        }\n        return count\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int countBattleships(List<List<String>> board) {\n      int count = 0;\n      \n      for (int i = 0; i < board.length; i++) {\n          for (int j = 0; j < board[i].length; j++) {\n              if (board[i][j] == 'X') {\n                  if ((i == 0 || board[i - 1][j] != 'X') && (j == 0 || board[i][j - 1] != 'X')) {\n                      count++;\n                  }\n              }\n          }\n      }\n      \n      return count;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func countBattleships(board [][]byte) int {\n    count := 0\n    for i := 0; i < len(board); i++ {\n        for j := 0; j < len(board[i]); j++ {\n            if board[i][j] == 'X' {\n                if (i == 0 || board[i-1][j] == '.') && (j == 0 || board[i][j-1] == '.') {\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Character[][]} board\n# @return {Integer}\ndef count_battleships(board)\n    count = 0\n    (0...board.length).each do |i|\n        (0...board[0].length).each do |j|\n            if board[i][j] == 'X' && (i == 0 || board[i-1][j] == '.') && (j == 0 || board[i][j-1] == '.')\n                count += 1\n            end\n        end\n    end\n    count\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def countBattleships(board: Array[Array[Char]]): Int = {\n        var count = 0\n        for (i <- 0 until board.length; j <- 0 until board(0).length) {\n            if (board(i)(j) == 'X' && (i == 0 || board(i - 1)(j) == '.') && (j == 0 || board(i)(j - 1) == '.')) {\n                count += 1\n            }\n        }\n        count\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn count_battleships(board: Vec<Vec<char>>) -> i32 {\n        let mut count = 0;\n        \n        for i in 0..board.len() {\n            for j in 0..board[i].len() {\n                if board[i][j] == 'X' &&\n                    (i == 0 || board[i - 1][j] == '.') &&\n                    (j == 0 || board[i][j - 1] == '.') {\n                    count += 1;\n                }\n            }\n        }\n        \n        count\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse through the given matrix and identify the number of battleships represented by 'X'. We'll ensure that we follow the given constraints and avoid counting the same battleship more than once.\n\n# Explanation\n1. **Initialization**: We'll initialize a counter `count` to zero which will keep track of the number of battleships.\n2. **Matrix Traversal**: We'll iterate over each cell in the matrix using nested loops.\n3. **Check Battleship**: For each cell, we will check if it contains an 'X'.\n4. **Avoid Duplicate Counting**: If a cell contains 'X', we'll check its immediate top and immediate left cells:\n    - If the top cell (if it exists) also contains 'X', it means this cell is part of a vertically aligned battleship that we've already counted.\n    - Similarly, if the left cell (if it exists) contains 'X', it implies this cell is part of a horizontally aligned battleship already counted.\n5. **Count Battleship**: If both the above conditions are false, it means we've encountered a new battleship. We then increment our counter.\n6. **Return count**: Return the final count of battleships.\n\n# Pseudocode\n```\nfunction countBattleships(board):\n    count = 0\n    rows = length of board\n    cols = length of board[0]\n\n    for i from 0 to rows - 1:\n        for j from 0 to cols - 1:\n            if board[i][j] == 'X':\n                if i > 0 and board[i - 1][j] == 'X':\n                    continue\n                if j > 0 and board[i][j - 1] == 'X':\n                    continue\n                count += 1\n\n    return count\n```\n\nThis pseudocode outlines a linear time complexity approach to counting battleships, ensuring only O(1) extra space is used and the given board's contents are not modified.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-battleships-in-a-board"
    },
    {
        "name": "Pacific Atlantic Water Flow",
        "site": "LeetCode",
        "href": "/solution/LeetCode-pacific-atlantic-water-flow",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        vector<vector<int>> result;\n        \n        if (heights.empty()) {\n            return result;\n        }\n        \n        int m = heights.size();\n        int n = heights[0].size();\n        \n        vector<vector<bool>> pacific(m, vector<bool>(n, false));\n        vector<vector<bool>> atlantic(m, vector<bool>(n, false));\n        \n        queue<pair<int, int>> q_pacific;\n        queue<pair<int, int>> q_atlantic;\n        \n        for (int i = 0; i < m; ++i) {\n            q_pacific.push({i, 0});\n            q_atlantic.push({i, n - 1});\n            pacific[i][0] = true;\n            atlantic[i][n - 1] = true;\n        }\n        \n        for (int j = 0; j < n; ++j) {\n            q_pacific.push({0, j});\n            q_atlantic.push({m - 1, j});\n            pacific[0][j] = true;\n            atlantic[m - 1][j] = true;\n        }\n        \n        bfs(heights, q_pacific, pacific);\n        bfs(heights, q_atlantic, atlantic);\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    result.push_back({i, j});\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    void bfs(vector<vector<int>>& heights, queue<pair<int, int>>& q, vector<vector<bool>>& visited) {\n        int m = heights.size();\n        int n = heights[0].size();\n        \n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        \n        while (!q.empty()) {\n            auto [i, j] = q.front();\n            q.pop();\n            \n            for (auto& dir : dirs) {\n                int new_i = i + dir.first;\n                int new_j = j + dir.second;\n                \n                if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && !visited[new_i][new_j] && heights[new_i][new_j] >= heights[i][j]) {\n                    visited[new_i][new_j] = true;\n                    q.push({new_i, new_j});\n                }\n            }\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (heights == null || heights.length == 0 || heights[0].length == 0) {\n            return result;\n        }\n        \n        int m = heights.length;\n        int n = heights[0].length;\n        boolean[][] pacificReachable = new boolean[m][n];\n        boolean[][] atlanticReachable = new boolean[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            dfs(heights, pacificReachable, i, 0);\n            dfs(heights, atlanticReachable, i, n - 1);\n        }\n        for (int j = 0; j < n; j++) {\n            dfs(heights, pacificReachable, 0, j);\n            dfs(heights, atlanticReachable, m - 1, j);\n        }\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacificReachable[i][j] && atlanticReachable[i][j]) {\n                    List<Integer> cell = new ArrayList<>();\n                    cell.add(i);\n                    cell.add(j);\n                    result.add(cell);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private void dfs(int[][] heights, boolean[][] reachable, int i, int j) {\n        reachable[i][j] = true;\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int[] dir : dirs) {\n            int newRow = i + dir[0];\n            int newCol = j + dir[1];\n            if (newRow >= 0 && newRow < heights.length && newCol >= 0 && newCol < heights[0].length\n               && !reachable[newRow][newCol] && heights[newRow][newCol] >= heights[i][j]) {\n                dfs(heights, reachable, newRow, newCol);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> PacificAtlantic(int[][] heights) {\n        IList<IList<int>> result = new List<IList<int>>();\n        \n        if(heights == null || heights.Length == 0 || heights[0].Length == 0) {\n            return result;\n        }\n        \n        int m = heights.Length;\n        int n = heights[0].Length;\n        \n        Queue<int[]> pacificQueue = new Queue<int[]>();\n        Queue<int[]> atlanticQueue = new Queue<int[]>();\n        \n        bool[,] pacificReachable = new bool[m, n];\n        bool[,] atlanticReachable = new bool[m, n];\n        \n        for(int i = 0; i < m; i++) {\n            pacificQueue.Enqueue(new int[] {i, 0});\n            atlanticQueue.Enqueue(new int[] {i, n - 1});\n            pacificReachable[i, 0] = true;\n            atlanticReachable[i, n - 1] = true;\n        }\n        for(int i = 0; i < n; i++) {\n            pacificQueue.Enqueue(new int[] {0, i});\n            atlanticQueue.Enqueue(new int[] {m - 1, i});\n            pacificReachable[0, i] = true;\n            atlanticReachable[m - 1, i] = true;\n        }\n        \n        BFS(heights, pacificQueue, pacificReachable);\n        BFS(heights, atlanticQueue, atlanticReachable);\n        \n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(pacificReachable[i, j] && atlanticReachable[i, j]) {\n                    result.Add(new List<int> {i, j});\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private void BFS(int[][] heights, Queue<int[]> queue, bool[,] reachable) {\n        int m = heights.Length;\n        int n = heights[0].Length;\n        \n        int[] dirX = new int[] {-1, 1, 0, 0};\n        int[] dirY = new int[] {0, 0, -1, 1};\n        \n        while(queue.Count > 0) {\n            int[] curr = queue.Dequeue();\n            int x = curr[0];\n            int y = curr[1];\n            \n            for(int i = 0; i < 4; i++) {\n                int newX = x + dirX[i];\n                int newY = y + dirY[i];\n                \n                if(newX >= 0 && newX < m && newY >= 0 && newY < n \n                   && !reachable[newX, newY] && heights[newX][newY] >= heights[x][y]) {\n                    reachable[newX, newY] = true;\n                    queue.Enqueue(new int[] {newX, newY});\n                }\n            }\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} heights\n * @return {number[][]}\n */\nconst pacificAtlantic = function(heights) {\n    const dfs = (matrix, row, col, prevVal, ocean) => {\n        if (row < 0 || col < 0 || row >= matrix.length || col >= matrix[0].length || matrix[row][col] < prevVal || ocean[row][col]) {\n            return;\n        }\n        \n        ocean[row][col] = true;\n        \n        dfs(matrix, row + 1, col, matrix[row][col], ocean);\n        dfs(matrix, row - 1, col, matrix[row][col], ocean);\n        dfs(matrix, row, col + 1, matrix[row][col], ocean);\n        dfs(matrix, row, col - 1, matrix[row][col], ocean);\n    };\n    \n    const m = heights.length;\n    const n = heights[0].length;\n    \n    const pacific = Array.from({ length: m }, () => Array(n).fill(false));\n    const atlantic = Array.from({ length: m }, () => Array(n).fill(false));\n    \n    for (let i = 0; i < m; i++) {\n        dfs(heights, i, 0, -Infinity, pacific);\n        dfs(heights, i, n - 1, -Infinity, atlantic);\n    }\n    \n    for (let i = 0; i < n; i++) {\n        dfs(heights, 0, i, -Infinity, pacific);\n        dfs(heights, m - 1, i, -Infinity, atlantic);\n    }\n    \n    const res = [];\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (pacific[i][j] && atlantic[i][j]) {\n                res.push([i, j]);\n            }\n        }\n    }\n    \n    return res;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function pacificAtlantic(heights: number[][]): number[][] {\n    const result: number[][] = [];\n    \n    if (!heights || heights.length === 0) {\n        return result;\n    }\n    \n    const rows = heights.length;\n    const cols = heights[0].length;\n    \n    const pacific: boolean[][] = Array.from({ length: rows }, () => Array(cols).fill(false));\n    const atlantic: boolean[][] = Array.from({ length: rows }, () => Array(cols).fill(false));\n    \n    const dfs = (r: number, c: number, ocean: boolean[][]) => {\n        ocean[r][c] = true;\n        \n        const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n        \n        for (const [dr, dc] of directions) {\n            const newRow = r + dr;\n            const newCol = c + dc;\n            \n            if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols || ocean[newRow][newCol] || heights[newRow][newCol] < heights[r][c]) {\n                continue;\n            }\n            \n            dfs(newRow, newCol, ocean);\n        }\n    };\n    \n    for (let r = 0; r < rows; r++) {\n        dfs(r, 0, pacific);\n        dfs(r, cols - 1, atlantic);\n    }\n    \n    for (let c = 0; c < cols; c++) {\n        dfs(0, c, pacific);\n        dfs(rows - 1, c, atlantic);\n    }\n    \n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push([r, c]);\n            }\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $heights\n     * @return Integer[][]\n     */\n    function pacificAtlantic($heights) {\n        // Solution code goes here\n        $result = [];\n        if (empty($heights)) return $result;\n        \n        $m = count($heights);\n        $n = count($heights[0]);\n        \n        $pacificVisited = array_fill(0, $m, array_fill(0, $n, false));\n        $atlanticVisited = array_fill(0, $m, array_fill(0, $n, false));\n        \n        for ($i = 0; $i < $m; $i++) {\n            $this->dfs($heights, $pacificVisited, $i, 0);\n            $this->dfs($heights, $atlanticVisited, $i, $n - 1);\n        }\n        \n        for ($j = 0; $j < $n; $j++) {\n            $this->dfs($heights, $pacificVisited, 0, $j);\n            $this->dfs($heights, $atlanticVisited, $m - 1, $j);\n        }\n        \n        for ($i = 0; $i < $m; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($pacificVisited[$i][$j] && $atlanticVisited[$i][$j]) {\n                    $result[] = [$i, $j];\n                }\n            }\n        }\n        \n        return $result;\n    }\n    \n    function dfs($heights, &$visited, $i, $j) {\n        $directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n        \n        $visited[$i][$j] = true;\n        $m = count($heights);\n        $n = count($heights[0]);\n        \n        foreach ($directions as $dir) {\n            $newX = $i + $dir[0];\n            $newY = $j + $dir[1];\n            if ($newX >= 0 && $newX < $m && $newY >= 0 && $newY < $n \n                && !$visited[$newX][$newY] && $heights[$newX][$newY] >= $heights[$i][$j]) {\n                $this->dfs($heights, $visited, $newX, $newY);\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func pacificAtlantic(_ heights: [[Int]]) -> [[Int]] {\n        if heights.isEmpty || heights[0].isEmpty {\n            return []\n        }\n        \n        let m = heights.count\n        let n = heights[0].count\n        var pacificReachable = Array(repeating: Array(repeating: false, count: n), count: m)\n        var atlanticReachable = Array(repeating: Array(repeating: false, count: n), count: m)\n        var result = [[Int]]()\n        \n        func dfs(_ r: Int, _ c: Int, _ reachable: inout [[Bool]]) {\n            reachable[r][c] = true\n            let directions = [0, 1, 0, -1, 0]\n            for i in 0..<4 {\n                let nr = r + directions[i]\n                let nc = c + directions[i + 1]\n                if nr >= 0 && nr < m && nc >= 0 && nc < n &&\n                    heights[nr][nc] >= heights[r][c] &&\n                    !reachable[nr][nc] {\n                    dfs(nr, nc, &reachable)\n                }\n            }\n        }\n        \n        for i in 0..<m {\n            dfs(i, 0, &pacificReachable)\n            dfs(i, n - 1, &atlanticReachable)\n        }\n        \n        for j in 0..<n {\n            dfs(0, j, &pacificReachable)\n            dfs(m - 1, j, &atlanticReachable)\n        }\n        \n        for i in 0..<m {\n            for j in 0..<n {\n                if pacificReachable[i][j] && atlanticReachable[i][j] {\n                    result.append([i, j])\n                }\n            }\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun pacificAtlantic(heights: Array<IntArray>): List<List<Int>> {\n        val m = heights.size\n        val n = heights[0].size\n        val pacificVisited = Array(m) { BooleanArray(n) }\n        val atlanticVisited = Array(m) { BooleanArray(n) }\n        val result = mutableListOf<List<Int>>()\n\n        fun dfs(row: Int, col: Int, visited: Array<BooleanArray>) {\n            visited[row][col] = true\n            for (dir in listOf(0 to 1, 0 to -1, 1 to 0, -1 to 0)) {\n                val newRow = row + dir.first\n                val newCol = col + dir.second\n                if (newRow in 0 until m && newCol in 0 until n &&\n                    !visited[newRow][newCol] && heights[newRow][newCol] >= heights[row][col]) {\n                    dfs(newRow, newCol, visited)\n                }\n            }\n        }\n\n        for (i in 0 until m) {\n            dfs(i, 0, pacificVisited)\n            dfs(i, n - 1, atlanticVisited)\n        }\n\n        for (j in 0 until n) {\n            dfs(0, j, pacificVisited)\n            dfs(m - 1, j, atlanticVisited)\n        }\n\n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                if (pacificVisited[i][j] && atlanticVisited[i][j]) {\n                    result.add(listOf(i, j))\n                }\n            }\n        }\n\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> pacificAtlantic(List<List<int>> heights) {\n    List<List<int>> result = [];\n    if (heights.isEmpty || heights[0].isEmpty) return result;\n\n    int m = heights.length;\n    int n = heights[0].length;\n    List<List<bool>> canReachPacific = List.generate(m, (_) => List.filled(n, false));\n    List<List<bool>> canReachAtlantic = List.generate(m, (_) => List.filled(n, false));\n\n    void dfs(int row, int col, List<List<bool>> visited) {\n      if (visited[row][col]) return;\n      visited[row][col] = true;\n\n      List<List<int>> directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n      for (List<int> dir in directions) {\n        int newRow = row + dir[0];\n        int newCol = col + dir[1];\n        if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && heights[newRow][newCol] >= heights[row][col]) {\n          dfs(newRow, newCol, visited);\n        }\n      }\n    }\n\n    for (int i = 0; i < m; i++) {\n      dfs(i, 0, canReachPacific);\n      dfs(i, n - 1, canReachAtlantic);\n    }\n\n    for (int j = 0; j < n; j++) {\n      dfs(0, j, canReachPacific);\n      dfs(m - 1, j, canReachAtlantic);\n    }\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (canReachPacific[i][j] && canReachAtlantic[i][j]) {\n          result.add([i, j]);\n        }\n      }\n    }\n\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func pacificAtlantic(heights [][]int) [][]int {\n    var result [][]int\n    var dir = [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n\n    if len(heights) == 0 {\n        return result\n    }\n\n    rows, cols := len(heights), len(heights[0])\n    can_reach_pacific := make([][]bool, rows)\n    can_reach_atlantic := make([][]bool, rows)\n\n    for i := range can_reach_pacific {\n        can_reach_pacific[i] = make([]bool, cols)\n    }\n\n    for i := range can_reach_atlantic {\n        can_reach_atlantic[i] = make([]bool, cols)\n    }\n\n    var dfs func(row, col int, ocean [][]bool)\n    dfs = func(row, col int, ocean [][]bool) {\n        ocean[row][col] = true\n        for _, d := range dir {\n            new_row, new_col := row+d[0], col+d[1]\n            if new_row >= 0 && new_row < rows && new_col >= 0 && new_col < cols &&\n                !ocean[new_row][new_col] && heights[new_row][new_col] >= heights[row][col] {\n                dfs(new_row, new_col, ocean)\n            }\n        }\n    }\n\n    for i := 0; i < rows; i++ {\n        dfs(i, 0, can_reach_pacific)\n        dfs(i, cols-1, can_reach_atlantic)\n    }\n\n    for i := 0; i < cols; i++ {\n        dfs(0, i, can_reach_pacific)\n        dfs(rows-1, i, can_reach_atlantic)\n    }\n\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            if can_reach_pacific[i][j] && can_reach_atlantic[i][j] {\n                result = append(result, []int{i, j})\n            }\n        }\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} heights\n# @return {Integer[][]}\ndef pacific_atlantic(heights)\n    return [] if heights.empty?\n    \n    pacific = Array.new(heights.length) { Array.new(heights[0].length, false) }\n    atlantic = Array.new(heights.length) { Array.new(heights[0].length, false) }\n    \n    directions = [[0,1], [0,-1], [1,0], [-1,0]]\n    \n    def dfs(row, col, matrix, visited)\n        visited[row][col] = true\n        directions = [[0,1], [0,-1], [1,0], [-1,0]]\n        \n        directions.each do |dir|\n            new_row = row + dir[0]\n            new_col = col + dir[1]\n            \n            if new_row >= 0 && new_row < matrix.length && new_col >= 0 && new_col < matrix[0].length && !visited[new_row][new_col] && matrix[new_row][new_col] >= matrix[row][col]\n                dfs(new_row, new_col, matrix, visited)\n            end\n        end\n    end\n    \n    (0...heights.length).each do |row|\n        dfs(row, 0, heights, pacific)\n        dfs(row, heights[0].length - 1, heights, atlantic)\n    end\n    \n    (0...heights[0].length).each do |col|\n        dfs(0, col, heights, pacific)\n        dfs(heights.length - 1, col, heights, atlantic)\n    end\n    \n    result = []\n    (0...heights.length).each do |row|\n        (0...heights[0].length).each do |col|\n            result << [row, col] if pacific[row][col] && atlantic[row][col]\n        end\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def pacificAtlantic(heights: Array[Array[Int]]): List[List[Int]] = {\n        val pacific = Array.ofDim[Boolean](heights.length, heights(0).length)\n        val atlantic = Array.ofDim[Boolean](heights.length, heights(0).length)\n\n        def dfs(r: Int, c: Int, prevHeight: Int, visited: Array[Array[Boolean]]): Unit = {\n            if (r < 0 || r >= heights.length || c < 0 || c >= heights(0).length || visited(r)(c) || heights(r)(c) < prevHeight) return\n\n            visited(r)(c) = true\n\n            dfs(r + 1, c, heights(r)(c), visited)\n            dfs(r - 1, c, heights(r)(c), visited)\n            dfs(r, c + 1, heights(r)(c), visited)\n            dfs(r, c - 1, heights(r)(c), visited)\n        }\n\n        for (r <- heights.indices) {\n            dfs(r, 0, Int.MinValue, pacific)\n            dfs(r, heights(0).length - 1, Int.MinValue, atlantic)\n        }\n\n        for (c <- heights(0).indices) {\n            dfs(0, c, Int.MinValue, pacific)\n            dfs(heights.length - 1, c, Int.MinValue, atlantic)\n        }\n\n        val result = for {\n            r <- heights.indices\n            c <- heights(0).indices\n            if pacific(r)(c) && atlantic(r)(c)\n        } yield List(r, c)\n\n        result.toList\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let rows = heights.len();\n        if rows == 0 {\n            return Vec::new();\n        }\n        let cols = heights[0].len();\n\n        let mut pacific = vec![vec![false; cols]; rows];\n        let mut atlantic = vec![vec![false; cols]; rows];\n\n        for i in 0..rows {\n            Self::dfs(&heights, &mut pacific, i, 0);\n            Self::dfs(&heights, &mut atlantic, i, cols - 1);\n        }\n\n        for j in 0..cols {\n            Self::dfs(&heights, &mut pacific, 0, j);\n            Self::dfs(&heights, &mut atlantic, rows - 1, j);\n        }\n\n        let mut result = Vec::new();\n        for i in 0..rows {\n            for j in 0..cols {\n                if pacific[i][j] && atlantic[i][j] {\n                    result.push(vec![i as i32, j as i32]);\n                }\n            }\n        }\n\n        result\n    }\n\n    fn dfs(heights: &Vec<Vec<i32>>, visited: &mut Vec<Vec<bool>>, row: usize, col: usize) {\n        visited[row][col] = true;\n        let directions = vec![-1, 0, 1, 0, -1];\n        let mut next_row;\n        let mut next_col;\n        for d in 0..4 {\n            next_row = row as i32 + directions[d];\n            next_col = col as i32 + directions[d + 1];\n            if next_row >= 0 && next_row < heights.len() as i32 && next_col >= 0 && next_col < heights[0].len() as i32\n                && !visited[next_row as usize][next_col as usize] && heights[next_row as usize][next_col as usize] >= heights[row][col] {\n                Self::dfs(heights, visited, next_row as usize, next_col as usize);\n            }\n        }\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine which cells in the m x n grid can allow water to flow to both the Pacific and Atlantic oceans. The idea is to simulate the water flow using depth-first search (DFS) starting from the ocean boundaries and mark the cells that can be reached. The cells that can be reached from both oceans are the solutions.\n\n# Explanation\n1. **Mark Reachable Cells**: We need to mark cells that can flow into the Pacific and Atlantic oceans. We will use two boolean matrices, `pacific` and `atlantic`, to track cells from which water can flow to the respective oceans.\n2. **Initialize DFS**: Perform DFS starting from cells adjacent to the Pacific on the top and left edges, and from the Atlantic on the bottom and right edges. Mark cells as reachable during DFS traversal.\n3. **Combine Results**: After DFS traversal, the cells that are reachable from both the Pacific and Atlantic oceans are the result.\n\n# Pseudocode\n``` \nfunction pacificAtlantic(heights):\n    def dfs(matrix, row, col, prevHeight, ocean):\n        if row < 0 or col < 0 or row >= len(matrix) or col >= len(matrix[0]) or matrix[row][col] < prevHeight or ocean[row][col]:\n            return\n        ocean[row][col] = True\n        for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nextRow = row + direction[0]\n            nextCol = col + direction[1]\n            dfs(matrix, nextRow, nextCol, matrix[row][col], ocean)\n\n    if not heights or not heights[0]:\n        return []\n\n    m = len(heights)\n    n = len(heights[0])\n    pacific = [[False for _ in range(n)] for _ in range(m)]\n    atlantic = [[False for _ in range(n)] for _ in range(m)]\n\n    # Run DFS from Pacific Ocean (top and left edges)\n    for i in range(m):\n        dfs(heights, i, 0, float('-inf'), pacific)  # left edge\n        dfs(heights, i, n - 1, float('-inf'), atlantic)  # right edge\n    for j in range(n):\n        dfs(heights, 0, j, float('-inf'), pacific)  # top edge\n        dfs(heights, m - 1, j, float('-inf'), atlantic)  # bottom edge\n\n    # Collect cells that can reach both oceans\n    result = []\n    for i in range(m):\n        for j in range(n):\n            if pacific[i][j] and atlantic[i][j]:\n                result.append([i, j])\n\n    return result\n```\n\nThis pseudocode provides a clear and structured approach to solving the Pacific Atlantic Water Flow problem using DFS to determine the cells from which water can flow to both oceans.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-pacific-atlantic-water-flow"
    },
    {
        "name": "Partition Equal Subset Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-partition-equal-subset-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        \n        if (sum % 2 != 0) {\n            return false;\n        }\n        \n        int target = sum / 2;\n        vector<bool> dp(target + 1, false);\n        dp[0] = true;\n        \n        for (int num : nums) {\n            for (int i = target; i >= num; i--) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n        \n        return dp[target];\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        \n        if (totalSum % 2 != 0) {\n            return false;\n        }\n        \n        int target = totalSum / 2;\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        \n        for (int num : nums) {\n            for (int i = target; i >= num; i--) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n        \n        return dp[target];\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def canPartition(self, nums):\n        total_sum = sum(nums)\n        if total_sum % 2 != 0:\n            return False\n        \n        half_sum = total_sum // 2\n        dp = [False] * (half_sum + 1)\n        dp[0] = True\n        \n        for num in nums:\n            for i in range(half_sum, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n        \n        return dp[half_sum]"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool canPartition(int* nums, int numsSize) {\n    int totalSum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        totalSum += nums[i];\n    }\n    if (totalSum % 2 != 0) {\n        return false;\n    }\n\n    int target = totalSum / 2;\n    bool dp[target + 1];\n    memset(dp, false, sizeof(dp));\n    dp[0] = true;\n\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = target; j >= nums[i]; j--) {\n            dp[j] = dp[j] || dp[j - nums[i]];\n        }\n    }\n\n    return dp[target];\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool CanPartition(int[] nums) {\n        int sum = 0;\n        foreach (int num in nums) {\n            sum += num;\n        }\n        \n        if (sum % 2 != 0) {\n            return false;\n        }\n        \n        int target = sum / 2;\n        bool[] dp = new bool[target + 1];\n        dp[0] = true;\n        \n        foreach (int num in nums) {\n            for (int i = target; i >= num; i--) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n        \n        return dp[target];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canPartition = function(nums) {\n    const sum = nums.reduce((a, b) => a + b, 0);\n    if (sum % 2 !== 0) {\n        return false;\n    }\n    \n    const target = sum / 2;\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n    \n    for (const num of nums) {\n        for (let i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    \n    return dp[target];\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function canPartition(nums: number[]): boolean {\n    const totalSum = nums.reduce((a, b) => a + b, 0);\n\n    if (totalSum % 2 !== 0) {\n        return false;\n    }\n\n    const targetSum = totalSum / 2;\n    const dp: boolean[] = new Array(targetSum + 1).fill(false);\n    dp[0] = true;\n\n    for (const num of nums) {\n        for (let i = targetSum; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n\n    return dp[targetSum];\n};"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function canPartition($nums) {\n        $total = array_sum($nums);\n        if ($total % 2 != 0) {\n            return false;\n        }\n        \n        $half = $total / 2;\n        $dp = array_fill(0, $half + 1, false);\n        $dp[0] = true;\n        \n        foreach ($nums as $num) {\n            for ($i = $half; $i >= $num; $i--) {\n                $dp[$i] = $dp[$i] || $dp[$i - $num];\n            }\n        }\n        \n        return $dp[$half];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func canPartition(_ nums: [Int]) -> Bool {\n        let totalSum = nums.reduce(0, +)\n        if totalSum % 2 != 0 {\n            return false\n        }\n        \n        let target = totalSum / 2\n        var dp = Array(repeating: false, count: target + 1)\n        dp[0] = true\n        \n        for num in nums {\n            var index = target\n            while index >= num {\n                dp[index] = dp[index] || dp[index - num]\n                index -= 1\n            }\n        }\n        \n        return dp[target]\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun canPartition(nums: IntArray): Boolean {\n        val totalSum = nums.sum()\n        if (totalSum % 2 != 0) return false\n\n        val targetSum = totalSum / 2\n        val dp = BooleanArray(targetSum + 1)\n        dp[0] = true\n\n        for (num in nums) {\n            for (i in targetSum downTo num) {\n                dp[i] = dp[i] || dp[i - num]\n            }\n        }\n\n        return dp[targetSum]\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool canPartition(List<int> nums) {\n    int sum = nums.reduce((value, element) => value + element);\n    if (sum % 2 != 0) {\n      return false;\n    }\n    int target = sum ~/ 2;\n    List<bool> dp = List.filled(target + 1, false);\n    dp[0] = true;\n\n    for (int num in nums) {\n      for (int i = target; i >= num; i--) {\n        dp[i] = dp[i] || dp[i - num];\n      }\n    }\n\n    return dp[target];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func canPartition(nums []int) bool {\n    total := 0\n    for _, num := range nums {\n        total += num\n    }\n    if total%2 != 0 {\n        return false\n    }\n    half := total / 2\n    dp := make([]bool, half+1)\n    dp[0] = true\n    for _, num := range nums {\n        for i := half; i >= num; i-- {\n            dp[i] = dp[i] || dp[i-num]\n        }\n    }\n    return dp[half]\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef can_partition(nums)\n    total = nums.sum\n    return false if total.odd?\n    \n    target = total / 2\n    dp = Array.new(target + 1, false)\n    dp[0] = true\n    \n    nums.each do |num|\n        (target - num).downto(0) do |i|\n            dp[i + num] = true if dp[i]\n        end\n    end\n    \n    dp[target]\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def canPartition(nums: Array[Int]): Boolean = {\n        val totalSum = nums.sum\n        if (totalSum % 2 != 0) return false\n        \n        val target = totalSum / 2\n        val dp = Array.ofDim[Boolean](nums.length + 1, target + 1)\n        \n        for (i <- 0 to nums.length) {\n            dp(i)(0) = true\n        }\n        \n        for (i <- 1 to nums.length; j <- 1 to target) {\n            dp(i)(j) = dp(i - 1)(j) || (j >= nums(i - 1) && dp(i - 1)(j - nums(i - 1)))\n        }\n        \n        dp(nums.length)(target)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn can_partition(nums: Vec<i32>) -> bool {\n        let sum: i32 = nums.iter().sum();\n        \n        if sum % 2 != 0 {\n            return false;\n        }\n        \n        let target = (sum / 2) as usize;\n        let mut dp = vec![false; target + 1];\n        dp[0] = true;\n        \n        for num in nums {\n            for i in (num as usize..=target).rev() {\n                dp[i] = dp[i] || dp[i - num as usize];\n            }\n        }\n        \n        dp[target]\n    }\n}"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec can_partition(Nums :: [integer()]) -> boolean\n().\ncan_partition(Nums) ->\n    Total = lists:sum(Nums),\n    case Total rem 2 of\n        1 -> false; % If total sum is odd, can't partition into equal subsets\n        _ -> can_partition(Nums, Total div 2)\n    end.\n\ncan_partition([], 0) -> true;\ncan_partition(_, 0) -> true;\ncan_partition([], _) -> false;\ncan_partition([H|T], Total) -> can_partition(T, Total) orelse can_partition(T, Total-H)."
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if an integer array can be partitioned into two subsets with equal sums. This boils down to a dynamic programming problem, where we will use a boolean array to keep track of possible subset sums. Here\u2019s how we can approach it:\n\n# Explanation\n\n1. **Sum Calculation and Early Exit**: First, compute the total sum of the elements in the array. If this total sum is odd, it's impossible to partition the array into two equal subsets, so we return `False`.\n\n2. **Target Sum**: If the total sum is even, divide it by 2 to get the target sum, which we need to achieve with a subset of the given array.\n\n3. **Dynamic Programming Array Setup**: Create a boolean array `dp` of size `target_sum + 1` initialized to `False`. The index represents the possible sum values. Set `dp[0]` to `True` because a sum of 0 is always possible with an empty subset.\n\n4. **Updating DP Array**: Iterate through each number in the array. For each number, update the `dp` array from the back (from `target_sum` down to the number itself). This avoids recomputing results for the same number within the same iteration.\n\n5. **Final Check**: After processing all numbers, check the value at `dp[target_sum]`. If it's `True`, it means it's possible to get a subset with the required sum, and thus the array can be partitioned into two equal subsets. Otherwise, it's not possible.\n\n# Pseudocode\n\n```\nfunction canPartition(nums):\n    total_sum = sum(nums)\n    \n    // Check if the total sum is odd\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    \n    // Initialize the dp array\n    dp = array of size (target_sum + 1) with all elements False\n    dp[0] = True // Base case: sum of 0 is always possible\n    \n    // Update dp array based on the numbers in nums\n    for num in nums:\n        for i from target_sum down to num:\n            dp[i] = dp[i] or dp[i - num]\n    \n    // Check if target_sum is achievable\n    return dp[target_sum]\n```\n\nThis methodology provides an efficient way to determine if the given array can be partitioned into two subsets with equal sums, using dynamic programming to keep track of all possible sums up to the target sum.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-partition-equal-subset-sum"
    },
    {
        "name": "Add Strings",
        "site": "LeetCode",
        "href": "/solution/LeetCode-add-strings",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string result = \"\";\n        int i = num1.size() - 1;\n        int j = num2.size() - 1;\n        int carry = 0;\n        \n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = 0;\n            if (i >= 0) {\n                sum += num1[i] - '0';\n                i--;\n            }\n            if (j >= 0) {\n                sum += num2[j] - '0';\n                j--;\n            }\n            sum += carry;\n            carry = sum / 10;\n            sum %= 10;\n            result = to_string(sum) + result;\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String addStrings(String num1, String num2) {\n        StringBuilder result = new StringBuilder();\n        int carry = 0;\n        int i = num1.length() - 1;\n        int j = num2.length() - 1;\n        \n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num1.charAt(i) - '0';\n                i--;\n            }\n            if (j >= 0) {\n                sum += num2.charAt(j) - '0';\n                j--;\n            }\n            result.insert(0, sum % 10);\n            carry = sum / 10;\n        }\n        \n        return result.toString();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def addStrings(self, num1, num2):\n        res = []\n        carry = 0\n        i = len(num1) - 1\n        j = len(num2) - 1\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res.append(str(carry % 10))\n            carry //= 10\n        \n        return ''.join(res[::-1])"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string AddStrings(string num1, string num2) {\n        string result = \"\";\n        int i = num1.Length - 1, j = num2.Length - 1;\n        int carry = 0;\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num1[i] - '0';\n                i--;\n            }\n            if (j >= 0) {\n                sum += num2[j] - '0';\n                j--;\n            }\n            carry = sum / 10;\n            result = (sum % 10).ToString() + result;\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar addStrings = function(num1, num2) {\n    let i = num1.length - 1, j = num2.length - 1;\n    let carry = 0;\n    let result = '';\n    \n    while (i >= 0 || j >= 0 || carry > 0) {\n        const digit1 = i < 0 ? 0 : parseInt(num1[i]);\n        const digit2 = j < 0 ? 0 : parseInt(num2[j]);\n        \n        const sum = digit1 + digit2 + carry;\n        result = `${sum % 10}${result}`;\n        carry = Math.floor(sum / 10);\n        \n        i--;\n        j--;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function addStrings(num1: string, num2: string): string {\n    let i = num1.length - 1;\n    let j = num2.length - 1;\n    let carry = 0;\n    let result = '';\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n        const digit1 = i >= 0 ? parseInt(num1[i]) : 0;\n        const digit2 = j >= 0 ? parseInt(num2[j]) : 0;\n        const sum = digit1 + digit2 + carry;\n        result = `${sum % 10}${result}`;\n        carry = Math.floor(sum / 10);\n        i--;\n        j--;\n    }\n\n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $num1\n     * @param String $num2\n     * @return String\n     */\n    function addStrings($num1, $num2) {\n        $res = \"\";\n        $i = strlen($num1) - 1;\n        $j = strlen($num2) - 1;\n        $carry = 0;\n        \n        while ($i >= 0 || $j >= 0 || $carry > 0) {\n            $n1 = $i >= 0 ? (int)$num1[$i] : 0;\n            $n2 = $j >= 0 ? (int)$num2[$j] : 0;\n            $sum = $n1 + $n2 + $carry;\n            $res = ($sum % 10) . $res;\n            $carry = intdiv($sum, 10);\n            $i--;\n            $j--;\n        }\n        \n        return $res;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func addStrings(_ num1: String, _ num2: String) -> String {\n        var i = num1.count - 1\n        var j = num2.count - 1\n        var carry = 0\n        var result = \"\"\n        \n        while i >= 0 || j >= 0 || carry > 0 {\n            let digit1 = i >= 0 ? Int(String(num1[num1.index(num1.startIndex, offsetBy: i)]))! : 0\n            let digit2 = j >= 0 ? Int(String(num2[num2.index(num2.startIndex, offsetBy: j)]))! : 0\n            \n            let sum = digit1 + digit2 + carry\n            carry = sum / 10\n            result = \"\\(sum % 10)\" + result\n            \n            i -= 1\n            j -= 1\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun addStrings(num1: String, num2: String): String {\n        var i = num1.length - 1\n        var j = num2.length - 1\n        var carry = 0\n        var result = StringBuilder()\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            val x = if (i >= 0) num1[i] - '0' else 0\n            val y = if (j >= 0) num2[j] - '0' else 0\n            val sum = x + y + carry\n            result.insert(0, sum % 10)\n            carry = sum / 10\n            i--\n            j--\n        }\n\n        return result.toString()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String addStrings(String num1, String num2) {\n    int i = num1.length - 1;\n    int j = num2.length - 1;\n    int carry = 0;\n    StringBuffer result = StringBuffer();\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n      int sum = carry;\n      if (i >= 0) {\n        sum += int.parse(num1[i]);\n        i--;\n      }\n      if (j >= 0) {\n        sum += int.parse(num2[j]);\n        j--;\n      }\n      carry = sum ~/ 10;\n      result.write((sum % 10).toString());\n    }\n\n    return result.toString().split('').reversed.join();\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func addStrings(num1 string, num2 string) string {\n    result := \"\"\n    carry := 0\n    i, j := len(num1)-1, len(num2)-1\n\n    for i >= 0 || j >= 0 || carry > 0 {\n        x, y := 0, 0\n        if i >= 0 {\n            x = int(num1[i] - '0')\n        }\n        if j >= 0 {\n            y = int(num2[j] - '0')\n        }\n\n        sum := x + y + carry\n        result = string(sum%10+'0') + result\n        carry = sum / 10\n\n        i--\n        j--\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} num1\n# @param {String} num2\n# @return {String}\ndef add_strings(num1, num2)\n    i = num1.length - 1\n    j = num2.length - 1\n    carry = 0\n    result = ''\n\n    while i >= 0 || j >= 0 || carry > 0\n        sum = carry\n        sum += num1[i].to_i if i >= 0\n        sum += num2[j].to_i if j >= 0\n\n        result = (sum % 10).to_s + result\n        carry = sum / 10\n\n        i -= 1\n        j -= 1\n    end\n\n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def addStrings(num1: String, num2: String): String = {\n        var i = num1.length - 1\n        var j = num2.length - 1\n        var carry = 0\n        var result = \"\"\n        \n        while (i >= 0 || j >= 0 || carry > 0) {\n            val sum = (if (i >= 0) num1(i) - '0' else 0) + (if (j >= 0) num2(j) - '0' else 0) + carry\n            result = (sum % 10).toString + result\n            carry = sum / 10\n            i -= 1\n            j -= 1\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn add_strings(num1: String, num2: String) -> String {\n        let num1_chars: Vec<char> = num1.chars().collect();\n        let num2_chars: Vec<char> = num2.chars().collect();\n        let mut result = String::new();\n        let (mut carry, mut i, mut j) = (0, num1.len() as i32 - 1, num2.len() as i32 - 1);\n        \n        while i >= 0 || j >= 0 || carry > 0 {\n            if i >= 0 {\n                carry += num1_chars[i as usize].to_digit(10).unwrap();\n                i -= 1;\n            }\n            if j >= 0 {\n                carry += num2_chars[j as usize].to_digit(10).unwrap();\n                j -= 1;\n            }\n            result.insert(0, ((carry % 10) as u8 + '0' as u8) as char);\n            carry /= 10;\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (add-strings num1 num2)\n  (-> string? string? string?)\n  (number->string (+ (string->number num1) (string->number num2))))"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to add two large numbers represented as strings without converting the entire string to an integer. We will perform addition digit by digit, starting from the least significant digit to the most significant one, maintaining a carry for each addition operation.\n\n# Explanation\nThe approach involves:\n1. Initializing variables to keep track of the position in each string and the carry.\n2. Looping through each digit from the end of both strings.\n3. Adding corresponding digits along with the carry.\n4. Determining the new carry and the current digit to append to the result.\n5. Reversing the resulting list of digits to form the final sum string.\n\n# Pseudocode\n```\nfunction addStrings(num1, num2):\n    initialize an empty list `result` to store digits of the sum\n    initialize `carry` to 0\n    initialize `i` to the last index of num1\n    initialize `j` to the last index of num2\n\n    while `i` >= 0 or `j` >= 0 or `carry` > 0:\n        if `i` >= 0:\n            add `num1[i]` (converted to integer) to `carry`\n            decrement `i` by 1\n        if `j` >= 0:\n            add `num2[j]` (converted to integer) to `carry`\n            decrement `j` by 1\n        \n        append `carry % 10` (converted to string) to `result`  # this is the current digit\n        update `carry` to `carry // 10`  # update carry for the next digit\n    \n    reverse the `result` list to get the correct order\n    return the joined string formed by the `result` list\n```\n\nThis pseudocode should allow you to manually trace through the steps for any given inputs and formulate a solution to the problem. The algorithm ensures that digits are processed from least significant to most significant, handling carries appropriately.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-add-strings"
    },
    {
        "name": "Third Maximum Number",
        "site": "LeetCode",
        "href": "/solution/LeetCode-third-maximum-number",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        set<int> uniqueNums(nums.begin(), nums.end());\n        \n        if (uniqueNums.size() < 3) {\n            return *uniqueNums.rbegin();\n        }\n        \n        auto it = uniqueNums.begin();\n        advance(it, uniqueNums.size() - 3);\n        \n        return *it;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int thirdMax(int[] nums) {\n        Integer max1 = null;\n        Integer max2 = null;\n        Integer max3 = null;\n        \n        for (Integer num : nums) {\n            if (num.equals(max1) || num.equals(max2) || num.equals(max3)) {\n                continue;\n            }\n            \n            if (max1 == null || num > max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = num;\n            } else if (max2 == null || num > max2) {\n                max3 = max2;\n                max2 = num;\n            } else if (max3 == null || num > max3) {\n                max3 = num;\n            }\n        }\n        \n        return max3 != null ? max3 : max1;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums)\n        nums.remove(max(nums))\n        nums.remove(max(nums))\n        return max(nums)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int thirdMax(int* nums, int numsSize) {\n    long max1 = LONG_MIN;\n    long max2 = LONG_MIN;\n    long max3 = LONG_MIN;\n    \n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] > max1) {\n            max3 = max2;\n            max2 = max1;\n            max1 = nums[i];\n        } else if (nums[i] < max1 && nums[i] > max2) {\n            max3 = max2;\n            max2 = nums[i];\n        } else if (nums[i] < max2 && nums[i] > max3) {\n            max3 = nums[i];\n        }\n    }\n    \n    if (max3 != LONG_MIN) {\n        return (int)max3;\n    } else {\n        return (int)max1;\n    }\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int ThirdMax(int[] nums) {\n        long first = long.MinValue;\n        long second = long.MinValue;\n        long third = long.MinValue;\n\n        foreach (int num in nums) {\n            if (num > first) {\n                third = second;\n                second = first;\n                first = num;\n            } else if (num > second && num < first) {\n                third = second;\n                second = num;\n            } else if (num > third && num < second) {\n                third = num;\n            }\n        }\n\n        return third == long.MinValue ? (int)first : (int)third;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar thirdMax = function(nums) {\n    let first = -Infinity;\n    let second = -Infinity;\n    let third = -Infinity;\n    \n    for (let num of nums) {\n        if (num > first) {\n            third = second;\n            second = first;\n            first = num;\n        } else if (num > second && num < first) {\n            third = second;\n            second = num;\n        } else if (num > third && num < second) {\n            third = num;\n        }\n    }\n    \n    return third !== -Infinity ? third : first;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function thirdMax(nums: number[]): number {\n    const set = new Set(nums);\n    const uniqueNums = Array.from(set);\n    uniqueNums.sort((a, b) => b - a);\n    if (uniqueNums.length < 3) {\n        return uniqueNums[0];\n    }\n    return uniqueNums[2];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     */\n    function thirdMax($nums) {\n        $nums = array_unique($nums);\n        rsort($nums);\n        \n        if(count($nums) < 3) {\n            return $nums[0];\n        }\n        \n        return $nums[2];\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func thirdMax(_ nums: [Int]) -> Int {\n        var set = Set<Int>()\n        for num in nums {\n            set.insert(num)\n            if set.count > 3 {\n                set.remove(set.min()!)\n            }\n        }\n        \n        if set.count < 3 {\n            return set.max()!\n        } else {\n            return set.min()!\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun thirdMax(nums: IntArray): Int {\n        val set = nums.toSortedSet()\n        return if (set.size < 3) set.last() else set.elementAt(set.size - 3)\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int thirdMax(List<int> nums) {\n    Set<int> set = nums.toSet();\n    List<int> uniqueNums = set.toList();\n    uniqueNums.sort();\n    if (uniqueNums.length < 3) {\n      return uniqueNums.last;\n    }\n    return uniqueNums[uniqueNums.length - 3];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func thirdMax(nums []int) int {\n    first := math.MinInt64\n    second := math.MinInt64\n    third := math.MinInt64\n\n    for _, num := range nums {\n        if num > first {\n            third = second\n            second = first\n            first = num\n        } else if num < first && num > second {\n            third = second\n            second = num\n        } else if num < second && num > third {\n            third = num\n        }\n    }\n\n    if third != math.MinInt64 {\n        return third\n    }\n\n    return first\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef third_max(nums)\n    nums.uniq.sort.reverse[2] || nums.max\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def thirdMax(nums: Array[Int]): Int = {\n        var firstMax = Long.MinValue\n        var secondMax = Long.MinValue\n        var thirdMax = Long.MinValue\n        \n        for (num <- nums) {\n            if (num > firstMax) {\n                thirdMax = secondMax\n                secondMax = firstMax\n                firstMax = num\n            } else if (num > secondMax && num < firstMax) {\n                thirdMax = secondMax\n                secondMax = num\n            } else if (num > thirdMax && num < secondMax) {\n                thirdMax = num\n            }\n        }\n        \n        if (thirdMax != Long.MinValue) thirdMax.toInt\n        else firstMax.toInt\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn third_max(nums: Vec<i32>) -> i32 {\n        let mut nums = nums;\n        nums.sort_unstable();\n        nums.dedup();\n        if nums.len() < 3 {\n            return *nums.last().unwrap();\n        }\n        nums[nums.len() - 3]\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (third-max nums)\n  (-> (listof exact-integer?) exact-integer?)\n  (define sorted-nums (sort (remove-duplicates nums) >))\n  (cond\n    ((< (length sorted-nums) 3) (first sorted-nums))\n    (else (list-ref sorted-nums 2))\n  )\n)"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the third distinct maximum number in an array of integers. If the third maximum does not exist, we return the maximum number instead. \n\n# Explanation\n1. **Remove Duplicates**: Since we want the third distinct maximum number, the first step is to remove any duplicate numbers from the list.\n2. **Check Length**: If there are fewer than three distinct numbers after removing duplicates, we return the maximum number from the result set.\n3. **Find Third Maximum**: If there are at least three distinct numbers, we remove the largest number twice, then return the largest number remaining, which will be the third maximum.\n\nThis approach ensures we handle distinct values and correctly find the third maximum if it exists.\n\n# Pseudocode\n```plaintext\nFUNCTION thirdMax(nums: List of Integers) -> Integer\n    # Convert the list to a set to remove duplicates\n    unique_nums = CONVERT nums TO SET\n    \n    # Check if we have fewer than three unique numbers\n    IF LENGTH of unique_nums < 3 THEN\n        # Return the maximum number since third max doesn't exist\n        RETURN MAX(unique_nums)\n    \n    # Remove the first maximum number\n    REMOVE MAX(unique_nums) FROM unique_nums\n    \n    # Remove the second maximum number\n    REMOVE MAX(unique_nums) FROM unique_nums\n    \n    # The next maximum will be the third maximum\n    RETURN MAX(unique_nums)\n```\n\nThis pseudocode outlines the steps to solve the problem using set operations for uniqueness and max function to find the distinct maximum values.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-third-maximum-number"
    },
    {
        "name": "Arithmetic Slices",
        "site": "LeetCode",
        "href": "/solution/LeetCode-arithmetic-slices",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& nums) {\n        int n = nums.size();\n        if(n < 3) {\n            return 0;\n        }\n        \n        int count = 0;\n        int result = 0;\n        \n        for(int i = 2; i < n; i++) {\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\n                count++;\n                result += count;\n            } else {\n                count = 0;\n            }\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        int n = nums.length;\n        int count = 0;\n        \n        for (int i = 0; i < n - 2; i++) {\n            int diff = nums[i + 1] - nums[i];\n            for (int j = i + 2; j < n; j++) {\n                if (nums[j] - nums[j - 1] == diff) {\n                    count++;\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        sum_slices = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                count += 1\n                sum_slices += count\n            else:\n                count = 0\n        \n        return sum_slices"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int numberOfArithmeticSlices(int* nums, int numsSize) {\n    int count = 0;\n    for (int i = 0; i < numsSize - 2; i++) {\n        int diff = nums[i + 1] - nums[i];\n        for (int j = i + 2; j < numsSize; j++) {\n            if (nums[j] - nums[j - 1] == diff) {\n                count++;\n            } else {\n                break;\n            }\n        }\n    }\n    return count;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int NumberOfArithmeticSlices(int[] nums) {\n        int count = 0;\n        int result = 0;\n        \n        for (int i = 2; i < nums.Length; i++) {\n            if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n                count++;\n                result += count;\n            } else {\n                count = 0;\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    let count = 0;\n    let dp = 0;\n    \n    for (let i = 2; i < nums.length; i++) {\n        if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {\n            dp = dp + 1;\n            count += dp;\n        } else {\n            dp = 0;\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function numberOfArithmeticSlices(nums: number[]): number {\n    let count = 0;\n    \n    for (let i = 0; i < nums.length - 2; i++) {\n        const diff = nums[i + 1] - nums[i];\n        for (let j = i + 2; j < nums.length; j++) {\n            if (nums[j] - nums[j - 1] === diff) {\n                count++;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function numberOfArithmeticSlices($nums) {\n        $n = count($nums);\n        $count = 0;\n        \n        for ($i = 0; $i < $n - 2; $i++) {\n            $diff = $nums[$i + 1] - $nums[$i];\n            \n            for ($j = $i + 2; $j < $n; $j++) {\n                if ($nums[$j] - $nums[$j - 1] == $diff) {\n                    $count++;\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        return $count;\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun numberOfArithmeticSlices(nums: IntArray): Int {\n        var count = 0\n        var sum = 0\n        for (i in 2 until nums.size) {\n            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\n                count++\n                sum += count\n            } else {\n                count = 0\n            }\n        }\n        return sum\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int numberOfArithmeticSlices(List<int> nums) {\n    int count = 0;\n    int result = 0;\n\n    for (int i = 2; i < nums.length; i++) {\n      if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n        count++;\n        result += count;\n      } else {\n        count = 0;\n      }\n    }\n\n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func numberOfArithmeticSlices(nums []int) int {\n    count := 0\n    result := 0\n    for i := 2; i < len(nums); i++ {\n        if nums[i]-nums[i-1] == nums[i-1]-nums[i-2] {\n            count++\n            result += count\n        } else {\n            count = 0\n        }\n    }\n    return result\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef number_of_arithmetic_slices(nums)\n    count = 0\n    result = 0\n    (2...nums.size).each do |i|\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]\n            count += 1\n            result += count\n        else\n            count = 0\n        end\n    end\n    result\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def numberOfArithmeticSlices(nums: Array[Int]): Int = {\n        var count = 0\n        var result = 0\n        \n        for (i <- 2 until nums.length) {\n            if (nums(i) - nums(i - 1) == nums(i - 1) - nums(i - 2)) {\n                count += 1\n                result += count\n            } else {\n                count = 0\n            }\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn number_of_arithmetic_slices(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n < 3 {\n            return 0;\n        }\n        \n        let mut dp = vec![0; n];\n        let mut count = 0;\n        \n        for i in 2..n {\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2] {\n                dp[i] = dp[i - 1] + 1;\n                count += dp[i];\n            }\n        }\n        \n        return count;\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll break down the problem and approach it step by step using well-defined pseudocode.\n\n# Explanation\n1. **Understand the Problem:**\n   - We need to find all the arithmetic slices in a given array.\n   - An arithmetic slice must have at least three elements with a constant difference between consecutive elements.\n   - The task is to count all subarrays (contiguous subsequences) that form arithmetic slices.\n\n2. **Approach:**\n   - Initialize two variables: `count` to keep track of consecutive arithmetic slices ending at the current position, and `sum_slices` to sum up all the valid arithmetic slices.\n   - Loop through the array starting from the third element.\n   - Check if the current element and the two preceding elements form an arithmetic sequence.\n   - If they do, increment the `count` and add it to `sum_slices`.\n   - Reset the `count` if the sequence is broken.\n\n# Pseudocode\n```\nfunction numberOfArithmeticSlices(nums):\n    if length of nums < 3:\n        return 0\n    \n    count <- 0\n    sum_slices <- 0\n    \n    for i from 2 to length of nums - 1:\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            count <- count + 1\n            sum_slices <- sum_slices + count\n        else:\n            count <- 0\n    \n    return sum_slices\n```\n\nThis approach ensures that we efficiently count all arithmetic slices in the array by iterating through it once and using a simple arithmetic check for each triplet of elements.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-arithmetic-slices"
    },
    {
        "name": "Basic Calculator",
        "site": "LeetCode",
        "href": "/solution/LeetCode-basic-calculator",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int calculate(string s) {\n        stack<int> stk;\n        int num = 0;\n        int res = 0;\n        int sign = 1;\n        for (int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if (isdigit(c)) {\n                num = num * 10 + (c - '0');\n            } else if (c == '+' || c == '-') {\n                res += sign * num;\n                num = 0;\n                sign = (c == '+') ? 1 : -1;\n            } else if (c == '(') {\n                stk.push(res);\n                stk.push(sign);\n                res = 0;\n                sign = 1;\n            } else if (c == ')') {\n                res += sign * num;\n                num = 0;\n                res *= stk.top();\n                stk.pop();\n                res += stk.top();\n                stk.pop();\n            }\n        }\n        res += sign * num;\n        return res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int calculate(String s) {\n        int result = 0;\n        int sign = 1;\n        int num = 0;\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                num = num * 10 + (c - '0');\n            } else if (c == '+') {\n                result += sign * num;\n                num = 0;\n                sign = 1;\n            } else if (c == '-') {\n                result += sign * num;\n                num = 0;\n                sign = -1;\n            } else if (c == '(') {\n                stack.push(result);\n                stack.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                result += sign * num;\n                num = 0;\n                result *= stack.pop();\n                result += stack.pop();\n            }\n        }\n\n        if (num != 0) {\n            result += sign * num;\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stack = []\n        num = 0\n        res = 0\n        sign = 1\n\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            elif s[i] == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif s[i] == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif s[i] == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif s[i] == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n\n        if num:\n            res += sign * num\n\n        return res"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Calculate(string s) {\n        Stack<int> stack = new Stack<int>();\n        int result = 0;\n        int num = 0;\n        int sign = 1;\n\n        for (int i = 0; i < s.Length; i++) {\n            char c = s[i];\n            if (char.IsDigit(c)) {\n                num = num * 10 + (c - '0');\n            } else if (c == '+') {\n                result += sign * num;\n                num = 0;\n                sign = 1;\n            } else if (c == '-') {\n                result += sign * num;\n                num = 0;\n                sign = -1;\n            } else if (c == '(') {\n                stack.Push(result);\n                stack.Push(sign);\n                result = 0;\n                num = 0;\n                sign = 1;\n            } else if (c == ')') {\n                result += sign * num;\n                num = 0;\n                result *= stack.Pop();\n                result += stack.Pop();\n            }\n        }\n\n        if (num != 0) {\n            result += sign * num;\n        }\n\n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nconst calculate = (s) => {\n    const stack = [];\n    let num = 0;\n    let sign = 1;\n    let result = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        const char = s.charAt(i);\n        \n        if (!isNaN(char) && char !== ' ') {\n            num = num * 10 + parseInt(char);\n        } else if (char === '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (char === '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (char === '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (char === ')') {\n            result += sign * num;\n            result *= stack.pop(); // previous sign\n            result += stack.pop(); // previous result\n            num = 0;\n        }\n    }\n    \n    return result + sign * num;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function calculate(s: string): number {\n    const stack: number[] = [];\n    let num = 0;\n    let sign = 1;\n    let result = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n        if (!isNaN(parseInt(char))) {\n            num = num * 10 + parseInt(char);\n        } else if (char === '+' || char === '-') {\n            result += sign * num;\n            num = 0;\n            sign = char === '+' ? 1 : -1;\n        } else if (char === '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (char === ')') {\n            result += sign * num;\n            result *= stack.pop() as number;\n            result += stack.pop() as number;\n            num = 0;\n        }\n    }\n\n    return result + sign * num;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function calculate($s) {\n        $stack = [];\n        $num = 0;\n        $sign = 1;\n        $result = 0;\n\n        for ($i = 0; $i < strlen($s); $i++) {\n            $char = $s[$i];\n\n            if (is_numeric($char)) {\n                $num = $num * 10 + intval($char);\n            } elseif ($char == '+') {\n                $result += $sign * $num;\n                $num = 0;\n                $sign = 1;\n            } elseif ($char == '-') {\n                $result += $sign * $num;\n                $num = 0;\n                $sign = -1;\n            } elseif ($char == '(') {\n                array_push($stack, $result);\n                array_push($stack, $sign);\n                $result = 0;\n                $sign = 1;\n            } elseif ($char == ')') {\n                $result += $sign * $num;\n                $num = 0;\n                $result *= array_pop($stack);\n                $result += array_pop($stack);\n            }\n        }\n\n        $result += $sign * $num;\n        return $result;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func calculate(_ s: String) -> Int {\n        var stack = [Int]()\n        var result = 0\n        var num = 0\n        var sign = 1\n        \n        for char in s {\n            if char.isNumber {\n                num = num * 10 + Int(String(char))!\n            } else if char == \"+\" {\n                result += sign * num\n                num = 0\n                sign = 1\n            } else if char == \"-\" {\n                result += sign * num\n                num = 0\n                sign = -1\n            } else if char == \"(\" {\n                stack.append(result)\n                stack.append(sign)\n                result = 0\n                sign = 1\n            } else if char == \")\" {\n                result += sign * num\n                num = 0\n                result *= stack.removeLast()\n                result += stack.removeLast()\n            }\n        }\n        \n        return result + (sign * num)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun calculate(s: String): Int {\n        val stack = LinkedList<Int>()\n        var result = 0\n        var num = 0\n        var sign = 1\n\n        for (i in s.indices) {\n            val c = s[i]\n            if (Character.isDigit(c)) {\n                num = num * 10 + (c - '0')\n            } else if (c == '+') {\n                result += sign * num\n                num = 0\n                sign = 1\n            } else if (c == '-') {\n                result += sign * num\n                num = 0\n                sign = -1\n            } else if (c == '(') {\n                stack.push(result)\n                stack.push(sign)\n                result = 0\n                sign = 1\n            } else if (c == ')') {\n                result += sign * num\n                result *= stack.pop()\n                result += stack.pop()\n                num = 0\n            }\n        }\n\n        if (num != 0) {\n            result += sign * num\n        }\n\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int calculate(String s) {\n    s = s.replaceAll(' ', ''); \n    List<int> stack = [];\n    int num = 0;\n    int res = 0;\n    int sign = 1;\n\n    for (int i = 0; i < s.length; i++) {\n      if (s[i] == '(') {\n        stack.add(res);\n        stack.add(sign);\n        res = 0;\n        sign = 1;\n      } else if (s[i] == ')') {\n        res *= stack.removeLast();\n        res += stack.removeLast();\n      } else if (s[i] == '+') {\n        sign = 1;\n      } else if (s[i] == '-') {\n        sign = -1;\n      } else {\n        num = 0;\n        while (i < s.length && s.codeUnitAt(i) >= '0'.codeUnitAt(0) && s.codeUnitAt(i) <= '9'.codeUnitAt(0)) {\n          num = num * 10 + int.parse(s[i]);\n          i++;\n        }\n        i--;\n        res += sign * num;\n      }\n    }\n\n    return res;\n  }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef calculate(s)\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n    \n    s.each_char do |char|\n        if char == '('\n            stack.push(result)\n            stack.push(sign)\n            result = 0\n            sign = 1\n        elsif char == ')'\n            result += sign * num\n            result *= stack.pop\n            result += stack.pop\n            num = 0\n        elsif char == '+'\n            result += sign * num\n            num = 0\n            sign = 1\n        elsif char == '-'\n            result += sign * num\n            num = 0\n            sign = -1\n        elsif char != ' '\n            num = num * 10 + char.to_i\n        end\n    end\n    \n    result + sign * num\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn calculate(s: String) -> i32 {\n        let mut stack: Vec<i32> = Vec::new();\n        let mut num = 0;\n        let mut sign = 1;\n        let mut result = 0;\n\n        for c in s.chars() {\n            if c.is_digit(10) {\n                num = num * 10 + c.to_digit(10).unwrap() as i32;\n            } else if c == '+' {\n                result += sign * num;\n                num = 0;\n                sign = 1;\n            } else if c == '-' {\n                result += sign * num;\n                num = 0;\n                sign = -1;\n            } else if c == '(' {\n                stack.push(result);\n                stack.push(sign);\n                result = 0;\n                sign = 1;\n            } else if c == ')' {\n                result += sign * num;\n                num = 0;\n                let prev_sign = stack.pop().unwrap();\n                let prev_result = stack.pop().unwrap();\n                result = prev_result + prev_sign * result;\n            }\n        }\n\n        result += sign * num;\n\n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to evaluate a mathematical expression given as a string without using built-in evaluation functions. Let's break down and explain how to approach this problem step by step.\n\n# Explanation\n\n1. **Initialization**: We need to initialize variables that will help us keep track of the current number, the current result, and the current sign (positive or negative).\n2. **Iterate through the string**: We will loop through each character of the string.\n   - If the character is a digit, we construct the number by appending the digit (we need to handle multi-digit numbers).\n   - If the character is a '+', we add the last constructed number to the result and set the sign to positive.\n   - If the character is a '-', we add the last constructed number to the result and set the sign to negative.\n   - If the character is '(', we push the current result and sign onto a stack and reset the result and sign for the new sub-expression.\n   - If the character is ')', we calculate the result of the expression within the parenthesis by multiplying with the sign and adding the previous result from the stack.\n3. **End of String**: After iterating through the string, if any number remains, we add it to the result.\n4. **Return Result**: We return the final result.\n\n# Pseudocode\n\n```\nTo solve this coding challenge:\n\n# Initialize variables\nstack = []          # Stack to keep track of results and signs\nnum = 0             # Current number being processed\nres = 0             # Current result of the expression\nsign = 1            # Current sign (+1 or -1)\n\n# Loop through each character in the string\nfor char in s:\n    if char.isdigit():\n        # If char is a digit, form the number (handle multi-digit numbers)\n        num = num * 10 + int(char)\n    elif char == '+':\n        # If char is '+', update the result with the current number and reset num\n        res += sign * num\n        num = 0\n        sign = 1  # Set sign to positive\n    elif char == '-':\n        # If char is '-', update the result with the current number and reset num\n        res += sign * num\n        num = 0\n        sign = -1 # Set sign to negative\n    elif char == '(':\n        # If char is '(', push the current result and sign onto the stack\n        stack.append(res)\n        stack.append(sign)\n        # Reset result and sign for new sub-expression\n        res = 0\n        sign = 1\n    elif char == ')':\n        # If char is ')', complete the calculation for the current sub-expression\n        res += sign * num\n        num = 0\n        res *= stack.pop() # Multiply by sign from stack\n        res += stack.pop() # Add to result from stack\n\n# After loop ends, if there's any number left, add it to the result\nif num != 0:\n    res += sign * num\n\n# Return the final result\nreturn res\n```\n\nThis pseudocode outlines the step-by-step approach to implementing a basic calculator capable of evaluating expressions with addition, subtraction, and parentheses.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-basic-calculator"
    },
    {
        "name": "Count The Repetitions",
        "site": "LeetCode",
        "href": "/solution/LeetCode-count-the-repetitions",
        "languages": [
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function getMaxRepetitions(s1: string, n1: number, s2: string, n2: number): number {\n    const dp: number[][] = [];\n    for (let a = 0; a <= s2.length; a++) {\n        dp[a] = [];\n        let next = a;\n        let count = 0;\n        for (let b = 0; b < s1.length; b++) {\n            if (s1[b] === s2[next]) {\n                next++;\n                if (next === s2.length) {\n                    next = 0;\n                    count++;\n                }\n            }\n        }\n        dp[a] = [next, count];\n    }\n\n    let ans = 0;\n    let j = 0;\n    let count = 0;\n    for (let i = 0; i < n1; i++) {\n        count += dp[j][1];\n        j = dp[j][0];\n        ans = Math.max(ans, count);\n    }\n\n    return Math.floor(ans / n2);\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func getMaxRepetitions(_ s1: String, _ n1: Int, _ s2: String, _ n2: Int) -> Int {\n        var s1Chars = Array(s1)\n        var s2Chars = Array(s2)\n        \n        var count1 = 0\n        var count2 = 0\n        var index = 0\n        \n        while count1 < n1 {\n            for ch in s1Chars {\n                if ch == s2Chars[index] {\n                    index += 1\n                    if index == s2Chars.count {\n                        index = 0\n                        count2 += 1\n                    }\n                }\n            }\n            count1 += 1\n        }\n        \n        return count2 / n2\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\n        if n1 == 0 || n2 == 0 {\n            return 0;\n        }\n        \n        let s1_chars: Vec<char> = s1.chars().collect();\n        let s2_chars: Vec<char> = s2.chars().collect();\n        \n        let mut repeats = 0;\n        let mut s2_index = 0;\n        \n        for _ in 0..n1 {\n            for &c in &s1_chars {\n                if c == s2_chars[s2_index] {\n                    s2_index += 1;\n                    if s2_index == s2_chars.len() {\n                        repeats += 1;\n                        s2_index = 0;\n                    }\n                }\n            }\n        }\n        \n        repeats / n2\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, let's break down the problem into manageable parts and structure the logic to come up with a solution. The goal is to determine the maximum integer \\( m \\) such that the string defined as \\([s2, m]\\) can be obtained from the string defined as \\([s1, n1]\\).\n\n# Explanation\n\n1. **Definitions and Examples**:\n   - Given \\([s1, n1]\\), the string consists of \\( s1 \\) repeated \\( n1 \\) times.\n   - Given \\([s2, n2]\\), the string consists of \\( s2 \\) repeated \\( n2 \\) times.\n   - The task is to determine the maximum \\( m \\) such that \\([s2, m]\\) can be formed by removing characters from \\([s1, n1]\\).\n\n2. **Observation**:\n   - This problem can be approached by simulating the process of checking how many times \\( s2 \\) can be extracted from \\( s1 \\) within the provided repetition constraints.\n\n3. **Steps to Solve**:\n   - Use a dynamic programming approach to count how many times we can fully extract \\( s2 \\) from \\( s1 \\) by iterating through their characters.\n   - Track the positions and the patterns found within the repetitions to determine the maximum \\( m \\).\n\n# Pseudocode\n\n```python\ndef getMaxRepetitions(s1, n1, s2, n2):\n    # Step 1: Initialize DP storage for counts and positions\n    dp = []\n    length_s1 = len(s1)\n    length_s2 = len(s2)\n    \n    # Step 2: Preprocess to understand how `s2` integrates into `s1`\n    for a in range(length_s2 + 1):\n        next_pos = a\n        count = 0\n        for b in range(length_s1):\n            if s1[b] == s2[next_pos]:  # Matching character found\n                next_pos += 1\n                if next_pos == length_s2:  # Completed an instance of `s2`\n                    next_pos = 0\n                    count += 1\n        dp.append([next_pos, count])\n    \n    # Step 3: Simulate the extraction process\n    total_count = 0  # Total number of s2 found in s1*n1\n    current_pos = 0  # Current position within s2\n\n    for i in range(n1):\n        total_count += dp[current_pos][1]\n        current_pos = dp[current_pos][0]\n\n    # The result is the floor of the total extracted `s2` divided by repetition of `n2`\n    return total_count // n2\n\n# Test Cases\n# Example 1:\nprint(getMaxRepetitions(\"acb\", 4, \"ab\", 2)) # Output: 2\n\n# Example 2:\nprint(getMaxRepetitions(\"acb\", 1, \"acb\", 1)) # Output: 1\n```\n\n- **Step-by-Step Execution**:\n  - We use a dynamic programming approach to evaluate the match positions.\n  - In each main iteration, update the number of times \\( s2 \\) was fully found in the repeated string \\( s1 \\).\n  - The answer is derived by calculating how many complete cycles of \\( s2 \\) fit into \\( s1 \\times n1 \\) and subsequently divide by \\( n2 \\) to determine the maximum \\( m \\).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-count-the-repetitions"
    },
    {
        "name": "Hamming Distance",
        "site": "LeetCode",
        "href": "/solution/LeetCode-hamming-distance",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int xorResult = x ^ y;\n        int count = 0;\n        \n        while (xorResult > 0) {\n            count += xorResult & 1;\n            xorResult >>= 1;\n        }\n        \n        return count;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int hammingDistance(int x, int y) {\n        int xor = x ^ y;\n        int count = 0;\n        \n        while (xor != 0) {\n            count += xor & 1;\n            xor >>= 1;\n        }\n        \n        return count;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        return bin(x ^ y).count('1')"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int hammingDistance(int x, int y) {\n    int xor_result = x ^ y;\n    int count = 0;\n    \n    while (xor_result > 0) {\n        if (xor_result & 1) {\n            count++;\n        }\n        xor_result = xor_result >> 1;\n    }\n    \n    return count;\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function hammingDistance(x: number, y: number): number {\n    let xor = x ^ y;\n    let count = 0;\n    while (xor !== 0) {\n        count += xor & 1;\n        xor = xor >> 1;\n    }\n    return count;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $x\n     * @param Integer $y\n     * @return Integer\n     */\n    function hammingDistance($x, $y) {\n        $xor = $x ^ $y;\n        $count = 0;\n        while ($xor > 0) {\n            if ($xor & 1 == 1) {\n                $count++;\n            }\n            $xor >>= 1;\n        }\n        \n        return $count;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func hammingDistance(_ x: Int, _ y: Int) -> Int {\n        var xor = x ^ y\n        var count = 0\n        while xor > 0 {\n            count += xor & 1\n            xor >>= 1\n        }\n        return count\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun hammingDistance(x: Int, y: Int): Int {\n        var xor = x xor y\n        var count = 0\n        while (xor != 0) {\n            count += xor and 1\n            xor = xor ushr 1\n        }\n        return count\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int hammingDistance(int x, int y) {\n    int xor = x ^ y;\n    int count = 0;\n    while (xor != 0) {\n      count += xor & 1;\n      xor >>= 1;\n    }\n    return count;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func hammingDistance(x int, y int) int {\n    xor := x ^ y\n    distance := 0\n    for xor != 0 {\n        if xor&1 == 1 {\n            distance++\n        }\n        xor = xor >> 1\n    }\n    return distance\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} x\n# @param {Integer} y\n# @return {Integer}\ndef hamming_distance(x, y)\n    (x ^ y).to_s(2).count(\"1\")\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def hammingDistance(x: Int, y: Int): Int = {\n        (x ^ y).toBinaryString.count(_ == '1')\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn hamming_distance(x: i32, y: i32) -> i32 {\n        (x ^ y).count_ones() as i32\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (hamming-distance x y)\n  (-> exact-integer? exact-integer? exact-integer?)\n  (let loop ((count 0) (xor-result (bitwise-xor x y)))\n    (cond\n      [(zero? xor-result) count]\n      [else (loop (+ count (bitwise-and xor-result 1)) (arithmetic-shift xor-result -1))])))\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec hamming_distance(X :: integer(), Y :: integer()) -> integer().\nhamming_distance(X, Y) ->\n    count_bits_set(X bxor Y).\n\ncount_bits_set(0) ->\n    0;\ncount_bits_set(N) ->\n    1 + count_bits_set(N band (N - 1)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to compute the Hamming distance between two integers, which is the number of positions where the corresponding bits differ.\n\n# Explanation\n\n1. **Understanding Hamming Distance**: The Hamming distance between two integers is calculated by comparing their binary representations and counting the number of positions at which the bits differ.\n2. **Bit Manipulation**: To find the differing bits, we use the XOR (^) operator. The XOR operator outputs a 1 at each bit position where the corresponding bits of its operands differ.\n3. **Counting Differing Bits**: After computing the XOR of the two integers, we convert the result to its binary form and count the number of '1's, which represents the differing bits.\n\nWe will break down this process into clear steps and provide the pseudocode for the solution.\n\n# Pseudocode\n\n```\n# Define a function to calculate Hamming distance\nfunction hammingDistance(x, y):\n    # Compute XOR of x and y\n    xor_result = x XOR y\n    \n    # Convert XOR result to binary and count the number of '1's\n    hamming_distance = count of '1' in binary representation of xor_result\n    \n    # Return the Hamming distance\n    return hamming_distance\n    \n# Example usage:\n# Input: x = 1, y = 4\n# Output: hammingDistance(1, 4) should return 2\n```\n\nThe approach utilizes the XOR operator and handles the counting of differing bits efficiently. This method leverages Python's built-in string conversion and counting functions to simplify the implementation.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-hamming-distance"
    },
    {
        "name": "Minimum Moves To Equal Array Elements Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-moves-to-equal-array-elements-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minMoves2(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int i = 0, j = nums.size() - 1;\n        int moves = 0;\n        while (i < j) {\n            moves += nums[j] - nums[i];\n            i++;\n            j--;\n        }\n        return moves;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minMoves2(int[] nums) {\n        Arrays.sort(nums);\n        int median = nums[nums.length / 2];\n        int moves = 0;\n        for (int num : nums) {\n            moves += Math.abs(num - median);\n        }\n        return moves;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minMoves2(self, nums):\n        nums.sort()\n        mid = nums[len(nums)//2]\n        return sum(abs(num - mid) for num in nums)"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int MinMoves2(int[] nums) {\n        Array.Sort(nums);\n        int median = nums[nums.Length / 2];\n        int moves = 0;\n        \n        foreach (int num in nums) {\n            moves += Math.Abs(num - median);\n        }\n        \n        return moves;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minMoves2 = function(nums) {\n    nums.sort((a, b) => a - b);\n    let mid = nums[Math.floor(nums.length / 2)];\n    let moves = 0;\n    \n    for (let num of nums) {\n        moves += Math.abs(num - mid);\n    }\n    \n    return moves;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minMoves2(nums: number[]): number {\n    nums.sort((a, b) => a - b);\n    let mid = nums[Math.floor(nums.length / 2)];\n    let moves = 0;\n    for (let num of nums) {\n        moves += Math.abs(num - mid);\n    }\n    return moves;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function minMoves2($nums) {\n        sort($nums);\n        $n = count($nums);\n        $median = $nums[floor($n / 2)];\n        \n        $moves = 0;\n        foreach ($nums as $num) {\n            $moves += abs($num - $median);\n        }\n        \n        return $moves;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minMoves2(_ nums: [Int]) -> Int {\n        let sortedNums = nums.sorted()\n        var moves = 0\n        var left = 0\n        var right = sortedNums.count - 1\n        \n        while left < right {\n            moves += sortedNums[right] - sortedNums[left]\n            left += 1\n            right -= 1\n        }\n        \n        return moves\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minMoves2(nums: IntArray): Int {\n        nums.sort()\n        var minMoves = 0\n        var left = 0\n        var right = nums.size - 1\n        while (left < right) {\n            minMoves += nums[right] - nums[left]\n            left++\n            right--\n        }\n        return minMoves\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int minMoves2(List<int> nums) {\n    nums.sort();\n    \n    int mid = nums[nums.length ~/ 2];\n    int moves = 0;\n    \n    for (int num in nums) {\n      moves += (num - mid).abs();\n    }\n    \n    return moves;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func minMoves2(nums []int) int {\n    sort.Ints(nums)\n    \n    median := nums[len(nums)/2]\n    \n    moves := 0\n    for _, num := range nums {\n        moves += abs(num - median)\n    }\n    \n    return moves\n}\n\nfunc abs(n int) int {\n    if n < 0 {\n        return -n\n    }\n    return n\n}"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def minMoves2(nums: Array[Int]): Int = {\n        val sortedNums = nums.sorted\n        val median = sortedNums(sortedNums.length / 2)\n        sortedNums.map(num => math.abs(num - median)).sum\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn min_moves2(nums: Vec<i32>) -> i32 {\n        let mut nums = nums;\n        nums.sort();\n\n        let mut moves = 0;\n        let median = nums[nums.len() / 2];\n\n        for num in nums {\n            moves += (num - median).abs();\n        }\n\n        moves\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (min-moves2 nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (define sorted-nums (sort nums <))\n  (define target (list-ref sorted-nums (quotient (length sorted-nums) 2)))\n  \n  (for/sum ([num sorted-nums])\n    (abs (- num target))\n    )\n  )\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec min_moves2(Nums :: [integer()]) -> integer().\nmin_moves2(Nums) ->\n    lists:sum(lists:map(fun(X) -> abs(X - lists:nth((length(Nums) div 2) + 1, lists:sort(Nums))) end, Nums)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the minimum number of moves to make all array elements equal, where each move involves incrementing or decrementing an element by 1.\n\n# Explanation\n1. **Sorting the Array**: First, we sort the array. This helps to determine the median value, which is crucial for minimizing the total number of moves.\n2. **Finding the Median**: The median minimizes the sum of absolute deviations from all other numbers in the array, which is why it is chosen as the target value.\n3. **Calculating Moves**: Once we have the median, we calculate the total number of moves required to make all elements equal to this median by summing up the absolute differences between each element and the median.\n\nThis method works because the median has a special property: it minimizes the sum of absolute differences.\n\n# Pseudocode\n```\nfunction minMoves2(nums):\n    sort(nums)\n    mid = nums[length(nums) // 2]   # Find the median\n    moves = 0\n    for num in nums:\n        moves += absolute(num - mid)  # Sum the absolute differences\n    return moves\n\n# Function to find absolute value\nfunction absolute(value):\n    if value < 0:\n        return -value\n    else:\n        return value\n\n# Function to sort an array (e.g., using quicksort, mergesort, etc.)\nfunction sort(array):\n    # Sorting logic here\n    return sorted array\n```\n\nHere's a breakdown of the steps:\n- Sort the array to find the median.\n- Compute the median which will be `nums[length(nums) // 2]`.\n- Sum up the absolute differences from the median for all elements in the array.\n- Return the total number of moves.\n\nThis approach ensures that we achieve the minimum number of moves as required by the problem statement.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-moves-to-equal-array-elements-ii"
    },
    {
        "name": "Island Perimeter",
        "site": "LeetCode",
        "href": "/solution/LeetCode-island-perimeter",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int islandPerimeter(vector<vector<int>>& grid) {\n        int perimeter = 0;\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    perimeter += 4;\n                    if (i > 0 && grid[i - 1][j] == 1) perimeter -= 2;\n                    if (j > 0 && grid[i][j - 1] == 1) perimeter -= 2;\n                }\n            }\n        }\n        return perimeter;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int islandPerimeter(int[][] grid) {\n        int perimeter = 0;\n        \n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    perimeter += 4;\n                    \n                    if (i > 0 && grid[i - 1][j] == 1) {\n                        perimeter -= 2;\n                    }\n                    \n                    if (j > 0 && grid[i][j - 1] == 1) {\n                        perimeter -= 2;\n                    }\n                }\n            }\n        }\n        \n        return perimeter;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def islandPerimeter(self, grid):\n        perimeter = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    perimeter += 4\n                    if i > 0 and grid[i - 1][j] == 1:\n                        perimeter -= 2\n                    if j > 0 and grid[i][j - 1] == 1:\n                        perimeter -= 2\n        return perimeter"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int islandPerimeter(int** grid, int gridSize, int* gridColSize) {\n    int perimeter = 0;\n    \n    for(int i = 0; i < gridSize; i++) {\n        for(int j = 0; j < *gridColSize; j++) {\n            if(grid[i][j] == 1) {\n                perimeter += 4;\n                if(i > 0 && grid[i-1][j] == 1) perimeter -= 2;\n                if(j > 0 && grid[i][j-1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    \n    return perimeter;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int IslandPerimeter(int[][] grid) {\n        int perimeter = 0;\n        int rows = grid.Length;\n        int cols = grid[0].Length;\n        \n        for(int i = 0; i < rows; i++) {\n            for(int j = 0; j < cols; j++) {\n                if(grid[i][j] == 1) {\n                    perimeter += 4;\n                    \n                    if(i > 0 && grid[i - 1][j] == 1) {\n                        perimeter -= 2;\n                    }\n                    \n                    if(j > 0 && grid[i][j - 1] == 1) {\n                        perimeter -= 2;\n                    }\n                }\n            }\n        }\n        \n        return perimeter;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar islandPerimeter = function(grid) {\n    let perimeter = 0;\n    \n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n                perimeter += 4;\n                \n                if (i > 0 && grid[i - 1][j] === 1) {\n                    perimeter -= 2;\n                }\n                \n                if (j > 0 && grid[i][j - 1] === 1) {\n                    perimeter -= 2;\n                }\n            }\n        }\n    }\n    \n    return perimeter;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function islandPerimeter(grid: number[][]): number {\n    let perimeter = 0;\n    const rows = grid.length;\n    const cols = grid[0].length;\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === 1) {\n                perimeter += 4;\n                if (i > 0 && grid[i - 1][j] === 1) perimeter--; // top neighbor\n                if (i < rows - 1 && grid[i + 1][j] === 1) perimeter--; // bottom neighbor\n                if (j > 0 && grid[i][j - 1] === 1) perimeter--; // left neighbor\n                if (j < cols - 1 && grid[i][j + 1] === 1) perimeter--; // right neighbor\n            }\n        }\n    }\n\n    return perimeter;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function islandPerimeter($grid) {\n        $perimeter = 0;\n        \n        for ($i = 0; $i < count($grid); $i++) {\n            for ($j = 0; $j < count($grid[0]); $j++) {\n                if ($grid[$i][$j] == 1) {\n                    $perimeter += 4;\n                    if ($i > 0 && $grid[$i - 1][$j] == 1) {\n                        $perimeter -= 2;\n                    }\n                    if ($j > 0 && $grid[$i][$j - 1] == 1) {\n                        $perimeter -= 2;\n                    }\n                }\n            }\n        }\n        \n        return $perimeter;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func islandPerimeter(_ grid: [[Int]]) -> Int {\n        var perimeter = 0\n        \n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n                    perimeter += 4\n                    \n                    if i > 0 && grid[i - 1][j] == 1 {\n                        perimeter -= 2\n                    }\n                    \n                    if j > 0 && grid[i][j - 1] == 1 {\n                        perimeter -= 2\n                    }\n                }\n            }\n        }\n        \n        return perimeter\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun islandPerimeter(grid: Array<IntArray>): Int {\n        var perimeter = 0\n        for (i in grid.indices) {\n            for (j in grid[i].indices) {\n                if (grid[i][j] == 1) {\n                    perimeter += 4\n                    if (i > 0 && grid[i - 1][j] == 1) {\n                        perimeter -= 2\n                    }\n                    if (j > 0 && grid[i][j - 1] == 1) {\n                        perimeter -= 2\n                    }\n                }\n            }\n        }\n        return perimeter\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int islandPerimeter(List<List<int>> grid) {\n      int perimeter = 0;\n      \n      for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n          if (grid[i][j] == 1) {\n            perimeter += 4;\n            \n            if (i > 0 && grid[i - 1][j] == 1) {\n              perimeter -= 2;\n            }\n            \n            if (j > 0 && grid[i][j - 1] == 1) {\n              perimeter -= 2;\n            }\n          }\n        }\n      }\n      \n      return perimeter;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func islandPerimeter(grid [][]int) int {\n    perimeter := 0\n    \n    for i := 0; i < len(grid); i++ {\n        for j := 0; j < len(grid[0]); j++ {\n            if grid[i][j] == 1 {\n                perimeter += 4\n                \n                if i > 0 && grid[i-1][j] == 1 {\n                    perimeter -= 2\n                }\n                if j > 0 && grid[i][j-1] == 1 {\n                    perimeter -= 2\n                }\n            }\n        }\n    }\n    \n    return perimeter\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef island_perimeter(grid)\n    perimeter = 0\n    grid.each_with_index do |row, i|\n        row.each_with_index do |cell, j|\n            next if cell == 0\n            perimeter += 4\n            perimeter -= 2 if i > 0 && grid[i-1][j] == 1\n            perimeter -= 2 if j > 0 && row[j-1] == 1\n        end\n    end\n    perimeter\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def islandPerimeter(grid: Array[Array[Int]]): Int = {\n        var perimeter = 0\n        for (i <- 0 until grid.length; j <- 0 until grid(0).length) {\n            if (grid(i)(j) == 1) {\n                perimeter += 4\n                if (i > 0 && grid(i - 1)(j) == 1) perimeter -= 2\n                if (j > 0 && grid(i)(j - 1) == 1) perimeter -= 2\n            }\n        }\n        perimeter\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn island_perimeter(grid: Vec<Vec<i32>>) -> i32 {\n        let mut perimeter = 0;\n\n        for i in 0..grid.len() {\n            for j in 0..grid[0].len() {\n                if grid[i][j] == 1 {\n                    perimeter += 4;\n\n                    if i > 0 && grid[i - 1][j] == 1 {\n                        perimeter -= 2;\n                    }\n\n                    if j > 0 && grid[i][j - 1] == 1 {\n                        perimeter -= 2;\n                    }\n                }\n            }\n        }\n\n        perimeter\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the perimeter of an island represented in a grid. The grid consists of 1s (land) and 0s (water). \n\n# Explanation\n\n1. **Initialize Perimeter**: Start by setting the perimeter to 0.\n2. **Iterate through the Grid**: Traverse each cell in the grid.\n3. **Check for Land Cell**: For each land cell (grid[i][j] == 1), add 4 to the perimeter (since a single land cell adds 4 to the perimeter).\n4. **Subtract for Shared Edges**: For neighboring land cells (up and left), subtract 2 from the perimeter for each neighboring land cell. This is because the shared edge between two land cells only counts as one edge in the perimeter.\n\n# Pseudocode\n\n```\nfunction islandPerimeter(grid):\n    # Initialize perimeter to 0\n    perimeter = 0\n\n    # Get number of rows and columns in the grid\n    rows = length of grid\n    cols = length of grid[0]\n\n    # Iterate through each cell in the grid\n    for i from 0 to rows - 1:\n        for j from 0 to cols - 1:\n            # Check if the cell is land\n            if grid[i][j] == 1:\n                # Add 4 to the perimeter for each land cell\n                perimeter += 4\n                \n                # Check for upper neighboring land cell and subtract 2 if it's land\n                if i > 0 and grid[i - 1][j] == 1:\n                    perimeter -= 2\n                \n                # Check for left neighboring land cell and subtract 2 if it's land\n                if j > 0 and grid[i][j - 1] == 1:\n                    perimeter -= 2\n\n    # Return the final perimeter\n    return perimeter\n```\n\nThis solution efficiently calculates the island perimeter by iterating through each cell in the grid exactly once, making it run in O(n*m) time, where n is the number of rows and m is the number of columns. The grid size is constrained to a maximum of 100x100, so this approach is computationally feasible.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-island-perimeter"
    },
    {
        "name": "Can I Win",
        "site": "LeetCode",
        "href": "/solution/LeetCode-can-i-win",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) return true;\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n        \n        unordered_map<int, bool> memo;\n        return canWin(maxChoosableInteger, desiredTotal, 0, memo);\n    }\n    \n    bool canWin(int maxChoosableInteger, int desiredTotal, int chosen, unordered_map<int, bool>& memo) {\n        if (memo.find(chosen) != memo.end()) return memo[chosen];\n        \n        for (int i = 1; i <= maxChoosableInteger; ++i) {\n            int mask = 1 << i;\n            if ((chosen & mask) == 0) {\n                if (i >= desiredTotal || !canWin(maxChoosableInteger, desiredTotal - i, chosen | mask, memo)) {\n                    memo[chosen] = true;\n                    return true;\n                }\n            }\n        }\n        \n        memo[chosen] = false;\n        return false;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.*;\n\nclass Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= maxChoosableInteger) {\n            return true;\n        }\n        \n        if (desiredTotal > (maxChoosableInteger + 1) * maxChoosableInteger / 2) {\n            return false;\n        }\n        \n        Map<Integer, Boolean> memo = new HashMap<>();\n        return canWin(maxChoosableInteger, desiredTotal, 0, memo);\n    }\n\n    private boolean canWin(int maxChoosableInteger, int desiredTotal, int state, Map<Integer, Boolean> memo) {\n        if (desiredTotal <= 0) {\n            return false;\n        }\n        if (memo.containsKey(state)) {\n            return memo.get(state);\n        }\n        for (int i = 0; i < maxChoosableInteger; i++) {\n            if ((state & (1 << i)) == 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i - 1, state | (1 << i), memo)) {\n                    memo.put(state, true);\n                    return true;\n                }\n            }\n        }\n        memo.put(state, false);\n        return false;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(1, maxChoosableInteger + 1)) < desiredTotal:\n            return False\n        \n        memo = {}\n        def canWin(choices, total):\n            if choices[-1] >= total:\n                return True\n            key = tuple(choices)\n            if key in memo:\n                return memo[key]\n            \n            for i in range(len(choices)):\n                if not canWin(choices[:i] + choices[i+1:], total - choices[i]):\n                    memo[key] = True\n                    return True\n                \n            memo[key] = False\n            return False\n        \n        return canWin(range(1, maxChoosableInteger + 1), desiredTotal)"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool CanIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal) \n            return true;\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal)\n            return false;\n        \n        return CanWin(0, new Dictionary<int, bool>(), maxChoosableInteger, desiredTotal);\n    }\n    \n    private bool CanWin(int state, Dictionary<int, bool> memo, int maxChoosableInteger, int desiredTotal) {\n        if (memo.ContainsKey(state))\n            return memo[state];\n        \n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int curr = 1 << i;\n            if ((curr & state) == 0) {\n                if (i >= desiredTotal || !CanWin(state | curr, memo, maxChoosableInteger, desiredTotal - i)) {\n                    memo[state] = true;\n                    return true;\n                }\n            }\n        }\n        \n        memo[state] = false;\n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} maxChoosableInteger\n * @param {number} desiredTotal\n * @return {boolean}\n */\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\n\n    const memo = new Map();\n\n    const dfs = (maxChoosableInteger, desiredTotal, state) => {\n        if (desiredTotal <= 0) return false;\n        if (memo.has(state)) return memo.get(state);\n\n        for (let i = 1; i <= maxChoosableInteger; i++) {\n            if ((state & (1 << i)) === 0) {\n                if (!dfs(maxChoosableInteger, desiredTotal - i, state | (1 << i))) {\n                    memo.set(state, true);\n                    return true;\n                }\n            }\n        }\n\n        memo.set(state, false);\n        return false;\n    };\n\n    return dfs(maxChoosableInteger, desiredTotal, 0);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function canIWin(maxChoosableInteger: number, desiredTotal: number): boolean {\n    if (desiredTotal === 0) return true;\n    if ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2 < desiredTotal) return false;\n    const memo: Map<string, boolean> = new Map();\n\n    function canWin(maxChoosableInteger: number, desiredTotal: number, chosen: number, memo: Map<string, boolean>): boolean {\n        if (desiredTotal <= 0) return false;\n        const key = chosen.toString();\n        if (memo.has(key)) return memo.get(key)!;\n\n        for (let i = 1; i <= maxChoosableInteger; i++) {\n            if ((chosen & (1 << i)) === 0) {\n                if (!canWin(maxChoosableInteger, desiredTotal - i, chosen | (1 << i), memo)) {\n                    memo.set(key, true);\n                    return true;\n                }\n            }\n        }\n        memo.set(key, false);\n        return false;\n    }\n\n    return canWin(maxChoosableInteger, desiredTotal, 0, memo);\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $maxChoosableInteger\n     * @param Integer $desiredTotal\n     * @return Boolean\n     */\n    function canIWin($maxChoosableInteger, $desiredTotal) {\n        if ($desiredTotal <= $maxChoosableInteger) {\n            return true;\n        }\n        if (($maxChoosableInteger * ($maxChoosableInteger + 1) / 2) < $desiredTotal) {\n            return false;\n        }\n        \n        return $this->canWin(0, $desiredTotal, $maxChoosableInteger, 0);\n    }\n    \n    function canWin($chosen, $total, $max, $mask) {\n        if (isset($this->memo[$mask])) {\n            return $this->memo[$mask];\n        }\n        \n        for ($i = 1; $i <= $max; $i++) {\n            $curr = 1 << $i;\n            if (($mask & $curr) === 0) {\n                if ($total <= $i || !$this->canWin($i, $total - $i, $max, $mask | $curr)) {\n                    $this->memo[$mask] = true;\n                    return true;\n                }\n            }\n        }\n        $this->memo[$mask] = false;\n        return false;\n    }\n    \n    private $memo = [];\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func canIWin(_ maxChoosableInteger: Int, _ desiredTotal: Int) -> Bool {\n        if maxChoosableInteger >= desiredTotal {\n            return true\n        }\n        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal {\n            return false\n        }\n        var memo = [Int: Bool]()\n        func canWin(_ total: Int, _ visited: Int) -> Bool {\n            if let result = memo[visited] {\n                return result\n            }\n            for i in 0..<maxChoosableInteger {\n                let curr = 1 << i\n                if (curr & visited) == 0 {\n                    if total <= i + 1 || !canWin(total - (i + 1), visited | curr) {\n                        memo[visited] = true\n                        return true\n                    }\n                }\n            }\n            memo[visited] = false\n            return false\n        }\n        \n        return canWin(desiredTotal, 0)\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun canIWin(maxChoosableInteger: Int, desiredTotal: Int): Boolean {\n        if (maxChoosableInteger >= desiredTotal) return true\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false\n        val map = HashMap<Int, Boolean>()\n        return canWin(maxChoosableInteger, desiredTotal, 0, map)\n    }\n\n    private fun canWin(maxChoosableInteger: Int, desiredTotal: Int, state: Int, map: HashMap<Int, Boolean>): Boolean {\n        if (desiredTotal <= 0) return false\n        if (map.containsKey(state)) return map[state]!!\n\n        for (i in 0 until maxChoosableInteger) {\n            val move = (1 shl i)\n            if ((state and move) == 0 && !canWin(maxChoosableInteger, desiredTotal - (i + 1), state or move, map)) {\n                map[state] = true\n                return true\n            }\n        }\n\n        map[state] = false\n        return false\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool canIWin(int maxChoosableInteger, int desiredTotal) {\n    if (maxChoosableInteger >= desiredTotal) return true;\n    if (maxChoosableInteger * (maxChoosableInteger + 1) ~/ 2 < desiredTotal) return false;\n    \n    return canWin(maxChoosableInteger, desiredTotal, 0, {}, {});\n  }\n  \n  bool canWin(int maxChoosableInteger, int desiredTotal, int state, Map<int, bool> dp, Map<int, bool> visited) {\n    if (desiredTotal <= 0) return false;\n    \n    if (visited.containsKey(state)) {\n      return dp[state]!;\n    }\n    \n    for (int i = 0; i < maxChoosableInteger; i++) {\n      int curr = 1 << i;\n      if ((state & curr) == 0) {\n        if (!canWin(maxChoosableInteger, desiredTotal - i - 1, state | curr, dp, visited)) {\n          dp[state] = true;\n          visited[state] = true;\n          return true;\n        }\n      }\n    }\n    \n    dp[state] = false;\n    visited[state] = true;\n    return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func canIWin(maxChoosableInteger int, desiredTotal int) bool {\n    if desiredTotal <= 0 {\n        return true\n    }\n    if (maxChoosableInteger*(maxChoosableInteger+1))/2 < desiredTotal {\n        return false\n    }\n    memo := make(map[int]bool)\n    return helper(maxChoosableInteger, desiredTotal, 0, memo)\n}\n\nfunc helper(maxChoosableInteger int, desiredTotal int, state int, memo map[int]bool) bool {\n    if val, ok := memo[state]; ok {\n        return val\n    }\n    for i := 1; i <= maxChoosableInteger; i++ {\n        curr := 1 << (i - 1)\n        if curr&state == 0 {\n            if i >= desiredTotal || !helper(maxChoosableInteger, desiredTotal-i, curr|state, memo) {\n                memo[state] = true\n                return true\n            }\n        }\n    }\n    memo[state] = false\n    return false\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def canIWin(maxChoosableInteger: Int, desiredTotal: Int): Boolean = {\n        if (maxChoosableInteger >= desiredTotal) return true\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false\n        \n        val dp = scala.collection.mutable.Map[Int, Boolean]()\n        def canWin(remaining: Int, visited: Int): Boolean = {\n            if (dp.contains(visited)) return dp(visited)\n            \n            var result = false\n            var i = maxChoosableInteger\n            while (i >= 1 && !result) {\n                val mask = 1 << i\n                if ((mask & visited) == 0) {\n                    if (i >= remaining || !canWin(remaining - i, mask | visited)) {\n                        result = true\n                    }\n                }\n                i -= 1\n            }\n            \n            dp(visited) = result\n            result\n        }\n        \n        canWin(desiredTotal, 0)\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn can_i_win(max_choosable_integer: i32, desired_total: i32) -> bool {\n        if max_choosable_integer >= desired_total {\n            return true;\n        }\n        if (1 + max_choosable_integer) * max_choosable_integer / 2 < desired_total {\n            return false;\n        }\n        \n        let mut seen = std::collections::HashMap::new();\n        \n        fn can_win(max_choosable_integer: i32, desired_total: i32, state: i32, seen: &mut std::collections::HashMap<i32, bool>) -> bool {\n            if let Some(&result) = seen.get(&state) {\n                return result;\n            }\n            \n            for i in 0..max_choosable_integer {\n                let current = 1 << i;\n                if current & state == 0 {\n                    if desired_total <= i + 1 || !can_win(max_choosable_integer, desired_total - i - 1, state | current, seen) {\n                        seen.insert(state, true);\n                        return true;\n                    }\n                }\n            }\n            \n            seen.insert(state, false);\n            false\n        }\n        \n        can_win(max_choosable_integer, desired_total, 0, &mut seen)\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if the first player can force a win in a modified version of the \"100 game\" where players cannot reuse integers. Both players play optimally, which introduces a significant layer of complexity to the problem. Here's a structured methodology that explains the solution:\n\n# Explanation\n\n1. **Initial Check:** The simplest scenarios are checked first:\n   - If the `desiredTotal` is less than or equal to the `maxChoosableInteger`, the first player can achieve the total in one move and win.\n   - If the sum of integers from 1 to `maxChoosableInteger` is less than `desiredTotal`, it means it's impossible to reach the target, so the first player cannot win.\n\n2. **Memoization:** Use a dictionary to store results of subproblems to avoid re-computation. This optimization technique helps in efficiently solving the problem by storing previously solved states.\n\n3. **Recursive Function:** Define a helper function `canWin` which takes the remaining choices and the remaining total. The function checks the following:\n   - If the largest remaining choice exceeds or meets the required total, then the current player can win by choosing that number.\n   - Iterate through the remaining choices, recursively calling `canWin` to check if there exists any choice that forces the other player into a losing position.\n\n4. **Combination of Choices:** Use tuple representations of the choices as keys in the memoization dictionary to store already computed results.\n\n# Pseudocode\n\n```plaintext\nfunction canIWin(maxChoosableInteger, desiredTotal):\n    if desiredTotal <= maxChoosableInteger:\n        return True\n    if sum(1 to maxChoosableInteger) < desiredTotal:\n        return False\n    \n    memo = {}  # memoization dictionary\n\n    function canWin(choices, total):\n        if choices[-1] >= total:\n            return True  # if the largest choice exceeds or meets the target\n        key = tuple(choices)  # convert list of choices into tuple for memoization\n        if key in memo:\n            return memo[key]  # return memoized result if exists\n\n        for i in range(length of choices):\n            remaining_choices = choices[:i] + choices[i+1:]  # possible choices if current choice is used\n            if not canWin(remaining_choices, total - choices[i]):\n                memo[key] = True  # memoize result\n                return True\n\n        memo[key] = False  # memoize result\n        return False\n\n    # initial call to canWin with full set of choices and target total\n    return canWin(list(range(1, maxChoosableInteger + 1)), desiredTotal)\n```\n\nThis pseudocode captures the essence of the problem solution, demonstrating the initial checks, recursive function design, and memoization technique to solve the problem efficiently.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-can-i-win"
    },
    {
        "name": "Contains Duplicate",
        "site": "LeetCode",
        "href": "/solution/LeetCode-contains-duplicate",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> seen;\n        \n        for(int num : nums){\n            if(seen.count(num) > 0){\n                return true;\n            } else {\n                seen.insert(num);\n            }\n        }\n        \n        return false;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            if (set.contains(num)) {\n                return true;\n            }\n            set.add(num);\n        }\n        return false;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        num_set = set()\n        \n        for num in nums:\n            if num in num_set:\n                return True\n            num_set.add(num)\n        \n        return False"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool ContainsDuplicate(int[] nums) {\n        HashSet<int> set = new HashSet<int>();\n        foreach (int num in nums) {\n            if (set.Contains(num)) {\n                return true;\n            }\n            set.Add(num);\n        }\n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst containsDuplicate = (nums) => {\n    let seen = new Set();\n    for (let num of nums) {\n        if (seen.has(num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function containsDuplicate(nums: number[]): boolean {\n    const set = new Set<number>();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @return Boolean\n     */\n    function containsDuplicate($nums) {\n        $uniqueNums = array_unique($nums);\n        if (count($nums) == count($uniqueNums)) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func containsDuplicate(_ nums: [Int]) -> Bool {\n        var set = Set<Int>()\n        \n        for num in nums {\n            if set.contains(num) {\n                return true\n            }\n            set.insert(num)\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun containsDuplicate(nums: IntArray): Boolean {\n        val set = HashSet<Int>()\n        for (num in nums) {\n            if (set.contains(num)) {\n                return true\n            } else {\n                set.add(num)\n            }\n        }\n        return false\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool containsDuplicate(List<int> nums) {\n    Set<int> set = Set<int>();\n    for (int num in nums) {\n      if (set.contains(num)) {\n        return true;\n      } else {\n        set.add(num);\n      }\n    }\n    return false;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func containsDuplicate(nums []int) bool {\n    numMap := make(map[int]bool)\n    \n    for _, num := range nums {\n        if numMap[num] {\n            return true\n        }\n        numMap[num] = true\n    }\n    \n    return false\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Boolean}\ndef contains_duplicate(nums)\n    nums.uniq.length != nums.length\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def containsDuplicate(nums: Array[Int]): Boolean = {\n        nums.length != nums.toSet.size\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        use std::collections::HashSet;\n        \n        let mut set = HashSet::new();\n        \n        for num in nums {\n            if !set.insert(num) {\n                return true;\n            }\n        }\n        \n        false\n    }\n}\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (contains-duplicate nums)\n  (-> (listof exact-integer?) boolean?)\n  \n  (not (=\n        (length nums)\n        (length (remove-duplicates nums))\n       )\n  )\n)"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec contains_duplicate(Nums :: [integer()]) -> \n    boolean().\ncontains_duplicate(Nums) ->\n    length(lists:usort(Nums)) /= length(Nums).\n"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec contains_duplicate(nums :: [integer]) :: boolean\n  def contains_duplicate(nums) do\n    Enum.count(nums) != Enum.uniq(nums) |> length()\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need a method to determine if any value appears at least twice in an input array of integers. We will employ a set to help track the unique values encountered as we iterate through the array. If we come across a value that's already in the set, it means the value is duplicated, and we return `True`. If no duplicates are found by the end of the iteration, we return `False`.\n\n# Explanation\n1. **Initialize a set**: This set will store unique values seen so far as we iterate through the array.\n2. **Loop through the array**: For each integer in the array:\n   - Check if it exists in the set:\n     - If it does, return `True` immediately.\n     - If it doesn't, add it to the set.\n3. **Return `False`**: If we finish the loop without finding a duplicate, return `False`.\n\n# Pseudocode\n```python\n# Pseudocode\n\nfunction containsDuplicate(nums):\n    # Initialize an empty set to keep track of values seen\n    num_set = set()\n    \n    # Iterate through each number in the nums array\n    for each num in nums:\n        # Check if the number is already in the set\n        if num is in num_set:\n            # If yes, return True since we found a duplicate\n            return True\n        # If no, add the number to the set\n        num_set.add(num)\n    \n    # If no duplicates were found, return False\n    return False\n```\n\nThis approach ensures that we efficiently check for duplicates with a time complexity of O(n) and a space complexity of O(n), where n is the length of the input array.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-contains-duplicate"
    },
    {
        "name": "Contains Duplicate Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-contains-duplicate-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> numIndexMap;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (numIndexMap.find(nums[i]) != numIndexMap.end() && i - numIndexMap[nums[i]] <= k) {\n                return true;\n            } else {\n                numIndexMap[nums[i]] = i;\n            }\n        }\n        \n        return false;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (set.contains(nums[i])) {\n                return true;\n            }\n            set.add(nums[i]);\n            if (set.size() > k) {\n                set.remove(nums[i - k]);\n            }\n        }\n        return false;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        num_dict = {}\n        for i, num in enumerate(nums):\n            if num in num_dict and abs(i - num_dict[num]) <= k:\n                return True\n            num_dict[num] = i\n        return False"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "bool containsNearbyDuplicate(int* nums, int numsSize, int k) {\n    for(int i = 0; i < numsSize; i++) {\n        for(int j = i+1; j < numsSize; j++) {\n            if(nums[i] == nums[j] && abs(i - j) <= k) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool ContainsNearbyDuplicate(int[] nums, int k) {\n        HashSet<int> set = new HashSet<int>();\n        \n        for (int i = 0; i < nums.Length; i++) {\n            if (set.Contains(nums[i])) {\n                return true;\n            }\n            \n            set.Add(nums[i]);\n            \n            if (set.Count > k) {\n                set.Remove(nums[i - k]);\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\n\nconst containsNearbyDuplicate = (nums, k) => {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i]) && (i - map.get(nums[i]) <= k)) {\n            return true;\n        }\n        map.set(nums[i], i);\n    }\n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function containsNearbyDuplicate(nums: number[], k: number): boolean {\n    const map = new Map();\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i]) && i - map.get(nums[i]) <= k) {\n            return true;\n        }\n        map.set(nums[i], i);\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Boolean\n     */\n    function containsNearbyDuplicate($nums, $k) {\n        $map = array();\n        \n        for ($i = 0; $i < count($nums); $i++) {\n            if (array_key_exists($nums[$i], $map) && $i - $map[$nums[$i]] <= $k) {\n                return true;\n            }\n            $map[$nums[$i]] = $i;\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func containsNearbyDuplicate(_ nums: [Int], _ k: Int) -> Bool {\n        var numIndexMap = [Int: Int]()\n        \n        for i in 0..<nums.count {\n            if let index = numIndexMap[nums[i]] {\n                if i - index <= k {\n                    return true\n                }\n            }\n            numIndexMap[nums[i]] = i\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun containsNearbyDuplicate(nums: IntArray, k: Int): Boolean {\n        val map = HashMap<Int, Int>()\n        \n        for (i in nums.indices) {\n            if (map.containsKey(nums[i]) && i - map[nums[i]]!! <= k) {\n                return true\n            } else {\n                map[nums[i]] = i\n            }\n        }\n        \n        return false\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool containsNearbyDuplicate(List<int> nums, int k) {\n    Map<int, int> map = {};\n    \n    for (int i = 0; i < nums.length; i++) {\n      if (map.containsKey(nums[i]) && i - (map[nums[i]] ?? i) <= k) {\n        return true;\n      }\n      map[nums[i]] = i;\n    }\n    \n    return false;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func containsNearbyDuplicate(nums []int, k int) bool {\n    seen := make(map[int]int)\n    \n    for i, num := range nums {\n        if j, ok := seen[num]; ok && i - j <= k {\n            return true\n        }\n        \n        seen[num] = i\n    }\n    \n    return false\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Boolean}\ndef contains_nearby_duplicate(nums, k)\n    seen = {}\n    \n    nums.each_with_index do |num, idx|\n        if seen.key?(num) && idx - seen[num] <= k\n            return true\n        end\n        seen[num] = idx\n    end\n    \n    return false\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\n        use std::collections::HashMap;\n        \n        let mut num_map = HashMap::new();\n        \n        for (index, &num) in nums.iter().enumerate() {\n            if let Some(&prev_index) = num_map.get(&num) {\n                if (index as i32 - prev_index) <= k {\n                    return true;\n                }\n            }\n            \n            num_map.insert(num, index as i32);\n        }\n        \n        false\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to check whether there are two distinct indices \\( i \\) and \\( j \\) in the array such that the elements at these indices are equal and the absolute difference between the indices is less than or equal to \\( k \\).\n\n# Explanation\n1. We will use a dictionary to keep track of the last seen index of each number in the array.\n2. As we iterate through the list, for each number, we will:\n   - Check if the number is already in the dictionary.\n   - If it is, check if the absolute difference between the current index and the last seen index is less than or equal to \\( k \\).\n   - If both conditions are met, return `True`.\n   - If it's not in the dictionary or the conditions are not met, update the dictionary with the current index of the number.\n3. If we complete the iteration without finding such a pair, return `False`.\n\n# Pseudocode\n```\nfunction containsNearbyDuplicate(nums, k):\n    initialize num_dict as an empty dictionary\n    \n    for each index i and value num in nums:\n        if num is in num_dict:\n            if abs(i - num_dict[num]) <= k:\n                return True\n        num_dict[num] = i\n    \n    return False\n```\n\nThe pseudocode describes a function `containsNearbyDuplicate` that takes an array `nums` and an integer `k`, and then iterates through the array while maintaining a dictionary (`num_dict`) to keep track of the indices of the last occurrences of the numbers. If it finds two indices with the same number and their difference is less than or equal to \\( k \\), it returns `True`. If no such indices are found by the end of the array, it returns `False`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-contains-duplicate-ii"
    },
    {
        "name": "The Skyline Problem",
        "site": "LeetCode",
        "href": "/solution/LeetCode-the-skyline-problem",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        vector<vector<int>> result;\n        \n        multiset<pair<int, int>> criticalPoints;\n        for (auto& b : buildings) {\n            criticalPoints.emplace(b[0], -b[2]);\n            criticalPoints.emplace(b[1], b[2]);\n        }\n        \n        multiset<int> heights = {0};\n        vector<int> prev = {0, 0};\n        for (auto& cp : criticalPoints) {\n            int x = cp.first;\n            int h = abs(cp.second);\n            \n            if (cp.second < 0) {\n                heights.insert(h);\n            } else {\n                heights.erase(heights.find(h));\n            }\n            \n            int maxHeight = *heights.rbegin();\n            if (prev[1] != maxHeight) {\n                result.push_back({x, maxHeight});\n                prev[0] = x;\n                prev[1] = maxHeight;\n            }\n        }\n        \n        return result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<int[]> buildingPoints = new ArrayList<>();\n        \n        for (int[] building : buildings) {\n            buildingPoints.add(new int[]{building[0], -building[2]});\n            buildingPoints.add(new int[]{building[1], building[2]});\n        }\n        \n        Collections.sort(buildingPoints, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else {\n                return a[1] - b[1];\n            }\n        });\n        \n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\n        maxHeap.offer(0);\n        int prevMaxHeight = 0;\n        \n        for (int[] buildingPoint : buildingPoints) {\n            if (buildingPoint[1] < 0) {\n                maxHeap.offer(-buildingPoint[1]);\n            } else {\n                maxHeap.remove(buildingPoint[1]);\n            }\n            \n            int currentMaxHeight = maxHeap.peek();\n            \n            if (prevMaxHeight != currentMaxHeight) {\n                result.add(Arrays.asList(buildingPoint[0], currentMaxHeight));\n                prevMaxHeight = currentMaxHeight;\n            }\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        \n        \"\"\"\n        import heapq\n        res = []\n        points = []\n        for building in buildings:\n            points.append((building[0], -building[2]))\n            points.append((building[1], building[2]))\n        \n        points.sort()\n        pq = [0]\n        prev_max = 0\n        \n        for point in points:\n            if point[1] < 0:\n                heapq.heappush(pq, point[1])\n            else:\n                pq.remove(-point[1])\n                heapq.heapify(pq)\n            \n            curr_max = -pq[0]\n            if curr_max != prev_max:\n                res.append([point[0], curr_max])\n                prev_max = curr_max\n        \n        return res\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the contour of the skyline formed by a set of buildings. We can utilize a sweep line algorithm combined with a priority queue (max-heap) to efficiently manage the active building heights as we process each critical point.\n\n# Explanation\n\n1. **Event Points**: First, we collect all the critical points where the building's height changes, i.e., the left and right edges of the buildings. We annotate the left edge with the negative height to indicate the start of a building and the right edge with the actual height to indicate the end.\n\n2. **Sort Event Points**: Then, sort these points. The sorting is primarily by the x-coordinate. If two points have the same x-coordinate, sort by the negative and positive heights where the left edges come before the right edges.\n\n3. **Priority Queue**: Use a priority queue (max-heap) to keep track of the currently active buildings. Initialize this priority queue with height 0 to handle the ground level.\n\n4. **Process Points**: Traverse through sorted points:\n   - If the point is a left edge, add its height to the priority queue.\n   - If it is a right edge, remove its corresponding height from the priority queue.\n   - Track the maximum height in the current priority queue. If it changes, it means the skyline has a new key point.\n\n5. **Formation of Result**: Append the new key point (x-coordinate and current max height) to the result list whenever the maximum height changes.\n\n# Pseudocode\n\n```pseudocode\nfunction getSkyline(buildings):\n    # Initialize result list and points list\n    result = []\n    points = []\n\n    # Collect all critical points\n    for each building in buildings:\n        left, right, height = building\n        points.append((left, -height))  # Start edge with negative height\n        points.append((right, height))  # End edge with positive height\n\n    # Sort points\n    sort points by (x-coordinate, height)\n\n    # Initialize max-heap and previous max height\n    max_heap = [0]\n    prev_max = 0\n\n    # Process each point in sorted points\n    for each point in points:\n        x, h = point\n\n        if h < 0:  # Left edge\n            insert -h into max-heap\n        else:  # Right edge\n            remove h from max-heap\n\n        # Get current max height from max-heap\n        curr_max = -max_heap[0]\n\n        # If max height has changed, update result\n        if curr_max != prev_max:\n            result.append([x, curr_max])\n            prev_max = curr_max\n\n    return result\n```\n\nThis pseudocode outlines how to handle and process the event points, maintain the active building heights using a max-heap, and construct the skyline by identifying key points where the height changes.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-the-skyline-problem"
    },
    {
        "name": "Trapping Rain Water Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-trapping-rain-water-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int trapRainWater(vector<vector<int>>& heightMap) {\n        if (heightMap.empty()) return 0;\n        \n        const int m = heightMap.size();\n        const int n = heightMap[0].size();\n        \n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> minHeap;\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        \n        for (int i = 0; i < m; ++i) {\n            minHeap.emplace(heightMap[i][0], i, 0);\n            minHeap.emplace(heightMap[i][n - 1], i, n - 1);\n            visited[i][0] = visited[i][n - 1] = true;\n        }\n        \n        for (int j = 1; j < n - 1; ++j) {\n            minHeap.emplace(heightMap[0][j], 0, j);\n            minHeap.emplace(heightMap[m - 1][j], m - 1, j);\n            visited[0][j] = visited[m - 1][j] = true;\n        }\n        \n        int water = 0;\n        vector<int> dirs = {-1, 0, 1, 0, -1};\n        \n        while (!minHeap.empty()) {\n            auto [h, r, c] = minHeap.top();\n            minHeap.pop();\n            \n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dirs[k];\n                int nc = c + dirs[k + 1];\n                \n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]) {\n                    water += max(0, h - heightMap[nr][nc]);\n                    minHeap.emplace(max(h, heightMap[nr][nc]), nr, nc);\n                    visited[nr][nc] = true;\n                }\n            }\n        }\n        \n        return water;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.PriorityQueue;\n\nclass Solution {\n    public int trapRainWater(int[][] heightMap) {\n        if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0) {\n            return 0;\n        }\n\n        int m = heightMap.length;\n        int n = heightMap[0].length;\n        boolean[][] visited = new boolean[m][n];\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n\n        for (int i = 0; i < m; i++) {\n            pq.offer(new int[]{i, 0, heightMap[i][0]});\n            pq.offer(new int[]{i, n - 1, heightMap[i][n - 1]});\n            visited[i][0] = true;\n            visited[i][n - 1] = true;\n        }\n\n        for (int j = 0; j < n; j++) {\n            pq.offer(new int[]{0, j, heightMap[0][j]});\n            pq.offer(new int[]{m - 1, j, heightMap[m - 1][j]});\n            visited[0][j] = true;\n            visited[m - 1][j] = true;\n        }\n\n        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int waterTrapped = 0;\n        while (!pq.isEmpty()) {\n            int[] cell = pq.poll();\n            int row = cell[0];\n            int col = cell[1];\n            int height = cell[2];\n\n            for (int[] dir : dirs) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\n                    visited[newRow][newCol] = true;\n                    waterTrapped += Math.max(0, height - heightMap[newRow][newCol]);\n                    pq.offer(new int[]{newRow, newCol, Math.max(height, heightMap[newRow][newCol])});\n                }\n            }\n        }\n\n        return waterTrapped;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        import heapq\n        m, n = len(heightMap), len(heightMap[0])\n        visited = set()\n        heap = []\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in directions:\n                ni, nj = i + x, j + y\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    nh = max(h, heightMap[ni][nj])\n                    res += max(0, nh - heightMap[ni][nj])\n                    heapq.heappush(heap, (nh, ni, nj))\n                    visited.add((ni, nj))\n        \n        return res\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class MinHeap<T> {\n    heap: T[];\n    compare: (a: T, b: T) => number;\n\n    constructor(compare: (a: T, b: T) => number) {\n        this.heap = [];\n        this.compare = compare;\n    }\n\n    push(value: T) {\n        this.heap.push(value);\n        this.siftUp(this.heap.length - 1);\n    }\n\n    pop() {\n        const rootValue = this.heap[0];\n        const lastValue = this.heap.pop();\n        if (this.heap.length > 0 && lastValue !== undefined) {\n            this.heap[0] = lastValue;\n            this.siftDown(0);\n        }\n        return rootValue;\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n\n    siftUp(index: number) {\n        let parentIndex = Math.floor((index - 1) / 2);\n        while (index > 0 && this.compare(this.heap[index], this.heap[parentIndex]) < 0) {\n            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n            index = parentIndex;\n            parentIndex = Math.floor((index - 1) / 2);\n        }\n    }\n\n    siftDown(index: number) {\n        let leftChildIndex = 2 * index + 1;\n        let rightChildIndex = 2 * index + 2;\n        let smallestIndex = index;\n\n        if (leftChildIndex < this.heap.length && this.compare(this.heap[leftChildIndex], this.heap[smallestIndex]) < 0) {\n            smallestIndex = leftChildIndex;\n        }\n        if (rightChildIndex < this.heap.length && this.compare(this.heap[rightChildIndex], this.heap[smallestIndex]) < 0) {\n            smallestIndex = rightChildIndex;\n        }\n\n        if (smallestIndex !== index) {\n            [this.heap[index], this.heap[smallestIndex]] = [this.heap[smallestIndex], this.heap[index]];\n            this.siftDown(smallestIndex);\n        }\n    }\n}\n\nfunction trapRainWater(heightMap: number[][]): number {\n    if (heightMap.length === 0) return 0;\n\n    const m = heightMap.length;\n    const n = heightMap[0].length;\n    let volume = 0;\n\n    const heap = new MinHeap<number[]>((a, b) => heightMap[a[0]][a[1]] - heightMap[b[0]][b[1]]);\n    const visited = Array.from({ length: m }, () => Array(n).fill(false));\n\n    for (let i = 0; i < m; i++) {\n        heap.push([i, 0]);\n        heap.push([i, n - 1]);\n        visited[i][0] = true;\n        visited[i][n - 1] = true;\n    }\n    for (let j = 1; j < n - 1; j++) {\n        heap.push([0, j]);\n        heap.push([m - 1, j]);\n        visited[0][j] = true;\n        visited[m - 1][j] = true;\n    }\n\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    while (!heap.isEmpty()) {\n        const [i, j] = heap.pop();\n        for (const [dx, dy] of directions) {\n            const x = i + dx;\n            const y = j + dy;\n            if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\n                volume += Math.max(0, heightMap[i][j] - heightMap[x][y]);\n                heap.push([x, y]);\n                visited[x][y] = true;\n                heightMap[x][y] = Math.max(heightMap[x][y], heightMap[i][j]);\n            }\n        }\n    }\n\n    return volume;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func trapRainWater(_ heightMap: [[Int]]) -> Int {\n        // Check for edge cases\n        if heightMap.isEmpty || heightMap[0].isEmpty {\n            return 0\n        }\n        \n        let m = heightMap.count\n        let n = heightMap[0].count\n        var visited = Array(repeating: Array(repeating: false, count: n), count: m)\n        var minHeap: [(h: Int, r: Int, c: Int)] = []\n        var result = 0\n        \n        // Add all boundary cells to the minHeap\n        for i in 0..<m {\n            visited[i][0] = true\n            visited[i][n - 1] = true\n            minHeap.append((h: heightMap[i][0], r: i, c: 0))\n            minHeap.append((h: heightMap[i][n - 1], r: i, c: n - 1))\n        }\n        \n        for j in 1..<(n - 1) {\n            visited[0][j] = true\n            visited[m - 1][j] = true\n            minHeap.append((h: heightMap[0][j], r: 0, c: j))\n            minHeap.append((h: heightMap[m - 1][j], r: m - 1, c: j))\n        }\n        \n        minHeap.sort { $0.h < $1.h }\n        \n        // Define directions for visiting neighbors\n        let directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        while !minHeap.isEmpty {\n            let curr = minHeap.removeFirst()\n            for dir in directions {\n                let newRow = curr.r + dir.0\n                let newCol = curr.c + dir.1\n                \n                if newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !visited[newRow][newCol] {\n                    visited[newRow][newCol] = true\n                    result += max(0, curr.h - heightMap[newRow][newCol])\n                    minHeap.append((h: max(curr.h, heightMap[newRow][newCol]), r: newRow, c: newCol))\n                    minHeap.sort { $0.h < $1.h }\n                }\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun trapRainWater(heightMap: Array<IntArray>): Int {\n        if (heightMap.isEmpty() || heightMap[0].isEmpty()) {\n            return 0\n        }\n        \n        val m = heightMap.size\n        val n = heightMap[0].size\n        \n        val visited = Array(m) { BooleanArray(n) }\n        val pq = PriorityQueue<Cell> { a, b -> a.h - b.h }\n        \n        for (i in 0 until m) {\n            visited[i][0] = true\n            visited[i][n - 1] = true\n            pq.offer(Cell(i, 0, heightMap[i][0]))\n            pq.offer(Cell(i, n - 1, heightMap[i][n - 1]))\n        }\n        \n        for (j in 1 until n - 1) {\n            visited[0][j] = true\n            visited[m - 1][j] = true\n            pq.offer(Cell(0, j, heightMap[0][j]))\n            pq.offer(Cell(m - 1, j, heightMap[m - 1][j]))\n        }\n        \n        val dirs = arrayOf(0, 1, 0, -1, 0)\n        var trapped = 0\n        var maxHeight = Int.MIN_VALUE\n        \n        while (pq.isNotEmpty()) {\n            val cell = pq.poll()\n            maxHeight = maxOf(maxHeight, cell.h)\n            for (d in 0 until 4) {\n                val ni = cell.i + dirs[d]\n                val nj = cell.j + dirs[d + 1]\n                if (ni in 0 until m && nj in 0 until n && !visited[ni][nj]) {\n                    visited[ni][nj] = true\n                    trapped += maxOf(0, maxHeight - heightMap[ni][nj])\n                    pq.offer(Cell(ni, nj, heightMap[ni][nj]))\n                }\n            }\n        }\n        \n        return trapped\n    }\n\n    data class Cell(val i: Int, val j: Int, val h: Int)\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine how much water can be trapped within a given 2D elevation map after rainfall. The solution involves using a priority queue (min-heap) to efficiently calculate the minimum height boundary and iteratively adjust it as we explore the grid.\n\n### # Explanation\n1. **Initialization:**\n   - We start by checking if the `heightMap` is empty. If it is, we return 0.\n   - We initialize a priority queue (min-heap) and mark all boundary cells as visited, adding them to the heap.\n\n2. **Processing the Grid:**\n  - The main idea is to always process the smallest boundary cell in the heap. This ensures we always have the correct water boundary.\n  - For the current cell popped from the heap, we look at its neighbors. If a neighbor hasn't been visited, we calculate the trapped water (if any) by checking the difference between the current cell's height and the neighbor\u2019s height.\n  - The effective new height of the neighbor cell is the maximum of its own height and the current cell\u2019s height (to account for trapping water).\n\n3. **Heuristic Movement:**\n  - A 4-directional approach (up, down, left, right) is used to explore the neighboring cells.\n  - Each neighbor is then added to the heap with its effective height if it has not been visited.\n\n4. **Completion:**\n  - This process continues until all reachable cells have been processed, accumulating the total trapped water.\n\n### # Pseudocode\n\n```\n# Pseudocode\n\nfunction trapRainWater(heightMap):\n    if heightMap is empty:\n        return 0\n\n    # Import required library\n    import heapq\n\n    # Get the dimensions of the grid\n    m = number of rows in heightMap\n    n = number of columns in heightMap\n\n    # Initialize variables\n    visited = set()\n    heap = []\n    res = 0\n\n    # Push all boundary cells into the heap and mark as visited\n    for i from 0 to m - 1:\n        for j from 0 to n - 1:\n            if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                push (heightMap[i][j], i, j) onto heap\n                add (i, j) to visited\n\n    # Define the 4 directions for moving in the grid\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Process cells until heap is empty\n    while heap is not empty:\n        (h, i, j) = pop heap\n\n        for each (x, y) in directions:\n            ni = i + x\n            nj = j + y\n\n            # Check if the neighboring cell is within bounds and not visited\n            if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                nh = maximum of h and heightMap[ni][nj]\n                res += maximum of 0 and (nh - heightMap[ni][nj])\n                push (nh, ni, nj) onto heap\n                add (ni, nj) to visited\n\n    return res\n```\n\nThis pseudocode provides a clear pathway for solving the described problem by leveraging a heap to manage and process the boundaries systematically while maintaining an up-to-date height boundary to calculate the volume of trapped water.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-trapping-rain-water-ii"
    },
    {
        "name": "Strong Password Checker",
        "site": "LeetCode",
        "href": "/solution/LeetCode-strong-password-checker",
        "languages": [
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int StrongPasswordChecker(string password) {\n        int n = password.Length;\n        int res = 0;\n        int lower = 1, upper = 1, digit = 1;\n        int[] dp = new int[n];\n        \n        for (int i = 0; i < n;) {\n            if (char.IsLower(password[i])) lower = 0;\n            if (char.IsUpper(password[i])) upper = 0;\n            if (char.IsDigit(password[i])) digit = 0;\n            \n            int j = i;\n            while (i < n && password[i] == password[j]) i++;\n            dp[j] = i - j;\n        }\n        \n        int toAdd = (lower + upper + digit);\n        if (n < 6) {\n            res = toAdd + Math.Max(0, 6 - (n + toAdd));\n        } else {\n            int overLen = Math.Max(n - 20, 0), left = 0;\n            res = overLen;\n            \n            for (int k = 1; k < 3; k++) {\n                for (int i = 0; i < n && overLen > 0; i++) {\n                    if (dp[i] < 3 || dp[i] % 3 != k - 1) continue;\n                    dp[i] -= Math.Min(overLen, k);\n                    overLen -= k;\n                }\n            }\n            \n            for (int i = 0; i < n; i++) {\n                if (dp[i] >= 3 && overLen > 0) {\n                    int need = dp[i] - 2;\n                    dp[i] -= overLen;\n                    overLen -= need;    \n                }\n                if (dp[i] >= 3) {\n                    left += dp[i] / 3;\n                }\n            }\n            \n            res += Math.Max(toAdd, left);\n        }\n        \n        return res;\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func strongPasswordChecker(password string) int {\n    n := len(password)\n    lo, up, digit := 1, 1, 1\n    missing := 3\n\n    for _, char := range password {\n        if lo > 0 && unicode.IsLower(char) {\n            lo = 0\n            missing--\n        }\n        if up > 0 && unicode.IsUpper(char) {\n            up = 0\n            missing--\n        }\n        if digit > 0 && unicode.IsDigit(char) {\n            digit = 0\n            missing--\n        }\n    }\n\n    if n < 6 {\n        return max(6-n, missing)\n    }\n    \n    replacements := 0\n    one := 0\n    two := 0\n    three := 0\n\n    count := 0\n    for count < n {\n        start := count\n        char := password[count]\n        for count < n && password[count] == char {\n            count++\n        }\n        len := count - start\n\n        if len >= 3 {\n            replacements += len / 3\n            if len%3 == 0 {\n                one++\n            } else if len%3 == 1 {\n                two++\n            } else {\n                three++\n            }\n        }\n    }\n\n    if n <= 20 {\n        return max(missing, replacements)\n    }\n\n    deleteCount := n - 20\n    replacements -= min(deleteCount, one)\n    replacements -= min(max(deleteCount-one, 0), two*2) / 2\n    replacements -= max(deleteCount-one-2*two, 0) / 3\n\n    return deleteCount + max(missing, replacements)\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine if a given password meets certain strength criteria and, if not, figure out the minimum number of steps required to make it strong. The steps include inserting, deleting, or replacing a character in the password.\n\nHere\u2019s a structured approach to solve the problem using pseudocode:\n\n# Explanation:\n1. **Check Length**: Determine if the password length is less than 6 or greater than 20.\n2. **Check Character Types**: Check for at least one lowercase letter, one uppercase letter, and one digit.\n3. **Check for Repeating Characters**: Identify sequences of three or more repeating characters.\n4. **Calculate Necessary Steps**: Depending on the findings from the previous checks, calculate the number of steps to make the password strong.\n\n# Pseudocode:\n```\nfunction StrongPasswordChecker(password):\n    n = length(password)\n    res = 0\n    lower = True\n    upper = True\n    digit = True\n    repeating_counts = []\n    \n    # Step 1: Check character types and record repeating characters\n    i = 0\n    while i < n:\n        if is_lowercase(password[i]):\n            lower = False\n        if is_uppercase(password[i]):\n            upper = False\n        if is_digit(password[i]):\n            digit = False\n        \n        j = i\n        while i < n and password[i] == password[j]:\n            i += 1\n        repeating_counts.append(i - j)\n    \n    to_add = (lower + upper + digit)\n    \n    # Step 2: Calculate steps based on password length\n    if n < 6:\n        res = to_add + max(0, 6 - (n + to_add))\n    else:\n        over_len = max(n - 20, 0)\n        res = over_len\n        left = 0\n        \n        for k in [1, 2]:\n            for i in range(len(repeating_counts)):\n                if repeating_counts[i] < 3 or repeating_counts[i] % 3 != k - 1:\n                    continue\n                change_needed = min(over_len, k)\n                repeating_counts[i] -= change_needed\n                over_len -= change_needed\n        \n        for i in range(len(repeating_counts)):\n            if repeating_counts[i] >= 3 and over_len > 0:\n                change_needed = repeating_counts[i] - 2\n                repeating_counts[i] -= over_len\n                over_len -= change_needed\n            \n            if repeating_counts[i] >= 3:\n                left += repeating_counts[i] // 3\n        \n        res += max(to_add, left)\n    \n    return res\n```\n\nThis pseudocode first determines the type of each character and identifies any sequences of repeating characters. Based on the length of the password and the types of characters present, it then calculates the necessary steps to make the password strong. If the password length is less than 6 or more than 20, appropriate adjustments (insertions or deletions) are made. Finally, changes needed to eliminate consecutive repeating characters are calculated.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-strong-password-checker"
    },
    {
        "name": "Split Array Largest Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-split-array-largest-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int splitArray(vector<int>& nums, int k) {\n        int left = *max_element(nums.begin(), nums.end());\n        int right = accumulate(nums.begin(), nums.end(), 0);\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            int count = 1;\n            int sum = 0;\n            \n            for (int num : nums) {\n                sum += num;\n                if (sum > mid) {\n                    sum = num;\n                    count++;\n                }\n            }\n            \n            if (count > k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return left;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int splitArray(int[] nums, int k) {\n        int start = 0;\n        int end = 0;\n        for (int num : nums) {\n            start = Math.max(start, num);\n            end += num;\n        }\n        \n        while (start < end) {\n            int mid = start + (end - start) / 2;\n            int sum = 0;\n            int parts = 1;\n            for (int num : nums) {\n                if (sum + num > mid) {\n                    parts++;\n                    sum = num;\n                } else {\n                    sum += num;\n                }\n            }\n            if (parts > k) {\n                start = mid + 1;\n            } else {\n                end = mid;\n            }\n        }\n        \n        return start;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def splitArray(self, nums, k):\n        def is_valid(mid):\n            count = 1\n            total = 0\n            for num in nums:\n                total += num\n                if total > mid:\n                    total = num\n                    count += 1\n            return count <= k\n            \n        left = max(nums)\n        right = sum(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int splitArray(int* nums, int numsSize, int k) {\n    int left = 0, right = 0;\n    for (int i = 0; i < numsSize; i++) {\n        left = fmax(left, nums[i]);\n        right += nums[i];\n    }\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int sum = 0, count = 1;\n        for (int i = 0; i < numsSize; i++) {\n            if (sum + nums[i] > mid) {\n                count++;\n                sum = nums[i];\n            } else {\n                sum += nums[i];\n            }\n        }\n        if (count > k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int SplitArray(int[] nums, int k) {\n        int left = 0, right = 0;\n        foreach (int num in nums) {\n            left = Math.Max(left, num);\n            right += num;\n        }\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            int sum = 0;\n            int count = 1;\n            foreach (int num in nums) {\n                if (sum + num > mid) {\n                    count++;\n                    sum = num;\n                } else {\n                    sum += num;\n                }\n            }\n            if (count <= k) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar splitArray = function(nums, k) {\n    let left = Math.max(...nums);\n    let right = nums.reduce((acc, curr) => acc + curr, 0);\n    \n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 0;\n        let sum = 0;\n        \n        for (let num of nums) {\n            sum += num;\n            if (sum > mid) {\n                count++;\n                sum = num;\n            }\n        }\n        \n        count++;\n        \n        if (count > k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function splitArray(nums: number[], k: number): number {\n    let left = Math.max(...nums);\n    let right = nums.reduce((acc, curr) => acc + curr, 0);\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        let sum = 0;\n        let count = 1;\n        \n        for (let num of nums) {\n            sum += num;\n            if (sum > mid) {\n                sum = num;\n                count++;\n            }\n        }\n        \n        if (count > k) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function splitArray($nums, $k) {\n        $left = max($nums);\n        $right = array_sum($nums);\n        \n        while ($left < $right) {\n            $mid = $left + intval(($right - $left) / 2);\n            if ($this->validSplit($nums, $mid, $k)) {\n                $right = $mid;\n            } else {\n                $left = $mid + 1;\n            }\n        }\n        return $left;\n    }\n    \n    function validSplit($nums, $max, $k) {\n        $count = 1;\n        $sum = 0;\n        foreach ($nums as $num) {\n            $sum += $num;\n            if ($sum > $max) {\n                $count++;\n                $sum = $num;\n                if ($count > $k) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func splitArray(_ nums: [Int], _ k: Int) -> Int {\n        var left = nums.max() ?? 0\n        var right = nums.reduce(0, +)\n        \n        while left < right {\n            let mid = left + (right - left) / 2\n            if isPossible(nums, k, mid) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        \n        return left\n    }\n    \n    func isPossible(_ nums: [Int], _ k: Int, _ target: Int) -> Bool {\n        var count = 1\n        var sum = 0\n        \n        for num in nums {\n            sum += num\n            if sum > target {\n                count += 1\n                sum = num\n            }\n        }\n        \n        return count <= k\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun splitArray(nums: IntArray, k: Int): Int {\n        var left = nums.maxOrNull() ?: 0\n        var right = nums.sum()\n        while (left < right) {\n            val mid = left + (right - left) / 2\n            if (isValid(nums, k, mid)) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        return left\n    }\n\n    fun isValid(nums: IntArray, k: Int, target: Int): Boolean {\n        var count = 1\n        var sum = 0\n        for (num in nums) {\n            sum += num\n            if (sum > target) {\n                count++\n                sum = num\n            }\n        }\n        return count <= k\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int splitArray(List<int> nums, int k) {\n    int left = 0;\n    int right = 0;\n    \n    for (int num in nums) {\n      left = left > num ? left : num;\n      right += num;\n    }\n    \n    while (left < right) {\n      int mid = left + (right - left) ~/ 2;\n      int count = 1;\n      int sum = 0;\n      \n      for (int num in nums) {\n        if (sum + num > mid) {\n          count++;\n          sum = num;\n        } else {\n          sum += num;\n        }\n      }\n      \n      if (count > k) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    \n    return left;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func splitArray(nums []int, k int) int {\n    left := 0\n    right := 0\n    \n    for _, num := range nums {\n        right += num\n        if num > left {\n            left = num\n        }\n    }\n    \n    for left < right {\n        mid := left + (right - left) / 2\n        if isValid(nums, k, mid) {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    \n    return left\n}\n\nfunc isValid(nums []int, k, target int) bool {\n    count := 1\n    sum := 0\n    \n    for i := 0; i < len(nums); i++ {\n        sum += nums[i]\n        if sum > target {\n            count++\n            sum = nums[i]\n        }\n    }\n    \n    return count <= k\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef split_array(nums, k)\n    def valid?(nums, mid, k)\n        count = 1\n        total = 0\n        nums.each do |num|\n            total += num\n            if total > mid\n                total = num\n                count += 1\n                return false if count > k\n            end\n        end\n        true\n    end\n    \n    left = nums.max\n    right = nums.sum\n    while left < right\n        mid = left + (right - left) / 2\n        if valid?(nums, mid, k)\n            right = mid\n        else\n            left = mid + 1\n        end\n    end\n    left\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def splitArray(nums: Array[Int], k: Int): Int = {\n        def isValid(mid: Long, nums: Array[Int], k: Int): Boolean = {\n            var count = 1\n            var sum = 0\n            for (num <- nums) {\n                sum += num\n                if (sum > mid) {\n                    count += 1\n                    sum = num\n                }\n            }\n            count <= k\n        }\n\n        var left = nums.max.toLong\n        var right = nums.sum.toLong\n        while (left < right) {\n            val mid = left + (right - left) / 2\n            if (isValid(mid, nums, k)) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        left.toInt\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn split_array(nums: Vec<i32>, k: i32) -> i32 {\n        let mut left = 0;\n        let mut right = 0;\n        let mut result = 0;\n        \n        for num in &nums {\n            left = left.max(*num);\n            right += num;\n        }\n        \n        while left <= right {\n            let mid = left + (right - left) / 2;\n            if Self::valid_split(&nums, k, mid) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        result\n    }\n    \n    fn valid_split(nums: &Vec<i32>, k: i32, target: i32) -> bool {\n        let mut sum = 0;\n        let mut count = 1;\n        \n        for &num in nums {\n            sum += num;\n            if sum > target {\n                sum = num;\n                count += 1;\n                if count > k {\n                    return false;\n                }\n            }\n        }\n        \n        true\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge of splitting an array into k subarrays such that the largest sum among the subarrays is minimized, you can employ a binary search approach with a helper function that checks if a given maximum subarray sum can be achieved with k splits.\n\n# Explanation:\n1. **Initial Range**: The smallest possible value for the largest subarray sum is the maximum element in the array (`max(nums)`), because in the worst case, a single element would be the largest subarray. The largest possible value for the largest subarray sum is the sum of all the elements in the array (`sum(nums)`), which occurs when there is only one subarray.\n\n2. **Binary Search Setup**: Use a binary search to find the minimum possible value for the largest subarray sum between the above-calculated minimum and maximum.\n\n3. **Validation Function**: Create a helper function `is_valid(mid)` that checks whether the array can be split into no more than k subarrays with each subarray sum being no more than `mid`.\n\n4. **Binary Search Process**: Adjust the binary search bounds based on whether the current midpoint can be a valid maximum subarray sum or not.\n\n# Pseudocode:\n```\nfunction splitArray(nums, k):\n    function is_valid(mid):\n        count = 1\n        total = 0\n        for num in nums:\n            total += num\n            if total > mid:\n                total = num\n                count += 1\n        return count <= k\n\n    left = max(nums)\n    right = sum(nums)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if is_valid(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n```\nThis pseudocode provides a clear and concise roadmap for implementing the solution to the problem of splitting an array into k subarrays with the minimized largest sum.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-split-array-largest-sum"
    },
    {
        "name": "Longest Palindrome",
        "site": "LeetCode",
        "href": "/solution/LeetCode-longest-palindrome",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int longestPalindrome(string s) {\n        unordered_map<char, int> freq;\n        int length = 0;\n        bool hasOdd = false;\n        \n        for(char c : s) {\n            freq[c]++;\n        }\n        \n        for(auto& p : freq) {\n            if(p.second % 2 == 0) {\n                length += p.second;\n            } else {\n                length += p.second - 1;\n                hasOdd = true;\n            }\n        }\n        \n        return hasOdd ? length + 1 : length;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int longestPalindrome(String s) {\n        int[] count = new int[128];\n        for (char c : s.toCharArray()) {\n            count[c]++;\n        }\n        \n        int palindromeLength = 0;\n        boolean hasOdd = false;\n        \n        for (int num : count) {\n            palindromeLength += num / 2 * 2;\n            if (num % 2 == 1) {\n                hasOdd = true;\n            }\n        }\n        \n        return hasOdd ? palindromeLength + 1 : palindromeLength;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        char_count = {}\n        palindrome_length = 0\n        odd_found = False\n        \n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        for count in char_count.values():\n            if count % 2 == 0:\n                palindrome_length += count\n            else:\n                palindrome_length += count - 1\n                odd_found = True\n        \n        return palindrome_length + 1 if odd_found else palindrome_length"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int longestPalindrome(char* s) {\n    int count[128] = {0};\n    int length = 0;\n    int oddFound = 0;\n    \n    while (*s) {\n        count[*s]++;\n        s++;\n    }\n    \n    for (int i = 0; i < 128; i++) {\n        length += count[i] / 2 * 2;\n        if (count[i] % 2 == 1) {\n            oddFound = 1;\n        }\n    }\n    \n    return length + oddFound;\n}"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int LongestPalindrome(string s) {\n        Dictionary<char, int> dict = new Dictionary<char, int>();\n        int result = 0;\n        \n        foreach(char c in s){\n            if(dict.ContainsKey(c)){\n                dict[c]++;\n            } else {\n                dict[c] = 1;\n            }\n        }\n        \n        bool hasOdd = false;\n        \n        foreach(var pair in dict){\n            if(pair.Value % 2 == 0){\n                result += pair.Value;\n            } else {\n                result += pair.Value - 1;\n                hasOdd = true;\n            }\n        }\n        \n        return hasOdd ? result + 1 : result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestPalindrome = function(s) {\n    let charCount = {};\n    let maxLength = 0;\n    let hasOdd = false;\n    \n    for(let char of s) {\n        if(charCount[char] === undefined) {\n            charCount[char] = 1;\n        } else {\n            charCount[char]++;\n        }\n    }\n    \n    for(let char in charCount) {\n        if(charCount[char] % 2 === 0) {\n            maxLength += charCount[char];\n        } else {\n            maxLength += charCount[char] - 1;\n            hasOdd = true;\n        }\n    }\n    \n    return hasOdd ? maxLength + 1 : maxLength;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function longestPalindrome(s: string): number {\n    const charCount = new Map<string, number>();\n    \n    for (let char of s) {\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n    \n    let palindromeLength = 0;\n    let hasOddCount = false;\n    \n    for (let count of charCount.values()) {\n        palindromeLength += Math.floor(count / 2) * 2;\n        \n        if (count % 2 !== 0) {\n            hasOddCount = true;\n        }\n    }\n    \n    return hasOddCount ? palindromeLength + 1 : palindromeLength;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function longestPalindrome($s) {\n        $charCount = [];\n        $length = 0;\n        \n        for ($i = 0; $i < strlen($s); $i++) {\n            $char = $s[$i];\n            if (isset($charCount[$char])) {\n                $charCount[$char]++;\n            } else {\n                $charCount[$char] = 1;\n            }\n        }\n        \n        $oddFound = false;\n        \n        foreach ($charCount as $count) {\n            if ($count % 2 == 0) {\n                $length += $count;\n            } else {\n                $length += $count - 1;\n                $oddFound = true;\n            }\n        }\n        \n        return $oddFound ? $length + 1 : $length;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func longestPalindrome(_ s: String) -> Int {\n        var charCount = [Character: Int]()\n        \n        for char in s {\n            charCount[char, default: 0] += 1\n        }\n        \n        var length = 0\n        var hasOdd = false\n        \n        for (_, count) in charCount {\n            length += count / 2 * 2\n            if count % 2 == 1 {\n                hasOdd = true\n            }\n        }\n        \n        if hasOdd {\n            length += 1\n        }\n        \n        return length\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun longestPalindrome(s: String): Int {\n        var count = 0\n        val charCount = mutableMapOf<Char, Int>()\n\n        for (char in s) {\n            charCount[char] = charCount.getOrDefault(char, 0) + 1\n        }\n\n        var hasOdd = false\n        for ((_, value) in charCount) {\n            count += value\n            if (value % 2 != 0) {\n                count--\n                hasOdd = true\n            }\n        }\n\n        return if (hasOdd) count + 1 else count\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int longestPalindrome(String s) {\n    Map<String, int> charCount = {};\n    \n    for (int i = 0; i < s.length; i++) {\n      String char = s[i];\n      if (charCount.containsKey(char)) {\n        charCount[char] = charCount[char]! + 1;\n      } else {\n        charCount[char] = 1;\n      }\n    }\n    \n    int palindromeLength = 0;\n    bool hasOddCount = false;\n    \n    charCount.forEach((key, value) {\n      palindromeLength += value ~/ 2 * 2;\n      if (value % 2 == 1) {\n        hasOddCount = true;\n      }\n    });\n    \n    if (hasOddCount) {\n      palindromeLength++;\n    }\n    \n    return palindromeLength;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func longestPalindrome(s string) int {\n    charCount := make(map[rune]int)\n    for _, char := range s {\n        charCount[char]++\n    }\n    \n    palindromeLength := 0\n    hasOdd := false\n    \n    for _, count := range charCount {\n        palindromeLength += count\n        if count%2 == 1 {\n            palindromeLength--\n            hasOdd = true\n        }\n    }\n    \n    if hasOdd {\n        palindromeLength++\n    }\n    \n    return palindromeLength\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef longest_palindrome(s)\n    count = s.chars.tally\n    palindrome_length = 0\n    odd_count = false\n    \n    count.each do |_, c|\n        if c % 2 == 0\n            palindrome_length += c\n        else\n            palindrome_length += c - 1\n            odd_count = true\n        end\n    end\n    \n    palindrome_length += 1 if odd_count\n    \n    return palindrome_length\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def longestPalindrome(s: String): Int = {\n        val charCount = s.groupBy(identity).view.mapValues(_.size)\n        var longestLen = 0\n        var hasOdd = false\n        for ((_, count) <- charCount) {\n            longestLen += count / 2 * 2\n            if (count % 2 == 1) hasOdd = true\n        }\n        if (hasOdd) longestLen + 1 else longestLen\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn longest_palindrome(s: String) -> i32 {\n        use std::collections::HashMap;\n\n        let mut freq_map = HashMap::new();\n        let mut odd_count = 0;\n\n        for c in s.chars() {\n            *freq_map.entry(c).or_insert(0) += 1;\n        }\n\n        for (_, freq) in freq_map {\n            if freq % 2 == 1 {\n                odd_count += 1;\n            }\n        }\n\n        if odd_count > 0 {\n            return s.len() as i32 - odd_count + 1;\n        } else {\n            return s.len() as i32;\n        }\n    }\n}"
            },
            {
                "name": "Elixir",
                "abbreviation_for_prism_styles": "elixir",
                "code": "defmodule Solution do\n  @spec longest_palindrome(s :: String.t) :: integer\n  def longest_palindrome(s) do\n    freq_map = s\n      |> String.graphemes()\n      |> Enum.frequencies()\n    \n    total_length = freq_map\n      |> Enum.reduce(0, fn {_, count}, acc -> \n        acc + div(count, 2) * 2\n      end)\n    \n    if total_length < String.length(s) do\n      total_length + 1\n    else\n      total_length\n    end\n  end\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you'll need to determine the length of the longest palindrome that can be built from the given string. A palindrome reads the same backward as forward and can include both lowercase and uppercase letters, which are case-sensitive.\n\n## Explanation\n1. **Character Frequency Count**: First, count the frequency of each character in the string.\n2. **Calculate the Palindrome Length**: \n   - Add the counts of characters that appear an even number of times directly to the palindrome length.\n   - For characters that appear an odd number of times, add the largest even part of their counts to the palindrome length. We can also include one of these odd characters in the center of the palindrome.\n3. **Return the Result**: The final length is the sum of the even counts and, if there are any characters with odd counts, add one more to the length to account for a central character.\n\n## Pseudocode\n```pseudocode\nFUNCTION longestPalindrome(s):\n    INITIALIZE char_count as empty dictionary\n    INITIALIZE palindrome_length as 0\n    INITIALIZE odd_found as False\n\n    FOR each char in s:\n        IF char is in char_count:\n            INCREMENT char_count[char] by 1\n        ELSE:\n            SET char_count[char] to 1\n\n    FOR each count in char_count.values():\n        IF count is even:\n            ADD count to palindrome_length\n        ELSE:\n            ADD (count - 1) to palindrome_length\n            SET odd_found to True\n\n    IF odd_found is True:\n        RETURN palindrome_length + 1\n    ELSE:\n        RETURN palindrome_length\nEND FUNCTION\n```\nThis pseudocode outlines how to solve the problem by breaking down the required steps in a logical flow. The algorithm ensures that we efficiently calculate the length of the longest possible palindrome by leveraging the frequency of characters.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-longest-palindrome"
    },
    {
        "name": "Validate Ip Address",
        "site": "LeetCode",
        "href": "/solution/LeetCode-validate-ip-address",
        "languages": [
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def validIPAddress(self, queryIP):\n        \"\"\"\n        :type queryIP: str\n        :rtype: str\n        \"\"\"\n        if '.' in queryIP:\n            parts = queryIP.split('.')\n            if len(parts) != 4:\n                return \"Neither\"\n            for part in parts:\n                if not part.isdigit() or not 0 <= int(part) <= 255 or (len(part) > 1 and part[0] == '0'):\n                    return \"Neither\"\n            return \"IPv4\"\n        \n        if ':' in queryIP:\n            parts = queryIP.split(':')\n            if len(parts) != 8:\n                return \"Neither\"\n            for part in parts:\n                if not part.isalnum() or not 1 <= len(part) <= 4 or any(c.isalpha() and c.upper() > 'F' for c in part):\n                    return \"Neither\"\n            return \"IPv6\"\n        \n        return \"Neither\""
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine whether a given string is a valid IPv4 address, a valid IPv6 address, or neither. \n\n# Explanation\n\n1. **Check if it's an IPv4 Address**:\n    - An IPv4 address consists of four parts separated by `.`.\n    - Each part (segment) must be a number between 0 and 255.\n    - Leading zeroes in each segment are not allowed except for the number 0 itself.\n\n2. **Check if it's an IPv6 Address**:\n    - An IPv6 address consists of eight parts separated by `:`.\n    - Each part must be a hexadecimal number that can have 1 to 4 characters.\n    - Hexadecimal characters include digits (0-9) and letters (a-f or A-F).\n\n3. **Return the appropriate type based on the checks**:\n    - If the string conforms to IPv4 requirements, return `\"IPv4\"`.\n    - If it conforms to IPv6 requirements, return `\"IPv6\"`.\n    - If it conforms to neither, return `\"Neither\"`.\n\n# Pseudocode\n\n1. **Define a function (`validIPAddress`) that takes `queryIP` as input**.\n2. **Check if `queryIP` contains a period (`.`)**:\n    - Split `queryIP` by `.` to get the parts.\n    - If the number of parts is not equal to 4, return `\"Neither\"`.\n    - For each part:\n        - Check if it is a digit.\n        - Convert the part to an integer and check if it lies between 0 and 255.\n        - Ensure that the part doesn't have leading zeros unless it is exactly \"0\".\n    - If all checks pass, return `\"IPv4\"`.\n\n3. **Check if `queryIP` contains a colon (`:`)**:\n    - Split `queryIP` by `:` to get the parts.\n    - If the number of parts is not equal to 8, return `\"Neither\"`.\n    - For each part:\n        - Check if its length is between 1 and 4 (inclusive).\n        - Ensure each character is a valid hexadecimal digit (0-9, a-f, A-F).\n    - If all checks pass, return `\"IPv6\"`.\n\n4. **If `queryIP` does not contain either period (`.`) or colon (`:`), return `\"Neither\"`**.\n\n# Pseudocode\n\n```\nfunction validIPAddress(queryIP):\n    if '.' in queryIP:\n        parts = split queryIP by '.'\n        if length of parts is not 4:\n            return \"Neither\"\n        for each part in parts:\n            if part is not a digit:\n                return \"Neither\"\n            if part as integer is not between 0 and 255:\n                return \"Neither\"\n            if length of part > 1 and part starts with '0':\n                return \"Neither\"\n        return \"IPv4\"\n    \n    if ':' in queryIP:\n        parts = split queryIP by ':'\n        if length of parts is not 8:\n            return \"Neither\"\n        for each part in parts:\n            if length of part is not between 1 and 4:\n                return \"Neither\"\n            for each character in part:\n                if character is not a valid hexadecimal digit:\n                    return \"Neither\"\n        return \"IPv6\"\n    \n    return \"Neither\"\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-validate-ip-address"
    },
    {
        "name": "Unique Substrings In Wraparound String",
        "site": "LeetCode",
        "href": "/solution/LeetCode-unique-substrings-in-wraparound-string",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findSubstringInWraproundString(string s) {\n        if (s.empty()) {\n            return 0;\n        }\n        vector<int> dp(26, 0);\n        int len = 1;\n        dp[s[0] - 'a'] = 1;\n        \n        for (int i = 1; i < s.length(); ++i) {\n            if (s[i] - s[i - 1] == 1 || s[i - 1] - s[i] == 25) {\n                len++;\n            } else {\n                len = 1;\n            }\n            dp[s[i] - 'a'] = max(dp[s[i] - 'a'], len);\n        }\n        \n        return accumulate(dp.begin(), dp.end(), 0);\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findSubstringInWraproundString(String s) {\n        if(s == null || s.length() == 0) {\n            return 0;\n        }\n        \n        int[] maxLengthEndingAt = new int[26];\n        int length = 0;\n        \n        for(int i = 0; i < s.length(); i++) {\n            if(i > 0 && (s.charAt(i) - s.charAt(i-1) == 1 || s.charAt(i-1) - s.charAt(i) == 25)) {\n                length++;\n            } else {\n                length = 1;\n            }\n            int index = s.charAt(i) - 'a';\n            maxLengthEndingAt[index] = Math.max(maxLengthEndingAt[index], length);\n        }\n        \n        int result = 0;\n        for(int i = 0; i < maxLengthEndingAt.length; i++) {\n            result += maxLengthEndingAt[i];\n        }\n        \n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findSubstringInWraproundString(self, s):\n        \"\"\"\n        :type s: str\n        \"\"\"\n        if not s:\n            return 0\n        \n        dp = [0] * 26\n        dp[ord(s[0]) - ord('a')] = 1\n        length = 1\n        \n        for i in range(1, len(s)):\n            if ord(s[i]) - ord(s[i-1]) == 1 or ord(s[i-1]) - ord(s[i]) == 25:\n                length += 1\n            else:\n                length = 1\n            index = ord(s[i]) - ord('a')\n            dp[index] = max(dp[index], length)\n        \n        return sum(dp)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int findSubstringInWraproundString(char* s) {\n    if (s == NULL || *s == '\\0') return 0;\n    \n    int counts[26] = {0};\n    int len = 1;\n    \n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (i > 0 && (s[i] == s[i-1] + 1 || (s[i] == 'a' && s[i-1] == 'z'))) {\n            len++;\n        } else {\n            len = 1;\n        }\n        \n        counts[s[i] - 'a'] = fmax(counts[s[i] - 'a'], len);\n    }\n    \n    int result = 0;\n    for (int i = 0; i < 26; i++) {\n        result += counts[i];\n    }\n    \n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindSubstringInWraproundString(string s) {\n        if (string.IsNullOrEmpty(s)) return 0;\n        int[] maxLengths = new int[26];\n        int currentMax = 0;\n        for (int i = 0; i < s.Length; i++) {\n            if (i > 0 && (s[i] == s[i - 1] + 1 || s[i] == 'a' && s[i - 1] == 'z')) {\n                currentMax++;\n            } else {\n                currentMax = 1;\n            }\n            maxLengths[s[i] - 'a'] = Math.Max(maxLengths[s[i] - 'a'], currentMax);\n        }\n        return maxLengths.Sum();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar findSubstringInWraproundString = function(s) {\n    let count = 0;\n    let dp = Array(26).fill(0);\n\n    for (let i = 0; i < s.length; i++) {\n        if (i > 0 && (s.charCodeAt(i) - s.charCodeAt(i - 1) === 1 || s.charCodeAt(i - 1) - s.charCodeAt(i) === 25)) {\n            count++;\n        } else {\n            count = 1;\n        }\n        let index = s.charCodeAt(i) - 'a'.charCodeAt(0);\n        dp[index] = Math.max(dp[index], count);\n    }\n\n    return dp.reduce((acc, val) => acc + val, 0);\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findSubstringInWraproundString(s: string): number {\n    const dp = new Array(26).fill(0);\n    \n    let count = 0;\n    let maxLength = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        if (i > 0 && (s[i].charCodeAt(0) - s[i - 1].charCodeAt(0) === 1 || s[i].charCodeAt(0) - s[i - 1].charCodeAt(0) === -25)) {\n            maxLength++;\n        } else {\n            maxLength = 1;\n        }\n        \n        const index = s[i].charCodeAt(0) - 'a'.charCodeAt(0);\n        dp[index] = Math.max(dp[index], maxLength);\n    }\n    \n    count = dp.reduce((acc, cur) => acc + cur, 0);\n    \n    return count;\n};"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findSubstringInWraproundString(s: String): Int {\n        \n        val count = IntArray(26)\n        var maxLength = 0\n        for (i in s.indices) {\n            if (i > 0 && (s[i] - s[i-1] == 1 || s[i] - s[i-1] == -25)) {\n                maxLength++\n            } else {\n                maxLength = 1\n            }\n            val index = s[i] - 'a'\n            count[index] = maxOf(count[index], maxLength)\n        }\n        \n        return count.sum()\n    }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findSubstringInWraproundString(s string) int {\n    if s == \"\" {\n        return 0\n    }\n\n    dp := make([]int, 26)\n    dp[s[0]-'a'] = 1\n    consecutive := 1\n\n    for i := 1; i < len(s); i++ {\n        if s[i]-s[i-1] == 1 || s[i-1]-s[i] == 25 {\n            consecutive++\n        } else {\n            consecutive = 1\n        }\n        index := s[i] - 'a'\n        dp[index] = max(dp[index], consecutive)\n    }\n\n    total := 0\n    for _, val := range dp {\n        total += val\n    }\n    return total\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {Integer}\ndef find_substring_in_wrapround_string(s)\n    if s.empty?\n        return 0\n    end\n    \n    counts = Array.new(26, 0)\n    result = 0\n    length = 0\n    \n    s.chars.each_with_index do |char, index|\n        if index > 0 && (char.ord - s[index - 1].ord == 1 || char.ord - s[index - 1].ord == -25)\n            length += 1\n        else\n            length = 1\n        end\n        \n        counts[char.ord - 'a'.ord] = [counts[char.ord - 'a'.ord], length].max\n    end\n    \n    counts.each do |count|\n        result += count\n    end\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findSubstringInWraproundString(s: String): Int = {\n        val counts = Array.ofDim[Int](26)\n        \n        def maxSubstringLength(c: Char): Int = {\n            if (c == 'a') 1\n            else ('z' - c + 1) % 26 + 1\n        }\n        \n        def updateMaxSubstringLength(c: Char, len: Int): Unit = {\n            val idx = c - 'a'\n            counts(idx) = math.max(counts(idx), len)\n        }\n        \n        var maxLength = 0\n        var length = 1\n        for (i <- s.indices) {\n            if (i > 0 && (s(i) - s(i - 1) == 1 || s(i - 1) - s(i) == 25)) {\n                length += 1\n            } else {\n                length = 1\n            }\n            updateMaxSubstringLength(s(i), length)\n        }\n        \n        counts.sum\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_substring_in_wrapround_string(s: String) -> i32 {\n        let mut dp = vec![0; 26];\n        let mut count = 1;\n\n        for (i, c) in s.chars().enumerate() {\n            if i > 0 && (s.as_bytes()[i-1] + 1) % 26 == s.as_bytes()[i] % 26 {\n                count += 1;\n            } else {\n                count = 1;\n            }\n            dp[(c as u8 - b'a') as usize] = dp[(c as u8 - b'a') as usize].max(count);\n        }\n\n        dp.iter().sum()\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the number of unique non-empty substrings of string `s` that exist in the infinite wraparound string \"abcdefghijklmnopqrstuvwxyz\".\n\n### # Explanation\nWe observe that the problem can be reduced to identifying the longest possible substrings ending with each character in `s` that are present in the wraparound string. Using dynamic programming, we can track the longest such substring for each ending character.\n\n### # Pseudocode\n\n1. **Initialize variables**:\n   - Create an array `dp` of length 26 (for each letter a-z) initialized to 0. This array will be used to store the length of the longest substring ending with the corresponding character.\n   - Set a variable `length` to 1 to keep track of the current sequence length.\n\n2. **Edge case**:\n   - If input string `s` is empty, return 0.\n\n3. **Process the string**:\n   - Set `dp[ord(s[0]) - ord('a')] = 1` as we start with the first character of `s`.\n   - Iterate through the string starting from the second character (index 1):\n     - If the current and previous characters are consecutive in the wraparound string (either `ord(s[i]) - ord(s[i-1]) == 1` or the wrap around case `ord(s[i-1]) - ord(s[i]) == 25`):\n       - Increment `length`.\n     - Otherwise, reset `length` to 1.\n     - Update `dp[ord(s[i]) - ord('a')]` with the maximum of its current value or `length`.\n\n4. **Result**:\n   - Sum up all elements in `dp` to get the total number of unique substrings.\n\n### Pseudocode\n\n```plain\nfunction findSubstringInWraproundString(s):\n    if s is empty:\n        return 0\n\n    dp = array of length 26 initialized to 0\n    dp[ord(s[0]) - ord('a')] = 1\n    length = 1\n\n    for i from 1 to len(s)-1:\n        if (ord(s[i]) - ord(s[i-1]) == 1 or ord(s[i-1]) - ord(s[i]) == 25):\n            length += 1\n        else:\n            length = 1\n\n        index = ord(s[i]) - ord('a')\n        dp[index] = max(dp[index], length)\n\n    return sum(dp)\n```\n\nThis pseudocode captures the essence of the algorithm needed to solve the problem. Each unique substring is counted based on the longest contiguous substring ending at each character, ensuring all possible substrings are accounted for.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-unique-substrings-in-wraparound-string"
    },
    {
        "name": "Random Pick Index",
        "site": "LeetCode",
        "href": "/solution/LeetCode-random-pick-index",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> numbers;\n    unordered_map<int, vector<int>> numIndexMap;\n    \n    Solution(vector<int>& nums) {\n        numbers = nums;\n        for (int i = 0; i < nums.size(); i++) {\n            numIndexMap[nums[i]].push_back(i);\n        }\n    }\n    \n    int pick(int target) {\n        int n = numIndexMap[target].size();\n        int randomIndex = rand() % n;\n        return numIndexMap[target][randomIndex];\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    int[] nums;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n    }\n\n    public int pick(int target) {\n        Random rand = new Random();\n        int count = 0;\n        int result = -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                count++;\n                if (rand.nextInt(count) == 0) {\n                    result = i;\n                }\n            }\n        }\n        return result;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def __init__(self, nums):\n        self.nums = nums\n\n    def pick(self, target):\n        index = []\n        for i in range(len(self.nums)):\n            if self.nums[i] == target:\n                index.append(i)\n        \n        return random.choice(index)"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "typedef struct {\n    int* nums;\n    int numsSize;\n} Solution;\n\nSolution* solutionCreate(int* nums, int numsSize) {\n    Solution* obj = (Solution*)malloc(sizeof(Solution));\n    obj->nums = nums;\n    obj->numsSize = numsSize;\n    return obj;\n}\n\nint solutionPick(Solution* obj, int target) {\n    int count = 0;\n    int result = -1;\n\n    for (int i = 0; i < obj->numsSize; i++) {\n        if (obj->nums[i] == target) {\n            count++;\n            if (rand() % count == 0) {\n                result = i;\n            }\n        }\n    }\n\n    return result;\n}\n\nvoid solutionFree(Solution* obj) {\n    free(obj);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "    public class Solution {\n        private Dictionary<int, List<int>> dict;\n        private Random rand;\n        \n        public Solution(int[] nums) {\n            dict = new Dictionary<int, List<int>>();\n            rand = new Random();\n            \n            for (int i = 0; i < nums.Length; i++) {\n                if (!dict.ContainsKey(nums[i])) {\n                    dict[nums[i]] = new List<int>();\n                }\n                dict[nums[i]].Add(i);\n            }\n        }\n        \n        public int Pick(int target) {\n            List<int> indexes = dict[target];\n            return indexes[rand.Next(0, indexes.Count)];\n        }\n    }\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n */\nvar Solution = function(nums) {\n    this.nums = nums;\n};\n\n/**\n * @param {number} target\n * @return {number}\n */\nSolution.prototype.pick = function(target) {\n    let result = -1;\n    let count = 0;\n    \n    for (let i = 0; i < this.nums.length; i++) {\n        if (this.nums[i] === target) {\n            if (Math.floor(Math.random() * ++count) === 0) {\n                result = i;\n            }\n        }\n    }\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class Solution {\n    nums: number[];\n\n    constructor(nums: number[]) {\n        this.nums = nums;\n    }\n\n    pick(target: number): number {\n        const indexes = [];\n        for (let i = 0; i < this.nums.length; i++) {\n            if (this.nums[i] === target) {\n                indexes.push(i);\n            }\n        }\n        const randomIndex = Math.floor(Math.random() * indexes.length);\n        return indexes[randomIndex];\n    }\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    private $nums;\n    \n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        $this->nums = $nums;\n    }\n    \n    /**\n     * @param Integer $target\n     * @return Integer\n     */\n    function pick($target) {\n        $count = 0;\n        $res = -1;\n        \n        foreach($this->nums as $key => $num) {\n            if($num == $target) {\n                $count++;\n                if(rand(1, $count) == 1) {\n                    $res = $key;\n                }\n            }\n        }\n        \n        return $res;\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to implement a class `Solution` that initializes with an array `nums` and provides a method `pick` to randomly select an index where the array value equals a given target. \n\n# Explanation\n1. **Initialization**: The `Solution` class takes an integer array `nums` during initialization and stores it.\n2. **Pick Method**: The `pick` method takes a target value as input and returns a random index from the array where the value equals the target. Each valid index should have an equal probability of being chosen.\n3. **Finding Indices**: The method iterates through the array to collect all indices where the value matches the target.\n4. **Random Selection**: From the collected indices, the method randomly selects and returns one index.\n\n# Pseudocode\nHere's how we can resolve the challenge using pseudocode:\n\n### Initialization\n- Define a class `Solution`.\n  - Implement the `__init__(self, nums)` method:\n    - Store the input array `nums` in an instance variable.\n\n### Pick Method\n- Implement the `pick(self, target)` method:\n  - Initialize an empty list `indices`.\n  - Loop through each element in `nums` with its index:\n    - If the element equals `target`, append the index to `indices`.\n  - Randomly select and return an index from `indices`.\n\n### Usage\n- Create an instance of the `Solution` class with the given `nums`.\n- Call the `pick` method with the desired `target` and capture the output.\n\n```plaintext\n# Pseudocode\n\nClass Solution:\n    \n    # Constructor to initialize the object with the array nums\n    Function __init__(nums):\n        Set self.nums to nums\n    \n    # Method to pick a random index where the value is equal to target\n    Function pick(target):\n        Initialize an empty list called indices\n        \n        For each index i in range of length of self.nums:\n            If self.nums[i] equals target:\n                Append i to indices\n        \n        # Return a randomly selected index from indices\n        Return a random choice from indices\n\n# Example Usage:\n# Initialize the object with nums\nsolution = Solution([1, 2, 3, 3, 3])\n\n# Randomly pick an index of target 3\nprint(solution.pick(3)) # Possible outputs can be 2, 3, or 4\n\n# Randomly pick an index of target 1\nprint(solution.pick(1)) # Output should be 0\n\n# Randomly pick an index of target 3 again\nprint(solution.pick(3)) # Possible outputs can be 2, 3, or 4\n```",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-random-pick-index"
    },
    {
        "name": "Queue Reconstruction By Height",
        "site": "LeetCode",
        "href": "/solution/LeetCode-queue-reconstruction-by-height",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort(people.begin(), people.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0];\n        });\n        \n        vector<vector<int>> res;\n        for (const auto& p : people) {\n            res.insert(res.begin() + p[1], p);\n        }\n        \n        return res;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\n        List<int[]> result = new ArrayList<>();\n        for (int[] person : people) {\n            result.add(person[1], person);\n        }\n        return result.toArray(new int[people.length][]);\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def reconstructQueue(self, people):\n        \"\"\"\n        :type people: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        people.sort(key=lambda x: (-x[0], x[1]))\n        result = []\n        for p in people:\n            result.insert(p[1], p)\n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[][] ReconstructQueue(int[][] people) {\n        Array.Sort(people, (a, b) =>\n        {\n            if (a[0] != b[0])\n            {\n                return b[0] - a[0];\n            }\n            else\n            {\n                return a[1] - b[1];\n            }\n        });\n        \n        List<int[]> result = new List<int[]>();\n        \n        foreach (var p in people)\n        {\n            result.Insert(p[1], p);\n        }\n        \n        return result.ToArray();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[][]} people\n * @return {number[][]}\n */\nvar reconstructQueue = function(people) {\n    people.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return a[1] - b[1];\n        } else {\n            return b[0] - a[0];\n        }\n    });\n    \n    let result = [];\n    for (let i = 0; i < people.length; i++) {\n        result.splice(people[i][1], 0, people[i]);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function reconstructQueue(people: number[][]): number[][] {\n    people.sort((a, b) => a[0] !== b[0] ? b[0] - a[0] : a[1] - b[1]);\n    \n    const result: number[][] = [];\n    for (const p of people) {\n        result.splice(p[1], 0, p);\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[][] $people\n     * @return Integer[][]\n     */\n    function reconstructQueue($people) {\n        usort($people, function($a, $b) {\n            if ($a[0] == $b[0]) {\n                return $a[1] - $b[1];\n            }\n            return $b[0] - $a[0];\n        });\n        \n        $result = [];\n        foreach ($people as $p) {\n            array_splice($result, $p[1], 0, [$p]);\n        }\n        \n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func reconstructQueue(_ people: [[Int]]) -> [[Int]] {\n        let sortedPeople = people.sorted { a, b in\n            if a[0] == b[0] {\n                return a[1] < b[1]\n            } else {\n                return a[0] > b[0]\n            }\n        }\n        \n        var result = [[Int]]()\n        \n        for person in sortedPeople {\n            result.insert(person, at: person[1])\n        }\n        \n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun reconstructQueue(people: Array<IntArray>): Array<IntArray> {\n        val sortedPeople = people.sortedWith(compareBy({ -it[0] }, { it[1] }))\n        val result = mutableListOf<IntArray>()\n        for (person in sortedPeople) {\n            result.add(person[1], person)\n        }\n        return result.toTypedArray()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> reconstructQueue(List<List<int>> people) {\n    people.sort((a, b) {\n      if (a[0] != b[0]) {\n        return b[0] - a[0];\n      } else {\n        return a[1] - b[1];\n      }\n    });\n\n    List<List<int>> result = [];\n    for (var p in people) {\n      result.insert(p[1], p);\n    }\n\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func reconstructQueue(people [][]int) [][]int {\n    sort.Slice(people, func(i, j int) bool {\n        a, b := people[i], people[j]\n        return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1])\n    })\n\n    result := make([][]int, 0)\n    for _, p := range people {\n        result = append(result, p)\n        copy(result[p[1]+1:], result[p[1]:])\n        result[p[1]] = p\n    }\n\n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[][]} people\n# @return {Integer[][]}\ndef reconstruct_queue(people)\n    people.sort! { |a, b| a[0] == b[0] ? a[1] - b[1] : b[0] - a[0] }\n    \n    result = []\n    people.each { |p| result.insert(p[1], p) }\n    \n    return result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def reconstructQueue(people: Array[Array[Int]]): Array[Array[Int]] = {\n        val sortedPeople = people.sortWith((a, b) => {\n            if (a(0) == b(0)) a(1) < b(1)\n            else a(0) > b(0)\n        })\n        var result = List.empty[Array[Int]]\n        for (person <- sortedPeople) {\n            result = result.take(person(1)) ++ Array(person) ++ result.drop(person(1))\n        }\n        result.toArray\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn reconstruct_queue(people: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut people = people;\n        people.sort_by(|a, b| {\n            if a[0] != b[0] {\n                b[0].cmp(&a[0])\n            } else {\n                a[1].cmp(&b[1])\n            }\n        });\n        \n        let mut result = Vec::new();\n        for p in people {\n            result.insert(p[1] as usize, p);\n        }\n        \n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to reconstruct the queue using the given height and k values for each person. The approach involves sorting the people array and then inserting them into the result list at the correct positions.\n\n# Explanation:\n1. **Sort the people array**: First, sort the array by height in descending order. If two people have the same height, sort them by their k-value in ascending order. This ensures that when we insert people into the queue, taller people are placed first and the k-value correctly reflects their position in the queue concerning other taller people already placed.\n   \n2. **Insert people into the queue**: Initialize an empty list to represent the queue. Iterate through the sorted people array and insert each person at the position specified by their k-value. This insertion will shift the smaller or equal-height people to the right, maintaining the correct number of taller or equal-height people in front of each person.\n\n# Pseudocode:\n```python\n# Sort the people array\nSORT people BY height in descending order, if equal, BY k-value in ascending order\n\n# Initialize an empty list for the reconstructed queue\nresult = []\n\n# Insert each person into the result list at the position indicated by their k-value\nFOR each person IN sorted people:\n    INSERT person INTO result AT position person[1]\n\n# Return the constructed queue\nRETURN result\n```\n\nThis approach ensures that the queue is reconstructed correctly with the given height and k-value constraints, as taller people are always placed first, and the k-values determine their exact positions relative to each other.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-queue-reconstruction-by-height"
    },
    {
        "name": "Convert A Number To Hexadecimal",
        "site": "LeetCode",
        "href": "/solution/LeetCode-convert-a-number-to-hexadecimal",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string toHex(int num) {\n        if (num == 0) return \"0\";\n        \n        unsigned int n = num;\n        string hex = \"\";\n        string hexChars = \"0123456789abcdef\";\n        \n        while (n != 0) {\n            hex = hexChars[n & 15] + hex;\n            n = n >> 4;\n        }\n        \n        return hex;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String toHex(int num) {\n        if (num == 0) {\n            return \"0\";\n        }\n        \n        char[] hexDigits = \"0123456789abcdef\".toCharArray();\n        StringBuilder sb = new StringBuilder();\n        \n        while (num != 0) {\n            sb.insert(0, hexDigits[num & 15]);\n            num >>>= 4;\n        }\n        \n        return sb.toString();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num += 2**32\n        \n        hex_chars = \"0123456789abcdef\"\n        result = \"\"\n        while num > 0:\n            digit = num % 16\n            result = hex_chars[digit] + result\n            num = num // 16\n        \n        return result"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string ToHex(int num) {\n        if(num == 0) return \"0\";\n        \n        char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        StringBuilder result = new StringBuilder();\n        \n        while(num != 0){\n            result.Insert(0, hexDigits[num & 15]);\n            num = (int)((uint)num >> 4);\n        }\n        \n        return result.ToString();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} num\n * @return {string}\n */\nconst toHex = (num) => {\n    if (num === 0) return '0';\n    const hexChars = '0123456789abcdef';\n    let result = '';\n    while (num !== 0) {\n        result = hexChars[num & 15] + result;\n        num >>>= 4;\n    }\n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function toHex(num: number): string {\n    if (num === 0) return \"0\";\n    \n    let hex = \"0123456789abcdef\";\n    let result = \"\";\n    \n    while (num !== 0) {\n        result = hex[num & 15] + result;\n        num >>>= 4;\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func toHex(_ num: Int) -> String {\n        if num == 0 {\n            return \"0\"\n        }\n        \n        let hexChars = Array(\"0123456789abcdef\")\n        var num = num\n        var result = \"\"\n        \n        for _ in 0..<8 {\n            let digit = num & 15\n            result = String(hexChars[digit]) + result\n            num >>= 4\n            if num == 0 {\n                break\n            }\n        }\n        \n        return result\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun toHex(num: Int): String {\n        if (num == 0) return \"0\"\n        \n        val hexChars = \"0123456789abcdef\"\n        var ans = \"\"\n        var n = num.toLong()\n        \n        if (n < 0) {\n            n += (1L shl 32)\n        }\n        \n        while (n > 0) {\n            val remainder = (n % 16).toInt()\n            ans = hexChars[remainder] + ans\n            n /= 16\n        }\n        \n        return ans\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String toHex(int num) {\n    if (num == 0) return \"0\";\n    \n    String hexChars = \"0123456789abcdef\";\n    String result = \"\";\n    \n    for (int i = 7; i >= 0; i--) {\n      int val = (num >> (i * 4)) & 15;\n      if (val != 0 || result.isNotEmpty) {\n        result += hexChars[val];\n      }\n    }\n    \n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func toHex(num int) string {\n    if num == 0 {\n        return \"0\"\n    }\n    \n    hexMap := []byte(\"0123456789abcdef\")\n\n    result := \"\"\n    for i := 0; i < 8 && num != 0; i++ {\n        index := num & 15\n        result = string(hexMap[index]) + result\n        num = num >> 4\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} num\n# @return {String}\ndef to_hex(num)\n    return \"0\" if num == 0\n    hex_chars = \"0123456789abcdef\"\n    result = \"\"\n    mask = 0xf\n    8.times do\n        result = hex_chars[num & mask] + result\n        num = num >> 4\n    end\n    result.gsub(/^0+/, \"\")\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def toHex(num: Int): String = {\n        if (num == 0) return \"0\"\n        \n        val hexChars = \"0123456789abcdef\"\n        var result = \"\"\n        var number = num.toLong\n        \n        if (number < 0) number = (BigInt(2).pow(32) + number).toLong\n        \n        while (number > 0) {\n            val remainder = (number % 16).toInt\n            result = s\"${hexChars.charAt(remainder)}$result\"\n            number = number / 16\n        }\n        \n        result\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn to_hex(num: i32) -> String {\n        if num == 0 {\n            return String::from(\"0\");\n        }\n        \n        let mut result = String::new();\n        let hex_chars: Vec<char> = vec!['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n        let mut num = num as u32;\n        \n        while num != 0 {\n            let rem = (num % 16) as usize;\n            result.insert(0, hex_chars[rem]);\n            num /= 16;\n        }\n        \n        result\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to convert a given integer to its hexadecimal representation. The solution involves determining the hexadecimal digits for both positive and negative integers, incorporating the two's complement method for negative values.\n\n# Explanation\n\n1. **Input Handling**: Start with handling the given number, notably for the special case of `0`.\n2. **Negative Numbers**: If the number is negative, adjust it using the two\u2019s complement method by adding \\(2^{32}\\).\n3. **Hexadecimal Conversion**: For non-zero positive or adjusted negative numbers, derive each hexadecimal digit from the least significant digit to the most significant.\n4. **Digit Extraction**: Use modulo and integer division operations to extract each hexadecimal digit by repeatedly dividing the number by 16.\n5. **Character Mapping**: Map each resulting digit to its corresponding hexadecimal character using an array of hexadecimal characters (`'0123456789abcdef'`).\n6. **String Construction**: Accumulate these characters into the final hexadecimal string.\n7. **Return the Result**: Finally, return the constructed string ensuring no leading zeros appear unless the number itself is zero.\n\n# Pseudocode\n\n```\nfunction toHex(num):\n    if num == 0:\n        return \"0\"\n\n    if num < 0:\n        num += 2**32\n\n    hex_chars = \"0123456789abcdef\"\n    result = \"\"\n\n    while num > 0:\n        digit = num % 16\n        result = hex_chars[digit] + result\n        num = num // 16\n\n    return result\n```\n\nThis pseudocode describes a step-by-step process for converting an integer to a hexadecimal string without utilizing built-in library methods for direct conversion. The methodology ensures handling both positive and negative integers as per the given constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-convert-a-number-to-hexadecimal"
    },
    {
        "name": "Sum Of Left Leaves",
        "site": "LeetCode",
        "href": "/solution/LeetCode-sum-of-left-leaves",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        int sum = 0;\n        if (root->left && !root->left->left && !root->left->right) {\n            sum += root->left->val;\n        }\n        sum += sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n        return sum;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        int sum = 0;\n        \n        if (root.left != null && root.left.left == null && root.left.right == null) {\n            sum += root.left.val;\n        }\n        \n        sum += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);\n        \n        return sum;\n    }\n}\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nint sumOfLeftLeaves(struct TreeNode* root){\n    if(root == NULL)\n        return 0;\n    \n    int sum = 0;\n    \n    if(root->left != NULL && root->left->left == NULL && root->left->right == NULL)\n        sum += root->left->val;\n    \n    sum += sumOfLeftLeaves(root->left);\n    sum += sumOfLeftLeaves(root->right);\n    \n    return sum;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int SumOfLeftLeaves(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        int sum = 0;\n        if (root.left != null && root.left.left == null && root.left.right == null) {\n            sum += root.left.val;\n        }\n        \n        sum += SumOfLeftLeaves(root.left);\n        sum += SumOfLeftLeaves(root.right);\n        \n        return sum;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val);\n *     this.left = (left===undefined ? null : left);\n *     this.right = (right===undefined ? null : right);\n */\nvar sumOfLeftLeaves = function(root) {\n    let sum = 0;\n    \n    const dfs = (node, isLeft) => {\n        if (!node) return;\n        \n        if (!node.left && !node.right && isLeft) {\n            sum += node.val;\n            return;\n        }\n        \n        dfs(node.left, true);\n        dfs(node.right, false);\n    }\n    \n    dfs(root, false);\n    \n    return sum;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction sumOfLeftLeaves(root: TreeNode | null): number {\n    let sum = 0;\n    \n    const dfs = (node: TreeNode | null, isLeft: boolean) => {\n        if (!node) return;\n        \n        if (!node.left && !node.right && isLeft) {\n            sum += node.val;\n        }\n        \n        dfs(node.left, true);\n        dfs(node.right, false);\n    };\n    \n    dfs(root, false);\n    \n    return sum;\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     var val: Int\n *     var left: TreeNode?\n *     var right: TreeNode?\n *     init() { self.val = 0; self.left = nil; self.right = nil; }\n *     init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n */\n\nclass Solution {\n    func sumOfLeftLeaves(_ root: TreeNode?) -> Int {\n        guard let root = root else { return 0 }\n        \n        var sum = 0\n        \n        if let left = root.left, left.left == nil, left.right == nil {\n            sum += left.val\n        }\n        \n        sum += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)\n        \n        return sum\n    }\n}\n\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc sumOfLeftLeaves(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    \n    if root.Left != nil && root.Left.Left == nil && root.Left.Right == nil {\n        return root.Left.Val + sumOfLeftLeaves(root.Right)\n    }\n    \n    return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left, @right = left, right\n#     end\n# end\n\ndef sum_of_left_leaves(root)\n    return 0 unless root\n\n    stack = [[root, false]]\n    sum = 0\n\n    until stack.empty?\n        node, is_left = stack.pop\n        if node.left.nil? && node.right.nil? && is_left\n            sum += node.val\n        end\n        stack.push([node.right, false]) if node.right\n        stack.push([node.left, true]) if node.left\n    end\n\n    sum\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode \n= null, _right: TreeNode = null) {\n */\nobject Solution {\n  def sumOfLeftLeaves(root: TreeNode): Int = {\n    if (root == null) 0\n    else {\n      var sum = 0\n      if (root.left != null && root.left.left == null && root.left.right == null)\n        sum += root.left.value\n      sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)\n    }\n  }\n}\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Box<TreeNode>>,\n//   pub right: Option<Box<TreeNode>>,\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nimpl Solution {\n    pub fn sum_of_left_leaves(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        fn is_leaf(node: &Option<Rc<RefCell<TreeNode>>>) -> bool {\n            match node {\n                Some(n) => {\n                    let n = n.borrow();\n                    n.left.is_none() && n.right.is_none()\n                },\n                None => false,\n            }\n        }\n        \n        fn sum_left_leaves(node: &Option<Rc<RefCell<TreeNode>>>, is_left: bool) -> i32 {\n            match node {\n                Some(n) => {\n                    let n = n.borrow();\n                    if is_leaf(&node) && is_left {\n                        n.val\n                    } else {\n                        sum_left_leaves(&n.left, true) + sum_left_leaves(&n.right, false)\n                    }\n                },\n                None => 0,\n            }\n        }\n        \n        sum_left_leaves(&root, false)\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to traverse the given binary tree and compute the sum of all \"left leaves\". A left leaf is defined as a leaf node that is the left child of its parent node.\n\nHere\u2019s how we can approach solving this problem:\n\n# Explanation\n1. **Tree Traversal**: We need to traverse the tree to check each node. We will use Depth-First Search (DFS) for this purpose.\n2. **Identify Left Leaves**: For every node, we will check if its left child is a leaf node. If it is, we add its value to our sum.\n3. **Recursive Strategy**: Use a recursive function to traverse the tree and pass an additional parameter to track whether the current node is a left child or not.\n4. **Edge Cases**: Handle cases with an empty tree or a tree with no left leaves.\n\n# Pseudocode\nBelow is the pseudocode that describes the above steps:\n\n```\n# Function to sum left leaves in a binary tree\nFunction sumOfLeftLeaves(root):\n    # Initialize the sum of left leaves\n    sum = 0\n    \n    # Define a helper function to perform DFS\n    Function dfs(node, isLeft):\n        # Base case: if the node is null, return\n        If node is None:\n            Return\n        \n        # Check if it's a leaf node and if it's a left child\n        If node.left == None AND node.right == None AND isLeft:\n            # If it's a left leaf, add its value to sum\n            sum = sum + node.val\n        \n        # Recurse on the left child, marking it as left\n        dfs(node.left, True)\n        \n        # Recurse on the right child, marking it as not left\n        dfs(node.right, False)\n        \n    # Call dfs starting with the root and isLeft as False (since root is not a left child)\n    dfs(root, False)\n    \n    # Return the computed sum\n    Return sum\n```\n\nThis pseudocode outlines how to traverse each node in the tree, check if it is a left leaf, and maintain the sum of such nodes. The recursive DFS approach ensures we visit all nodes while efficiently checking their properties.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-sum-of-left-leaves"
    },
    {
        "name": "Frog Jump",
        "site": "LeetCode",
        "href": "/solution/LeetCode-frog-jump",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        unordered_map<int, unordered_set<int>> dp;\n        for (int stone : stones) {\n            dp[stone] = unordered_set<int>();\n        }\n        \n        dp[0].insert(0);\n        \n        for (int i = 0; i < stones.size(); ++i) {\n            for (int k : dp[stones[i]]) {\n                for (int step = k - 1; step <= k + 1; ++step) {\n                    if (step > 0 && dp.find(stones[i] + step) != dp.end()) {\n                        dp[stones[i] + step].insert(step);\n                    }\n                }\n            }\n        }\n        \n        return !dp[stones.back()].empty();\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public boolean canCross(int[] stones) {\n        if (stones.length < 2 || stones[1] != 1) {\n            return false;\n        }\n        \n        int n = stones.length;\n        \n        // Create a HashSet to store all the stones for quicker access\n        Set<Integer> stoneSet = new HashSet<>();\n        for (int stone : stones) {\n            stoneSet.add(stone);\n        }\n        \n        // Create a HashMap to store the possible jumps for each stone\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\n        dp.put(0, new HashSet<>());\n        dp.get(0).add(1);\n        \n        for (int i = 1; i < n; i++) {\n            dp.put(stones[i], new HashSet<>());\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            int stone = stones[i];\n            for (int jump : dp.get(stone)) {\n                int nextPos = stone + jump;\n                if (nextPos == stones[n - 1]) {\n                    return true;\n                }\n                \n                if (stoneSet.contains(nextPos)) {\n                    if (jump - 1 > 0) dp.get(nextPos).add(jump - 1);\n                    dp.get(nextPos).add(jump);\n                    dp.get(nextPos).add(jump + 1);\n                }\n            }\n        }\n        \n        return false;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if not stones:\n            return False\n        \n        dp = {}\n        \n        for stone in stones:\n            dp[stone] = set()\n        \n        dp[0].add(0)\n        \n        for stone in stones:\n            for step in dp[stone]:\n                for move in range(step-1, step+2):\n                    if move > 0 and stone + move in dp:\n                        dp[stone + move].add(move)\n        \n        return len(dp[stones[-1]]) > 0\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public bool CanCross(int[] stones) {\n        // Create a HashSet to store all the stones\n        HashSet<int> stoneSet = new HashSet<int>();\n        foreach (int stone in stones) {\n            stoneSet.Add(stone);\n        }\n        \n        // Create a dictionary to store each stone and the jumps that can reach it\n        Dictionary<int, HashSet<int>> dp = new Dictionary<int, HashSet<int>>();\n        dp[0] = new HashSet<int>();\n        dp[0].Add(0);\n        \n        // Iterate through each stone and check if it is reachable from any previous stone\n        for (int i = 0; i < stones.Length; i++) {\n            int stone = stones[i];\n            if (!dp.ContainsKey(stone)) continue;\n            \n            HashSet<int> jumps = dp[stone];\n            \n            foreach (int jump in jumps) {\n                for (int k = jump - 1; k <= jump + 1; k++) {\n                    if (k <= 0) continue;\n                    int nextStone = stone + k;\n                    if (nextStone == stones[stones.Length - 1]) return true;\n                    if (stoneSet.Contains(nextStone)) {\n                        if (!dp.ContainsKey(nextStone)) {\n                            dp[nextStone] = new HashSet<int>();\n                        }\n                        dp[nextStone].Add(k);\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} stones\n * @return {boolean}\n */\nconst canCross = (stones) => {\n    const dp = Array(stones.length).fill().map(() => Array(stones.length).fill(false));\n    dp[0][0] = true;\n    \n    for (let i = 1; i < stones.length; i++) {\n        for (let j = i - 1; j >= 0; j--) {\n            const jump = stones[i] - stones[j];\n            if (jump > j + 1) break;\n            \n            if (jump <= i) {\n                dp[i][jump] = dp[j][jump - 1] || dp[j][jump] || dp[j][jump + 1]; \n                if (i === stones.length - 1 && dp[i][jump]) return true;\n            }\n        }\n    }\n    \n    return false;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function canCross(stones: number[]): boolean {\n    const dp: Set<number>[] = stones.map(() => new Set());\n    dp[0].add(0);\n\n    for (let i = 0; i < stones.length; i++) {\n        for (const k of dp[i]) {\n            for (let j = i + 1; j < stones.length; j++) {\n                const gap = stones[j] - stones[i];\n                if (gap >= k - 1 && gap <= k + 1) {\n                    dp[j].add(gap);\n                }\n            }\n        }\n    }\n\n    return dp[stones.length - 1].size > 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $stones\n     * @return Boolean\n     */\n    function canCross($stones) {\n        $n = count($stones);\n        $dp = array_fill(0, $n, array());\n        $dp[0][0] = true;\n\n        for ($i = 1; $i < $n; $i++) {\n            for ($j = $i - 1; $j >= 0; $j--) {\n                $diff = $stones[$i] - $stones[$j];\n                if ($diff > $j + 1) break;\n                if (isset($dp[$j][$diff]) || isset($dp[$j][$diff - 1]) || isset($dp[$j][$diff + 1])) {\n                    $dp[$i][$diff] = true;\n                    if ($i == $n - 1) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func canCross(_ stones: [Int]) -> Bool {\n        var dp = [Int: Set<Int>]()\n        \n        for stone in stones {\n            dp[stone] = Set<Int>()\n        }\n        dp[0]!.insert(0)\n        \n        for i in 0..<stones.count {\n            let stone = stones[i]\n            for k in dp[stone]! {\n                for step in -1...1 {\n                    if step + k > 0, let next = dp[stone + step + k] {\n                        dp[stone + step + k]!.insert(step + k)\n                    }\n                }\n            }\n        }\n        \n        return !dp[stones.last!]!.isEmpty\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun canCross(stones: IntArray): Boolean {\n        val map = HashMap<Int, HashSet<Int>>()\n        for (stone in stones) {\n            map[stone] = HashSet()\n        }\n        \n        map[0]!!.add(0)\n        \n        for (i in stones.indices) {\n            val positions = map[stones[i]]!!\n            for (k in positions) {\n                for (step in -1..1) {\n                    if (step + k > 0 && map.containsKey(stones[i] + step + k)) {\n                        map[stones[i] + step + k]!!.add(step + k)\n                    }\n                }\n            }\n        }\n        \n        return map[stones.last()]!!.isNotEmpty()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  bool canCross(List<int> stones) {\n    // Check if the stones list is empty or has a stone at the second position\n    if (stones.isEmpty || stones[1] != 1) {\n      return false;\n    }\n    \n    // Create a set to store all stones positions for faster lookup\n    Set<int> stoneSet = stones.toSet();\n    \n    // Use a recursive helper function to simulate frog jumps\n    return canCrossHelper(stoneSet, 1, 1, stones.last);\n  }\n  \n  bool canCrossHelper(Set<int> stoneSet, int position, int jumpSize, int target) {\n    // Check if the landing position is the target stone\n    if (position == target) {\n      return true;\n    }\n    \n    // Loop through the possible next jump sizes\n    for (int nextJump = jumpSize - 1; nextJump <= jumpSize + 1; nextJump++) {\n      if (nextJump > 0 && stoneSet.contains(position + nextJump)) {\n        // Recursively check if the frog can reach the target stone from the next position\n        if (canCrossHelper(stoneSet, position + nextJump, nextJump, target)) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func canCross(stones []int) bool {\n    n := len(stones)\n    dp := make([]map[int]bool, n)\n    for i := range dp {\n        dp[i] = make(map[int]bool)\n    }\n\n    dp[0][0] = true\n\n    for i := 1; i < n; i++ {\n        for j := 0; j < i; j++ {\n            k := stones[i] - stones[j]\n            if k <= i {\n                if dp[j][k-1] || dp[j][k] || dp[j][k+1] {\n                    dp[i][k] = true\n                }\n            }\n        }\n    }\n\n    return len(dp[n-1]) > 0\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} stones\n# @return {Boolean}\ndef can_cross(stones)\n    dp = Hash.new { |h, k| h[k] = Hash.new(false) }\n    dp[0][0] = true\n    (1...stones.length).each do |i|\n        (0...i).each do |j|\n            dist = stones[i] - stones[j]\n            dp[i][dist] = dp[j][dist - 1] || dp[j][dist] || dp[j][dist + 1]\n        end\n    end\n    !dp[stones.length - 1].select { |k, v| v }.empty?\nend"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def canCross(stones: Array[Int]): Boolean = {\n        val map = collection.mutable.HashMap[Int, collection.mutable.HashSet[Int]]()\n        stones.foreach(map(_) = collection.mutable.HashSet[Int]())\n        map(0).add(0)\n\n        stones.foreach { stone =>\n            map(stone).foreach { step =>\n                for (s <- step - 1 to step + 1 if s > 0 && map.contains(stone + s))\n                    map(stone + s).add(s)\n            }\n        }\n\n        map(stones.last).nonEmpty\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to determine if the frog can successfully cross the river by landing on the last stone given the set of restrictions. This can be done by dynamically tracking the possible jumps the frog can make at each stone.\n\nHere\u2019s how you can approach the solution:\n\n### # Explanation\n\n1. Start by setting up a dictionary to store the stones and the possible jumps that can land on those stones.\n2. Initialize the first stone with a jump of 0 (as the frog starts at the first stone without making a jump).\n3. Iterate through each stone and the potential jumps that can land on that stone.\n4. For each possible jump length from the current stone, check all possible next moves (jump - 1, jump, jump + 1).\n5. If the jump lands on another stone, update the dictionary to include this stone and the jump.\n6. At the end of the iteration, check if there are any jumps that can land on the last stone. If yes, the frog can cross the river; otherwise, it cannot.\n\n### # Pseudocode\n\n```plaintext\nfunction canCross(stones):\n    if stones is empty:\n        return False\n    \n    # Initialize dp dictionary\n    dp = {}\n    for each stone in stones:\n        dp[stone] = set()\n    \n    # Initial jump at the first stone\n    dp[0].add(0)\n    \n    # Iterate over each stone\n    for each stone in stones:\n        for each step in dp[stone]:\n            for move in range(step - 1, step + 2):\n                if move > 0 and (stone + move) in dp:\n                    dp[stone + move].add(move)\n    \n    # Check if last stone has any jumps in dp\n    return len(dp[stones[-1]]) > 0\n```\n\nIn this pseudocode:\n\n- We start by checking if the input list of stones is empty.\n- A dictionary `dp` is initialized to store the stones and the possible jumps that can land there.\n- Set the initial condition where the frog starts on the first stone.\n- Iterate through each stone, and for each jump that can reach that stone, calculate the possible next jumps.\n- Update the dictionary with new stones that can be reached with the calculated jumps.\n- Finally, check if the last stone has any jumps recorded in the dictionary. If it does, return `true` indicating the frog can cross; otherwise, return `false`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-frog-jump"
    },
    {
        "name": "Remove K Digits",
        "site": "LeetCode",
        "href": "/solution/LeetCode-remove-k-digits",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string removeKdigits(string num, int k) {\n        string result = \"\";\n        int keep = num.size() - k;\n        \n        for (char &c : num) {\n            while (k && result.size() && result.back() > c) {\n                result.pop_back();\n                k--;\n            }\n            result.push_back(c);\n        }\n        \n        result.resize(keep);\n        \n        while (!result.empty() && result[0] == '0') {\n            result.erase(0, 1);\n        }\n        \n        return result.empty() ? \"0\" : result;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        if (k == num.length()) {\n            return \"0\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : num.toCharArray()) {\n            while (k > 0 && !stack.isEmpty() && stack.peek() > c) {\n                stack.pop();\n                k--;\n            }\n            stack.push(c);\n        }\n\n        while (k > 0) {\n            stack.pop();\n            k--;\n        }\n\n        while (!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n        }\n\n        while (sb.length() > 1 && sb.charAt(0) == '0') {\n            sb.deleteCharAt(0);\n        }\n\n        return sb.toString();\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def removeKdigits(self, num, k):\n        stack = []\n        \n        for digit in num:\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n        \n        while k > 0:\n            stack.pop()\n            k -= 1\n        \n        result = \"\".join(stack).lstrip(\"0\")\n        \n        if not result:\n            return \"0\"\n        \n        return result"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "char* removeKdigits(char* num, int k) {\n    int len = strlen(num);\n    \n    if (len == k) {\n        char* res = (char*)malloc(2 * sizeof(char));\n        res[0] = '0';\n        res[1] = '\\0';\n        return res;\n    }\n    \n    int top = 0;\n    char stack[len];\n    \n    for (int i = 0; i < len; i++) {\n        while (k > 0 && top > 0 && stack[top - 1] > num[i]) {\n            top--;\n            k--;\n        }\n        stack[top++] = num[i];\n    }\n    \n    while (k > 0) {\n        top--;\n        k--;\n    }\n    \n    while (top > 0 && stack[0] == '0') {\n        for (int i = 0; i < top - 1; i++) {\n            stack[i] = stack[i + 1];\n        }\n        top--;\n    }\n    \n    if (top == 0) {\n        char* res = (char*)malloc(2 * sizeof(char));\n        res[0] = '0';\n        res[1] = '\\0';\n        return res;\n    } else {\n        char* res = (char*)malloc((top + 1) * sizeof(char));\n        for (int i = 0; i < top; i++) {\n            res[i] = stack[i];\n        }\n        res[top] = '\\0';\n        return res;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} num\n * @param {number} k\n * @return {string}\n */\nvar removeKdigits = function(num, k) {\n    const stack = [];\n    let count = 0;\n    \n    for (let i = 0; i < num.length; i++) {\n        while (stack.length && num[i] < stack[stack.length - 1] && count < k) {\n            stack.pop();\n            count++;\n        }\n        stack.push(num[i]);\n    }\n    \n    while (count < k) {\n        stack.pop();\n        count++;\n    }\n    \n    while (stack[0] === '0') {\n        stack.shift();\n    }\n    \n    return stack.length ? stack.join('') : '0';\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function removeKdigits(num: string, k: number): string {\n    const stack: string[] = [];\n    \n    for (let digit of num) {\n        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > digit) {\n            stack.pop();\n            k--;\n        }\n        stack.push(digit);\n    }\n    \n    while (k > 0) {\n        stack.pop();\n        k--;\n    }\n    \n    // Remove leading zeros\n    while (stack.length > 1 && stack[0] === '0') {\n        stack.shift();\n    }\n    \n    return stack.join('') || '0';\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $num\n     */\n    function removeKdigits($num, $k) {\n        $stack = [];\n        \n        for ($i = 0; $i < strlen($num); $i++) {\n            $digit = $num[$i];\n            while ($k > 0 && !empty($stack) && $stack[count($stack) - 1] > $digit) {\n                array_pop($stack);\n                $k--;\n            }\n            array_push($stack, $digit);\n        }\n        \n        while ($k > 0) {\n            array_pop($stack);\n            $k--;\n        }\n        \n        $result = ltrim(implode('', $stack), '0');\n        \n        return $result === '' ? '0' : $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func removeKdigits(_ num: String, _ k: Int) -> String {\n        var k = k\n        var stack = [Character]()\n        \n        for digit in num {\n            while k > 0 && !stack.isEmpty && stack.last! > digit {\n                stack.removeLast()\n                k -= 1\n            }\n            stack.append(digit)\n        }\n        \n        while k > 0 {\n            stack.removeLast()\n            k -= 1\n        }\n        \n        // Remove leading zeros\n        while !stack.isEmpty && stack.first! == \"0\" {\n            stack.removeFirst()\n        }\n        \n        return stack.isEmpty ? \"0\" : String(stack)\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String removeKdigits(String num, int k) {\n    List<String> stack = [];\n    \n    for (int i = 0; i < num.length; i++) {\n      String digit = num[i];\n      \n      while (k > 0 && stack.isNotEmpty && int.parse(stack.last) > int.parse(digit)) {\n        stack.removeLast();\n        k--;\n      }\n      \n      stack.add(digit);\n    }\n    \n    for (int i = 0; i < k; i++) {\n      stack.removeLast();\n    }\n    \n    String result = stack.join().replaceAll(RegExp('^0+'), '');\n    \n    return result.isEmpty ? '0' : result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func removeKdigits(num string, k int) string {\n    stack := []rune{}\n    \n    for _, digit := range num {\n        for k > 0 && len(stack) > 0 && stack[len(stack)-1] > digit {\n            stack = stack[:len(stack)-1]\n            k--\n        }\n        \n        if len(stack) > 0 || digit != '0' {\n            stack = append(stack, digit)\n        }\n    }\n    \n    for k > 0 && len(stack) > 0 {\n        stack = stack[:len(stack)-1]\n        k--\n    }\n    \n    if len(stack) == 0 {\n        return \"0\"\n    }\n    \n    return string(stack)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} num\n# @param {Integer} k\n# @return {String}\ndef remove_kdigits(num, k)\n    stack = []\n    \n    num.each_char do |digit|\n        while k > 0 && !stack.empty? && stack[-1] > digit\n            stack.pop\n            k -= 1\n        end\n        stack << digit\n    end\n    \n    stack.pop(k)\n    \n    result = stack.join(\"\").sub(/^0+/, \"\")\n    \n    result.empty? ? \"0\" : result\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to devise a strategy that enables us to remove `k` digits from the given number `num` to form the smallest possible integer. Below is the step-by-step explanation followed by pseudocode.\n\n# Explanation\n1. **Initialize a Stack**: We'll use a stack to keep track of the digits of the smallest possible number.\n2. **Iteration and Comparison**: Traverse through each digit of the given number `num`. For each digit, while there are digits in the stack and we can remove more digits (i.e., `k > 0`), compare the current digit with the top of the stack.\n    - If the current digit is smaller than the top of the stack, pop the stack (remove the top digit) and decrement `k`.\n    - This ensures that the larger digits are removed to make the number smallest.\n3. **Add Current Digit**: Append the current digit to the stack.\n4. **Remove Remaining Digits**: If `k` is still greater than 0 after the traversal, remove additional digits from the top of the stack to account for the remaining `k`.\n5. **Form the Result**: Combine the digits in the stack to form the resulting number and strip any leading zeros.\n6. **Handle Special Case**: If the resultant number is empty, return \"0\".\n\n# Pseudocode\n```\n# Initialize an empty stack to hold the digits of the smallest number\nstack = []\n\n# Iterate over each digit in the input number `num`\nfor each digit in num:\n    # While `k` is greater than 0 and the stack is not empty and the last digit in the stack is greater than the current digit\n    while k > 0 and stack is not empty and stack[-1] > digit:\n        # Pop the top digit from the stack (remove it)\n        stack.pop()\n        # Decrement `k` by 1\n        k -= 1\n    # Push the current digit onto the stack\n    stack.append(digit)\n\n# If there are still digits to remove (k > 0), remove them from the top of the stack\nwhile k > 0:\n    stack.pop()\n    k -= 1\n\n# Combine the remaining digits in the stack and remove any leading zeros\nresult = \"\".join(stack).lstrip(\"0\")\n\n# If the result is an empty string, return \"0\"\nif result is empty:\n    return \"0\"\n\n# Return the resultant smallest number\nreturn result\n```\n\nThis approach ensures that we get the smallest possible number after removing `k` digits by using a greedy strategy combined with a stack-based approach to efficiently track and remove the necessary digits.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-remove-k-digits"
    },
    {
        "name": "Binary Watch",
        "site": "LeetCode",
        "href": "/solution/LeetCode-binary-watch",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> result;\n        for(int h = 0; h < 12; ++h) {\n            bitset<4> hourBits(h);\n            for(int m = 0; m < 60; ++m) {\n                bitset<6> minuteBits(m);\n                if(hourBits.count() + minuteBits.count() == turnedOn) {\n                    string time = to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m);\n                    result.push_back(time);\n                }\n            }\n        }\n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int h = 0; h < 12; h++) {\n            for (int m = 0; m < 60; m++) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                    res.add(String.format(\"%d:%02d\", h, m));\n                }\n            }\n        }\n        return res;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        return [\"{0}:{1:02d}\".format(h, m) for h in range(12) for m in range(60) if (bin(h) + bin(m)).count('1') == turnedOn]"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<string> ReadBinaryWatch(int turnedOn) {\n        List<string> result = new List<string>();\n        \n        for (int hour = 0; hour < 12; hour++) {\n            for (int minute = 0; minute < 60; minute++) {\n                if (Convert.ToString(hour, 2).Count(c => c == '1') + Convert.ToString(minute, 2).Count(c => c == '1') == turnedOn) {\n                    result.Add(hour + \":\" + (minute < 10 ? \"0\" + minute : minute.ToString()));\n                }\n            }\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} turnedOn\n * @return {string[]}\n */\nvar readBinaryWatch = function(turnedOn) {\n    const result = [];\n    \n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (h.toString(2).split('0').join('').length + m.toString(2).split('0').join('').length === turnedOn) {\n                result.push(`${h}:${m < 10 ? '0' + m : m}`);\n            }\n        }\n    }\n    \n    return result;\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function readBinaryWatch(turnedOn: number): string[] {\n    const result: string[] = [];\n    \n    for (let i = 0; i < 12; i++) {\n        for (let j = 0; j < 60; j++) {\n            if (i.toString(2).split('0').join('').length + j.toString(2).split('0').join('').length === turnedOn) {\n                result.push(i + ':' + (j < 10 ? '0' + j : j));\n            }\n        }\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $turnedOn\n     */\n    function readBinaryWatch($turnedOn) {\n        $result = [];\n        for ($h = 0; $h < 12; $h++) {\n            for ($m = 0; $m < 60; $m++) {\n                if (substr_count(decbin($h) . decbin($m), '1') === $turnedOn) {\n                    $result[] = sprintf(\"%d:%02d\", $h, $m);\n                }\n            }\n        }\n        return $result;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func readBinaryWatch(_ turnedOn: Int) -> [String] {\n        var result = [String]()\n        for i in 0..<12 {\n            for j in 0..<60 {\n                if i.nonzeroBitCount + j.nonzeroBitCount == turnedOn {\n                    result.append(\"\\(i):\" + String(format: \"%02d\", j))\n                }\n            }\n        }\n        return result\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun readBinaryWatch(turnedOn: Int): List<String> {\n        val result = mutableListOf<String>()\n        for (i in 0 until 12) {\n            for (j in 0 until 60) {\n                if (Integer.bitCount(i) + Integer.bitCount(j) == turnedOn) {\n                    result.add(\"$i:${if (j < 10) \"0$j\" else j}\")\n                }\n            }\n        }\n        return result\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<String> readBinaryWatch(int turnedOn) {\n    List<String> result = [];\n\n    for (int h = 0; h < 12; h++) {\n      for (int m = 0; m < 60; m++) {\n        if (h.toRadixString(2).split('1').length - 1 + m.toRadixString(2).split('1').length - 1 == turnedOn) {\n          result.add('$h:${m < 10 ? '0$m' : m}');\n        }\n      }\n    }\n\n    return result;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func readBinaryWatch(turnedOn int) []string {\n    result := []string{}\n    for i := 0; i < 12; i++ {\n        for j := 0; j < 60; j++ {\n            if countBits(i)+countBits(j) == turnedOn {\n                result = append(result, fmt.Sprintf(\"%d:%02d\", i, j))\n            }\n        }\n    }\n    return result\n}\n\nfunc countBits(num int) int {\n    count := 0\n    for num > 0 {\n        count += num & 1\n        num >>= 1\n    }\n    return count\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} turned_on\n# @return {String[]}\ndef read_binary_watch(turned_on)\n    result = []\n    (0..11).each do |h|\n        (0..59).each do |m|\n            if h.to_s(2).count(\"1\") + m.to_s(2).count(\"1\") == turned_on\n                result << \"#{h}:#{m.to_s.rjust(2, \"0\")}\"\n            end\n        end\n    end\n    result\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def readBinaryWatch(turnedOn: Int): List[String] = {\n        (0 to 11).flatMap(h => (0 to 59).filter(m => Integer.bitCount(h) + Integer.bitCount(m) == turnedOn).map(m => s\"$h:${if (m < 10) \"0\" else \"\"}$m\")).toList\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate all possible times that a binary watch can represent given a certain number of LEDs that are turned on. We need to consider the constraints for both hours (0-11) and minutes (0-59) and ensure that each valid time adheres to the required formatting.\n\n# Explanation\n\n1. **Understand the Watch Layout**: The binary watch consists of 4 LEDs for the hour (0 to 11) and 6 LEDs for the minutes (0 to 59).\n\n2. **LED Count**: We are given `turnedOn`, which indicates the total number of LEDs that are currently on. We need to find all valid hour and minute combinations that use exactly this many LEDs.\n\n3. **Binary Representation**: We will use Python\u2019s built-in `bin()` function to convert numbers to their binary representation. The number of '1's in the binary representation indicates how many LEDs are on.\n\n4. **Nested Loops**: We can use two nested loops to iterate through all possible hours and minutes, checking in each iteration if the total number of LEDs in the binary representation matches `turnedOn`.\n\n5. **Formatting**: Ensure that minutes are always formatted with two digits (e.g., \"02\" instead of \"2\").\n\n6. **Return the Results**: Collect all valid combinations and return them as a list of formatted strings.\n\n# Pseudocode\n\n```\nfunction readBinaryWatch(turnedOn):\n\n    def generate_possible_times(turnedOn):\n        results = []\n        for hour in range(12):\n            for minute in range(60):\n                if count_set_bits(hour) + count_set_bits(minute) == turnedOn:\n                    formatted_time = format_time(hour, minute)\n                    results.append(formatted_time)\n        return results\n\n    def count_set_bits(number):\n        return bin(number).count('1')\n\n    def format_time(hour, minute):\n        return f\"{hour}:{minute:02d}\"\n\n    return generate_possible_times(turnedOn)\n```\n\nIn this pseudocode:\n- We define the main function `readBinaryWatch` which handles the generation and formatting of possible times.\n- Inside this, `generate_possible_times` iterates through all combinations of hours and minutes.\n- The helper function `count_set_bits` counts the number of LEDs (bits) that are on in the binary representation of a given number.\n- The helper function `format_time` ensures that the time is correctly formatted according to the constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-binary-watch"
    },
    {
        "name": "Nth Digit",
        "site": "LeetCode",
        "href": "/solution/LeetCode-nth-digit",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findNthDigit(int n) {\n        long len = 1, count = 9, start = 1;\n        while (n > len * count) {\n            n -= len * count;\n            len++;\n            count *= 10;\n            start *= 10;\n        }\n        start += (n - 1) / len;\n        string s = to_string(start);\n        return s[(n - 1) % len] - '0';\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findNthDigit(int n) {\n        int len = 1;\n        long count = 9;\n        int start = 1;\n        \n        while (n > len * count) {\n            n -= len * count;\n            len++;\n            count *= 10;\n            start *= 10;\n        }\n        \n        start += (n - 1) / len;\n        String s = Integer.toString(start);\n        return Character.getNumericValue(s.charAt((n - 1) % len));\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findNthDigit(self, n):\n        if n < 10:\n            return n\n        n -= 1\n        length = 1\n        count = 9\n        while n > length * count:\n            n -= length * count\n            length += 1\n            count *= 10\n        \n        num = 10 ** (length - 1) + n // length\n        return int(str(num)[n % length])"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int findNthDigit(int n) {\n    long len = 1, count = 9, start = 1;\n\n    while (n > len * count) {\n        n -= len * count;\n        len += 1;\n        count *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / len;\n    int digit = (start / (int)pow(10, (len - 1 - (n - 1) % len))) % 10;\n    \n    return digit;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindNthDigit(int n) {\n        int length = 1;\n        long count = 9;\n        int start = 1;\n\n        while (n > length * count) {\n            n -= length * (int)count;\n            length++;\n            count *= 10;\n            start *= 10;\n        }\n\n        start += (n - 1) / length;\n        string s = start.ToString();\n        return s[(n - 1) % length] - '0';\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar findNthDigit = function(n) {\n    let len = 1;\n    let start = 1;\n    let count = 9;\n    \n    while (n > len * count) {\n        n -= len * count;\n        len++;\n        start *= 10;\n        count *= 10;\n    }\n    \n    start += Math.floor((n - 1) / len);\n    const str = start.toString();\n    return +str[(n - 1) % len];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findNthDigit(n: number): number {\n    let len = 1;\n    let count = 9;\n    let start = 1;\n\n    while (n > len * count) {\n        n -= len * count;\n        len++;\n        count *= 10;\n        start *= 10;\n    }\n\n    start += Math.ceil(n / len) - 1;\n    const s = start.toString();\n    return parseInt(s.charAt((n - 1) % len));\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function findNthDigit($n) {\n        $len = 1;\n        $count = 9;\n        $start = 1;\n        \n        while ($n > $len * $count) {\n            $n -= $len * $count;\n            $len++;\n            $count *= 10;\n            $start *= 10;\n        }\n        \n        $num = $start + intval(($n - 1) / $len);\n        $pos = ($n - 1) % $len;\n        \n        return intval(strval($num)[$pos]);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findNthDigit(_ n: Int) -> Int {\n        var n = n\n        var len = 1\n        var count = 9\n        var start = 1\n\n        while n > len * count {\n            n -= len * count\n            len += 1\n            count *= 10\n            start *= 10\n        }\n\n        start += (n - 1) / len\n        let s = String(start)\n        let index = (n - 1) % len\n        return Int(String(s[s.index(s.startIndex, offsetBy: Int(index))]))!\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int findNthDigit(int n) {\n    int len = 1;\n    int start = 1;\n    int count = 9;\n\n    while (n > len * count) {\n      n -= len * count;\n      len++;\n      start *= 10;\n      count *= 10;\n    }\n\n    start += (n - 1) ~/ len;\n    return int.parse(start.toString().substring((n - 1) % len, (n - 1) % len + 1));\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findNthDigit(n int) int {\n    if n < 10 {\n        return n\n    }\n    \n    base := 1\n    digits := 1\n    for n > 9*base*digits {\n        n -= 9 * base * digits\n        base *= 10\n        digits++\n    }\n    \n    num := base + (n-1)/digits\n    index := (n - 1) % digits\n    return int(strconv.Itoa(num)[index] - '0')\n}"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} n\n# @return {Integer}\ndef find_nth_digit(n)\n    n -= 1\n    digits = 1\n    while n > 9 * 10 ** (digits - 1) * digits\n        n -= 9 * 10 ** (digits - 1) * digits\n        digits += 1\n    end\n    num = 10 ** (digits - 1) + n / digits\n    return num.to_s[n % digits].to_i\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to identify the nth digit in an infinite sequence of integers that starts with 1 and goes on indefinitely. \n\n# Explanation\n\nHere's a step-by-step breakdown of the approach to solve the problem:\n\n1. **Immediate Return for Single-Digit Cases**:\n   - If \\( n \\) is less than 10, the digit itself is \\( n \\).\n   \n2. **Adjust \\( n \\)**:\n   - Decrease \\( n \\) by 1 to handle zero-based indexing.\n\n3. **Determine the Length of Numbers Contributing to the nth Digit**:\n   - Start with `length` as 1 (indicating single-digit numbers) and `count` as 9 (since there are 9 single-digit numbers).\n   - In a loop, check if `n` exceeds the total number of digits contributed by numbers of the current length.\n   - When `n` is larger, reduce `n` by the number of digits considered (`length * count`), increment `length` and update `count` to represent the number of digits in the next set of numbers.\n\n4. **Identify the Exact Number and Digit**:\n   - Calculate the exact number that contains the nth digit using \\( \\text{num} = 10^{(\\text{length} - 1)} + \\frac{n}{\\text{length}} \\).\n   - Extract the digit using the string representation of the number.\n\n# Pseudocode\n\n```plaintext\nfunction findNthDigit(n):\n    if n < 10:\n        return n\n    \n    n -= 1\n    length = 1\n    count = 9\n    \n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n    \n    num = 10 ^ (length - 1) + (n // length)\n    \n    return int(str(num)[n % length])\n```\n\nThis pseudocode follows the outlined approach to compute the nth digit efficiently without generating the entire sequence, making it suitable for large values of \\( n \\).",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-nth-digit"
    },
    {
        "name": "Evaluate Division",
        "site": "LeetCode",
        "href": "/solution/LeetCode-evaluate-division",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        unordered_map<string, unordered_map<string, double>> graph;\n        for (int i = 0; i < equations.size(); ++i) {\n            graph[equations[i][0]][equations[i][1]] = values[i];\n            graph[equations[i][1]][equations[i][0]] = 1.0 / values[i];\n        }\n        \n        vector<double> result;\n        for (const auto& query : queries) {\n            unordered_set<string> visited;\n            double res = dfs(query[0], query[1], graph, visited);\n            result.push_back(res);\n        }\n        \n        return result;\n    }\n    \n    double dfs(string start, string end, unordered_map<string, unordered_map<string, double>>& graph, unordered_set<string>& visited) {\n        if (graph.find(start) == graph.end() || visited.count(start)) {\n            return -1.0;\n        }\n        if (start == end) {\n            return 1.0;\n        }\n        \n        visited.insert(start);\n        for (const auto& neighbor : graph[start]) {\n            if (visited.count(neighbor.first)) {\n                continue;\n            }\n            double temp = dfs(neighbor.first, end, graph, visited);\n            if (temp != -1.0) {\n                return temp * neighbor.second;\n            }\n        }\n        \n        return -1.0;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "import java.util.*;\n\nclass Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        Map<String, Map<String, Double>> graph = new HashMap<>();\n        \n        for (int i = 0; i < equations.size(); i++) {\n            String a = equations.get(i).get(0);\n            String b = equations.get(i).get(1);\n            double val = values[i];\n            \n            graph.putIfAbsent(a, new HashMap<>());\n            graph.get(a).put(b, val);\n            \n            graph.putIfAbsent(b, new HashMap<>());\n            graph.get(b).put(a, 1.0 / val);\n        }\n        \n        double[] result = new double[queries.size()];\n        for (int i = 0; i < queries.size(); i++) {\n            result[i] = dfs(queries.get(i).get(0), queries.get(i).get(1), graph, new HashSet<>());\n        }\n        \n        return result;\n    }\n    \n    private double dfs(String start, String end, Map<String, Map<String, Double>> graph, Set<String> visited) {\n        if (!graph.containsKey(start) || !graph.containsKey(end)) {\n            return -1.0;\n        }\n        if (start.equals(end)) {\n            return 1.0;\n        }\n        \n        visited.add(start);\n        for (Map.Entry<String, Double> neighbor : graph.get(start).entrySet()) {\n            if (!visited.contains(neighbor.getKey())) {\n                double result = dfs(neighbor.getKey(), end, graph, visited);\n                if (result != -1.0) {\n                    return neighbor.getValue() * result;\n                }\n            }\n        }\n        \n        return -1.0;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def calcEquation(self, equations, values, queries):\n        graph = {}\n        for (dividend, divisor), value in zip(equations, values):\n            if dividend not in graph:\n                graph[dividend] = {}\n            if divisor not in graph:\n                graph[divisor] = {}\n            graph[dividend][divisor] = value\n            graph[divisor][dividend] = 1 / value\n        \n        def dfs(start, end, visited):\n            if start not in graph or end not in graph:\n                return -1.0\n            if start == end:\n                return 1.0\n            visited.add(start)\n            for neighbor in graph[start]:\n                if neighbor not in visited:\n                    result = dfs(neighbor, end, visited)\n                    if result != -1.0:\n                        return result * graph[start][neighbor]\n            visited.remove(start)\n            return -1.0\n        \n        results = []\n        for dividend, divisor in queries:\n            results.append(dfs(dividend, divisor, set()))\n        \n        return results\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public double[] CalcEquation(IList<IList<string>> equations, double[] values, IList<IList<string>> queries) {\n        Dictionary<string, Dictionary<string, double>> graph = new Dictionary<string, Dictionary<string, double>>();\n        for (int i = 0; i < equations.Count; i++) {\n            string dividend = equations[i][0];\n            string divisor = equations[i][1];\n            double quotient = values[i];\n\n            if (!graph.ContainsKey(dividend)) {\n                graph[dividend] = new Dictionary<string, double>();\n            }\n            if (!graph.ContainsKey(divisor)) {\n                graph[divisor] = new Dictionary<string, double>();\n            }\n\n            graph[dividend].Add(divisor, quotient);\n            graph[divisor].Add(dividend, 1 / quotient);\n        }\n\n        double[] results = new double[queries.Count];\n        for (int i = 0; i < queries.Count; i++) {\n            string dividend = queries[i][0];\n            string divisor = queries[i][1];\n            if (!graph.ContainsKey(dividend) || !graph.ContainsKey(divisor)) {\n                results[i] = -1.0;\n            } else {\n                HashSet<string> visited = new HashSet<string>();\n                results[i] = Dfs(graph, dividend, divisor, 1.0, visited);\n            }\n        }\n\n        return results;\n    }\n\n    private double Dfs(Dictionary<string, Dictionary<string, double>> graph, string start, string end, double current, HashSet<string> visited) {\n        if (start == end) {\n            return current;\n        }\n        visited.Add(start);\n\n        foreach (var neighbor in graph[start]) {\n            if (!visited.Contains(neighbor.Key)) {\n                double result = Dfs(graph, neighbor.Key, end, current * neighbor.Value, visited);\n                if (result != -1.0) {\n                    return result;\n                }\n            }\n        }\n\n        return -1.0;\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var calcEquation = function(equations, values, queries) {\n    const graph = new Map();\n    const weight = new Map();\n    \n    for(let i = 0; i < equations.length; i++) {\n        const [a, b] = equations[i];\n        if(!graph.has(a)) {\n            graph.set(a, new Map());\n            weight.set(a, new Map());\n        }\n        if(!graph.has(b)) {\n            graph.set(b, new Map());\n            weight.set(b, new Map());\n        }\n        graph.get(a).set(b, values[i]);\n        graph.get(b).set(a, 1 / values[i]);\n        weight.get(a).set(b, values[i]);\n        weight.get(b).set(a, 1 / values[i]);\n    }\n    \n    const dfs = (curr, target, visited) => {\n        if(curr === target) return 1.0;\n        if(visited.has(curr)) return -1.0;\n        \n        visited.add(curr);\n        \n        const neighbors = graph.get(curr);\n        for(const neighbor of neighbors.keys()) {\n            const value = neighbors.get(neighbor);\n            const result = dfs(neighbor, target, visited);\n            if(result !== -1.0) {\n                const w = weight.get(curr).get(neighbor);\n                return w * result;\n            }\n        }\n        \n        return -1.0;\n    };\n    \n    const results = [];\n    for(const [src, dest] of queries) {\n        if(!graph.has(src) || !graph.has(dest)) {\n            results.push(-1.0);\n        } else {\n            results.push(dfs(src, dest, new Set()));\n        }\n    }\n    \n    return results;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function calcEquation(equations: string[][], values: number[], queries: string[][]): number[] {\n    const graph = new Map<string, Map<string, number>>();\n    \n    for (let i = 0; i < equations.length; i++) {\n        const [a, b] = equations[i];\n        const val = values[i];\n        \n        if (!graph.has(a)) graph.set(a, new Map());\n        if (!graph.has(b)) graph.set(b, new Map());\n        \n        graph.get(a)!.set(b, val);\n        graph.get(b)!.set(a, 1 / val);\n    }\n    \n    const dfs = (curr: string, target: string, visited: Set<string>): number => {\n        if (!graph.has(curr)) return -1;\n        if (curr === target) return 1;\n        \n        visited.add(curr);\n        \n        for (const [neighbor, val] of graph.get(curr)!) {\n            if (visited.has(neighbor)) continue;\n            \n            const result = dfs(neighbor, target, visited);\n            if (result !== -1) {\n                return val * result;\n            }\n        }\n        \n        return -1;\n    };\n    \n    const result: number[] = [];\n    \n    for (const [dividend, divisor] of queries) {\n        result.push(dfs(dividend, divisor, new Set<string>()));\n    }\n    \n    return result;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String[][] $equations\n     * @param Float[] $values\n     * @param String[][] $queries\n     * @return Float[]\n     */\n    function calcEquation($equations, $values, $queries) {\n        $graph = [];\n        for ($i = 0; $i < count($equations); $i++) {\n            list($dividend, $divisor) = $equations[$i];\n            $graph[$dividend][$divisor] = $values[$i];\n            $graph[$divisor][$dividend] = 1 / $values[$i];\n        }\n\n        $results = [];\n        foreach ($queries as $query) {\n            $results[] = $this->dfs($query[0], $query[1], $graph, []);\n        }\n\n        return $results;\n    }\n\n    function dfs($start, $end, $graph, $visited) {\n        if (!array_key_exists($start, $graph) || in_array($start, $visited)) {\n            return -1.0;\n        }\n\n        if ($start == $end) {\n            return 1.0;\n        }\n\n        $visited[] = $start;\n        foreach ($graph[$start] as $node => $value) {\n            $result = $this->dfs($node, $end, $graph, $visited);\n            if ($result != -1.0) {\n                return $value * $result;\n            }\n        }\n\n        return -1.0;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func calcEquation(_ equations: [[String]], _ values: [Double], _ queries: [[String]]) -> [Double] {\n        var graph = [String: [(String, Double)]]()\n        \n        for i in 0..<equations.count {\n            let (a, b) = (equations[i][0], equations[i][1])\n            let (value, reverseValue) = (values[i], 1 / values[i])\n            \n            if graph[a] == nil {\n                graph[a] = [(b, value)]\n            } else {\n                graph[a]?.append((b, value))\n            }\n            \n            if graph[b] == nil {\n                graph[b] = [(a, reverseValue)]\n            } else {\n                graph[b]?.append((a, reverseValue))\n            }\n        }\n        \n        func dfs(_ start: String, _ end: String, _ visited: inout Set<String>) -> Double? {\n            if start == end {\n                return 1.0\n            }\n            \n            visited.insert(start)\n            \n            if let neighbors = graph[start] {\n                for (neighbor, value) in neighbors {\n                    if !visited.contains(neighbor) {\n                        if let result = dfs(neighbor, end, &visited) {\n                            return result * value\n                        }\n                    }\n                }\n            }\n            \n            return nil\n        }\n        \n        var results = [Double]()\n        \n        for query in queries {\n            let (start, end) = (query[0], query[1])\n            \n            if graph[start] == nil || graph[end] == nil {\n                results.append(-1.0)\n            } else {\n                var visited = Set<String>()\n                if let result = dfs(start, end, &visited) {\n                    results.append(result)\n                } else {\n                    results.append(-1.0)\n                }\n            }\n        }\n        \n        return results\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun calcEquation(equations: List<List<String>>, values: DoubleArray, queries: List<List<String>>): DoubleArray {\n        val graph = mutableMapOf<String, MutableMap<String, Double>>()\n        for (i in equations.indices) {\n            val (from, to) = equations[i]\n            val value = values[i]\n            \n            graph.computeIfAbsent(from) { mutableMapOf() }[to] = value\n            graph.computeIfAbsent(to) { mutableMapOf() }[from] = 1 / value\n        }\n        \n        fun dfs(start: String, end: String, visited: MutableSet<String>): Double {\n            if (start !in graph || end !in graph) return -1.0\n            if (start == end) return 1.0\n            \n            visited.add(start)\n            val neighbors = graph[start] ?: return -1.0\n            for ((neighbor, value) in neighbors) {\n                if (neighbor == end) return value\n                if (neighbor !in visited) {\n                    val result = dfs(neighbor, end, visited)\n                    if (result != -1.0) {\n                        return value * result\n                    }\n                }\n            }\n            return -1.0\n        }\n        \n        return queries.map { query ->\n            val (start, end) = query\n            dfs(start, end, mutableSetOf())\n        }.toDoubleArray()\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    graph := make(map[string]map[string]float64)\n    for i, eq := range equations {\n        if _, ok := graph[eq[0]]; !ok {\n            graph[eq[0]] = make(map[string]float64)\n        }\n        if _, ok := graph[eq[1]]; !ok {\n            graph[eq[1]] = make(map[string]float64)\n        }\n        graph[eq[0]][eq[1]] = values[i]\n        graph[eq[1]][eq[0]] = 1.0 / values[i]\n    }\n\n    var dfs func(curr, dest string, visited map[string]bool) float64\n    dfs = func(curr, dest string, visited map[string]bool) float64 {\n        if _, ok := graph[curr]; !ok {\n            return -1.0\n        }\n        if curr == dest {\n            return 1.0\n        }\n        visited[curr] = true\n        for next, val := range graph[curr] {\n            if !visited[next] {\n                if res := dfs(next, dest, visited); res != -1.0 {\n                    return val * res\n                }\n            }\n        }\n        visited[curr] = false\n        return -1.0\n    }\n\n    results := make([]float64, len(queries))\n    for i, query := range queries {\n        results[i] = dfs(query[0], query[1], make(map[string]bool))\n    }\n    return results\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "def calc_equation(equations, values, queries)\n    graph = {}\n    \n    equations.each_with_index do |eq, idx|\n        a, b = eq\n        value = values[idx]\n        \n        graph[a] ||= {}\n        graph[b] ||= {}\n        \n        graph[a][b] = value\n        graph[b][a] = 1.0 / value\n    end\n    \n    result = []\n    \n    queries.each do |query|\n        result << dfs(query[0], query[1], 1.0, graph, Set.new)\n    end\n    \n    result\nend\n\ndef dfs(curr, target, product, graph, visited)\n    return -1.0 if !graph[curr] || visited.include?(curr)\n    return product if curr == target\n    \n    visited.add(curr)\n    \n    graph[curr].each do |neighbor, value|\n        result = dfs(neighbor, target, product * value, graph, visited)\n        return result if result != -1.0\n    end\n    \n    return -1.0\nend\n"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn calc_equation(equations: Vec<Vec<String>>, values: Vec<f64>, queries: Vec<Vec<String>>) -> Vec<f64> {\n        let mut graph: HashMap<String, HashMap<String, f64>> = HashMap::new();\n        \n        for i in 0..equations.len() {\n            let (a, b) = (&equations[i][0], &equations[i][1]);\n            let value = values[i];\n            \n            graph.entry(a.to_string()).or_insert(HashMap::new()).insert(b.to_string(), value);\n            graph.entry(b.to_string()).or_insert(HashMap::new()).insert(a.to_string(), 1.0 / value);\n        }\n        \n        let mut results = Vec::new();\n        \n        for query in queries {\n            let mut visited = HashMap::new();\n            let result = Self::dfs(&graph, &query[0], &query[1], 1.0, &mut visited);\n            results.push(result);\n        }\n        \n        results\n    }\n    \n    fn dfs(graph: &HashMap<String, HashMap<String, f64>>, start: &String, end: &String, value: f64, visited: &mut HashMap<String, bool>) -> f64 {\n        if let Some(edges) = graph.get(start) {\n            if start == end {\n                return value;\n            }\n            \n            visited.insert(start.clone(), true);\n            \n            for (next, edge_value) in edges.iter() {\n                if !visited.contains_key(next) {\n                    let result = Self::dfs(graph, next, end, value * edge_value, visited);\n                    if result != -1.0 {\n                        return result;\n                    }\n                }\n            }\n            \n            visited.remove(start);\n        }\n        \n        -1.0\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to evaluate the division results of given variable pairs using a graph structure and depth-first search (DFS). The challenge can be broken down into several steps: constructing the graph, performing DFS to compute the division results, and collecting the answers to the queries.\n\n# Explanation\n\n1. **Graph Construction**:\n   - Use a dictionary to represent the graph. Each key is a variable (like \"a\"), and its value is another dictionary representing the neighbor variables and their corresponding values. For instance, if the equation is \"a / b = 2.0\", then in the graph, `graph[\"a\"][\"b\"] = 2.0` and `graph[\"b\"][\"a\"] = 1/2.0`.\n\n2. **Depth-First Search (DFS)**:\n   - For each query, we use DFS to find the path from the numerator to the denominator. During the DFS traversal, we multiply the edge values to get the result of the division.\n   - If a path cannot be found, return `-1.0`.\n\n3. **Handling Queries**:\n   - Iterate over each query and perform DFS for each one.\n\n# Pseudocode\n\n```pseudo\nfunction calcEquation(equations, values, queries):\n    graph = {}\n    \n    # Construct the graph\n    for each equation (Ai, Bi) and corresponding value in equations and values:\n        if Ai not in graph:\n            graph[Ai] = {}\n        if Bi not in graph:\n            graph[Bi] = {}\n        graph[Ai][Bi] = value\n        graph[Bi][Ai] = 1 / value\n    \n    # Depth-First Search function\n    function dfs(start, end, visited):\n        if start not in graph or end not in graph:\n            return -1.0\n        if start == end:\n            return 1.0\n        \n        visited.add(start)\n        for each neighbor in graph[start]:\n            if neighbor not in visited:\n                result = dfs(neighbor, end, visited)\n                if result != -1.0:\n                    return result * graph[start][neighbor]\n        visited.remove(start)\n        return -1.0\n    \n    # Process each query\n    results = []\n    for each query (Cj, Dj) in queries:\n        results.append(dfs(Cj, Dj, set()))\n    \n    return results\n```\n\nThis pseudocode outlines the key steps in constructing the graph and performing the necessary DFS to handle the queries and compute their results. Each function is described clearly, with control structures for traversing and searching the graph effectively.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-evaluate-division"
    },
    {
        "name": "Implement Trie Prefix Tree",
        "site": "LeetCode",
        "href": "/solution/LeetCode-implement-trie-prefix-tree",
        "languages": [
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Trie {\n    private TrieNode root;\n\n    private static class TrieNode {\n        TrieNode[] children;\n        boolean isEnd;\n\n        TrieNode() {\n            children = new TrieNode[26];\n            isEnd = false;\n        }\n    }\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new TrieNode();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) {\n                return false;\n            }\n            node = node.children[index];\n        }\n        return node != null && node.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode node = root;\n        for (char c : prefix.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) {\n                return false;\n            }\n            node = node.children[index];\n        }\n        return node != null;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Trie(object):\n    def __init__(self):\n        self.root = {}\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node:\n                return False\n            node = node[char]\n        return True"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "typedef struct {\n    bool isEnd;\n    struct Trie* children[26];\n} Trie;\n\n/** Initialize your data structure here. */\n\nTrie* trieCreate() {\n    Trie* node = (Trie*)malloc(sizeof(Trie));\n    node->isEnd = false;\n    for (int i = 0; i < 26; i++) {\n        node->children[i] = NULL;\n    }\n    return node;\n}\n\n/** Inserts a word into the trie. */\nvoid trieInsert(Trie* obj, char * word) {\n    Trie* curr = obj;\n    while (*word) {\n        int index = *word - 'a';\n        if (curr->children[index] == NULL) {\n            curr->children[index] = trieCreate();\n        }\n        curr = curr->children[index];\n        word++;\n    }\n    curr->isEnd = true;\n}\n\n/** Returns if the word is in the trie. */\nbool trieSearch(Trie* obj, char * word) {\n    Trie* curr = obj;\n    while (*word) {\n        int index = *word - 'a';\n        if (curr->children[index] == NULL) {\n            return false;\n        }\n        curr = curr->children[index];\n        word++;\n    }\n    return curr != NULL && curr->isEnd;\n}\n\n/** Returns if there is any word in the trie that starts with the given prefix. */\nbool trieStartsWith(Trie* obj, char * prefix) {\n    Trie* curr = obj;\n    while (*prefix) {\n        int index = *prefix - 'a';\n        if (curr->children[index] == NULL) {\n            return false;\n        }\n        curr = curr->children[index];\n        prefix++;\n    }\n    return curr != NULL;\n}\n\nvoid trieFree(Trie* obj) {\n    if (obj == NULL) {\n        return;\n    }\n    for (int i = 0; i < 26; i++) {\n        trieFree(obj->children[i]);\n    }\n    free(obj);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void Insert(string word) {\n        TrieNode node = root;\n        foreach (char c in word) {\n            if (!node.Contains(c)) {\n                node.Add(c);\n            }\n            node = node.Get(c);\n        }\n        node.IsEnd = true;\n    }\n\n    public bool Search(string word) {\n        TrieNode node = SearchPrefix(word);\n        return node != null && node.IsEnd;\n    }\n\n    public bool StartsWith(string prefix) {\n        TrieNode node = SearchPrefix(prefix);\n        return node != null;\n    }\n\n    private TrieNode SearchPrefix(string prefix) {\n        TrieNode node = root;\n        foreach (char c in prefix) {\n            if (node.Contains(c)) {\n                node = node.Get(c);\n            } else {\n                return null;\n            }\n        }\n        return node;\n    }\n\n    private class TrieNode {\n        private TrieNode[] links;\n        public bool IsEnd;\n\n        public TrieNode() {\n            links = new TrieNode[26];\n        }\n\n        public bool Contains(char c) {\n            return links[c - 'a'] != null;\n        }\n\n        public void Add(char c) {\n            links[c - 'a'] = new TrieNode();\n        }\n\n        public TrieNode Get(char c) {\n            return links[c - 'a'];\n        }\n    }\n}\n"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var Trie = function() {\n    this.root = {};\n    \n    this.insert = function(word) {\n        let node = this.root;\n        for (let char of word) {\n            if (!node[char]) {\n                node[char] = {};\n            }\n            node = node[char];\n        }\n        node.isEnd = true;\n    };\n    \n    this.search = function(word) {\n        let node = this.root;\n        for (let char of word) {\n            if (!node[char]) {\n                return false;\n            }\n            node = node[char];\n        }\n        return node.isEnd === true;\n    };\n    \n    this.startsWith = function(prefix) {\n        let node = this.root;\n        for (let char of prefix) {\n            if (!node[char]) {\n                return false;\n            }\n            node = node[char];\n        }\n        return true;\n    };\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Trie {\n    private $children = [];\n    private $isEndOfWord = false;\n    \n    function __construct() {\n    }\n    \n    function insert($word) {\n        $current = $this;\n        for ($i = 0; $i < strlen($word); $i++) {\n            $char = $word[$i];\n            if (!isset($current->children[$char])) {\n                $current->children[$char] = new Trie();\n            }\n            $current = $current->children[$char];\n        }\n        $current->isEndOfWord = true;\n    }\n\n    function search($word) {\n        $current = $this;\n        for ($i = 0; $i < strlen($word); $i++) {\n            $char = $word[$i];\n            if (!isset($current->children[$char])) {\n                return false;\n            }\n            $current = $current->children[$char];\n        }\n        return ($current != null && $current->isEndOfWord);\n    }\n\n    function startsWith($prefix) {\n        $current = $this;\n        for ($i = 0; $i < strlen($prefix); $i++) {\n            $char = $prefix[$i];\n            if (!isset($current->children[$char])) {\n                return false;\n            }\n            $current = $current->children[$char];\n        }\n        return true;\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you need to implement a Trie (Prefix Tree) data structure that supports insertion of words, searching for the exact word, and checking if a word starts with a given prefix.\n\n# Explanation\n1. **Initialization (`__init__` method)**:\n   - You create a root node, which is an empty dictionary. This root will serve as the starting point for all insertions and searches.\n\n2. **Insertion (`insert` method)**:\n   - Begin at the root node.\n   - For each character in the word:\n     - If the character is not already a key in the current node, add a new dictionary as the value for this character.\n     - Move to the next node (the dictionary corresponding to the current character).\n   - After inserting all characters, mark the end of the word by adding a special marker (e.g., `'$', True`) in the current node.\n\n3. **Searching (`search` method)**:\n   - Start at the root node.\n   - For each character in the word:\n     - If the character is not present in the current node, return `False`.\n     - Move to the next node.\n   - After checking all characters, verify if the special end-of-word marker (`'$'`) is in the current node to confirm the word exists.\n\n4. **Prefix checking (`startsWith` method)**:\n   - Start at the root node.\n   - For each character in the prefix:\n     - If the character is not present in the current node, return `False`.\n     - Move to the next node.\n   - If all characters in the prefix are found, return `True`.\n\n# Pseudocode\nBelow is the pseudocode representation of the Trie class based on the given challenge:\n\n``` \nClass Trie:\n  # Initialize your data structure here.\n  Function __init__():\n    root = {}\n\n  # Inserts a word into the trie.\n  Function insert(word):\n    node = root\n    For each char in word:\n      If char not in node:\n        node[char] = {}\n      node = node[char]\n    node['$'] = True  # Mark the end of the word\n\n  # Returns if the word is in the trie.\n  Function search(word):\n    node = root\n    For each char in word:\n      If char not in node:\n        Return False\n      node = node[char]\n    Return '$' in node  # Check if the word ends here\n\n  # Returns if there is any word in the trie that starts with the given prefix.\n  Function startsWith(prefix):\n    node = root\n    For each char in prefix:\n      If char not in node:\n        Return False\n      node = node[char]\n    Return True\n```\n\nThis methodology ensures efficient insertion, search, and prefix checking in the Trie data structure, optimally handling the constraints provided.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-implement-trie-prefix-tree"
    },
    {
        "name": "Combination Sum Iii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-combination-sum-iii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int>> res;\n        vector<int> cur;\n        backtrack(res, cur, 1, k, n);\n        return res;\n    }\n    \n    void backtrack(vector<vector<int>>& res, vector<int>& cur, int start, int k, int n) {\n        if (k == 0 && n == 0) {\n            res.push_back(cur);\n            return;\n        }\n        \n        for (int i = start; i <= 9; ++i) {\n            cur.push_back(i);\n            backtrack(res, cur, i + 1, k - 1, n - i);\n            cur.pop_back();\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> current = new ArrayList<>();\n        backtrack(result, current, k, n, 1);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> result, List<Integer> current, int k, int n, int start) {\n        if (n == 0 && k == 0) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        for (int i = start; i <= 9; i++) {\n            if (n - i < 0 || k - 1 < 0) {\n                break;\n            }\n            current.add(i);\n            backtrack(result, current, k - 1, n - i, i + 1);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def combinationSum3(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, k, n, path, res):\n            if k == 0 and n == 0:\n                res.append(path)\n                return\n            if k < 0 or n < 0:\n                return\n            for i in range(start, 10):\n                backtrack(i + 1, k - 1, n - i, path + [i], res)\n        \n        res = []\n        backtrack(1, k, n, [], res)\n        return res"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as \n * returnColumnSizes array.\n */\nvoid combinationSum3Helper(int k, int n, int start, int count, int *temp, int **result, int *returnSize, int **returnColumnSizes) {\n    if (n == 0 && count == k) {\n        result[*returnSize] = (int *)malloc(k * sizeof(int));\n        memcpy(result[*returnSize], temp, k * sizeof(int));\n        (*returnColumnSizes)[*returnSize] = k;\n        (*returnSize)++;\n        return;\n    }\n\n    for (int i = start; i <= 9; i++) {\n        temp[count] = i;\n        combinationSum3Helper(k, n - i, i + 1, count + 1, temp, result, returnSize, returnColumnSizes);\n    }\n}\n\nint **combinationSum3(int k, int n, int *returnSize, int **returnColumnSizes) {\n    *returnSize = 0;\n    int **result = (int **)malloc(1000 * sizeof(int *));\n    *returnColumnSizes = (int *)malloc(1000 * sizeof(int));\n    int temp[10];\n    combinationSum3Helper(k, n, 1, 0, temp, result, returnSize, returnColumnSizes);\n    return result;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public IList<IList<int>> CombinationSum3(int k, int n) {\n        IList<IList<int>> result = new List<IList<int>>();\n        List<int> current = new List<int>();\n        Backtrack(result, current, k, n, 1);\n        return result;\n    }\n    \n    private void Backtrack(IList<IList<int>> result, List<int> current, int k, int target, int start) {\n        if (k == 0 && target == 0) {\n            result.Add(new List<int>(current));\n            return;\n        }\n        \n        for (int i = start; i <= 9; i++) {\n            current.Add(i);\n            Backtrack(result, current, k - 1, target - i, i + 1);\n            current.RemoveAt(current.Count - 1);\n        }\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} k\n * @param {number} n\n * @return {number[][]}\n */\nconst combinationSum3 = (k, n) => {\n    const result = [];\n    \n    const backtrack = (start, k, n, path) => {\n        if (k === 0 && n === 0) {\n            result.push([...path]);\n            return;\n        }\n        if (k === 0 || n === 0) {\n            return;\n        }\n        \n        for (let i = start; i <= 9; i++) {\n            path.push(i);\n            backtrack(i + 1, k - 1, n - i, path);\n            path.pop();\n        }\n    };\n    \n    backtrack(1, k, n, []);\n    \n    return result;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function combinationSum3(k: number, n: number): number[][] {\n    const results: number[][] = [];\n    \n    function backtrack(start: number, target: number, current: number, path: number[]) {\n        if (target === 0 && path.length === k) {\n            results.push([...path]);\n            return;\n        }\n        \n        for (let i = start; i <= 9; i++) {\n            if (current + i > n || path.length >= k) {\n                return;\n            }\n            path.push(i);\n            backtrack(i + 1, target - i, current + i, path);\n            path.pop();\n        }\n    }\n    \n    backtrack(1, n, 0, []);\n    \n    return results;\n}\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $k\n     * @param Integer $n\n     * @return Integer[][]\n     */\n    function combinationSum3($k, $n) {\n        $result = [];\n        $path = [];\n        $start = 1;\n        $this->dfs($k, $n, $start, $path, $result);\n        \n        return $result;\n    }\n    \n    function dfs($k, $n, $start, $path, &$result) {\n        if ($k == 0 && $n == 0) {\n            $result[] = $path;\n            return;\n        }\n        \n        for ($i = $start; $i <= 9; $i++) {\n            array_push($path, $i);\n            $this->dfs($k - 1, $n - $i, $i + 1, $path, $result);\n            array_pop($path);\n        }\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun combinationSum3(k: Int, n: Int): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        backtrack(k, n, 1, mutableListOf(), result)\n        return result\n    }\n\n    private fun backtrack(k: Int, target: Int, start: Int, path: MutableList<Int>, result: MutableList<List<Int>>) {\n        if (k == 0 && target == 0) {\n            result.add(path.toList())\n            return\n        }\n        \n        for (i in start..9) {\n            if (i > target) break\n            path.add(i)\n            backtrack(k - 1, target - i, i + 1, path, result)\n            path.removeAt(path.size - 1)\n        }\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  List<List<int>> combinationSum3(int k, int n) {\n    List<List<int>> result = [];\n  \n    void backtrack(List<int> curr, int start, int k, int n) {\n      if (k == 0 && n == 0) {\n        result.add(List.from(curr));\n        return;\n      }\n      \n      for (int i = start; i <= 9; i++) {\n        curr.add(i);\n        backtrack(curr, i + 1, k - 1, n - i);\n        curr.removeLast();\n      }\n    }\n    \n    backtrack([], 1, k, n);\n    \n    return result;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func combinationSum3(k int, n int) [][]int {\n    var result [][]int\n    var path []int\n    backtrack(&result, &path, k, n, 1)\n    return result\n}\n\nfunc backtrack(result *[][]int, path *[]int, k, n, start int) {\n    if k == 0 && n == 0 {\n        tmp := make([]int, len(*path))\n        copy(tmp, *path)\n        *result = append(*result, tmp)\n        return\n    }\n    if k == 0 || n == 0 {\n        return\n    }\n\n    for i := start; i <= 9; i++ {\n        *path = append(*path, i)\n        backtrack(result, path, k-1, n-i, i+1)\n        *path = (*path)[:len(*path)-1]\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} k\n# @param {Integer} n\n# @return {Integer[][]}\ndef combination_sum3(k, n)\n    result = []\n    dfs(k, n, 1, [], result)\n    result\nend\n\ndef dfs(k, n, start, path, result)\n    if k == 0 && n == 0\n        result << path.dup\n        return\n    end\n    \n    return if k == 0 || n == 0\n    \n    (start..9).each do |num|\n        path << num\n        dfs(k - 1, n - num, num + 1, path, result)\n        path.pop\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def combinationSum3(k: Int, n: Int): List[List[Int]] = {\n        var res = List[List[Int]]()\n        \n        def backtrack(k: Int, n: Int, start: Int, path: List[Int]): Unit = {\n            if (k == 0 && n == 0) {\n                res = path :: res\n            } else {\n                for (i <- start to 9) {\n                    backtrack(k - 1, n - i, i + 1, i :: path)\n                }\n            }\n        }\n        \n        backtrack(k, n, 1, List())\n        res\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn combination_sum3(k: i32, n: i32) -> Vec<Vec<i32>> {\n        let mut result = Vec::new();\n        let mut current = Vec::new();\n        Self::backtrack(1, k, n, &mut current, &mut result);\n        result\n    }\n\n    fn backtrack(start: i32, k: i32, target: i32, current: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {\n        if target == 0 && k == 0 {\n            result.push(current.clone());\n            return;\n        }\n\n        if target < 0 || k == 0 {\n            return;\n        }\n\n        for i in start..=9 {\n            current.push(i);\n            Self::backtrack(i + 1, k - 1, target - i, current, result);\n            current.pop();\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we'll use a backtracking approach to generate all valid combinations of `k` numbers that sum up to `n`. This method allows us to explore all possible subsets of numbers from 1 to 9, ensuring that each number is used at most once.\n\n# Explanation\n\n1. **Base Case:** If `k` is zero and `n` is zero, we have found a valid combination, so we add the current combination (`path`) to the result list.\n2. **Termination Cases:** If `k` becomes negative or `n` becomes negative, the current path cannot lead to a valid combination, so we return early.\n3. **Recursive Case:** For each number from the current starting point to 9, add the number to the current path and recurse with updated `k` and `n`. Specifically, reduce `k` by 1 and `n` by the chosen number, and increment the start point to avoid reuse of the same number.\n\n# Pseudocode\n\n```\nfunction combinationSum3(k, n):\n    initialize result as an empty list\n    call backtrack function with start=1, k, n, empty path list, and result list\n    return result\n\nfunction backtrack(start, k, n, path, res):\n    if k == 0 and n == 0:\n        add path to res\n        return\n\n    if k < 0 or n < 0:\n        return\n\n    for i from start to 9:\n        call backtrack with start=i+1, k-1, n-i, path + [i], res\n```\n\nThis pseudocode covers the essential steps of the algorithm: initializing the result list, defining the recursive backtracking function, handling base cases, and iterating through potential numbers to build valid combinations.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-combination-sum-iii"
    },
    {
        "name": "Kth Largest Element In An Array",
        "site": "LeetCode",
        "href": "/solution/LeetCode-kth-largest-element-in-an-array",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int, vector<int>, greater<int>> pq;\n        \n        for(int num : nums) {\n            pq.push(num);\n            if(pq.size() > k) {\n                pq.pop();\n            }\n        }\n        \n        return pq.top();\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        for (int num : nums) {\n            pq.offer(num);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        \n        return pq.peek();\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "import heapq\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        return heapq.nlargest(k, nums)[-1]\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)b - *(int *)a);\n}\n\nint findKthLargest(int* nums, int numsSize, int k) {\n    qsort(nums, numsSize, sizeof(int), compare);\n    return nums[k-1];\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int FindKthLargest(int[] nums, int k) {\n        Array.Sort(nums);\n        return nums[nums.Length - k];\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var findKthLargest = function(nums, k) {\n    return nums.sort((a, b) => b - a)[k - 1];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findKthLargest(nums: number[], k: number): number {\n    const sortedNums = nums.sort((a, b) => b - a);\n    return sortedNums[k - 1];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function findKthLargest($nums, $k) {\n        $n = count($nums);\n        $heap = new SplMaxHeap();\n        \n        foreach ($nums as $num) {\n            $heap->insert($num);\n        }\n        \n        $result = 0;\n        for ($i = 0; $i < $k; $i++) {\n            $result = $heap->extract();\n        }\n        \n        return $result;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {\n        var nums = nums\n        return quickSelect(&nums, 0, nums.count - 1, k)\n    }\n    \n    func quickSelect(_ nums: inout [Int], _ left: Int, _ right: Int, _ k: Int) -> Int {\n        let pivotIndex = partition(&nums, left, right)\n        if pivotIndex == k - 1 {\n            return nums[pivotIndex]\n        } else if pivotIndex < k - 1 {\n            return quickSelect(&nums, pivotIndex + 1, right, k)\n        } else {\n            return quickSelect(&nums, left, pivotIndex - 1, k)\n        }\n    }\n    \n    func partition(_ nums: inout [Int], _ left: Int, _ right: Int) -> Int {\n        let pivot = nums[right]\n        var i = left\n        for j in left..<right {\n            if nums[j] >= pivot {\n                nums.swapAt(i, j)\n                i += 1\n            }\n        }\n        nums.swapAt(i, right)\n        return i\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findKthLargest(nums: IntArray, k: Int): Int {\n        val pq = PriorityQueue<Int>()\n        \n        for (num in nums) {\n            pq.offer(num)\n            if (pq.size > k) {\n                pq.poll()\n            }\n        }\n        \n        return pq.peek()\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "import 'dart:math';\n\nclass Solution {\n  int findKthLargest(List<int> nums, int k) {\n    nums.sort((a, b) => b - a);\n    return nums[k - 1];\n  }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef find_kth_largest(nums, k)\n    nums.sort[-k]\nend\n"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (find-kth-largest nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  \n  (define sorted-nums (sort nums >))\n  (list-ref sorted-nums (sub1 k))\n)"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec find_kth_largest(Nums :: [integer()], K :: integer()) -> integer().\nfind_kth_largest(Nums, K) ->\n    lists:max(lists:sublist(lists:sort(Nums), length(Nums) - K + 1)).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we will use a heap data structure, which allows us to efficiently manage the kth largest element as we traverse through the array. By using a min-heap of size k, we can maintain the k largest elements encountered so far.\n\n# Explanation\n1. **Understand the requirement**: We need to find the kth largest element in an array without sorting it.\n2. **Use a min-heap**: A min-heap of size k will help manage the k largest elements efficiently. The smallest element in this heap will be the kth largest element of the array.\n3. **Traversal**: As we traverse the array:\n   - Add elements to the heap until its size reaches k.\n   - If the heap already contains k elements, compare the new element with the smallest element in the heap (the heap root).\n   - If the new element is larger, replace the root with this new element.\n4. **Result**: After processing all elements, the root of the heap will be the kth largest element.\n\n# Pseudocode\n```\nfunction findKthLargest(nums, k):\n    minHeap = empty heap\n    \n    for each num in nums:\n        if size of minHeap < k:\n            add num to minHeap\n        else:\n            if num > minHeap root element:\n                replace root of minHeap with num\n                \n    return root of minHeap\n```\n\nThis approach ensures that we always have the k largest elements in the heap, with the smallest of these k elements at the heap's root. The time complexity is O(n log k), where n is the number of elements in the array, because each insertion/deletion from the heap takes O(log k) time. This makes it efficient for large arrays.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-kth-largest-element-in-an-array"
    },
    {
        "name": "Shortest Palindrome",
        "site": "LeetCode",
        "href": "/solution/LeetCode-shortest-palindrome",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        string rev = s;\n        reverse(rev.begin(), rev.end());\n        \n        string temp = s + \"#\" + rev;\n        int n = temp.size();\n        \n        vector<int> lps(n, 0);\n        \n        for(int i = 1; i < n; i++){\n            int j = lps[i - 1];\n            while(j > 0 && temp[i] != temp[j]){\n                j = lps[j - 1];\n            }\n            if(temp[i] == temp[j]){\n                j++;\n            }\n            lps[i] = j;\n        }\n        \n        return rev.substr(0, s.size() - lps[n - 1]) + s;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public String shortestPalindrome(String s) {\n        int n = s.length();\n        String rev = new StringBuilder(s).reverse().toString();\n        for (int i = 0; i < n; i++) {\n            if (s.substring(0, n - i).equals(rev.substring(i))) {\n                return rev.substring(0, i) + s;\n            }\n        }\n        return \"\"; // should never reach here\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        rev_s = s[::-1]\n        for i in range(len(s)+1):\n            if s.startswith(rev_s[i:]):\n                return rev_s[:i] + s"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public string ShortestPalindrome(string s) {\n        if (s.Length == 0) return s;\n        \n        string rev = new string(s.Reverse().ToArray());\n        string comb = s + \"#\" + rev;\n        \n        int[] lps = new int[comb.Length];\n        int len = 0, i = 1;\n        \n        while (i < comb.Length) {\n            if (comb[i] == comb[len]) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else {\n                if (len != 0) {\n                    len = lps[len - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        \n        int toAdd = s.Length - lps[comb.Length - 1];\n        string suffix = rev.Substring(0, toAdd);\n        \n        return suffix + s;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar shortestPalindrome = function(s) {\n    const reversed = s.split('').reverse().join('');\n    const l = s + '#' + reversed;\n    const p = new Array(l.length).fill(0);\n    for (let i = 1; i < l.length; i++) {\n        let j = p[i - 1];\n        while (j > 0 && l[i] !== l[j]) {\n            j = p[j - 1];\n        }\n        p[i] = j + (l[i] === l[j] ? 1 : 0);\n    }\n    return reversed.slice(0, s.length - p[l.length - 1]) + s;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function shortestPalindrome(s: string): string {\n    const reversed = s.split('').reverse().join('');\n    const full = s + '#' + reversed;\n    const lps = new Array(full.length).fill(0);\n    \n    for (let i = 1; i < full.length; i++) {\n        let j = lps[i - 1];\n        while (j > 0 && full[i] !== full[j]) {\n            j = lps[j - 1];\n        }\n        lps[i] = j + (full[i] === full[j] ? 1 : 0);\n    }\n    \n    return reversed.slice(0, s.length - lps[full.length - 1]) + s;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param String $s\n     * @return String\n     */\n    function shortestPalindrome($s) {\n        $rev = strrev($s);\n        $n = strlen($s);\n        for ($i = 0; $i < $n; $i++) {\n            if (substr($s, 0, $n - $i) == substr($rev, $i)) {\n                return substr($rev, 0, $i) . $s;\n            }\n        }\n        return '';\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func shortestPalindrome(_ s: String) -> String {\n        guard !s.isEmpty else { return \"\" }\n        var rev = String(s.reversed())\n        var i = 0\n        while !s.hasPrefix(rev.suffix(s.count - i)) {\n            i += 1\n        }\n        return String(rev.prefix(i)) + s\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun shortestPalindrome(s: String): String {\n        val rev = s.reversed()\n        for (i in s.indices) {\n            if (s.startsWith(rev.substring(i))) {\n                return rev.substring(0, i) + s\n            }\n        }\n        return \"\"\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  String shortestPalindrome(String s) {\n    String rev = s.split('').reversed.join();\n    String temp = s + '#' + rev;\n    List<int> lps = List.filled(temp.length, 0);\n    \n    for (int i = 1; i < temp.length; i++) {\n      int j = lps[i - 1];\n      while (j > 0 && temp[i] != temp[j]) {\n        j = lps[j - 1];\n      }\n      if (temp[i] == temp[j]) {\n        j++;\n      }\n      lps[i] = j;\n    }\n    \n    return rev.substring(0, s.length - lps[temp.length - 1]) + s;\n  }\n}"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func shortestPalindrome(s string) string {\n    if len(s) <= 1 {\n        return s\n    }\n    \n    for i := len(s); i >= 0; i-- {\n        if isPalindrome(s[:i]) {\n            return reverse(s[i:]) + s\n        }\n    }\n    \n    return \"\"\n}\n\nfunc isPalindrome(s string) bool {\n    left, right := 0, len(s)-1\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for left, right := 0, len(runes)-1; left < right; left, right = left+1, right-1 {\n        runes[left], runes[right] = runes[right], runes[left]\n    }\n    return string(runes)\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {String} s\n# @return {String}\ndef shortest_palindrome(s)\n    i = 0\n    for j in (s.length - 1).downto(0)\n        if s[i] == s[j]\n            i += 1\n        end\n    end\n    if i == s.length\n        return s\n    end\n    return s[i..-1].reverse + shortest_palindrome(s[0...i]) + s[i..-1]\nend\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we can determine the shortest palindrome by identifying the largest suffix of the string that is already a palindrome, then prepending the reverse of the remaining suffix to the string. This approach ensures that the number of characters added is minimized. \n\nLet's break down the methodology into two main sections:\n\n# Explanation\n\n1. **Reverse the String:** We first reverse the given string `s`.\n2. **Check Prefix Matches:** We then iterate to find the point where the string `s` starts matching with the suffix of this reversed string.\n3. **Identify and Prepend:** Once we locate the match, the unmatched prefix of the reversed string is prepended to the original string `s`.\n\n# Pseudocode\n\n- Take the input string `s`.\n- Create `rev_s` which is the reversed string of `s`.\n- For each index `i` from 0 to the length of `s`:\n  - Check if `s` starts with the substring of `rev_s` starting from `i`.\n  - If it does, return the substring of `rev_s` up to `i` concatenated with `s`.\n\nHere\u2019s how we can outline this in pseudocode:\n\n```\nfunction shortestPalindrome(s):\n    if s is empty:\n        return s\n    \n    rev_s = reverse(s)\n    \n    for i from 0 to length(s) + 1:\n        if s starts with rev_s[i:]:\n            return rev_s[:i] + s\n\n    # If no match is found (although this shouldn't happen given the problem constraints)\n    return s\n```\n\nThis pseudocode should outline the necessary steps to formulate the shortest palindrome by transforming the string as described. The approach leverages string manipulation techniques to efficiently identify and form the required palindrome.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-shortest-palindrome"
    },
    {
        "name": "House Robber Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-house-robber-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 1) {\n            return nums[0];\n        } \n        \n        return max(robHelper(nums, 0, nums.size() - 2), robHelper(nums, 1, nums.size() - 1));\n    }\n    \n    int robHelper(vector<int>& nums, int start, int end) {\n        int prevMax = 0;\n        int currMax = 0;\n        \n        for (int i = start; i <= end; i++) {\n            int temp = currMax;\n            currMax = max(prevMax + nums[i], currMax);\n            prevMax = temp;\n        }\n        \n        return currMax;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 1){\n            return nums[0];\n        }\n        return Math.max(robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1));\n    }\n    \n    private int robRange(int[] nums, int start, int end){\n        int rob1 = 0;\n        int rob2 = 0;\n        for(int i = start; i <= end; i++){\n            int temp = Math.max(nums[i] + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def rob_range(nums, start, end):\n            rob_next, rob_curr = 0, 0\n            for i in range(start, end):\n                rob_next, rob_curr = max(rob_next, rob_curr), rob_next + nums[i]\n            return max(rob_next, rob_curr)\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        return max(rob_range(nums, 0, len(nums)-1), rob_range(nums, 1, len(nums)))"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int rob(int* nums, int numsSize) {\n    if (numsSize == 1) {\n        return nums[0];\n    }\n    \n    int rob1 = robHelper(nums, 0, numsSize - 2);\n    int rob2 = robHelper(nums, 1, numsSize - 1);\n    \n    return rob1 > rob2 ? rob1 : rob2;\n}\n\nint robHelper(int* nums, int start, int end) {\n    int prev1 = 0;\n    int prev2 = 0;\n    \n    for (int i = start; i <= end; i++) {\n        int temp = prev1;\n        prev1 = fmax(prev2 + nums[i], prev1);\n        prev2 = temp;\n    }\n    \n    return prev1;\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int Rob(int[] nums) {\n        if (nums.Length == 1) {\n            return nums[0];\n        }\n        \n        return Math.Max(RobHelper(nums, 0, nums.Length - 2), RobHelper(nums, 1, nums.Length - 1));\n    }\n    \n    private int RobHelper(int[] nums, int start, int end) {\n        int prevMax = 0;\n        int currMax = 0;\n        \n        for (int i = start; i <= end; i++) {\n            int temp = currMax;\n            currMax = Math.Max(prevMax + nums[i], currMax);\n            prevMax = temp;\n        }\n        \n        return currMax;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst rob = (nums) => {\n    if (nums.length === 1) return nums[0];\n    \n    const robRange = (start, end) => {\n        let prev1 = 0, prev2 = 0;\n        for (let i = start; i <= end; i++) {\n            const current = Math.max(prev1, prev2 + nums[i]);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        return prev1;\n    };\n    \n    return Math.max(robRange(0, nums.length - 2), robRange(1, nums.length - 1));\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function rob(nums: number[]): number {\n    const n = nums.length;\n    if (n === 1) return nums[0];\n  \n    const robHelper = (start: number, end: number): number => {\n        let prevMax = 0;\n        let currMax = 0;\n        for (let i = start; i <= end; i++) {\n            const temp = currMax;\n            currMax = Math.max(currMax, prevMax + nums[i]);\n            prevMax = temp;\n        }\n        return currMax;\n    };\n  \n    return Math.max(robHelper(0, n - 2), robHelper(1, n - 1));\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     */\n    function rob($nums) {\n        $n = count($nums);\n        if ($n == 1) {\n            return $nums[0];\n        }\n        \n        return max($this->robRange($nums, 0, $n - 2), $this->robRange($nums, 1, $n - 1));\n    }\n    \n    function robRange($nums, $start, $end) {\n        $dp1 = 0;\n        $dp2 = 0;\n        \n        for ($i = $start; $i <= $end; $i++) {\n            $temp = $dp1;\n            $dp1 = max($dp2 + $nums[$i], $dp1);\n            $dp2 = $temp;\n        }\n        \n        return max($dp1, $dp2);\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func rob(_ nums: [Int]) -> Int {\n        func robHelper(_ nums: [Int]) -> Int {\n            var dp = Array(repeating: 0, count: nums.count)\n            \n            if nums.count == 1 {\n                return nums[0]\n            }\n            \n            dp[0] = nums[0]\n            dp[1] = max(nums[0], nums[1])\n            \n            for i in 2..<nums.count {\n                dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n            }\n            \n            return dp[nums.count - 1]\n        }\n        \n        if nums.count == 1 {\n            return nums[0]\n        }\n        \n        return max(robHelper(Array(nums[0..<nums.count-1])), robHelper(Array(nums[1..<nums.count])))\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun rob(nums: IntArray): Int {\n        if (nums.size == 1) {\n            return nums[0]\n        }\n        \n        return Math.max(robHelper(nums, 0, nums.size - 2), robHelper(nums, 1, nums.size - 1))\n    }\n    \n    fun robHelper(nums: IntArray, start: Int, end: Int): Int {\n        var prevMax = 0\n        var currentMax = 0\n        \n        for (i in start..end) {\n            val temp = currentMax\n            currentMax = Math.max(prevMax + nums[i], currentMax)\n            prevMax = temp\n        }\n        \n        return currentMax\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class Solution {\n  int rob(List<int> nums) {\n    if (nums.length == 1) {\n      return nums[0];\n    }\n    \n    int rob1 = robRange(nums.sublist(0, nums.length - 1));\n    int rob2 = robRange(nums.sublist(1));\n    \n    return rob1 > rob2 ? rob1 : rob2;\n  }\n  \n  int robRange(List<int> nums) {\n    int previousMax = 0;\n    int currentMax = 0;\n    \n    for (int num in nums) {\n      int temp = currentMax;\n      currentMax = currentMax > previousMax + num ? currentMax : previousMax + num;\n      previousMax = temp;\n    }\n    \n    return currentMax;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func rob(nums []int) int {\n    if len(nums) == 1 {\n        return nums[0]\n    }\n    return max(robHelper(nums[:len(nums)-1]), robHelper(nums[1:]))\n}\n\nfunc robHelper(nums []int) int {\n    if len(nums) == 1 {\n        return nums[0]\n    }\n    prevMax, currMax := 0, 0\n    for _, num := range nums {\n        temp := currMax\n        currMax = max(prevMax+num, currMax)\n        prevMax = temp\n    }\n    return currMax\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef rob(nums)\n    return 0 if nums.empty?\n    return nums[0] if nums.length == 1\n    return [nums[0], nums[1]].max if nums.length == 2\n    \n    def rob_range(nums, start, finish)\n        prev_max = curr_max = 0\n        for i in start..finish\n            temp = curr_max\n            curr_max = [prev_max + nums[i], curr_max].max\n            prev_max = temp\n        end\n        curr_max\n    end\n    \n    return [rob_range(nums, 0, nums.length - 2), rob_range(nums, 1, nums.length - 1)].max\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n  def rob(nums: Array[Int]): Int = {\n    def robRange(nums: Array[Int], start: Int, end: Int): Int = {\n      var rob1 = 0\n      var rob2 = 0\n      var currentRob = 0\n\n      for (i <- start to end) {\n        currentRob = Math.max(rob1 + nums(i), rob2)\n        rob1 = rob2\n        rob2 = currentRob\n      }\n\n      return currentRob\n    }\n\n    if (nums.length == 1) {\n      return nums(0)\n    } else {\n      return Math.max(robRange(nums, 0, nums.length - 2), robRange(nums, 1, nums.length - 1))\n    }\n  }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        \n        if n == 0 {\n            return 0;\n        } else if n == 1 {\n            return nums[0];\n        }\n        \n        fn rob_helper(nums: &[i32]) -> i32 {\n            let mut prev_max = 0;\n            let mut curr_max = 0;\n            \n            for &num in nums {\n                let temp = curr_max;\n                curr_max = curr_max.max(prev_max + num);\n                prev_max = temp;\n            }\n            \n            return curr_max;\n        }\n        \n        return rob_helper(&nums[0..n-1]).max(rob_helper(&nums[1..n]));\n    }\n}"
            },
            {
                "name": "Racket",
                "abbreviation_for_prism_styles": "racket",
                "code": "(define/contract (rob nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (define (robber nums)\n    (define (robber-helper start end)\n      (let loop ((i start) (prev 0) (curr 0))\n        (cond\n          ((= i end) curr)\n          (else (loop (+ i 1) curr (max (+ (list-ref nums i) prev) curr)))\n          )\n        )\n      )\n    (if (null? nums) 0\n        (if (< (length nums) 2) (apply max nums)\n            (max (robber-helper 0 (- (length nums) 1))\n                 (robber-helper 1 (length nums)))\n            )\n      )\n    )\n  \n  (robber nums)\n  )\n"
            },
            {
                "name": "Erlang",
                "abbreviation_for_prism_styles": "erlang",
                "code": "-spec rob(Nums :: [integer()]) -> integer().\nrob(Nums) ->\n    Length = length(Nums),\n    case Length of\n        0 -> 0;\n        1 -> hd(Nums);\n        _ -> Max1 = rob_helper(lists:sublist(Nums, 1, Length - 1)),\n             Max2 = rob_helper(lists:sublist(Nums, 2, Length)),\n             lists:max([Max1, Max2])\n    end.\n\nrob_helper(Nums) ->\n    rob_helper(Nums, 0, 0).\n\nrob_helper([], Prev, Curr) ->\n    lists:max([Prev, Curr]);\nrob_helper([H | T], Prev2, Prev1) ->\n    rob_helper(T, Prev1, lists:max([Prev1, H + Prev2])).\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find the maximum amount of money that can be robbed from houses arranged in a circular manner without robbing two adjacent houses. The challenge boils down to handling the circular aspect of the arrangement.\n\n# Explanation\n1. **Base Case**: If there is only one house, the maximum amount of money we can rob is the amount in that house.\n2. **Circular Dependency Handling**: Given that the houses are in a circle, if we rob the first house, we cannot rob the last house, and vice versa. We can split the problem into two scenarios: \n   - Rob houses from the first to the second last\n   - Rob houses from the second to the last.\n3. **Dynamic Programming Approach**: For both scenarios, implement a dynamic programming approach where at every house, we decide whether to rob it or not. Use two variables to keep track of the maximum robbed amount:\n   - `rob_next`: The maximum amount that can be robbed from the next house\n   - `rob_curr`: The maximum amount that can be robbed from the current house\n4. **Result**: The maximum amount we can rob will be the maximum of the results from both scenarios.\n\n# Pseudocode\n```\nfunction rob(nums):\n    if length of nums is 1:\n        return nums[0]\n\n    function rob_range(nums, start, end):\n        rob_next = 0\n        rob_curr = 0\n        for i from start to end-1:\n            new_rob = max(rob_next, rob_curr)\n            rob_curr = rob_next + nums[i]\n            rob_next = new_rob\n        return max(rob_next, rob_curr)\n\n    result1 = rob_range(nums, 0, length of nums - 1)\n    result2 = rob_range(nums, 1, length of nums)\n\n    return max(result1, result2)\n```\n\nThis approach ensures that we correctly handle the circular arrangement of houses and maximizes the amount of money that can be robbed for a given input list `nums`.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-house-robber-ii"
    },
    {
        "name": "Word Search Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-word-search-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class TrieNode {\npublic:\n    vector<TrieNode*> children;\n    string word;\n    \n    TrieNode(): children(26), word(\"\") {}\n};\n\nclass Solution {\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        vector<string> result;\n        TrieNode* root = buildTrie(words);\n        \n        for (int i = 0; i < board.size(); ++i) {\n            for (int j = 0; j < board[0].size(); ++j) {\n                dfs(board, i, j, root, result);\n            }\n        }\n        \n        return result;\n    }\n    \n    TrieNode* buildTrie(vector<string>& words) {\n        TrieNode* root = new TrieNode();\n        \n        for (string word : words) {\n            TrieNode* node = root;\n            for (char c : word) {\n                int index = c - 'a';\n                if (!node->children[index]) {\n                    node->children[index] = new TrieNode();\n                }\n                node = node->children[index];\n            }\n            node->word = word;\n        }\n        \n        return root;\n    }\n    \n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode* node, vector<string>& result) {\n        char c = board[i][j];\n        if (c == '#' || !node->children[c - 'a']) {\n            return;\n        }\n        \n        node = node->children[c - 'a'];\n        if (!node->word.empty()) {\n            result.push_back(node->word);\n            node->word = \"\";\n        }\n        \n        board[i][j] = '#';\n        if (i > 0) dfs(board, i - 1, j, node, result);\n        if (j > 0) dfs(board, i, j - 1, node, result);\n        if (i < board.size() - 1) dfs(board, i + 1, j, node, result);\n        if (j < board[0].size() - 1) dfs(board, i, j + 1, node, result);\n        board[i][j] = c;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> result = new ArrayList<>();\n        TrieNode root = buildTrie(words);\n        \n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfs(board, i, j, root, result);\n            }\n        }\n        \n        return result;\n    }\n    \n    private void dfs(char[][] board, int i, int j, TrieNode node, List<String> result) {\n        char c = board[i][j];\n        if (c == '#' || node.next[c - 'a'] == null) return;\n        \n        node = node.next[c - 'a'];\n        if (node.word != null) {\n            result.add(node.word);\n            node.word = null;\n        }\n        \n        board[i][j] = '#';\n        if (i > 0) dfs(board, i - 1, j, node, result);\n        if (j > 0) dfs(board, i, j - 1, node, result);\n        if (i < board.length - 1) dfs(board, i + 1, j, node, result);\n        if (j < board[0].length - 1) dfs(board, i, j + 1, node, result);\n        board[i][j] = c;\n    }\n    \n    private TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                int index = c - 'a';\n                if (node.next[index] == null) {\n                    node.next[index] = new TrieNode();\n                }\n                node = node.next[index];\n            }\n            node.word = word;\n        }\n        return root;\n    }\n    \n    class TrieNode {\n        TrieNode[] next;\n        String word;\n        \n        TrieNode() {\n            next = new TrieNode[26];\n            word = null;\n        }\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        \"\"\"\n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            tmp, board[i][j] = board[i][j], '#'\n            res = dfs(board, i + 1, j, word[1:]) or dfs(board, i - 1, j, word[1:]) or dfs(board, i, j + 1, word[1:]) or dfs(board, i, j - 1, word[1:])\n            board[i][j] = tmp\n            return res\n        \n        result = set()\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(board, i, j, word):\n                        result.add(word)\n        return list(result)"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to find all words from a given list that can be formed by traversing sequentially adjacent cells in a character board. We will employ Depth-First Search (DFS) for this purpose.\n\n## # Explanation\n\n1. **Input and Constraints**:\n   - `board`: A 2D list of characters representing a grid.\n   - `words`: A list of strings, each representing a word we need to search in the board.\n   - Constraints ensure the board dimensions and the list lengths are manageable within provided limits.\n\n2. **Problem Requirements**:\n   - Each word must be formed by letters from sequentially adjacent cells.\n   - The same letter cell cannot be reused within a single word.\n  \n3. **Approach**:\n   - Use a Depth-First Search (DFS) algorithm to explore potential word formations starting from each cell.\n   - Mark cells as visited during the DFS to avoid reuse within the same word.\n   - Reset the cells after exploring each possibility.\n   - Collect and return all valid words found.\n\n4. **Efficiency**:\n   - We will optimize by breaking early if a word cannot be formed from the current path.\n   - Using a set for results ensures unique entries and faster checks.\n\n## # Pseudocode\n\n```pseudocode\nfunction findWords(board, words):\n    function dfs(board, i, j, word):\n        if length of word is 0:\n            return True\n        if i < 0 or i >= length of board or j < 0 or j >= length of board[0] or board[i][j] != word[0]:\n            return False\n        temp = board[i][j]\n        board[i][j] = '#'\n        result = dfs(board, i + 1, j, word[1:]) or dfs(board, i - 1, j, word[1:]) or dfs(board, i, j + 1, word[1:]) or dfs(board, i, j - 1, word[1:])\n        board[i][j] = temp\n        return result\n    \n    result = empty set\n    for each word in words:\n        for i from 0 to length of board:\n            for j from 0 to length of board[0]:\n                if dfs(board, i, j, word):\n                    add word to result\n    return list of result\n```\n\nThis pseudocode outlines a method where we systematically check each cell as a potential starting point for forming each word, using DFS to explore all possible paths. If a word can be formed, it\u2019s added to the result set, which we ultimately return as a list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-word-search-ii"
    },
    {
        "name": "Design Add And Search Words Data Structure",
        "site": "LeetCode",
        "href": "/solution/LeetCode-design-add-and-search-words-data-structure",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class WordDictionary {\npublic:\n    WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    void addWord(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                node->children[c - 'a'] = new TrieNode();\n            }\n            node = node->children[c - 'a'];\n        }\n        node->isEnd = true;\n    }\n\n    bool search(string word) {\n        return searchUtil(word, 0, root);\n    }\n    \nprivate:\n    struct TrieNode {\n        TrieNode* children[26] = {nullptr};\n        bool isEnd = false;\n    };\n    \n    TrieNode* root;\n    \n    bool searchUtil(string word, int index, TrieNode* node) {\n        if (index == word.length()) {\n            return node->isEnd;\n        }\n        \n        char c = word[index];\n        if (c == '.') {\n            for (TrieNode* child : node->children) {\n                if (child && searchUtil(word, index + 1, child)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (!node->children[c - 'a']) {\n                return false;\n            }\n            return searchUtil(word, index + 1, node->children[c - 'a']);\n        }\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class WordDictionary {\n    Map<Integer, Set<String>> map;\n\n    public WordDictionary() {\n        map = new HashMap<>();\n    }\n\n    public void addWord(String word) {\n        int length = word.length();\n        if (!map.containsKey(length)) {\n            map.put(length, new HashSet<>());\n        }\n        map.get(length).add(word);\n    }\n\n    public boolean search(String word) {\n        int length = word.length();\n        if (!map.containsKey(length)) {\n            return false;\n        }\n\n        Set<String> set = map.get(length);\n        for (String str : set) {\n            if (isMatch(str, word)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isMatch(String word, String pattern) {\n        for (int i = 0; i < word.length(); i++) {\n            if (pattern.charAt(i) != '.' && word.charAt(i) != pattern.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class WordDictionary(object):\n    def __init__(self):\n        self.trie = {}\n\n    def addWord(self, word):\n        node = self.trie\n        for letter in word:\n            if letter not in node:\n                node[letter] = {}\n            node = node[letter]\n        node['$'] = True\n\n    def search(self, word):\n        def search_in_node(word, node):\n            for i, letter in enumerate(word):\n                if letter not in node:\n                    if letter == '.':\n                        for char in node:\n                            if char != '$' and search_in_node(word[i + 1:], node[char]):\n                                return True\n                    return False\n                else:\n                    node = node[letter]\n            return '$' in node\n\n        return search_in_node(word, self.trie)\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "typedef struct {\n    bool isEnd;\n    struct WordDictionary* children[26];\n} WordDictionary;\n\nWordDictionary* wordDictionaryCreate() {\n    WordDictionary* obj = (WordDictionary*)malloc(sizeof(WordDictionary));\n    obj->isEnd = false;\n    for (int i = 0; i < 26; i++) {\n        obj->children[i] = NULL;\n    }\n    return obj;\n}\n\nvoid wordDictionaryAddWord(WordDictionary* obj, char *word) {\n    WordDictionary* node = obj;\n    while (*word) {\n        if (node->children[*word - 'a'] == NULL) {\n            node->children[*word - 'a'] = wordDictionaryCreate();\n        }\n        node = node->children[*word - 'a'];\n        word++;\n    }\n    node->isEnd = true;\n}\n\nbool wordDictionarySearchHelper(WordDictionary* node, char* word) {\n    while (*word) {\n        if (*word == '.') {\n            for (int i = 0; i < 26; i++) {\n                if (node->children[i] != NULL && wordDictionarySearchHelper(node->children[i], word + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (node->children[*word - 'a'] == NULL) {\n                return false;\n            }\n            node = node->children[*word - 'a'];\n            word++;\n        }\n    }\n    return node->isEnd;\n}\n\nbool wordDictionarySearch(WordDictionary* obj, char *word) {\n    return wordDictionarySearchHelper(obj, word);\n}\n\nvoid wordDictionaryFree(WordDictionary* obj) {\n    for (int i = 0; i < 26; i++) {\n        if (obj->children[i] != NULL) {\n            wordDictionaryFree(obj->children[i]);\n        }\n    }\n    free(obj);\n}\n"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class WordDictionary {\n    private Dictionary<int, List<string>> wordDictionary;\n\n    public WordDictionary() {\n        wordDictionary = new Dictionary<int, List<string>>();\n    }\n\n    public void AddWord(string word) {\n        int length = word.Length;\n        if (!wordDictionary.ContainsKey(length)) {\n            wordDictionary[length] = new List<string>();\n        }\n        wordDictionary[length].Add(word);\n    }\n\n    public bool Search(string word) {\n        int length = word.Length;\n\n        if (wordDictionary.ContainsKey(length)) {\n            foreach (var w in wordDictionary[length]) {\n                if (IsMatch(w, word)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private bool IsMatch(string s, string p) {\n        if (s.Length != p.Length) {\n            return false;\n        }\n\n        for (int i = 0; i < s.Length; i++) {\n            if (p[i] != '.' && p[i] != s[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "var WordDictionary = function() {\n    this.words = new Set();\n    \n    this.addWord = function(word) {\n        this.words.add(word);\n    };\n    \n    this.search = function(word) {\n        for (const w of this.words) {\n            if (this.match(w, word)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    \n    this.match = function(word1, word2) {\n        if (word1.length !== word2.length) {\n            return false;\n        }\n        \n        for (let i = 0; i < word1.length; i++) {\n            if (word1[i] !== word2[i] && word2[i] !== \".\") {\n                return false;\n            }\n        }\n        \n        return true;\n    };\n};"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "class WordDictionary {\n    private words: Set<string>;\n\n    constructor() {\n        this.words = new Set();\n    }\n\n    addWord(word: string): void {\n        this.words.add(word);\n    }\n\n    search(word: string): boolean {\n        for (const w of this.words) {\n            if (this.match(w, word)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private match(word1: string, word2: string): boolean {\n        if (word1.length !== word2.length) {\n            return false;\n        }\n        for (let i = 0; i < word1.length; i++) {\n            if (word1[i] !== word2[i] && word2[i] !== '.') {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class WordDictionary {\n    private $dictionary;\n\n    /**\n     */\n    function __construct() {\n        $this->dictionary = [];\n    }\n\n    /**\n     * @param String $word\n     * @return NULL\n     */\n    function addWord($word) {\n        $this->dictionary[$word] = true;\n    }\n\n    /**\n     * @param String $word\n     * @return Boolean\n     */\n    function search($word) {\n        foreach ($this->dictionary as $dictWord => $value) {\n            if (preg_match('/^' . $word . '$/', $dictWord)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class WordDictionary {\n    class TrieNode {\n        var children = [Character: TrieNode]()\n        var isEndOfWord = false\n    }\n\n    var root: TrieNode\n\n    init() {\n        root = TrieNode()\n    }\n\n    func addWord(_ word: String) {\n        var node = root\n        for char in word {\n            if node.children[char] == nil {\n                node.children[char] = TrieNode()\n            }\n            node = node.children[char]!\n        }\n        node.isEndOfWord = true\n    }\n\n    func search(_ word: String) -> Bool {\n        return searchHelper(word, root)\n    }\n\n    private func searchHelper(_ word: String, _ node: TrieNode) -> Bool {\n        var currentNode = node\n        for (index, char) in word.enumerated() {\n            if char == \".\" {\n                for child in currentNode.children.values {\n                    let newWord = String(word.suffix(word.count - index - 1))\n                    if searchHelper(newWord, child) {\n                        return true\n                    }\n                }\n                return false\n            } else if currentNode.children[char] == nil {\n                return false\n            }\n            currentNode = currentNode.children[char]!\n        }\n        return currentNode.isEndOfWord\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class WordDictionary() {\n    private val wordSet = HashSet<String>()\n\n    fun addWord(word: String) {\n        wordSet.add(word)\n    }\n\n    fun search(word: String): Boolean {\n        for (w in wordSet) {\n            if (isMatch(w, word)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private fun isMatch(word: String, pattern: String): Boolean {\n        if (word.length != pattern.length) {\n            return false\n        }\n        for (i in word.indices) {\n            if (pattern[i] != '.' && pattern[i] != word[i]) {\n                return false\n            }\n        }\n        return true\n    }\n}\n"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "class WordDictionary {\n  Map<int, List<String>> wordMap = Map();\n\n  void addWord(String word) {\n    int wordLength = word.length;\n    if (!wordMap.containsKey(wordLength)) {\n      wordMap[wordLength] = [];\n    }\n    wordMap[wordLength]!.add(word);\n  }\n\n  bool search(String word) {\n    int wordLength = word.length;\n    if (!wordMap.containsKey(wordLength)) {\n      return false;\n    }\n\n    List<String> words = wordMap[wordLength]!;\n    for (String w in words) {\n      if (_isMatch(w, word)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool _isMatch(String word, String pattern) {\n    for (int i = 0; i < word.length; i++) {\n      if (pattern[i] != '.' && pattern[i] != word[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "type WordDictionary struct {\n    wordMap map[int][]string\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() WordDictionary {\n    return WordDictionary{wordMap: make(map[int][]string)}\n}\n\n/** Adds a word into the data structure. */\nfunc (this *WordDictionary) AddWord(word string) {\n    wordLen := len(word)\n    this.wordMap[wordLen] = append(this.wordMap[wordLen], word)\n}\n\n/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\nfunc (this *WordDictionary) Search(word string) bool {\n    wordLen := len(word)\n    if _, ok := this.wordMap[wordLen]; !ok {\n        return false\n    }\n    for _, w := range this.wordMap[wordLen] {\n        if match(w, word) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc match(s, p string) bool {\n    if len(s) != len(p) {\n        return false\n    }\n    for i := range s {\n        if p[i] != '.' && p[i] != s[i] {\n            return false\n        }\n    }\n    return true\n}\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "class WordDictionary() {\n    var words: Set[String] = Set()\n\n    def addWord(word: String): Unit = {\n        words += word\n    }\n\n    def search(word: String): Boolean = {\n        words.exists(w => w.length == word.length && word.zip(w).forall { case (c1, c2) => c1 == '.' || c1 == c2 })\n    }\n}"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to create a data structure that allows adding words and searching for words, with support for wildcard character `.` which can represent any letter.\n\n# Explanation\nWe can use a Trie (prefix tree) data structure for efficient storage and lookup of words. The Trie will allow us to perform both exact searches and searches with wildcard characters efficiently.\n\n1. **Initialization**: We initialize our Trie structure.\n2. **Adding Words**: For each word, we traverse the Trie, adding nodes for each character in the word. A special end-of-word marker, such as `'$'`, marks the end of the word.\n3. **Searching Words**: To search for a word which may contain wildcard characters, we recursively search through the Trie. If we encounter a `.`, we must search all possible characters (children nodes) at that position.\n\nThe provided solution implements this using a nested function for the recursive search. Here\u2019s how you can think about the pseudocode for this approach:\n\n# Pseudocode\n\n1. **Define the WordDictionary class**\n   - **Initialize __init__ method**: Create an empty dictionary for the Trie.\n   \n2. **Define addWord method**:\n   - Traverse the Trie for each character in the word.\n   - If a character node does not exist, create it.\n   - Mark the end of the word with a special end marker (e.g., `'$'`).\n\n3. **Define search method**:\n   - Define a helper function `search_in_node` that will perform the search recursively.\n   - For each character in the word:\n     - If the character is `'.'`, recursively search all children nodes.\n     - If the character is in the current node, move to the next node.\n     - If the character is not found and it is not `.`, return `False`.\n   - Return `True` if the end marker is found at the end of the word.\n\n# Pseudocode Implementation\n\n```pseudo\nclass WordDictionary:\n    # Initialize the Trie structure\n    function __init__():\n        trie_root = {}\n\n    # Add a word to the Trie\n    function addWord(word):\n        node = trie_root\n        for each character in word:\n            if character not in node:\n                node[character] = {}\n            node = node[character]\n        node['$'] = True  # end-of-word marker\n\n    # Search a word, supporting '.' as wildcard\n    function search(word):\n        # Nested function to perform recursive search\n        function search_in_node(word, node):\n            for i, character in enumerate(word):\n                if character not in node:\n                    if character == '.':\n                        for each child in node:\n                            if child != '$' and search_in_node(word[i + 1:], node[child]):\n                                return True\n                    return False\n                else:\n                    node = node[character]\n            return ('$' in node)\n        \n        return search_in_node(word, trie_root)\n```\n\nThis pseudocode defines the `WordDictionary` object with methods for adding words to a Trie and searching words with possible wildcard characters. By following this methodology, you can effectively handle the constraints and requirements of the problem.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-design-add-and-search-words-data-structure"
    },
    {
        "name": "Course Schedule Ii",
        "site": "LeetCode",
        "href": "/solution/LeetCode-course-schedule-ii",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses, vector<int>());\n        vector<int> inDegree(numCourses, 0);\n        for (auto pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            inDegree[pre[0]]++;\n        }\n        \n        queue<int> q;\n        vector<int> res;\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n                res.push_back(i);\n            }\n        }\n        \n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (int next : graph[curr]) {\n                inDegree[next]--;\n                if (inDegree[next] == 0) {\n                    q.push(next);\n                    res.push_back(next);\n                }\n            }\n        }\n        \n        if (res.size() == numCourses) \n            return res;\n        else\n            return {};\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] result = new int[numCourses];\n        int[] inDegree = new int[numCourses];\n        List<List<Integer>> graph = new ArrayList<>();\n        \n        for (int i = 0; i < numCourses; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] prerequisite : prerequisites) {\n            graph.get(prerequisite[1]).add(prerequisite[0]);\n            inDegree[prerequisite[0]]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n        \n        int index = 0;\n        while (!queue.isEmpty()) {\n            int curr = queue.poll();\n            result[index++] = curr;\n            for (int next : graph.get(curr)) {\n                inDegree[next]--;\n                if (inDegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        \n        return index == numCourses ? result : new int[0];\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        from collections import defaultdict, deque\n        \n        graph = defaultdict(list)\n        in_degree = [0] * numCourses\n        \n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            in_degree[course] += 1\n        \n        queue = deque([course for course in range(numCourses) if in_degree[course] == 0])\n        result = []\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node)\n            \n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return result if len(result) == numCourses else []"
            },
            {
                "name": "C#",
                "abbreviation_for_prism_styles": "csharp",
                "code": "public class Solution {\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\n        List<int>[] graph = new List<int>[numCourses];\n        int[] inDegree = new int[numCourses];\n        Queue<int> queue = new Queue<int>();\n        List<int> result = new List<int>();\n        \n        for (int i = 0; i < numCourses; i++) {\n            graph[i] = new List<int>();\n        }\n        \n        foreach (var pair in prerequisites) {\n            graph[pair[1]].Add(pair[0]);\n            inDegree[pair[0]]++;\n        }\n        \n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.Enqueue(i);\n            }\n        }\n        \n        while (queue.Count > 0) {\n            int course = queue.Dequeue();\n            result.Add(course);\n            \n            foreach (var nextCourse in graph[course]) {\n                inDegree[nextCourse]--;\n                if (inDegree[nextCourse] == 0) {\n                    queue.Enqueue(nextCourse);\n                }\n            }\n        }\n        \n        if (result.Count != numCourses) {\n            return new int[0];\n        }\n        \n        return result.ToArray();\n    }\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function(numCourses, prerequisites) {\n    let adjList = Array.from({ length: numCourses }, () => []);\n    let inDegree = Array(numCourses).fill(0);\n    \n    for (let [course, pre] of prerequisites) {\n        adjList[pre].push(course);\n        inDegree[course]++;\n    }\n    \n    let queue = [];\n    for (let i = 0; i < inDegree.length; i++) {\n        if (inDegree[i] === 0) queue.push(i);\n    }\n    \n    let result = [];\n    while (queue.length > 0) {\n        let pre = queue.shift();\n        numCourses--;\n        result.push(pre);\n        for (let course of adjList[pre]) {\n            inDegree[course]--;\n            if (inDegree[course] === 0) queue.push(course);\n        }\n    }\n    \n    return numCourses === 0 ? result : [];\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function findOrder(numCourses: number, prerequisites: number[][]): number[] {\n    const inDegree: number[] = new Array(numCourses).fill(0);\n    const graph: {[key: number]: number[]} = {};\n    \n    for (let [course, prereq] of prerequisites) {\n        inDegree[course]++;\n        if (graph[prereq]) {\n            graph[prereq].push(course);\n        } else {\n            graph[prereq] = [course];\n        }\n    }\n    \n    const queue: number[] = [];\n    for (let i = 0; i < inDegree.length; i++) {\n        if (inDegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n    \n    const result: number[] = [];\n    while (queue.length > 0) {\n        const current = queue.shift();\n        result.push(current);\n        if (graph[current]) {\n            for (let nextCourse of graph[current]) {\n                inDegree[nextCourse]--;\n                if (inDegree[nextCourse] === 0) {\n                    queue.push(nextCourse);\n                }\n            }\n        }\n    }\n    \n    return result.length === numCourses ? result : [];\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $numCourses\n     * @param Integer[][] $prerequisites\n     * @return Integer[]\n     */\n    function findOrder($numCourses, $prerequisites) {\n        $graph = [];\n        $indegree = array_fill(0, $numCourses, 0);\n        $queue = new SplQueue();\n        $result = [];\n\n        foreach ($prerequisites as $pre) {\n            $graph[$pre[1]][] = $pre[0];\n            $indegree[$pre[0]]++;\n        }\n\n        for ($i = 0; $i < $numCourses; $i++) {\n            if ($indegree[$i] == 0) {\n                $queue->push($i);\n                $result[] = $i;\n            }\n        }\n\n        while (!$queue->isEmpty()) {\n            $course = $queue->shift();\n            if (isset($graph[$course])) {\n                foreach ($graph[$course] as $neighbor) {\n                    $indegree[$neighbor]--;\n                    if ($indegree[$neighbor] == 0) {\n                        $queue->push($neighbor);\n                        $result[] = $neighbor;\n                    }\n                }\n            }\n        }\n\n        return count($result) == $numCourses ? $result : [];\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {\n        var graph: [Int: [Int]] = [:]\n        var inDegrees: [Int: Int] = [:]\n        var queue: [Int] = []\n        var result: [Int] = []\n\n        for i in 0..<numCourses {\n            graph[i] = []\n            inDegrees[i] = 0\n        }\n\n        for edge in prerequisites {\n            let course = edge[0]\n            let prerequisite = edge[1]\n            graph[prerequisite]?.append(course)\n            inDegrees[course]? += 1\n        }\n\n        for i in 0..<numCourses {\n            if inDegrees[i] == 0 {\n                queue.append(i)\n            }\n        }\n\n        while !queue.isEmpty {\n            let course = queue.removeFirst()\n            result.append(course)\n\n            if let courses = graph[course] {\n                for c in courses {\n                    inDegrees[c]? -= 1\n                    if inDegrees[c] == 0 {\n                        queue.append(c)\n                    }\n                }\n            }\n        }\n\n        return result.count == numCourses ? result : []\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun findOrder(numCourses: Int, prerequisites: Array<IntArray>): IntArray {\n        val adjList = Array<MutableList<Int>>(numCourses) { mutableListOf() }\n        val inDegree = IntArray(numCourses)\n        \n        for (pre in prerequisites) {\n            adjList[pre[1]].add(pre[0])\n            inDegree[pre[0]]++\n        }\n        \n        val queue = LinkedList<Int>()\n        for (i in 0 until numCourses) {\n            if (inDegree[i] == 0) {\n                queue.offer(i)\n            }\n        }\n        \n        val result = mutableListOf<Int>()\n        while (queue.isNotEmpty()) {\n            val curr = queue.poll()\n            result.add(curr)\n            for (next in adjList[curr]) {\n                inDegree[next]--\n                if (inDegree[next] == 0) {\n                    queue.offer(next)\n                }\n            }\n        }\n        \n        return if (result.size == numCourses) result.toIntArray() else intArrayOf()\n    }\n}"
            },
            {
                "name": "Dart",
                "abbreviation_for_prism_styles": "dart",
                "code": "import 'dart:collection';\n\nclass Solution {\n  List<int> findOrder(int numCourses, List<List<int>> prerequisites) {\n    List<List<int>> adjacencyList = List.generate(numCourses, (index) => []);\n    List<int> inDegree = List.filled(numCourses, 0);\n    for (var edge in prerequisites) {\n      adjacencyList[edge[1]].add(edge[0]);\n      inDegree[edge[0]]++;\n    }\n    \n    List<int> result = [];\n    Queue<int> queue = Queue();\n    for (var i = 0; i < numCourses; i++) {\n      if (inDegree[i] == 0) {\n        queue.add(i);\n      }\n    }\n    \n    while (queue.isNotEmpty) {\n      int current = queue.removeFirst();\n      numCourses--;\n      result.add(current);\n      for (var neighbor in adjacencyList[current]) {\n        inDegree[neighbor]--;\n        if (inDegree[neighbor] == 0) {\n          queue.add(neighbor);\n        }\n      }\n    }\n    \n    return numCourses == 0 ? result : [];\n  }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func findOrder(numCourses int, prerequisites [][]int) []int {\n    // Build graph\n    graph := make(map[int][]int)\n    inDegree := make(map[int]int)\n    for _, pre := range prerequisites {\n        from, to := pre[1], pre[0]\n        graph[from] = append(graph[from], to)\n        inDegree[to]++\n    }\n    \n    // Topological sort\n    queue := make([]int, 0)\n    for i := 0; i < numCourses; i++ {\n        if inDegree[i] == 0 {\n            queue = append(queue, i)\n        }\n    }\n    \n    result := make([]int, 0)\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        result = append(result, node)\n        \n        for _, neighbor := range graph[node] {\n            inDegree[neighbor]--\n            if inDegree[neighbor] == 0 {\n                queue = append(queue, neighbor)\n            }\n        }\n    }\n    \n    if len(result) != numCourses {\n        return []int{}\n    }\n    \n    return result\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# @param {Integer} num_courses\n# @param {Integer[][]} prerequisites\n# @return {Integer[]}\ndef find_order(num_courses, prerequisites)\n    indegrees = Array.new(num_courses, 0)\n    graph = Array.new(num_courses) { [] }\n    result = []\n    \n    prerequisites.each do |pair|\n        course, pre_course = pair\n        graph[pre_course].push(course)\n        indegrees[course] += 1\n    end\n    \n    queue = []\n    indegrees.each_with_index { |degree, i| queue.push(i) if degree == 0 }\n    \n    while !queue.empty?\n        course = queue.shift\n        result.push(course)\n        graph[course].each do |next_course|\n            indegrees[next_course] -= 1\n            queue.push(next_course) if indegrees[next_course] == 0\n        end\n    end\n    \n    result.size == num_courses ? result : []\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "object Solution {\n    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {\n        val graph = Array.fill(numCourses)(List.empty[Int])\n        val inDegree = Array.fill(numCourses)(0)\n        val queue = new scala.collection.mutable.Queue[Int]()\n        val result = scala.collection.mutable.ListBuffer[Int]()\n\n        prerequisites.foreach(p => {\n            graph(p(1)) ::= p(0)\n            inDegree(p(0)) += 1\n        })\n\n        inDegree.zipWithIndex.foreach {\n            case (0, course) => queue.enqueue(course)\n            case _ =>\n        }\n\n        while (queue.nonEmpty) {\n            val course = queue.dequeue()\n            result += course\n\n            graph(course).foreach(dependent => {\n                inDegree(dependent) -= 1\n                if (inDegree(dependent) == 0) {\n                    queue.enqueue(dependent)\n                }\n            })\n        }\n\n        if (result.length == numCourses) result.toArray\n        else Array.empty[Int]\n    }\n}"
            },
            {
                "name": "Rust",
                "abbreviation_for_prism_styles": "rust",
                "code": "impl Solution {\n    pub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        let num_courses = num_courses as usize;\n        let mut graph: Vec<Vec<usize>> = vec![vec![]; num_courses];\n        let mut indegree: Vec<usize> = vec![0; num_courses];\n        let mut queue: Vec<usize> = Vec::new();\n        let mut result: Vec<i32> = Vec::new();\n        \n        for edge in &prerequisites {\n            let from = edge[1] as usize;\n            let to = edge[0] as usize;\n            graph[from].push(to);\n            indegree[to] += 1;\n        }\n        \n        for i in 0..num_courses {\n            if indegree[i] == 0 {\n                queue.push(i);\n            }\n        }\n        \n        while let Some(course) = queue.pop() {\n            result.push(course as i32);\n            for &next in &graph[course] {\n                indegree[next] -= 1;\n                if indegree[next] == 0 {\n                    queue.push(next);\n                }\n            }\n        }\n        \n        if result.len() == num_courses {\n            result\n        } else {\n            Vec::new()\n        }\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the order in which to take courses given a set of prerequisites. This can be thought of as a topological sorting problem on a directed acyclic graph (DAG). The nodes represent courses, and the directed edges represent prerequisites.\n\nWe'll use Kahn's Algorithm (BFS-based) for topological sorting. This involves:\n1. Tracking the in-degree (number of incoming edges) for each node.\n2. Using a queue to process nodes with zero in-degree.\n3. Gradually removing nodes from the graph and decreasing the in-degree of their neighbors.\n4. Verifying at the end if we've processed all nodes, checking for cycles.\n\n# Explanation:\n1. **Graph Representation**: We'll use an adjacency list to represent our graph.\n2. **In-degree Array**: We'll maintain an array where `in_degree[i]` tells us how many courses must be completed before course `i`.\n3. **Processing Nodes**:\n   - Initialize a queue with all courses having zero in-degree (i.e., no prerequisites).\n   - Repeatedly remove a node from the queue, add it to the course order, and decrease the in-degree of its neighbors by 1.\n   - If any neighbor's in-degree becomes zero, add it to the queue.\n4. **Cycle Detection**: At the end, if the number of courses in the result list matches `numCourses`, then we have a valid ordering. If not, it indicates the presence of a cycle, making it impossible to complete all courses.\n\n# Pseudocode:\n```\nfunction findOrder(numCourses, prerequisites):\n    initialize graph as an empty adjacency list (dict of lists)\n    initialize in_degree list with zeroes of length numCourses\n\n    for each (course, prereq) pair in prerequisites:\n        add course to the adjacency list of prereq\n        increment in_degree of course by 1\n\n    initialize queue and add all courses with in_degree of 0\n    initialize result list\n\n    while queue is not empty:\n        node = dequeue from queue\n        add node to result list\n\n        for each neighbor of node in graph:\n            decrement in_degree of neighbor by 1\n            if in_degree of neighbor becomes 0:\n                enqueue neighbor to queue\n\n    if length of result list equals numCourses:\n        return result list\n    else:\n        return empty list\n```\n\nThis pseudocode describes the high-level steps required to implement the course schedule solution, ensuring that it handles edge cases such as cycles and courses with no prerequisites.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-course-schedule-ii"
    },
    {
        "name": "Minimum Size Subarray Sum",
        "site": "LeetCode",
        "href": "/solution/LeetCode-minimum-size-subarray-sum",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int n = nums.size();\n        int minLength = INT_MAX;\n        int sum = 0;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            sum += nums[right];\n            \n            while (sum >= target) {\n                minLength = min(minLength, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        \n        return (minLength != INT_MAX) ? minLength : 0;\n    }\n};"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int left = 0;\n        int sum = 0;\n        int minLength = Integer.MAX_VALUE;\n        \n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n            while (sum >= target) {\n                minLength = Math.min(minLength, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        \n        return minLength == Integer.MAX_VALUE ? 0 : minLength;\n    }\n}"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def minSubArrayLen(self, target, nums):\n        left, sum_, min_len = 0, 0, float('inf')\n        for right in range(len(nums)):\n            sum_ += nums[right]\n            while sum_ >= target:\n                min_len = min(min_len, right - left + 1)\n                sum_ -= nums[left]\n                left += 1\n        return min_len if min_len != float('inf') else 0"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "int minSubArrayLen(int target, int* nums, int numsSize) {\n    int minLen = INT_MAX;\n    int sum = 0;\n    int left = 0;\n    \n    for (int right = 0; right < numsSize; right++) {\n        sum += nums[right];\n        \n        while (sum >= target) {\n            minLen = fmin(minLen, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n    }\n    \n    return minLen == INT_MAX ? 0 : minLen;\n}"
            },
            {
                "name": "JavaScript",
                "abbreviation_for_prism_styles": "javascript",
                "code": "/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nconst minSubArrayLen = (target, nums) => {\n    let left = 0;\n    let sum = 0;\n    let minLength = Infinity;\n    \n    for (let right = 0; right < nums.length; right++) {\n        sum += nums[right];\n        \n        while (sum >= target) {\n            minLength = Math.min(minLength, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n    }\n    \n    return minLength === Infinity ? 0 : minLength;\n};\n"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "function minSubArrayLen(target: number, nums: number[]): number {\n    let start = 0;\n    let sum = 0;\n    let minLength = Infinity;\n\n    for (let end = 0; end < nums.length; end++) {\n        sum += nums[end];\n\n        while (sum >= target) {\n            minLength = Math.min(minLength, end - start + 1);\n            sum -= nums[start];\n            start++;\n        }\n    }\n\n    return minLength !== Infinity ? minLength : 0;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "class Solution {\n    /**\n     * @param Integer $target\n     */\n    function minSubArrayLen($target, $nums) {\n        $n = count($nums);\n        $left = 0;\n        $sum = 0;\n        $minLen = PHP_INT_MAX;\n        \n        for ($right = 0; $right < $n; $right++) {\n            $sum += $nums[$right];\n            \n            while ($sum >= $target) {\n                $minLen = min($minLen, $right - $left + 1);\n                $sum -= $nums[$left];\n                $left++;\n            }\n        }\n        \n        return $minLen == PHP_INT_MAX ? 0 : $minLen;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "class Solution {\n    func minSubArrayLen(_ target: Int, _ nums: [Int]) -> Int {\n        var minLength = Int.max\n        var sum = 0\n        var left = 0\n        \n        for (index, num) in nums.enumerated() {\n            sum += num\n            \n            while sum >= target {\n                minLength = min(minLength, index - left + 1)\n                sum -= nums[left]\n                left += 1\n            }\n        }\n        \n        return minLength == Int.max ? 0 : minLength\n    }\n}"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "class Solution {\n    fun minSubArrayLen(target: Int, nums: IntArray): Int {\n        var minLength = Int.MAX_VALUE\n        var sum = 0\n        var left = 0\n        \n        for (right in nums.indices) {\n            sum += nums[right]\n            \n            while (sum >= target) {\n                minLength = minOf(minLength, right - left + 1)\n                sum -= nums[left]\n                left++\n            }\n        }\n        \n        return if (minLength == Int.MAX_VALUE) 0 else minLength\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to determine the minimal length of a subarray whose sum is greater than or equal to a given target. If no such subarray exists, we return 0. We can approach this using a sliding window technique that allows us to efficiently track the subarray sums.\n\n# Explanation\n1. **Initialization**: We start by initializing the `left` pointer at the start of the array, the current sum (`sum_`) as 0, and the minimum length (`min_len`) as infinity to track the shortest subarray found.\n2. **Expand the Window**: Iterate through the array with the `right` pointer. For each new element, add its value to the current sum.\n3. **Shrink the Window**: When the sum of the current window is greater than or equal to the target, update the minimal length if the current window is shorter. Then, subtract the value of the element at the `left` pointer from the current sum and move the `left` pointer to the right.\n4. **Check Final Length**: After the iteration, if no valid subarray was found (`min_len` is still infinity), return 0, otherwise return `min_len`.\n\n# Pseudocode\n```\nfunction minSubArrayLen(target, nums):\n    left = 0\n    sum_ = 0\n    min_len = infinity\n\n    for right from 0 to length of nums - 1:\n        sum_ = sum_ + nums[right]\n\n        while sum_ >= target:\n            min_len = minimum(min_len, right - left + 1)\n            sum_ = sum_ - nums[left]\n            left = left + 1\n\n    if min_len == infinity:\n        return 0\n    else:\n        return min_len\n```\n\nThis algorithm operates efficiently with a time complexity of O(n), making it suitable for large input sizes as specified in the problem constraints.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-minimum-size-subarray-sum"
    },
    {
        "name": "Concatenated Words",
        "site": "LeetCode",
        "href": "/solution/LeetCode-concatenated-words",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        vector<string> result;\n        unordered_set<string> wordSet(words.begin(), words.end());\n        \n        for (auto& word : words) {\n            int n = word.size();\n            vector<bool> dp(n + 1, false);\n            dp[0] = true;\n            \n            for (int i = 0; i < n; ++i) {\n                if (!dp[i]) continue;\n                \n                for (int j = i + 1; j <= n; ++j) {\n                    if (j - i < n && wordSet.count(word.substr(i, j - i))) {\n                        dp[j] = true;\n                    }\n                }\n                \n                if (dp[n]) {\n                    result.push_back(word);\n                    break;\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n"
            },
            {
                "name": "Java",
                "abbreviation_for_prism_styles": "java",
                "code": "class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> result = new ArrayList<>();\n        Set<String> wordSet = new HashSet<>(Arrays.asList(words));\n\n        for (String word : words) {\n            if (word.isEmpty()) {\n                continue;\n            }\n            wordSet.remove(word);\n\n            if (isValid(word, wordSet)) {\n                result.add(word);\n            }\n\n            wordSet.add(word);\n        }\n\n        return result;\n    }\n\n    private boolean isValid(String word, Set<String> wordSet) {\n        if (wordSet.isEmpty()) {\n            return false;\n        }\n\n        boolean[] dp = new boolean[word.length() + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= word.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordSet.contains(word.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[word.length()];\n    }\n}\n"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        def dfs(word, word_set):\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_set and suffix in word_set:\n                    return True\n                if prefix in word_set and dfs(suffix, word_set):\n                    return True\n            return False\n        \n        word_set = set(words)\n        result = []\n        for word in words:\n            word_set.remove(word)\n            if dfs(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        return result"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, you'll need to identify concatenated words from a list where each word can be formed by concatenating two or more other words from the same list. Here's how you can tackle the problem using a depth-first search (DFS) approach.\n\n# Explanation\n1. **DFS Function**: Create a helper function `dfs` that checks if a given word can be decomposed into two or more words from a set of words.\n2. **Word Set**: Use a set to store all words for efficient lookup.\n3. **Iterate Words**: Iterate through each word in the list, remove it from the set temporarily (to avoid using the word itself in decomposition), and use the DFS function to check if it can be concatenated by other words in the set.\n4. **List Concatenated Words**: Append the word to the result list if it can be constructed by concatenating other words.\n5. **Restore Set**: Add the word back to the set after checking.\n\n# Pseudocode\n```\nfunction findAllConcatenatedWordsInADict(words):\n    function dfs(word, word_set):\n        for i from 1 to length of word - 1:\n            prefix = substring of word from 0 to i\n            suffix = substring of word from i to end\n            if prefix in word_set and suffix in word_set:\n                return True\n            if prefix in word_set and dfs(suffix, word_set):\n                return True\n        return False\n    \n    word_set = set of words\n    result = empty list\n    \n    for word in words:\n        remove word from word_set\n        if dfs(word, word_set):\n            append word to result\n        add word back to word_set\n\n    return result\n```\n\nFollowing this methodology and pseudocode, you will be able to implement a solution that efficiently finds all concatenated words from the list.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-concatenated-words"
    },
    {
        "name": "Implement Rand10 Using Rand7",
        "site": "LeetCode",
        "href": "/solution/LeetCode-implement-rand10-using-rand7",
        "languages": [
            {
                "name": "C++",
                "abbreviation_for_prism_styles": "cpp",
                "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\nclass Solution {\npublic:\n    int rand10() {\n        int rand40 = 40;\n        while (rand40 >= 40) {\n            rand40 = 7 * (rand7() - 1) + (rand7() - 1);\n        }\n        return rand40 % 10 + 1;\n    }\n};"
            },
            {
                "name": "Python",
                "abbreviation_for_prism_styles": "python",
                "code": "# The rand7() API is already defined for you.\n# def rand7():\n# @return a random integer in the range 1 to 7\nclass Solution(object):\n    def rand10(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while True:\n            num = 7 * (rand7() - 1) + rand7()\n            if num <= 40:\n                return num % 10 + 1\n"
            },
            {
                "name": "C",
                "abbreviation_for_prism_styles": "c",
                "code": "// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\nint rand10() {\n    int val;\n    while(true){\n        val = (rand7() - 1) * 7 + rand7(); // Generate a number between 1 and 49\n        if(val <= 40) return val % 10 + 1; // Return a number between 1 and 10\n    }\n}"
            },
            {
                "name": "TypeScript",
                "abbreviation_for_prism_styles": "typescript",
                "code": "/**\n * The rand7() API is already defined for you.\n * function rand7(): number {}\n * @return a random integer in the range 1 to 7\n */\nfunction rand10(): number {\n    let row = rand7();\n    let col = rand7();\n    let index = (row - 1) * 7 + col;\n    \n    while (index > 40) {\n        row = rand7();\n        col = rand7();\n        index = (row - 1) * 7 + col;\n    }\n\n    return 1 + (index - 1) % 10;\n};\n"
            },
            {
                "name": "PHP",
                "abbreviation_for_prism_styles": "php",
                "code": "/*\n * The rand7() API is already defined for you.\n * @return a random integer in the range 1 to 7\n * function rand7();\n*/\nclass Solution {\n    /**\n     * @param \n     * @return Integer\n     */\n    function rand10() {\n        $result = 7 * (rand7() - 1) + rand7();\n        while ($result > 40) {\n            $result = 7 * (rand7() - 1) + rand7();\n        }\n        return 1 + $result % 10;\n    }\n}\n"
            },
            {
                "name": "Swift",
                "abbreviation_for_prism_styles": "swift",
                "code": "/**\n * The rand7() API is already defined in the parent class SolBase.\n * func rand7() -> Int = {}\n * @return a random integer in the range 1 to 7\n */\nclass Solution : SolBase {\n    func rand10() -> Int {\n        while true {\n            let idx = (rand7() - 1) * 7 + rand7()\n            if idx <= 40 {\n                return 1 + (idx - 1) % 10\n            }\n        }\n    }\n}\n"
            },
            {
                "name": "Kotlin",
                "abbreviation_for_prism_styles": "kotlin",
                "code": "/**\n * The rand7() API is already defined in the parent class SolBase.\n * fun rand7(): Int {}\n * @return a random integer in the range 1 to 7\n */\nclass Solution : SolBase() {\n    fun rand10(): Int {\n        var row = 0\n        var col = 0\n        var idx = 0\n        do {\n            row = rand7()\n            col = rand7()\n            idx = col + (row - 1) * 7\n        } while (idx > 40)\n        return 1 + (idx - 1) % 10\n    }\n}\n"
            },
            {
                "name": "Go",
                "abbreviation_for_prism_styles": "go",
                "code": "func rand10() int {\n    for {\n        num := (rand7()-1)*7 + rand7() // Generate a random number from 1 to 49\n        if num <= 40 {\n            return num%10 + 1 // Return number from 1 to 10\n        }\n    }\n}\n"
            },
            {
                "name": "Ruby",
                "abbreviation_for_prism_styles": "ruby",
                "code": "# The rand7() API is already defined for you.\n# def rand7()\n# @return {Integer} a random integer in the range 1 to 7\ndef rand10()\n    while true\n        num = (rand7() - 1) * 7 + rand7()\n        return num % 10 + 1 if num <= 40\n    end\nend\n"
            },
            {
                "name": "Scala",
                "abbreviation_for_prism_styles": "scala",
                "code": "/**\n * The rand7() API is already defined in the parent class SolBase.\n * def rand7(): Int = {}\n * @return a random integer in the range 1 to 7\n */\nobject Solution extends SolBase {\n    def rand10(): Int = {\n        var result = 40\n        result = rand7() + (rand7() - 1) * 7\n        while(result > 40) {\n            result = rand7() + (rand7() - 1) * 7\n        }\n        1 + (result - 1) % 10\n    }\n}\n"
            }
        ],
        "markdown_how_to_solve": "To solve this coding challenge, we need to generate a random integer in the range [1, 10] using a given API rand7() that generates a random integer in the range [1, 7]. \n\n# Explanation\n\n1. **Understanding rand7()**: This function generates a uniform random number between 1 and 7.\n2. **Creating rand10()**: We need to utilize rand7() to generate a random number between 1 and 10 uniformly.\n3. **Combination Technique**: To extend the range of random numbers, we can combine two calls to rand7() to create a random number in the range [1, 49] (since 7 * 7 gives us 49 unique combinations).\n4. **Range Limitation**: We need to map this range [1, 49] to [1, 10]. This can be achieved by filtering out numbers greater than 40, since 40 is the largest multiple of 10 that fits into 49.\n5. **Modulo Operation**: For numbers 1-40, we can take `num % 10` and add 1, ensuring a uniform distribution over [1, 10].\n\n# Pseudocode\n\n```\n# Pseudocode for rand7 (provided API)\n# def rand7():\n#     return a uniform random integer in range [1, 7]\n\nfunction rand10():\n    while true:\n        # Generate a number from 1 to 49\n        num = 7 * (rand7() - 1) + rand7()\n        \n        # Only consider the first 40 numbers\n        if num <= 40:\n            # Map the result to [1, 10]\n            return (num % 10) + 1\n```\n\nThis approach ensures that `rand10()` provides a uniform distribution over the range [1, 10] while adhering to the constraints of using only `rand7()`. Any number generated in the range [41, 49] is discarded to maintain uniformity, and thus the loop repeats until a suitable number is obtained.",
        "video": {
            "has_video": false,
            "scripts": []
        },
        "_id": "LeetCode-implement-rand10-using-rand7"
    }
]