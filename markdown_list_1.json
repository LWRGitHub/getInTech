[
    "To solve this coding challenge, we need to find all unique triplets in the array that sum up to zero. ",
    "",
    "# Explanation",
    "",
    "1. **Sort the Array**: Sorting the array helps in efficiently finding the triplets using the two-pointer technique.",
    "2. **Iterate through the Array**: For each element, use the two-pointer approach to find pairs that form a valid triplet with the current element.",
    "3. **Avoid Duplicates**: Ensure that we skip over duplicate elements to prevent duplicate triplets.",
    "4. **Two-pointer Technique**: For each element, use two pointers (one starting just after the current element and one at the end of the array) to find pairs that sum up to the negative of the current element.",
    "",
    "# Pseudocode",
    "",
    "```",
    "function threeSum(nums):",
    "    sort(nums)",
    "    result = []",
    "",
    "    for i from 0 to len(nums) - 1:",
    "        if nums[i] > 0:",
    "            break   // Since the array is sorted, no three positive numbers can sum to zero.",
    "",
    "        if i == 0 or nums[i-1] != nums[i]:   // Skip duplicates",
    "            twoSumZero(nums, i, result)",
    "",
    "    return result",
    "",
    "function twoSumZero(nums, i, result):",
    "    left = i + 1",
    "    right = len(nums) - 1",
    "",
    "    while left < right:",
    "        sum = nums[i] + nums[left] + nums[right]",
    "",
    "        if sum < 0:",
    "            left += 1",
    "        elif sum > 0:",
    "            right -= 1",
    "        else:",
    "            result.append([nums[i], nums[left], nums[right]])",
    "            left += 1",
    "            right -= 1",
    "",
    "            while left < right and nums[left] == nums[left - 1]:",
    "                left += 1",
    "```",
    "",
    "This approach ensures that the solution is efficient and handles duplicate triplets appropriately by leveraging sorting and the two-pointer technique."
]