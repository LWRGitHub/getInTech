[
    "To solve this coding challenge, we need to find all unique triplets in the given array that sum up to zero. We will use an efficient two-pointer approach after sorting the array to achieve this. Here's a detailed explanation of how to approach and solve this challenge.",
    "",
    "# Explanation",
    "",
    "1. **Sorting the Array**: Begin by sorting the input array. Sorting helps in efficiently locating the triplets using the two-pointer technique.",
    "",
    "2. **Iterating through the Array**: Iterate through the array with a loop. This loop will fix one element of the triplet, and the subsequent two-pointer technique will find the other two elements of the triplet.",
    "",
    "3. **Two-pointer Technique**: ",
    "   - For each fixed element, use two pointers to find the other two elements.",
    "   - One pointer (`left`) starts just after the fixed element, and the other pointer (`right`) starts at the end of the array.",
    "   - Adjust these pointers based on the sum of the values they point to:",
    "     - If the sum is less than zero, move the `left` pointer to the right to increase the sum.",
    "     - If the sum is more than zero, move the `right` pointer to the left to decrease the sum.",
    "     - If the sum equals zero, store the triplet and then move both pointers inward while skipping duplicate values.",
    "     ",
    "4. **Avoiding Duplicates**: ",
    "   - Skip over any duplicate values of the fixed element.",
    "   - Ensure that the resultant triplets are unique by checking the immediate neighbors for duplicates.",
    "",
    "Let's breakdown this approach step by step with pseudocode, including detailed comments to explain each step:",
    "",
    "# Detailed Steps in Pseudocode",
    "",
    "1. **Sort the Array**:",
    "",
    "   ```plaintext",
    "   Sort the nums array",
    "   ```",
    "",
    "2. **Iterate Through the Array**:",
    "",
    "   ```plaintext",
    "   Initialize an empty list `result` to store the unique triplets",
    "   ",
    "   For each index `i` from 0 to length of nums - 3:",
    "       If nums[i] is greater than 0:",
    "           Break the loop as further elements cannot sum to zero (since nums is sorted)",
    "      ",
    "       If `i` is greater than 0 and nums[i] is equal to nums[i-1]:",
    "           Skip to avoid duplicate triplets",
    "       ",
    "       Set `left` pointer to i + 1",
    "       Set `right` pointer to length of nums - 1",
    "",
    "       While `left` is less than `right`:",
    "           Calculate the `current_sum` as nums[i] + nums[left] + nums[right]",
    "           ",
    "           If `current_sum` is less than 0:",
    "               Increment `left` by 1",
    "           ",
    "           Else If `current_sum` is greater than 0:",
    "               Decrement `right` by 1",
    "           ",
    "           Else:  # Found a triplet",
    "               Append the triplet [nums[i], nums[left], nums[right]] to `result`",
    "               Increment `left` by 1 and decrement `right` by 1",
    "               ",
    "               # Skip duplicate elements",
    "               While `left` is less than `right` and nums[left] equals nums[left - 1]:",
    "                   Increment `left` by 1",
    "               While `right` is greater than `left` and nums[right] equals nums[right + 1]:",
    "                   Decrement `right` by 1",
    "",
    "   Return the `result` list",
    "   ```",
    "",
    "# Example with comments in each section",
    "",
    "```plaintext",
    "Sort nums           # Ensures array is sorted",
    "Initialize result   # List to store unique triplets",
    "",
    "For i = 0 to len(nums)-3 do",
    "    If nums[i] > 0 then",
    "        Break        # Remaining elements can't sum to zero",
    "        ",
    "    If i > 0 and nums[i] == nums[i-1] then",
    "        Continue     # Skip duplicate fixed element",
    "",
    "    Set left to i+1",
    "    Set right to len(nums)-1",
    "",
    "    While left < right do",
    "        Set current_sum to nums[i] + nums[left] + nums[right]",
    "",
    "        If current_sum < 0 then",
    "            Increment left    # Move left pointer to the right to increase sum",
    "        Else if current_sum > 0 then",
    "            Decrement right   # Move right pointer to the left to decrease sum",
    "        Else:",
    "            Append [nums[i], nums[left], nums[right]] to result",
    "            Increment left",
    "            Decrement right",
    "            ",
    "            # Skip duplicate elements",
    "            While (left < right and nums[left] == nums[left-1]) do:",
    "                Increment left",
    "            While (right > left and nums[right] == nums[right+1]) do:",
    "                Decrement right",
    "",
    "Return result       # List of unique triplets that sum to zero",
    "``` ",
    "",
    "This detailed explanation and pseudocode guide you through the entire process of solving the challenge, ensuring clarity in understanding how we efficiently find the unique triplets summing to zero."
]